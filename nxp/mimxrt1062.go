// Automatically generated file. DO NOT EDIT.
// Generated by gen-device-svd.go from MIMXRT1062.svd, see https://github.com/posborne/cmsis-svd/tree/master/data/NXP

// +build nxp,mimxrt1062

// MIMXRT1062DVL6A
//
//     Copyright 2016-2019 NXP All rights reserved. SPDX-License-Identifier: BSD-3-Clause
package nxp

import (
	"runtime/interrupt"
	"runtime/volatile"
	"unsafe"
)

// Some information about this device.
const (
	Device       = "MIMXRT1062"
	CPU          = "CM7"
	FPUPresent   = true
	NVICPrioBits = 4
)

// Interrupt numbers.
const (
	// DMA // Nested Vectored Interrupt Controller
	IRQ_DMA0_DMA16 = 0

	// DMA // Nested Vectored Interrupt Controller
	IRQ_DMA1_DMA17 = 1

	// DMA // Nested Vectored Interrupt Controller
	IRQ_DMA2_DMA18 = 2

	// DMA // Nested Vectored Interrupt Controller
	IRQ_DMA3_DMA19 = 3

	// DMA // Nested Vectored Interrupt Controller
	IRQ_DMA4_DMA20 = 4

	// DMA // Nested Vectored Interrupt Controller
	IRQ_DMA5_DMA21 = 5

	// DMA // Nested Vectored Interrupt Controller
	IRQ_DMA6_DMA22 = 6

	// DMA // Nested Vectored Interrupt Controller
	IRQ_DMA7_DMA23 = 7

	// DMA // Nested Vectored Interrupt Controller
	IRQ_DMA8_DMA24 = 8

	// DMA // Nested Vectored Interrupt Controller
	IRQ_DMA9_DMA25 = 9

	// DMA // Nested Vectored Interrupt Controller
	IRQ_DMA10_DMA26 = 10

	// DMA // Nested Vectored Interrupt Controller
	IRQ_DMA11_DMA27 = 11

	// DMA // Nested Vectored Interrupt Controller
	IRQ_DMA12_DMA28 = 12

	// DMA // Nested Vectored Interrupt Controller
	IRQ_DMA13_DMA29 = 13

	// DMA // Nested Vectored Interrupt Controller
	IRQ_DMA14_DMA30 = 14

	// DMA // Nested Vectored Interrupt Controller
	IRQ_DMA15_DMA31 = 15

	// DMA // Nested Vectored Interrupt Controller
	IRQ_DMA_ERROR = 16

	// Nested Vectored Interrupt Controller
	IRQ_CTI0_ERROR = 17

	// Nested Vectored Interrupt Controller
	IRQ_CTI1_ERROR = 18

	// Nested Vectored Interrupt Controller
	IRQ_CORE = 19

	// LPUART // Nested Vectored Interrupt Controller
	IRQ_LPUART1 = 20

	// Nested Vectored Interrupt Controller // LPUART
	IRQ_LPUART2 = 21

	// Nested Vectored Interrupt Controller // LPUART
	IRQ_LPUART3 = 22

	// Nested Vectored Interrupt Controller // LPUART
	IRQ_LPUART4 = 23

	// Nested Vectored Interrupt Controller // LPUART
	IRQ_LPUART5 = 24

	// Nested Vectored Interrupt Controller // LPUART
	IRQ_LPUART6 = 25

	// Nested Vectored Interrupt Controller // LPUART
	IRQ_LPUART7 = 26

	// Nested Vectored Interrupt Controller // LPUART
	IRQ_LPUART8 = 27

	// LPI2C // Nested Vectored Interrupt Controller
	IRQ_LPI2C1 = 28

	// Nested Vectored Interrupt Controller // LPI2C
	IRQ_LPI2C2 = 29

	// Nested Vectored Interrupt Controller // LPI2C
	IRQ_LPI2C3 = 30

	// Nested Vectored Interrupt Controller // LPI2C
	IRQ_LPI2C4 = 31

	// LPSPI // Nested Vectored Interrupt Controller
	IRQ_LPSPI1 = 32

	// Nested Vectored Interrupt Controller // LPSPI
	IRQ_LPSPI2 = 33

	// Nested Vectored Interrupt Controller // LPSPI
	IRQ_LPSPI3 = 34

	// Nested Vectored Interrupt Controller // LPSPI
	IRQ_LPSPI4 = 35

	// FLEXCAN // Nested Vectored Interrupt Controller
	IRQ_CAN1 = 36

	// Nested Vectored Interrupt Controller // FLEXCAN
	IRQ_CAN2 = 37

	// FLEXRAM // Nested Vectored Interrupt Controller
	IRQ_FLEXRAM = 38

	// KPP Registers // Nested Vectored Interrupt Controller
	IRQ_KPP = 39

	// Touch Screen Controller // Nested Vectored Interrupt Controller
	IRQ_TSC_DIG = 40

	// Nested Vectored Interrupt Controller
	IRQ_GPR_IRQ = 41

	// LCDIF Register Reference Index // Nested Vectored Interrupt Controller
	IRQ_LCDIF = 42

	// CSI // Nested Vectored Interrupt Controller
	IRQ_CSI = 43

	// PXP v2.0 Register Reference Index // Nested Vectored Interrupt Controller
	IRQ_PXP = 44

	// Nested Vectored Interrupt Controller // WDOG
	IRQ_WDOG2 = 45

	// SNVS // Nested Vectored Interrupt Controller
	IRQ_SNVS_HP_WRAPPER = 46

	// SNVS // Nested Vectored Interrupt Controller
	IRQ_SNVS_HP_WRAPPER_TZ = 47

	// SNVS // Nested Vectored Interrupt Controller
	IRQ_SNVS_LP_WRAPPER = 48

	// CSU registers // Nested Vectored Interrupt Controller
	IRQ_CSU = 49

	// DCP register reference index // Nested Vectored Interrupt Controller
	IRQ_DCP = 50

	// DCP register reference index // Nested Vectored Interrupt Controller
	IRQ_DCP_VMI = 51

	// Nested Vectored Interrupt Controller
	IRQ_Reserved68 = 52

	// TRNG // Nested Vectored Interrupt Controller
	IRQ_TRNG = 53

	// Nested Vectored Interrupt Controller
	IRQ_SJC = 54

	// Bus Encryption Engine // Nested Vectored Interrupt Controller
	IRQ_BEE = 55

	// I2S // Nested Vectored Interrupt Controller
	IRQ_SAI1 = 56

	// Nested Vectored Interrupt Controller // I2S
	IRQ_SAI2 = 57

	// Nested Vectored Interrupt Controller // I2S
	IRQ_SAI3_RX = 58

	// Nested Vectored Interrupt Controller // I2S
	IRQ_SAI3_TX = 59

	// SPDIF // Nested Vectored Interrupt Controller
	IRQ_SPDIF = 60

	// PMU // Nested Vectored Interrupt Controller
	IRQ_PMU_EVENT = 61

	// Nested Vectored Interrupt Controller
	IRQ_Reserved78 = 62

	// Temperature Monitor // Nested Vectored Interrupt Controller
	IRQ_TEMP_LOW_HIGH = 63

	// Temperature Monitor // Nested Vectored Interrupt Controller
	IRQ_TEMP_PANIC = 64

	// USBPHY Register Reference Index // Nested Vectored Interrupt Controller
	IRQ_USB_PHY1 = 65

	// Nested Vectored Interrupt Controller // USBPHY Register Reference Index
	IRQ_USB_PHY2 = 66

	// Analog-to-Digital Converter // Nested Vectored Interrupt Controller
	IRQ_ADC1 = 67

	// Nested Vectored Interrupt Controller // Analog-to-Digital Converter
	IRQ_ADC2 = 68

	// DCDC // Nested Vectored Interrupt Controller
	IRQ_DCDC = 69

	// Nested Vectored Interrupt Controller
	IRQ_Reserved86 = 70

	// Nested Vectored Interrupt Controller
	IRQ_Reserved87 = 71

	// GPIO // Nested Vectored Interrupt Controller
	IRQ_GPIO1_INT0 = 72

	// GPIO // Nested Vectored Interrupt Controller
	IRQ_GPIO1_INT1 = 73

	// GPIO // Nested Vectored Interrupt Controller
	IRQ_GPIO1_INT2 = 74

	// GPIO // Nested Vectored Interrupt Controller
	IRQ_GPIO1_INT3 = 75

	// GPIO // Nested Vectored Interrupt Controller
	IRQ_GPIO1_INT4 = 76

	// GPIO // Nested Vectored Interrupt Controller
	IRQ_GPIO1_INT5 = 77

	// GPIO // Nested Vectored Interrupt Controller
	IRQ_GPIO1_INT6 = 78

	// GPIO // Nested Vectored Interrupt Controller
	IRQ_GPIO1_INT7 = 79

	// GPIO // Nested Vectored Interrupt Controller
	IRQ_GPIO1_Combined_0_15 = 80

	// GPIO // Nested Vectored Interrupt Controller
	IRQ_GPIO1_Combined_16_31 = 81

	// Nested Vectored Interrupt Controller // GPIO
	IRQ_GPIO2_Combined_0_15 = 82

	// Nested Vectored Interrupt Controller // GPIO
	IRQ_GPIO2_Combined_16_31 = 83

	// Nested Vectored Interrupt Controller // GPIO
	IRQ_GPIO3_Combined_0_15 = 84

	// Nested Vectored Interrupt Controller // GPIO
	IRQ_GPIO3_Combined_16_31 = 85

	// Nested Vectored Interrupt Controller // GPIO
	IRQ_GPIO4_Combined_0_15 = 86

	// Nested Vectored Interrupt Controller // GPIO
	IRQ_GPIO4_Combined_16_31 = 87

	// Nested Vectored Interrupt Controller // GPIO
	IRQ_GPIO5_Combined_0_15 = 88

	// Nested Vectored Interrupt Controller // GPIO
	IRQ_GPIO5_Combined_16_31 = 89

	// FLEXIO // Nested Vectored Interrupt Controller
	IRQ_FLEXIO1 = 90

	// Nested Vectored Interrupt Controller // FLEXIO
	IRQ_FLEXIO2 = 91

	// WDOG // Nested Vectored Interrupt Controller
	IRQ_WDOG1 = 92

	// WDOG // Nested Vectored Interrupt Controller
	IRQ_RTWDOG = 93

	// EWM // Nested Vectored Interrupt Controller
	IRQ_EWM = 94

	// CCM // Nested Vectored Interrupt Controller
	IRQ_CCM_1 = 95

	// CCM // Nested Vectored Interrupt Controller
	IRQ_CCM_2 = 96

	// GPC // Nested Vectored Interrupt Controller
	IRQ_GPC = 97

	// SRC // Nested Vectored Interrupt Controller
	IRQ_SRC = 98

	// Nested Vectored Interrupt Controller
	IRQ_Reserved115 = 99

	// GPT // Nested Vectored Interrupt Controller
	IRQ_GPT1 = 100

	// Nested Vectored Interrupt Controller // GPT
	IRQ_GPT2 = 101

	// PWM // Nested Vectored Interrupt Controller
	IRQ_PWM1_0 = 102

	// PWM // Nested Vectored Interrupt Controller
	IRQ_PWM1_1 = 103

	// PWM // Nested Vectored Interrupt Controller
	IRQ_PWM1_2 = 104

	// PWM // Nested Vectored Interrupt Controller
	IRQ_PWM1_3 = 105

	// PWM // Nested Vectored Interrupt Controller
	IRQ_PWM1_FAULT = 106

	// Nested Vectored Interrupt Controller // FlexSPI
	IRQ_FLEXSPI2 = 107

	// FlexSPI
	IRQ_FLEXSPI = 108

	// SEMC // Nested Vectored Interrupt Controller
	IRQ_SEMC = 109

	// uSDHC // Nested Vectored Interrupt Controller
	IRQ_USDHC1 = 110

	// Nested Vectored Interrupt Controller // uSDHC
	IRQ_USDHC2 = 111

	// Nested Vectored Interrupt Controller // USB
	IRQ_USB_OTG2 = 112

	// USB // Nested Vectored Interrupt Controller
	IRQ_USB_OTG1 = 113

	// Ethernet MAC-NET Core // Nested Vectored Interrupt Controller
	IRQ_ENET = 114

	// Ethernet MAC-NET Core // Nested Vectored Interrupt Controller
	IRQ_ENET_1588_Timer = 115

	// Nested Vectored Interrupt Controller
	IRQ_XBAR1_IRQ_0_1 = 116

	// Nested Vectored Interrupt Controller
	IRQ_XBAR1_IRQ_2_3 = 117

	// ADC_ETC // Nested Vectored Interrupt Controller
	IRQ_ADC_ETC_IRQ0 = 118

	// ADC_ETC // Nested Vectored Interrupt Controller
	IRQ_ADC_ETC_IRQ1 = 119

	// ADC_ETC // Nested Vectored Interrupt Controller
	IRQ_ADC_ETC_IRQ2 = 120

	// ADC_ETC // Nested Vectored Interrupt Controller
	IRQ_ADC_ETC_ERROR_IRQ = 121

	// PIT // Nested Vectored Interrupt Controller
	IRQ_PIT = 122

	// High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX) // Nested Vectored Interrupt Controller
	IRQ_ACMP1 = 123

	// Nested Vectored Interrupt Controller // High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
	IRQ_ACMP2 = 124

	// Nested Vectored Interrupt Controller // High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
	IRQ_ACMP3 = 125

	// Nested Vectored Interrupt Controller // High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
	IRQ_ACMP4 = 126

	// Nested Vectored Interrupt Controller
	IRQ_Reserved143 = 127

	// Nested Vectored Interrupt Controller
	IRQ_Reserved144 = 128

	// Quadrature Decoder // Nested Vectored Interrupt Controller
	IRQ_ENC1 = 129

	// Nested Vectored Interrupt Controller // Quadrature Decoder
	IRQ_ENC2 = 130

	// Nested Vectored Interrupt Controller // Quadrature Decoder
	IRQ_ENC3 = 131

	// Nested Vectored Interrupt Controller // Quadrature Decoder
	IRQ_ENC4 = 132

	// Quad Timer // Nested Vectored Interrupt Controller
	IRQ_TMR1 = 133

	// Nested Vectored Interrupt Controller // Quad Timer
	IRQ_TMR2 = 134

	// Nested Vectored Interrupt Controller // Quad Timer
	IRQ_TMR3 = 135

	// Nested Vectored Interrupt Controller // Quad Timer
	IRQ_TMR4 = 136

	// Nested Vectored Interrupt Controller // PWM
	IRQ_PWM2_0 = 137

	// Nested Vectored Interrupt Controller // PWM
	IRQ_PWM2_1 = 138

	// Nested Vectored Interrupt Controller // PWM
	IRQ_PWM2_2 = 139

	// Nested Vectored Interrupt Controller // PWM
	IRQ_PWM2_3 = 140

	// Nested Vectored Interrupt Controller // PWM
	IRQ_PWM2_FAULT = 141

	// Nested Vectored Interrupt Controller // PWM
	IRQ_PWM3_0 = 142

	// Nested Vectored Interrupt Controller // PWM
	IRQ_PWM3_1 = 143

	// Nested Vectored Interrupt Controller // PWM
	IRQ_PWM3_2 = 144

	// Nested Vectored Interrupt Controller // PWM
	IRQ_PWM3_3 = 145

	// Nested Vectored Interrupt Controller // PWM
	IRQ_PWM3_FAULT = 146

	// Nested Vectored Interrupt Controller // PWM
	IRQ_PWM4_0 = 147

	// Nested Vectored Interrupt Controller // PWM
	IRQ_PWM4_1 = 148

	// Nested Vectored Interrupt Controller // PWM
	IRQ_PWM4_2 = 149

	// Nested Vectored Interrupt Controller // PWM
	IRQ_PWM4_3 = 150

	// Nested Vectored Interrupt Controller // PWM
	IRQ_PWM4_FAULT = 151

	// Ethernet MAC-NET Core // Nested Vectored Interrupt Controller
	IRQ_ENET2 = 152

	// Ethernet MAC-NET Core // Nested Vectored Interrupt Controller
	IRQ_ENET2_1588_Timer = 153

	// CAN // Nested Vectored Interrupt Controller
	IRQ_CAN3 = 154

	// Nested Vectored Interrupt Controller
	IRQ_Reserved171 = 155

	// Nested Vectored Interrupt Controller // FLEXIO
	IRQ_FLEXIO3 = 156

	// Nested Vectored Interrupt Controller // GPIO
	IRQ_GPIO6_7_8_9 = 157

	// Highest interrupt number on this device.
	IRQ_max = 157
)

// Map interrupt numbers to function names.
// These aren't real calls, they're removed by the compiler.
var (
	_ = interrupt.Register(IRQ_DMA0_DMA16, "DMA0_DMA16_IRQHandler")
	_ = interrupt.Register(IRQ_DMA1_DMA17, "DMA1_DMA17_IRQHandler")
	_ = interrupt.Register(IRQ_DMA2_DMA18, "DMA2_DMA18_IRQHandler")
	_ = interrupt.Register(IRQ_DMA3_DMA19, "DMA3_DMA19_IRQHandler")
	_ = interrupt.Register(IRQ_DMA4_DMA20, "DMA4_DMA20_IRQHandler")
	_ = interrupt.Register(IRQ_DMA5_DMA21, "DMA5_DMA21_IRQHandler")
	_ = interrupt.Register(IRQ_DMA6_DMA22, "DMA6_DMA22_IRQHandler")
	_ = interrupt.Register(IRQ_DMA7_DMA23, "DMA7_DMA23_IRQHandler")
	_ = interrupt.Register(IRQ_DMA8_DMA24, "DMA8_DMA24_IRQHandler")
	_ = interrupt.Register(IRQ_DMA9_DMA25, "DMA9_DMA25_IRQHandler")
	_ = interrupt.Register(IRQ_DMA10_DMA26, "DMA10_DMA26_IRQHandler")
	_ = interrupt.Register(IRQ_DMA11_DMA27, "DMA11_DMA27_IRQHandler")
	_ = interrupt.Register(IRQ_DMA12_DMA28, "DMA12_DMA28_IRQHandler")
	_ = interrupt.Register(IRQ_DMA13_DMA29, "DMA13_DMA29_IRQHandler")
	_ = interrupt.Register(IRQ_DMA14_DMA30, "DMA14_DMA30_IRQHandler")
	_ = interrupt.Register(IRQ_DMA15_DMA31, "DMA15_DMA31_IRQHandler")
	_ = interrupt.Register(IRQ_DMA_ERROR, "DMA_ERROR_IRQHandler")
	_ = interrupt.Register(IRQ_CTI0_ERROR, "CTI0_ERROR_IRQHandler")
	_ = interrupt.Register(IRQ_CTI1_ERROR, "CTI1_ERROR_IRQHandler")
	_ = interrupt.Register(IRQ_CORE, "CORE_IRQHandler")
	_ = interrupt.Register(IRQ_LPUART1, "LPUART1_IRQHandler")
	_ = interrupt.Register(IRQ_LPUART2, "LPUART2_IRQHandler")
	_ = interrupt.Register(IRQ_LPUART3, "LPUART3_IRQHandler")
	_ = interrupt.Register(IRQ_LPUART4, "LPUART4_IRQHandler")
	_ = interrupt.Register(IRQ_LPUART5, "LPUART5_IRQHandler")
	_ = interrupt.Register(IRQ_LPUART6, "LPUART6_IRQHandler")
	_ = interrupt.Register(IRQ_LPUART7, "LPUART7_IRQHandler")
	_ = interrupt.Register(IRQ_LPUART8, "LPUART8_IRQHandler")
	_ = interrupt.Register(IRQ_LPI2C1, "LPI2C1_IRQHandler")
	_ = interrupt.Register(IRQ_LPI2C2, "LPI2C2_IRQHandler")
	_ = interrupt.Register(IRQ_LPI2C3, "LPI2C3_IRQHandler")
	_ = interrupt.Register(IRQ_LPI2C4, "LPI2C4_IRQHandler")
	_ = interrupt.Register(IRQ_LPSPI1, "LPSPI1_IRQHandler")
	_ = interrupt.Register(IRQ_LPSPI2, "LPSPI2_IRQHandler")
	_ = interrupt.Register(IRQ_LPSPI3, "LPSPI3_IRQHandler")
	_ = interrupt.Register(IRQ_LPSPI4, "LPSPI4_IRQHandler")
	_ = interrupt.Register(IRQ_CAN1, "CAN1_IRQHandler")
	_ = interrupt.Register(IRQ_CAN2, "CAN2_IRQHandler")
	_ = interrupt.Register(IRQ_FLEXRAM, "FLEXRAM_IRQHandler")
	_ = interrupt.Register(IRQ_KPP, "KPP_IRQHandler")
	_ = interrupt.Register(IRQ_TSC_DIG, "TSC_DIG_IRQHandler")
	_ = interrupt.Register(IRQ_GPR_IRQ, "GPR_IRQ_IRQHandler")
	_ = interrupt.Register(IRQ_LCDIF, "LCDIF_IRQHandler")
	_ = interrupt.Register(IRQ_CSI, "CSI_IRQHandler")
	_ = interrupt.Register(IRQ_PXP, "PXP_IRQHandler")
	_ = interrupt.Register(IRQ_WDOG2, "WDOG2_IRQHandler")
	_ = interrupt.Register(IRQ_SNVS_HP_WRAPPER, "SNVS_HP_WRAPPER_IRQHandler")
	_ = interrupt.Register(IRQ_SNVS_HP_WRAPPER_TZ, "SNVS_HP_WRAPPER_TZ_IRQHandler")
	_ = interrupt.Register(IRQ_SNVS_LP_WRAPPER, "SNVS_LP_WRAPPER_IRQHandler")
	_ = interrupt.Register(IRQ_CSU, "CSU_IRQHandler")
	_ = interrupt.Register(IRQ_DCP, "DCP_IRQHandler")
	_ = interrupt.Register(IRQ_DCP_VMI, "DCP_VMI_IRQHandler")
	_ = interrupt.Register(IRQ_Reserved68, "Reserved68_IRQHandler")
	_ = interrupt.Register(IRQ_TRNG, "TRNG_IRQHandler")
	_ = interrupt.Register(IRQ_SJC, "SJC_IRQHandler")
	_ = interrupt.Register(IRQ_BEE, "BEE_IRQHandler")
	_ = interrupt.Register(IRQ_SAI1, "SAI1_IRQHandler")
	_ = interrupt.Register(IRQ_SAI2, "SAI2_IRQHandler")
	_ = interrupt.Register(IRQ_SAI3_RX, "SAI3_RX_IRQHandler")
	_ = interrupt.Register(IRQ_SAI3_TX, "SAI3_TX_IRQHandler")
	_ = interrupt.Register(IRQ_SPDIF, "SPDIF_IRQHandler")
	_ = interrupt.Register(IRQ_PMU_EVENT, "PMU_EVENT_IRQHandler")
	_ = interrupt.Register(IRQ_Reserved78, "Reserved78_IRQHandler")
	_ = interrupt.Register(IRQ_TEMP_LOW_HIGH, "TEMP_LOW_HIGH_IRQHandler")
	_ = interrupt.Register(IRQ_TEMP_PANIC, "TEMP_PANIC_IRQHandler")
	_ = interrupt.Register(IRQ_USB_PHY1, "USB_PHY1_IRQHandler")
	_ = interrupt.Register(IRQ_USB_PHY2, "USB_PHY2_IRQHandler")
	_ = interrupt.Register(IRQ_ADC1, "ADC1_IRQHandler")
	_ = interrupt.Register(IRQ_ADC2, "ADC2_IRQHandler")
	_ = interrupt.Register(IRQ_DCDC, "DCDC_IRQHandler")
	_ = interrupt.Register(IRQ_Reserved86, "Reserved86_IRQHandler")
	_ = interrupt.Register(IRQ_Reserved87, "Reserved87_IRQHandler")
	_ = interrupt.Register(IRQ_GPIO1_INT0, "GPIO1_INT0_IRQHandler")
	_ = interrupt.Register(IRQ_GPIO1_INT1, "GPIO1_INT1_IRQHandler")
	_ = interrupt.Register(IRQ_GPIO1_INT2, "GPIO1_INT2_IRQHandler")
	_ = interrupt.Register(IRQ_GPIO1_INT3, "GPIO1_INT3_IRQHandler")
	_ = interrupt.Register(IRQ_GPIO1_INT4, "GPIO1_INT4_IRQHandler")
	_ = interrupt.Register(IRQ_GPIO1_INT5, "GPIO1_INT5_IRQHandler")
	_ = interrupt.Register(IRQ_GPIO1_INT6, "GPIO1_INT6_IRQHandler")
	_ = interrupt.Register(IRQ_GPIO1_INT7, "GPIO1_INT7_IRQHandler")
	_ = interrupt.Register(IRQ_GPIO1_Combined_0_15, "GPIO1_Combined_0_15_IRQHandler")
	_ = interrupt.Register(IRQ_GPIO1_Combined_16_31, "GPIO1_Combined_16_31_IRQHandler")
	_ = interrupt.Register(IRQ_GPIO2_Combined_0_15, "GPIO2_Combined_0_15_IRQHandler")
	_ = interrupt.Register(IRQ_GPIO2_Combined_16_31, "GPIO2_Combined_16_31_IRQHandler")
	_ = interrupt.Register(IRQ_GPIO3_Combined_0_15, "GPIO3_Combined_0_15_IRQHandler")
	_ = interrupt.Register(IRQ_GPIO3_Combined_16_31, "GPIO3_Combined_16_31_IRQHandler")
	_ = interrupt.Register(IRQ_GPIO4_Combined_0_15, "GPIO4_Combined_0_15_IRQHandler")
	_ = interrupt.Register(IRQ_GPIO4_Combined_16_31, "GPIO4_Combined_16_31_IRQHandler")
	_ = interrupt.Register(IRQ_GPIO5_Combined_0_15, "GPIO5_Combined_0_15_IRQHandler")
	_ = interrupt.Register(IRQ_GPIO5_Combined_16_31, "GPIO5_Combined_16_31_IRQHandler")
	_ = interrupt.Register(IRQ_FLEXIO1, "FLEXIO1_IRQHandler")
	_ = interrupt.Register(IRQ_FLEXIO2, "FLEXIO2_IRQHandler")
	_ = interrupt.Register(IRQ_WDOG1, "WDOG1_IRQHandler")
	_ = interrupt.Register(IRQ_RTWDOG, "RTWDOG_IRQHandler")
	_ = interrupt.Register(IRQ_EWM, "EWM_IRQHandler")
	_ = interrupt.Register(IRQ_CCM_1, "CCM_1_IRQHandler")
	_ = interrupt.Register(IRQ_CCM_2, "CCM_2_IRQHandler")
	_ = interrupt.Register(IRQ_GPC, "GPC_IRQHandler")
	_ = interrupt.Register(IRQ_SRC, "SRC_IRQHandler")
	_ = interrupt.Register(IRQ_Reserved115, "Reserved115_IRQHandler")
	_ = interrupt.Register(IRQ_GPT1, "GPT1_IRQHandler")
	_ = interrupt.Register(IRQ_GPT2, "GPT2_IRQHandler")
	_ = interrupt.Register(IRQ_PWM1_0, "PWM1_0_IRQHandler")
	_ = interrupt.Register(IRQ_PWM1_1, "PWM1_1_IRQHandler")
	_ = interrupt.Register(IRQ_PWM1_2, "PWM1_2_IRQHandler")
	_ = interrupt.Register(IRQ_PWM1_3, "PWM1_3_IRQHandler")
	_ = interrupt.Register(IRQ_PWM1_FAULT, "PWM1_FAULT_IRQHandler")
	_ = interrupt.Register(IRQ_FLEXSPI2, "FLEXSPI2_IRQHandler")
	_ = interrupt.Register(IRQ_FLEXSPI, "FLEXSPI_IRQHandler")
	_ = interrupt.Register(IRQ_SEMC, "SEMC_IRQHandler")
	_ = interrupt.Register(IRQ_USDHC1, "USDHC1_IRQHandler")
	_ = interrupt.Register(IRQ_USDHC2, "USDHC2_IRQHandler")
	_ = interrupt.Register(IRQ_USB_OTG2, "USB_OTG2_IRQHandler")
	_ = interrupt.Register(IRQ_USB_OTG1, "USB_OTG1_IRQHandler")
	_ = interrupt.Register(IRQ_ENET, "ENET_IRQHandler")
	_ = interrupt.Register(IRQ_ENET_1588_Timer, "ENET_1588_Timer_IRQHandler")
	_ = interrupt.Register(IRQ_XBAR1_IRQ_0_1, "XBAR1_IRQ_0_1_IRQHandler")
	_ = interrupt.Register(IRQ_XBAR1_IRQ_2_3, "XBAR1_IRQ_2_3_IRQHandler")
	_ = interrupt.Register(IRQ_ADC_ETC_IRQ0, "ADC_ETC_IRQ0_IRQHandler")
	_ = interrupt.Register(IRQ_ADC_ETC_IRQ1, "ADC_ETC_IRQ1_IRQHandler")
	_ = interrupt.Register(IRQ_ADC_ETC_IRQ2, "ADC_ETC_IRQ2_IRQHandler")
	_ = interrupt.Register(IRQ_ADC_ETC_ERROR_IRQ, "ADC_ETC_ERROR_IRQ_IRQHandler")
	_ = interrupt.Register(IRQ_PIT, "PIT_IRQHandler")
	_ = interrupt.Register(IRQ_ACMP1, "ACMP1_IRQHandler")
	_ = interrupt.Register(IRQ_ACMP2, "ACMP2_IRQHandler")
	_ = interrupt.Register(IRQ_ACMP3, "ACMP3_IRQHandler")
	_ = interrupt.Register(IRQ_ACMP4, "ACMP4_IRQHandler")
	_ = interrupt.Register(IRQ_Reserved143, "Reserved143_IRQHandler")
	_ = interrupt.Register(IRQ_Reserved144, "Reserved144_IRQHandler")
	_ = interrupt.Register(IRQ_ENC1, "ENC1_IRQHandler")
	_ = interrupt.Register(IRQ_ENC2, "ENC2_IRQHandler")
	_ = interrupt.Register(IRQ_ENC3, "ENC3_IRQHandler")
	_ = interrupt.Register(IRQ_ENC4, "ENC4_IRQHandler")
	_ = interrupt.Register(IRQ_TMR1, "TMR1_IRQHandler")
	_ = interrupt.Register(IRQ_TMR2, "TMR2_IRQHandler")
	_ = interrupt.Register(IRQ_TMR3, "TMR3_IRQHandler")
	_ = interrupt.Register(IRQ_TMR4, "TMR4_IRQHandler")
	_ = interrupt.Register(IRQ_PWM2_0, "PWM2_0_IRQHandler")
	_ = interrupt.Register(IRQ_PWM2_1, "PWM2_1_IRQHandler")
	_ = interrupt.Register(IRQ_PWM2_2, "PWM2_2_IRQHandler")
	_ = interrupt.Register(IRQ_PWM2_3, "PWM2_3_IRQHandler")
	_ = interrupt.Register(IRQ_PWM2_FAULT, "PWM2_FAULT_IRQHandler")
	_ = interrupt.Register(IRQ_PWM3_0, "PWM3_0_IRQHandler")
	_ = interrupt.Register(IRQ_PWM3_1, "PWM3_1_IRQHandler")
	_ = interrupt.Register(IRQ_PWM3_2, "PWM3_2_IRQHandler")
	_ = interrupt.Register(IRQ_PWM3_3, "PWM3_3_IRQHandler")
	_ = interrupt.Register(IRQ_PWM3_FAULT, "PWM3_FAULT_IRQHandler")
	_ = interrupt.Register(IRQ_PWM4_0, "PWM4_0_IRQHandler")
	_ = interrupt.Register(IRQ_PWM4_1, "PWM4_1_IRQHandler")
	_ = interrupt.Register(IRQ_PWM4_2, "PWM4_2_IRQHandler")
	_ = interrupt.Register(IRQ_PWM4_3, "PWM4_3_IRQHandler")
	_ = interrupt.Register(IRQ_PWM4_FAULT, "PWM4_FAULT_IRQHandler")
	_ = interrupt.Register(IRQ_ENET2, "ENET2_IRQHandler")
	_ = interrupt.Register(IRQ_ENET2_1588_Timer, "ENET2_1588_Timer_IRQHandler")
	_ = interrupt.Register(IRQ_CAN3, "CAN3_IRQHandler")
	_ = interrupt.Register(IRQ_Reserved171, "Reserved171_IRQHandler")
	_ = interrupt.Register(IRQ_FLEXIO3, "FLEXIO3_IRQHandler")
	_ = interrupt.Register(IRQ_GPIO6_7_8_9, "GPIO6_7_8_9_IRQHandler")
)

// Peripherals.
var (
	// AIPSTZ Control Registers
	AIPSTZ1 = (*AIPSTZ_Type)(unsafe.Pointer(uintptr(0x4007c000)))

	// DCDC
	DCDC = (*DCDC_Type)(unsafe.Pointer(uintptr(0x40080000)))

	// PIT
	PIT = (*PIT_Type)(unsafe.Pointer(uintptr(0x40084000)))

	// High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
	CMP1 = (*ACMP_Type)(unsafe.Pointer(uintptr(0x40094000)))

	// IOMUXC
	IOMUXC_SNVS_GPR = (*IOMUXC_SNVS_GPR_Type)(unsafe.Pointer(uintptr(0x400a4000)))

	// IOMUXC_SNVS
	IOMUXC_SNVS = (*IOMUXC_SNVS_Type)(unsafe.Pointer(uintptr(0x400a8000)))

	// IOMUXC_GPR
	IOMUXC_GPR = (*IOMUXC_GPR_Type)(unsafe.Pointer(uintptr(0x400ac000)))

	// FLEXRAM
	FLEXRAM = (*FLEXRAM_Type)(unsafe.Pointer(uintptr(0x400b0000)))

	// EWM
	EWM = (*EWM_Type)(unsafe.Pointer(uintptr(0x400b4000)))

	// WDOG
	WDOG1 = (*WDOG_Type)(unsafe.Pointer(uintptr(0x400b8000)))

	// WDOG
	RTWDOG = (*RTWDOG_Type)(unsafe.Pointer(uintptr(0x400bc000)))

	// Analog-to-Digital Converter
	ADC1 = (*ADC_Type)(unsafe.Pointer(uintptr(0x400c4000)))

	// TRNG
	TRNG = (*TRNG_Type)(unsafe.Pointer(uintptr(0x400cc000)))

	// SNVS
	SNVS = (*SNVS_Type)(unsafe.Pointer(uintptr(0x400d4000)))

	// CCM_ANALOG
	CCM_ANALOG = (*CCM_ANALOG_Type)(unsafe.Pointer(uintptr(0x400d8000)))

	// PMU
	PMU = (*PMU_Type)(unsafe.Pointer(uintptr(0x400d8000)))

	// Temperature Monitor
	TEMPMON = (*TEMPMON_Type)(unsafe.Pointer(uintptr(0x400d8000)))

	// USB Analog
	USB_ANALOG = (*USB_ANALOG_Type)(unsafe.Pointer(uintptr(0x400d8000)))

	// XTALOSC24M
	XTALOSC24M = (*XTALOSC24M_Type)(unsafe.Pointer(uintptr(0x400d8000)))

	// USBPHY Register Reference Index
	USBPHY1 = (*USBPHY_Type)(unsafe.Pointer(uintptr(0x400d9000)))

	// CSU registers
	CSU = (*CSU_Type)(unsafe.Pointer(uintptr(0x400dc000)))

	// Touch Screen Controller
	TSC = (*TSC_Type)(unsafe.Pointer(uintptr(0x400e0000)))

	// DMA
	DMA0 = (*DMA_Type)(unsafe.Pointer(uintptr(0x400e8000)))

	// DMA_CH_MUX
	DMAMUX = (*DMAMUX_Type)(unsafe.Pointer(uintptr(0x400ec000)))

	// GPC
	GPC = (*GPC_Type)(unsafe.Pointer(uintptr(0x400f4000)))

	// PGC
	PGC = (*PGC_Type)(unsafe.Pointer(uintptr(0x400f4000)))

	// SRC
	SRC = (*SRC_Type)(unsafe.Pointer(uintptr(0x400f8000)))

	// CCM
	CCM = (*CCM_Type)(unsafe.Pointer(uintptr(0x400fc000)))

	// ROMC
	ROMC = (*ROMC_Type)(unsafe.Pointer(uintptr(0x40180000)))

	// LPUART
	LPUART1 = (*LPUART_Type)(unsafe.Pointer(uintptr(0x40184000)))

	// FLEXIO
	FLEXIO1 = (*FLEXIO_Type)(unsafe.Pointer(uintptr(0x401ac000)))

	// GPIO
	GPIO1 = (*GPIO_Type)(unsafe.Pointer(uintptr(0x401b8000)))

	// FLEXCAN
	CAN1 = (*CAN_Type)(unsafe.Pointer(uintptr(0x401d0000)))

	// CAN
	CAN3 = (*CAN_Type)(unsafe.Pointer(uintptr(0x401d8000)))

	// Quad Timer
	TMR1 = (*TMR_Type)(unsafe.Pointer(uintptr(0x401dc000)))

	// GPT
	GPT1 = (*GPT_Type)(unsafe.Pointer(uintptr(0x401ec000)))

	// OCOTP
	OCOTP = (*OCOTP_Type)(unsafe.Pointer(uintptr(0x401f4000)))

	// IOMUXC
	IOMUXC = (*IOMUXC_Type)(unsafe.Pointer(uintptr(0x401f8000)))

	// KPP Registers
	KPP = (*KPP_Type)(unsafe.Pointer(uintptr(0x401fc000)))

	// FlexSPI
	FLEXSPI = (*FlexSPI_Type)(unsafe.Pointer(uintptr(0x402a8000)))

	// PXP v2.0 Register Reference Index
	PXP = (*PXP_Type)(unsafe.Pointer(uintptr(0x402b4000)))

	// LCDIF Register Reference Index
	LCDIF = (*LCDIF_Type)(unsafe.Pointer(uintptr(0x402b8000)))

	// CSI
	CSI = (*CSI_Type)(unsafe.Pointer(uintptr(0x402bc000)))

	// uSDHC
	USDHC1 = (*USDHC_Type)(unsafe.Pointer(uintptr(0x402c0000)))

	// Ethernet MAC-NET Core
	ENET = (*ENET_Type)(unsafe.Pointer(uintptr(0x402d8000)))

	// Ethernet MAC-NET Core
	ENET2 = (*ENET_Type)(unsafe.Pointer(uintptr(0x402d4000)))

	// USB
	USB1 = (*USB_Type)(unsafe.Pointer(uintptr(0x402e0000)))

	// USB
	USBNC1 = (*USBNC_Type)(unsafe.Pointer(uintptr(0x402e0000)))

	// SEMC
	SEMC = (*SEMC_Type)(unsafe.Pointer(uintptr(0x402f0000)))

	// DCP register reference index
	DCP = (*DCP_Type)(unsafe.Pointer(uintptr(0x402fc000)))

	// SPDIF
	SPDIF = (*SPDIF_Type)(unsafe.Pointer(uintptr(0x40380000)))

	// I2S
	SAI1 = (*I2S_Type)(unsafe.Pointer(uintptr(0x40384000)))

	// LPSPI
	LPSPI1 = (*LPSPI_Type)(unsafe.Pointer(uintptr(0x40394000)))

	// ADC_ETC
	ADC_ETC = (*ADC_ETC_Type)(unsafe.Pointer(uintptr(0x403b0000)))

	// AND/OR/INVERT module
	AOI1 = (*AOI_Type)(unsafe.Pointer(uintptr(0x403b4000)))

	// Crossbar Switch
	XBARA1 = (*XBARA_Type)(unsafe.Pointer(uintptr(0x403bc000)))

	// Crossbar Switch
	XBARB2 = (*XBARA_Type)(unsafe.Pointer(uintptr(0x403c0000)))

	// Quadrature Decoder
	ENC1 = (*ENC_Type)(unsafe.Pointer(uintptr(0x403c8000)))

	// PWM
	PWM1 = (*PWM_Type)(unsafe.Pointer(uintptr(0x403dc000)))

	// Bus Encryption Engine
	BEE = (*BEE_Type)(unsafe.Pointer(uintptr(0x403ec000)))

	// LPI2C
	LPI2C1 = (*LPI2C_Type)(unsafe.Pointer(uintptr(0x403f0000)))

	// System Control Block
	SystemControl = (*SCB_Type)(unsafe.Pointer(uintptr(0xe000e000)))

	// Nested Vectored Interrupt Controller
	NVIC = (*NVIC_Type)(unsafe.Pointer(uintptr(0xe000e100)))

	// AIPSTZ Control Registers
	AIPSTZ2 = (*AIPSTZ_Type)(unsafe.Pointer(uintptr(0x4017c000)))

	// AIPSTZ Control Registers
	AIPSTZ3 = (*AIPSTZ_Type)(unsafe.Pointer(uintptr(0x4027c000)))

	// AIPSTZ Control Registers
	AIPSTZ4 = (*AIPSTZ_Type)(unsafe.Pointer(uintptr(0x4037c000)))

	// High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
	CMP2 = (*ACMP_Type)(unsafe.Pointer(uintptr(0x40094008)))

	// High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
	CMP3 = (*ACMP_Type)(unsafe.Pointer(uintptr(0x40094010)))

	// High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
	CMP4 = (*ACMP_Type)(unsafe.Pointer(uintptr(0x40094018)))

	// WDOG
	WDOG2 = (*WDOG_Type)(unsafe.Pointer(uintptr(0x400d0000)))

	// Analog-to-Digital Converter
	ADC2 = (*ADC_Type)(unsafe.Pointer(uintptr(0x400c8000)))

	// USBPHY Register Reference Index
	USBPHY2 = (*USBPHY_Type)(unsafe.Pointer(uintptr(0x400da000)))

	// LPUART
	LPUART2 = (*LPUART_Type)(unsafe.Pointer(uintptr(0x40188000)))

	// LPUART
	LPUART3 = (*LPUART_Type)(unsafe.Pointer(uintptr(0x4018c000)))

	// LPUART
	LPUART4 = (*LPUART_Type)(unsafe.Pointer(uintptr(0x40190000)))

	// LPUART
	LPUART5 = (*LPUART_Type)(unsafe.Pointer(uintptr(0x40194000)))

	// LPUART
	LPUART6 = (*LPUART_Type)(unsafe.Pointer(uintptr(0x40198000)))

	// LPUART
	LPUART7 = (*LPUART_Type)(unsafe.Pointer(uintptr(0x4019c000)))

	// LPUART
	LPUART8 = (*LPUART_Type)(unsafe.Pointer(uintptr(0x401a0000)))

	// FLEXIO
	FLEXIO2 = (*FLEXIO_Type)(unsafe.Pointer(uintptr(0x401b0000)))

	// FLEXIO
	FLEXIO3 = (*FLEXIO_Type)(unsafe.Pointer(uintptr(0x42020000)))

	// GPIO
	GPIO5 = (*GPIO_Type)(unsafe.Pointer(uintptr(0x400c0000)))

	// GPIO
	GPIO2 = (*GPIO_Type)(unsafe.Pointer(uintptr(0x401bc000)))

	// GPIO
	GPIO3 = (*GPIO_Type)(unsafe.Pointer(uintptr(0x401c0000)))

	// GPIO
	GPIO4 = (*GPIO_Type)(unsafe.Pointer(uintptr(0x401c4000)))

	// GPIO
	GPIO6 = (*GPIO_Type)(unsafe.Pointer(uintptr(0x42000000)))

	// GPIO
	GPIO7 = (*GPIO_Type)(unsafe.Pointer(uintptr(0x42004000)))

	// GPIO
	GPIO8 = (*GPIO_Type)(unsafe.Pointer(uintptr(0x42008000)))

	// GPIO
	GPIO9 = (*GPIO_Type)(unsafe.Pointer(uintptr(0x4200c000)))

	// FLEXCAN
	CAN2 = (*CAN_Type)(unsafe.Pointer(uintptr(0x401d4000)))

	// Quad Timer
	TMR2 = (*TMR_Type)(unsafe.Pointer(uintptr(0x401e0000)))

	// Quad Timer
	TMR3 = (*TMR_Type)(unsafe.Pointer(uintptr(0x401e4000)))

	// Quad Timer
	TMR4 = (*TMR_Type)(unsafe.Pointer(uintptr(0x401e8000)))

	// GPT
	GPT2 = (*GPT_Type)(unsafe.Pointer(uintptr(0x401f0000)))

	// FlexSPI
	FLEXSPI2 = (*FlexSPI_Type)(unsafe.Pointer(uintptr(0x402a4000)))

	// uSDHC
	USDHC2 = (*USDHC_Type)(unsafe.Pointer(uintptr(0x402c4000)))

	// USB
	USB2 = (*USB_Type)(unsafe.Pointer(uintptr(0x402e0200)))

	// USB
	USBNC2 = (*USBNC_Type)(unsafe.Pointer(uintptr(0x402e0004)))

	// I2S
	SAI2 = (*I2S_Type)(unsafe.Pointer(uintptr(0x40388000)))

	// I2S
	SAI3 = (*I2S_Type)(unsafe.Pointer(uintptr(0x4038c000)))

	// LPSPI
	LPSPI2 = (*LPSPI_Type)(unsafe.Pointer(uintptr(0x40398000)))

	// LPSPI
	LPSPI3 = (*LPSPI_Type)(unsafe.Pointer(uintptr(0x4039c000)))

	// LPSPI
	LPSPI4 = (*LPSPI_Type)(unsafe.Pointer(uintptr(0x403a0000)))

	// AND/OR/INVERT module
	AOI2 = (*AOI_Type)(unsafe.Pointer(uintptr(0x403b8000)))

	// Crossbar Switch
	XBARB3 = (*XBARA_Type)(unsafe.Pointer(uintptr(0x403c4000)))

	// Quadrature Decoder
	ENC2 = (*ENC_Type)(unsafe.Pointer(uintptr(0x403cc000)))

	// Quadrature Decoder
	ENC3 = (*ENC_Type)(unsafe.Pointer(uintptr(0x403d0000)))

	// Quadrature Decoder
	ENC4 = (*ENC_Type)(unsafe.Pointer(uintptr(0x403d4000)))

	// PWM
	PWM2 = (*PWM_Type)(unsafe.Pointer(uintptr(0x403e0000)))

	// PWM
	PWM3 = (*PWM_Type)(unsafe.Pointer(uintptr(0x403e4000)))

	// PWM
	PWM4 = (*PWM_Type)(unsafe.Pointer(uintptr(0x403e8000)))

	// LPI2C
	LPI2C2 = (*LPI2C_Type)(unsafe.Pointer(uintptr(0x403f4000)))

	// LPI2C
	LPI2C3 = (*LPI2C_Type)(unsafe.Pointer(uintptr(0x403f8000)))

	// LPI2C
	LPI2C4 = (*LPI2C_Type)(unsafe.Pointer(uintptr(0x403fc000)))
)

// AIPSTZ Control Registers
type AIPSTZ_Type struct {
	MPR    volatile.Register32 // 0x0
	_      [60]byte
	OPACR  volatile.Register32 // 0x40
	OPACR1 volatile.Register32 // 0x44
	OPACR2 volatile.Register32 // 0x48
	OPACR3 volatile.Register32 // 0x4C
	OPACR4 volatile.Register32 // 0x50
}

// DCDC
type DCDC_Type struct {
	REG0 volatile.Register32 // 0x0
	REG1 volatile.Register32 // 0x4
	REG2 volatile.Register32 // 0x8
	REG3 volatile.Register32 // 0xC
}

// PIT
type PIT_Type struct {
	MCR     volatile.Register32 // 0x0
	_       [220]byte
	LTMR64H volatile.Register32 // 0xE0
	LTMR64L volatile.Register32 // 0xE4
	_       [24]byte
	TIMER   [4]struct {
		LDVAL volatile.Register32
		CVAL  volatile.Register32
		TCTRL volatile.Register32
		TFLG  volatile.Register32
	} // 0x100
}

// High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
type ACMP_Type struct {
	CR0   volatile.Register8 // 0x0
	CR1   volatile.Register8 // 0x1
	FPR   volatile.Register8 // 0x2
	SCR   volatile.Register8 // 0x3
	DACCR volatile.Register8 // 0x4
	MUXCR volatile.Register8 // 0x5
}

// IOMUXC
type IOMUXC_SNVS_GPR_Type struct {
	GPR0 volatile.Register32 // 0x0
	GPR1 volatile.Register32 // 0x4
	GPR2 volatile.Register32 // 0x8
	GPR3 volatile.Register32 // 0xC
}

// IOMUXC_SNVS
type IOMUXC_SNVS_Type struct {
	SW_MUX_CTL_PAD_WAKEUP        volatile.Register32 // 0x0
	SW_MUX_CTL_PAD_PMIC_ON_REQ   volatile.Register32 // 0x4
	SW_MUX_CTL_PAD_PMIC_STBY_REQ volatile.Register32 // 0x8
	SW_PAD_CTL_PAD_TEST_MODE     volatile.Register32 // 0xC
	SW_PAD_CTL_PAD_POR_B         volatile.Register32 // 0x10
	SW_PAD_CTL_PAD_ONOFF         volatile.Register32 // 0x14
	SW_PAD_CTL_PAD_WAKEUP        volatile.Register32 // 0x18
	SW_PAD_CTL_PAD_PMIC_ON_REQ   volatile.Register32 // 0x1C
	SW_PAD_CTL_PAD_PMIC_STBY_REQ volatile.Register32 // 0x20
}

// IOMUXC_GPR
type IOMUXC_GPR_Type struct {
	GPR0  volatile.Register32 // 0x0
	GPR1  volatile.Register32 // 0x4
	GPR2  volatile.Register32 // 0x8
	GPR3  volatile.Register32 // 0xC
	GPR4  volatile.Register32 // 0x10
	GPR5  volatile.Register32 // 0x14
	GPR6  volatile.Register32 // 0x18
	GPR7  volatile.Register32 // 0x1C
	GPR8  volatile.Register32 // 0x20
	GPR9  volatile.Register32 // 0x24
	GPR10 volatile.Register32 // 0x28
	GPR11 volatile.Register32 // 0x2C
	GPR12 volatile.Register32 // 0x30
	GPR13 volatile.Register32 // 0x34
	GPR14 volatile.Register32 // 0x38
	GPR15 volatile.Register32 // 0x3C
	GPR16 volatile.Register32 // 0x40
	GPR17 volatile.Register32 // 0x44
	GPR18 volatile.Register32 // 0x48
	GPR19 volatile.Register32 // 0x4C
	GPR20 volatile.Register32 // 0x50
	GPR21 volatile.Register32 // 0x54
	GPR22 volatile.Register32 // 0x58
	GPR23 volatile.Register32 // 0x5C
	GPR24 volatile.Register32 // 0x60
	GPR25 volatile.Register32 // 0x64
	GPR26 volatile.Register32 // 0x68
	GPR27 volatile.Register32 // 0x6C
	GPR28 volatile.Register32 // 0x70
	GPR29 volatile.Register32 // 0x74
	GPR30 volatile.Register32 // 0x78
	GPR31 volatile.Register32 // 0x7C
	GPR32 volatile.Register32 // 0x80
	GPR33 volatile.Register32 // 0x84
	GPR34 volatile.Register32 // 0x88
}

// FLEXRAM
type FLEXRAM_Type struct {
	TCM_CTRL    volatile.Register32 // 0x0
	_           [12]byte
	INT_STATUS  volatile.Register32 // 0x10
	INT_STAT_EN volatile.Register32 // 0x14
	INT_SIG_EN  volatile.Register32 // 0x18
}

// EWM
type EWM_Type struct {
	CTRL         volatile.Register8 // 0x0
	SERV         volatile.Register8 // 0x1
	CMPL         volatile.Register8 // 0x2
	CMPH         volatile.Register8 // 0x3
	CLKCTRL      volatile.Register8 // 0x4
	CLKPRESCALER volatile.Register8 // 0x5
}

// WDOG
type WDOG_Type struct {
	WCR  volatile.Register16 // 0x0
	WSR  volatile.Register16 // 0x2
	WRSR volatile.Register16 // 0x4
	WICR volatile.Register16 // 0x6
	WMCR volatile.Register16 // 0x8
}

// WDOG
type RTWDOG_Type struct {
	CS    volatile.Register32 // 0x0
	CNT   volatile.Register32 // 0x4
	TOVAL volatile.Register32 // 0x8
	WIN   volatile.Register32 // 0xC
}

// Analog-to-Digital Converter
type ADC_Type struct {
	HC0 volatile.Register32 // 0x0
	HC1 volatile.Register32 // 0x4
	HC2 volatile.Register32 // 0x8
	HC3 volatile.Register32 // 0xC
	HC4 volatile.Register32 // 0x10
	HC5 volatile.Register32 // 0x14
	HC6 volatile.Register32 // 0x18
	HC7 volatile.Register32 // 0x1C
	HS  volatile.Register32 // 0x20
	R0  volatile.Register32 // 0x24
	R1  volatile.Register32 // 0x28
	R2  volatile.Register32 // 0x2C
	R3  volatile.Register32 // 0x30
	R4  volatile.Register32 // 0x34
	R5  volatile.Register32 // 0x38
	R6  volatile.Register32 // 0x3C
	R7  volatile.Register32 // 0x40
	CFG volatile.Register32 // 0x44
	GC  volatile.Register32 // 0x48
	GS  volatile.Register32 // 0x4C
	CV  volatile.Register32 // 0x50
	OFS volatile.Register32 // 0x54
	CAL volatile.Register32 // 0x58
}

// TRNG
type TRNG_Type struct {
	MCTL       volatile.Register32     // 0x0
	SCMISC     volatile.Register32     // 0x4
	PKRRNG     volatile.Register32     // 0x8
	PKRMAX     volatile.Register32     // 0xC
	SDCTL      volatile.Register32     // 0x10
	SBLIM      volatile.Register32     // 0x14
	FRQMIN     volatile.Register32     // 0x18
	FRQCNT     volatile.Register32     // 0x1C
	SCMC       volatile.Register32     // 0x20
	SCR1C      volatile.Register32     // 0x24
	SCR2C      volatile.Register32     // 0x28
	SCR3C      volatile.Register32     // 0x2C
	SCR4C      volatile.Register32     // 0x30
	SCR5C      volatile.Register32     // 0x34
	SCR6PC     volatile.Register32     // 0x38
	STATUS     volatile.Register32     // 0x3C
	ENT        [16]volatile.Register32 // 0x40
	PKRCNT10   volatile.Register32     // 0x80
	PKRCNT32   volatile.Register32     // 0x84
	PKRCNT54   volatile.Register32     // 0x88
	PKRCNT76   volatile.Register32     // 0x8C
	PKRCNT98   volatile.Register32     // 0x90
	PKRCNTBA   volatile.Register32     // 0x94
	PKRCNTDC   volatile.Register32     // 0x98
	PKRCNTFE   volatile.Register32     // 0x9C
	SEC_CFG    volatile.Register32     // 0xA0
	INT_CTRL   volatile.Register32     // 0xA4
	INT_MASK   volatile.Register32     // 0xA8
	INT_STATUS volatile.Register32     // 0xAC
	_          [64]byte
	VID1       volatile.Register32 // 0xF0
	VID2       volatile.Register32 // 0xF4
}

// SNVS
type SNVS_Type struct {
	HPLR                volatile.Register32 // 0x0
	HPCOMR              volatile.Register32 // 0x4
	HPCR                volatile.Register32 // 0x8
	HPSICR              volatile.Register32 // 0xC
	HPSVCR              volatile.Register32 // 0x10
	HPSR                volatile.Register32 // 0x14
	HPSVSR              volatile.Register32 // 0x18
	HPHACIVR            volatile.Register32 // 0x1C
	HPHACR              volatile.Register32 // 0x20
	HPRTCMR             volatile.Register32 // 0x24
	HPRTCLR             volatile.Register32 // 0x28
	HPTAMR              volatile.Register32 // 0x2C
	HPTALR              volatile.Register32 // 0x30
	LPLR                volatile.Register32 // 0x34
	LPCR                volatile.Register32 // 0x38
	LPMKCR              volatile.Register32 // 0x3C
	LPSVCR              volatile.Register32 // 0x40
	_                   [4]byte
	LPTDCR              volatile.Register32    // 0x48
	LPSR                volatile.Register32    // 0x4C
	LPSRTCMR            volatile.Register32    // 0x50
	LPSRTCLR            volatile.Register32    // 0x54
	LPTAR               volatile.Register32    // 0x58
	LPSMCMR             volatile.Register32    // 0x5C
	LPSMCLR             volatile.Register32    // 0x60
	LPPGDR              volatile.Register32    // 0x64
	LPGPR0_legacy_alias volatile.Register32    // 0x68
	LPZMKR              [8]volatile.Register32 // 0x6C
	_                   [4]byte
	LPGPR_alias         [4]volatile.Register32 // 0x90
	_                   [96]byte
	LPGPR               [8]volatile.Register32 // 0x100
	_                   [2776]byte
	HPVIDR1             volatile.Register32 // 0xBF8
	HPVIDR2             volatile.Register32 // 0xBFC
}

// CCM_ANALOG
type CCM_ANALOG_Type struct {
	PLL_ARM         volatile.Register32 // 0x0
	PLL_ARM_SET     volatile.Register32 // 0x4
	PLL_ARM_CLR     volatile.Register32 // 0x8
	PLL_ARM_TOG     volatile.Register32 // 0xC
	PLL_USB1        volatile.Register32 // 0x10
	PLL_USB1_SET    volatile.Register32 // 0x14
	PLL_USB1_CLR    volatile.Register32 // 0x18
	PLL_USB1_TOG    volatile.Register32 // 0x1C
	PLL_USB2        volatile.Register32 // 0x20
	PLL_USB2_SET    volatile.Register32 // 0x24
	PLL_USB2_CLR    volatile.Register32 // 0x28
	PLL_USB2_TOG    volatile.Register32 // 0x2C
	PLL_SYS         volatile.Register32 // 0x30
	PLL_SYS_SET     volatile.Register32 // 0x34
	PLL_SYS_CLR     volatile.Register32 // 0x38
	PLL_SYS_TOG     volatile.Register32 // 0x3C
	PLL_SYS_SS      volatile.Register32 // 0x40
	_               [12]byte
	PLL_SYS_NUM     volatile.Register32 // 0x50
	_               [12]byte
	PLL_SYS_DENOM   volatile.Register32 // 0x60
	_               [12]byte
	PLL_AUDIO       volatile.Register32 // 0x70
	PLL_AUDIO_SET   volatile.Register32 // 0x74
	PLL_AUDIO_CLR   volatile.Register32 // 0x78
	PLL_AUDIO_TOG   volatile.Register32 // 0x7C
	PLL_AUDIO_NUM   volatile.Register32 // 0x80
	_               [12]byte
	PLL_AUDIO_DENOM volatile.Register32 // 0x90
	_               [12]byte
	PLL_VIDEO       volatile.Register32 // 0xA0
	PLL_VIDEO_SET   volatile.Register32 // 0xA4
	PLL_VIDEO_CLR   volatile.Register32 // 0xA8
	PLL_VIDEO_TOG   volatile.Register32 // 0xAC
	PLL_VIDEO_NUM   volatile.Register32 // 0xB0
	_               [12]byte
	PLL_VIDEO_DENOM volatile.Register32 // 0xC0
	_               [28]byte
	PLL_ENET        volatile.Register32 // 0xE0
	PLL_ENET_SET    volatile.Register32 // 0xE4
	PLL_ENET_CLR    volatile.Register32 // 0xE8
	PLL_ENET_TOG    volatile.Register32 // 0xEC
	PFD_480         volatile.Register32 // 0xF0
	PFD_480_SET     volatile.Register32 // 0xF4
	PFD_480_CLR     volatile.Register32 // 0xF8
	PFD_480_TOG     volatile.Register32 // 0xFC
	PFD_528         volatile.Register32 // 0x100
	PFD_528_SET     volatile.Register32 // 0x104
	PFD_528_CLR     volatile.Register32 // 0x108
	PFD_528_TOG     volatile.Register32 // 0x10C
	_               [64]byte
	MISC0           volatile.Register32 // 0x150
	MISC0_SET       volatile.Register32 // 0x154
	MISC0_CLR       volatile.Register32 // 0x158
	MISC0_TOG       volatile.Register32 // 0x15C
	MISC1           volatile.Register32 // 0x160
	MISC1_SET       volatile.Register32 // 0x164
	MISC1_CLR       volatile.Register32 // 0x168
	MISC1_TOG       volatile.Register32 // 0x16C
	MISC2           volatile.Register32 // 0x170
	MISC2_SET       volatile.Register32 // 0x174
	MISC2_CLR       volatile.Register32 // 0x178
	MISC2_TOG       volatile.Register32 // 0x17C
}

// PMU
type PMU_Type struct {
	_            [272]byte
	REG_1P1      volatile.Register32 // 0x110
	REG_1P1_SET  volatile.Register32 // 0x114
	REG_1P1_CLR  volatile.Register32 // 0x118
	REG_1P1_TOG  volatile.Register32 // 0x11C
	REG_3P0      volatile.Register32 // 0x120
	REG_3P0_SET  volatile.Register32 // 0x124
	REG_3P0_CLR  volatile.Register32 // 0x128
	REG_3P0_TOG  volatile.Register32 // 0x12C
	REG_2P5      volatile.Register32 // 0x130
	REG_2P5_SET  volatile.Register32 // 0x134
	REG_2P5_CLR  volatile.Register32 // 0x138
	REG_2P5_TOG  volatile.Register32 // 0x13C
	REG_CORE     volatile.Register32 // 0x140
	REG_CORE_SET volatile.Register32 // 0x144
	REG_CORE_CLR volatile.Register32 // 0x148
	REG_CORE_TOG volatile.Register32 // 0x14C
	MISC0        volatile.Register32 // 0x150
	MISC0_SET    volatile.Register32 // 0x154
	MISC0_CLR    volatile.Register32 // 0x158
	MISC0_TOG    volatile.Register32 // 0x15C
	MISC1        volatile.Register32 // 0x160
	MISC1_SET    volatile.Register32 // 0x164
	MISC1_CLR    volatile.Register32 // 0x168
	MISC1_TOG    volatile.Register32 // 0x16C
	MISC2        volatile.Register32 // 0x170
	MISC2_SET    volatile.Register32 // 0x174
	MISC2_CLR    volatile.Register32 // 0x178
	MISC2_TOG    volatile.Register32 // 0x17C
}

// Temperature Monitor
type TEMPMON_Type struct {
	_              [384]byte
	TEMPSENSE0     volatile.Register32 // 0x180
	TEMPSENSE0_SET volatile.Register32 // 0x184
	TEMPSENSE0_CLR volatile.Register32 // 0x188
	TEMPSENSE0_TOG volatile.Register32 // 0x18C
	TEMPSENSE1     volatile.Register32 // 0x190
	TEMPSENSE1_SET volatile.Register32 // 0x194
	TEMPSENSE1_CLR volatile.Register32 // 0x198
	TEMPSENSE1_TOG volatile.Register32 // 0x19C
	_              [240]byte
	TEMPSENSE2     volatile.Register32 // 0x290
	TEMPSENSE2_SET volatile.Register32 // 0x294
	TEMPSENSE2_CLR volatile.Register32 // 0x298
	TEMPSENSE2_TOG volatile.Register32 // 0x29C
}

// USB Analog
type USB_ANALOG_Type struct {
	_                     [416]byte
	USB1_VBUS_DETECT      volatile.Register32 // 0x1A0
	USB1_VBUS_DETECT_SET  volatile.Register32 // 0x1A4
	USB1_VBUS_DETECT_CLR  volatile.Register32 // 0x1A8
	USB1_VBUS_DETECT_TOG  volatile.Register32 // 0x1AC
	USB1_CHRG_DETECT      volatile.Register32 // 0x1B0
	USB1_CHRG_DETECT_SET  volatile.Register32 // 0x1B4
	USB1_CHRG_DETECT_CLR  volatile.Register32 // 0x1B8
	USB1_CHRG_DETECT_TOG  volatile.Register32 // 0x1BC
	USB1_VBUS_DETECT_STAT volatile.Register32 // 0x1C0
	_                     [12]byte
	USB1_CHRG_DETECT_STAT volatile.Register32 // 0x1D0
	_                     [28]byte
	USB1_MISC             volatile.Register32 // 0x1F0
	USB1_MISC_SET         volatile.Register32 // 0x1F4
	USB1_MISC_CLR         volatile.Register32 // 0x1F8
	USB1_MISC_TOG         volatile.Register32 // 0x1FC
	USB2_VBUS_DETECT      volatile.Register32 // 0x200
	USB2_VBUS_DETECT_SET  volatile.Register32 // 0x204
	USB2_VBUS_DETECT_CLR  volatile.Register32 // 0x208
	USB2_VBUS_DETECT_TOG  volatile.Register32 // 0x20C
	USB2_CHRG_DETECT      volatile.Register32 // 0x210
	USB2_CHRG_DETECT_SET  volatile.Register32 // 0x214
	USB2_CHRG_DETECT_CLR  volatile.Register32 // 0x218
	USB2_CHRG_DETECT_TOG  volatile.Register32 // 0x21C
	USB2_VBUS_DETECT_STAT volatile.Register32 // 0x220
	_                     [12]byte
	USB2_CHRG_DETECT_STAT volatile.Register32 // 0x230
	_                     [28]byte
	USB2_MISC             volatile.Register32 // 0x250
	USB2_MISC_SET         volatile.Register32 // 0x254
	USB2_MISC_CLR         volatile.Register32 // 0x258
	USB2_MISC_TOG         volatile.Register32 // 0x25C
	DIGPROG               volatile.Register32 // 0x260
}

// XTALOSC24M
type XTALOSC24M_Type struct {
	_               [336]byte
	MISC0           volatile.Register32 // 0x150
	MISC0_SET       volatile.Register32 // 0x154
	MISC0_CLR       volatile.Register32 // 0x158
	MISC0_TOG       volatile.Register32 // 0x15C
	_               [272]byte
	LOWPWR_CTRL     volatile.Register32 // 0x270
	LOWPWR_CTRL_SET volatile.Register32 // 0x274
	LOWPWR_CTRL_CLR volatile.Register32 // 0x278
	LOWPWR_CTRL_TOG volatile.Register32 // 0x27C
	_               [32]byte
	OSC_CONFIG0     volatile.Register32 // 0x2A0
	OSC_CONFIG0_SET volatile.Register32 // 0x2A4
	OSC_CONFIG0_CLR volatile.Register32 // 0x2A8
	OSC_CONFIG0_TOG volatile.Register32 // 0x2AC
	OSC_CONFIG1     volatile.Register32 // 0x2B0
	OSC_CONFIG1_SET volatile.Register32 // 0x2B4
	OSC_CONFIG1_CLR volatile.Register32 // 0x2B8
	OSC_CONFIG1_TOG volatile.Register32 // 0x2BC
	OSC_CONFIG2     volatile.Register32 // 0x2C0
	OSC_CONFIG2_SET volatile.Register32 // 0x2C4
	OSC_CONFIG2_CLR volatile.Register32 // 0x2C8
	OSC_CONFIG2_TOG volatile.Register32 // 0x2CC
}

// USBPHY Register Reference Index
type USBPHY_Type struct {
	PWD           volatile.Register32 // 0x0
	PWD_SET       volatile.Register32 // 0x4
	PWD_CLR       volatile.Register32 // 0x8
	PWD_TOG       volatile.Register32 // 0xC
	TX            volatile.Register32 // 0x10
	TX_SET        volatile.Register32 // 0x14
	TX_CLR        volatile.Register32 // 0x18
	TX_TOG        volatile.Register32 // 0x1C
	RX            volatile.Register32 // 0x20
	RX_SET        volatile.Register32 // 0x24
	RX_CLR        volatile.Register32 // 0x28
	RX_TOG        volatile.Register32 // 0x2C
	CTRL          volatile.Register32 // 0x30
	CTRL_SET      volatile.Register32 // 0x34
	CTRL_CLR      volatile.Register32 // 0x38
	CTRL_TOG      volatile.Register32 // 0x3C
	STATUS        volatile.Register32 // 0x40
	_             [12]byte
	DEBUG         volatile.Register32 // 0x50
	DEBUG_SET     volatile.Register32 // 0x54
	DEBUG_CLR     volatile.Register32 // 0x58
	DEBUG_TOG     volatile.Register32 // 0x5C
	DEBUG0_STATUS volatile.Register32 // 0x60
	_             [12]byte
	DEBUG1        volatile.Register32 // 0x70
	DEBUG1_SET    volatile.Register32 // 0x74
	DEBUG1_CLR    volatile.Register32 // 0x78
	DEBUG1_TOG    volatile.Register32 // 0x7C
	VERSION       volatile.Register32 // 0x80
}

// CSU registers
type CSU_Type struct {
	CSL0       volatile.Register32 // 0x0
	CSL1       volatile.Register32 // 0x4
	CSL2       volatile.Register32 // 0x8
	CSL3       volatile.Register32 // 0xC
	CSL4       volatile.Register32 // 0x10
	CSL5       volatile.Register32 // 0x14
	CSL6       volatile.Register32 // 0x18
	CSL7       volatile.Register32 // 0x1C
	CSL8       volatile.Register32 // 0x20
	CSL9       volatile.Register32 // 0x24
	CSL10      volatile.Register32 // 0x28
	CSL11      volatile.Register32 // 0x2C
	CSL12      volatile.Register32 // 0x30
	CSL13      volatile.Register32 // 0x34
	CSL14      volatile.Register32 // 0x38
	CSL15      volatile.Register32 // 0x3C
	CSL16      volatile.Register32 // 0x40
	CSL17      volatile.Register32 // 0x44
	CSL18      volatile.Register32 // 0x48
	CSL19      volatile.Register32 // 0x4C
	CSL20      volatile.Register32 // 0x50
	CSL21      volatile.Register32 // 0x54
	CSL22      volatile.Register32 // 0x58
	CSL23      volatile.Register32 // 0x5C
	CSL24      volatile.Register32 // 0x60
	CSL25      volatile.Register32 // 0x64
	CSL26      volatile.Register32 // 0x68
	CSL27      volatile.Register32 // 0x6C
	CSL28      volatile.Register32 // 0x70
	CSL29      volatile.Register32 // 0x74
	CSL30      volatile.Register32 // 0x78
	CSL31      volatile.Register32 // 0x7C
	_          [384]byte
	HP0        volatile.Register32 // 0x200
	_          [20]byte
	SA         volatile.Register32 // 0x218
	_          [316]byte
	HPCONTROL0 volatile.Register32 // 0x358
}

// Touch Screen Controller
type TSC_Type struct {
	BASIC_SETTING   volatile.Register32 // 0x0
	_               [12]byte
	PRE_CHARGE_TIME volatile.Register32 // 0x10
	_               [12]byte
	FLOW_CONTROL    volatile.Register32 // 0x20
	_               [12]byte
	MEASEURE_VALUE  volatile.Register32 // 0x30
	_               [12]byte
	INT_EN          volatile.Register32 // 0x40
	_               [12]byte
	INT_SIG_EN      volatile.Register32 // 0x50
	_               [12]byte
	INT_STATUS      volatile.Register32 // 0x60
	_               [12]byte
	DEBUG_MODE      volatile.Register32 // 0x70
	_               [12]byte
	DEBUG_MODE2     volatile.Register32 // 0x80
}

// DMA
type DMA_Type struct {
	CR                  volatile.Register32 // 0x0
	ES                  volatile.Register32 // 0x4
	_                   [4]byte
	ERQ                 volatile.Register32 // 0xC
	_                   [4]byte
	EEI                 volatile.Register32 // 0x14
	CEEI                volatile.Register8  // 0x18
	SEEI                volatile.Register8  // 0x19
	CERQ                volatile.Register8  // 0x1A
	SERQ                volatile.Register8  // 0x1B
	CDNE                volatile.Register8  // 0x1C
	SSRT                volatile.Register8  // 0x1D
	CERR                volatile.Register8  // 0x1E
	CINT                volatile.Register8  // 0x1F
	_                   [4]byte
	INT                 volatile.Register32 // 0x24
	_                   [4]byte
	ERR                 volatile.Register32 // 0x2C
	_                   [4]byte
	HRS                 volatile.Register32 // 0x34
	_                   [12]byte
	EARS                volatile.Register32 // 0x44
	_                   [184]byte
	DCHPRI3             volatile.Register8 // 0x100
	DCHPRI2             volatile.Register8 // 0x101
	DCHPRI1             volatile.Register8 // 0x102
	DCHPRI0             volatile.Register8 // 0x103
	DCHPRI7             volatile.Register8 // 0x104
	DCHPRI6             volatile.Register8 // 0x105
	DCHPRI5             volatile.Register8 // 0x106
	DCHPRI4             volatile.Register8 // 0x107
	DCHPRI11            volatile.Register8 // 0x108
	DCHPRI10            volatile.Register8 // 0x109
	DCHPRI9             volatile.Register8 // 0x10A
	DCHPRI8             volatile.Register8 // 0x10B
	DCHPRI15            volatile.Register8 // 0x10C
	DCHPRI14            volatile.Register8 // 0x10D
	DCHPRI13            volatile.Register8 // 0x10E
	DCHPRI12            volatile.Register8 // 0x10F
	DCHPRI19            volatile.Register8 // 0x110
	DCHPRI18            volatile.Register8 // 0x111
	DCHPRI17            volatile.Register8 // 0x112
	DCHPRI16            volatile.Register8 // 0x113
	DCHPRI23            volatile.Register8 // 0x114
	DCHPRI22            volatile.Register8 // 0x115
	DCHPRI21            volatile.Register8 // 0x116
	DCHPRI20            volatile.Register8 // 0x117
	DCHPRI27            volatile.Register8 // 0x118
	DCHPRI26            volatile.Register8 // 0x119
	DCHPRI25            volatile.Register8 // 0x11A
	DCHPRI24            volatile.Register8 // 0x11B
	DCHPRI31            volatile.Register8 // 0x11C
	DCHPRI30            volatile.Register8 // 0x11D
	DCHPRI29            volatile.Register8 // 0x11E
	DCHPRI28            volatile.Register8 // 0x11F
	_                   [3808]byte
	TCD0_SADDR          volatile.Register32 // 0x1000
	TCD0_SOFF           volatile.Register16 // 0x1004
	TCD0_ATTR           volatile.Register16 // 0x1006
	TCD0_NBYTES_MLNO    volatile.Register32 // 0x1008
	TCD0_SLAST          volatile.Register32 // 0x100C
	TCD0_DADDR          volatile.Register32 // 0x1010
	TCD0_DOFF           volatile.Register16 // 0x1014
	TCD0_CITER_ELINKNO  volatile.Register16 // 0x1016
	TCD0_DLASTSGA       volatile.Register32 // 0x1018
	TCD0_CSR            volatile.Register16 // 0x101C
	TCD0_BITER_ELINKNO  volatile.Register16 // 0x101E
	TCD1_SADDR          volatile.Register32 // 0x1020
	TCD1_SOFF           volatile.Register16 // 0x1024
	TCD1_ATTR           volatile.Register16 // 0x1026
	TCD1_NBYTES_MLNO    volatile.Register32 // 0x1028
	TCD1_SLAST          volatile.Register32 // 0x102C
	TCD1_DADDR          volatile.Register32 // 0x1030
	TCD1_DOFF           volatile.Register16 // 0x1034
	TCD1_CITER_ELINKNO  volatile.Register16 // 0x1036
	TCD1_DLASTSGA       volatile.Register32 // 0x1038
	TCD1_CSR            volatile.Register16 // 0x103C
	TCD1_BITER_ELINKNO  volatile.Register16 // 0x103E
	TCD2_SADDR          volatile.Register32 // 0x1040
	TCD2_SOFF           volatile.Register16 // 0x1044
	TCD2_ATTR           volatile.Register16 // 0x1046
	TCD2_NBYTES_MLNO    volatile.Register32 // 0x1048
	TCD2_SLAST          volatile.Register32 // 0x104C
	TCD2_DADDR          volatile.Register32 // 0x1050
	TCD2_DOFF           volatile.Register16 // 0x1054
	TCD2_CITER_ELINKNO  volatile.Register16 // 0x1056
	TCD2_DLASTSGA       volatile.Register32 // 0x1058
	TCD2_CSR            volatile.Register16 // 0x105C
	TCD2_BITER_ELINKNO  volatile.Register16 // 0x105E
	TCD3_SADDR          volatile.Register32 // 0x1060
	TCD3_SOFF           volatile.Register16 // 0x1064
	TCD3_ATTR           volatile.Register16 // 0x1066
	TCD3_NBYTES_MLNO    volatile.Register32 // 0x1068
	TCD3_SLAST          volatile.Register32 // 0x106C
	TCD3_DADDR          volatile.Register32 // 0x1070
	TCD3_DOFF           volatile.Register16 // 0x1074
	TCD3_CITER_ELINKNO  volatile.Register16 // 0x1076
	TCD3_DLASTSGA       volatile.Register32 // 0x1078
	TCD3_CSR            volatile.Register16 // 0x107C
	TCD3_BITER_ELINKNO  volatile.Register16 // 0x107E
	TCD4_SADDR          volatile.Register32 // 0x1080
	TCD4_SOFF           volatile.Register16 // 0x1084
	TCD4_ATTR           volatile.Register16 // 0x1086
	TCD4_NBYTES_MLNO    volatile.Register32 // 0x1088
	TCD4_SLAST          volatile.Register32 // 0x108C
	TCD4_DADDR          volatile.Register32 // 0x1090
	TCD4_DOFF           volatile.Register16 // 0x1094
	TCD4_CITER_ELINKNO  volatile.Register16 // 0x1096
	TCD4_DLASTSGA       volatile.Register32 // 0x1098
	TCD4_CSR            volatile.Register16 // 0x109C
	TCD4_BITER_ELINKNO  volatile.Register16 // 0x109E
	TCD5_SADDR          volatile.Register32 // 0x10A0
	TCD5_SOFF           volatile.Register16 // 0x10A4
	TCD5_ATTR           volatile.Register16 // 0x10A6
	TCD5_NBYTES_MLNO    volatile.Register32 // 0x10A8
	TCD5_SLAST          volatile.Register32 // 0x10AC
	TCD5_DADDR          volatile.Register32 // 0x10B0
	TCD5_DOFF           volatile.Register16 // 0x10B4
	TCD5_CITER_ELINKNO  volatile.Register16 // 0x10B6
	TCD5_DLASTSGA       volatile.Register32 // 0x10B8
	TCD5_CSR            volatile.Register16 // 0x10BC
	TCD5_BITER_ELINKNO  volatile.Register16 // 0x10BE
	TCD6_SADDR          volatile.Register32 // 0x10C0
	TCD6_SOFF           volatile.Register16 // 0x10C4
	TCD6_ATTR           volatile.Register16 // 0x10C6
	TCD6_NBYTES_MLNO    volatile.Register32 // 0x10C8
	TCD6_SLAST          volatile.Register32 // 0x10CC
	TCD6_DADDR          volatile.Register32 // 0x10D0
	TCD6_DOFF           volatile.Register16 // 0x10D4
	TCD6_CITER_ELINKNO  volatile.Register16 // 0x10D6
	TCD6_DLASTSGA       volatile.Register32 // 0x10D8
	TCD6_CSR            volatile.Register16 // 0x10DC
	TCD6_BITER_ELINKNO  volatile.Register16 // 0x10DE
	TCD7_SADDR          volatile.Register32 // 0x10E0
	TCD7_SOFF           volatile.Register16 // 0x10E4
	TCD7_ATTR           volatile.Register16 // 0x10E6
	TCD7_NBYTES_MLNO    volatile.Register32 // 0x10E8
	TCD7_SLAST          volatile.Register32 // 0x10EC
	TCD7_DADDR          volatile.Register32 // 0x10F0
	TCD7_DOFF           volatile.Register16 // 0x10F4
	TCD7_CITER_ELINKNO  volatile.Register16 // 0x10F6
	TCD7_DLASTSGA       volatile.Register32 // 0x10F8
	TCD7_CSR            volatile.Register16 // 0x10FC
	TCD7_BITER_ELINKNO  volatile.Register16 // 0x10FE
	TCD8_SADDR          volatile.Register32 // 0x1100
	TCD8_SOFF           volatile.Register16 // 0x1104
	TCD8_ATTR           volatile.Register16 // 0x1106
	TCD8_NBYTES_MLNO    volatile.Register32 // 0x1108
	TCD8_SLAST          volatile.Register32 // 0x110C
	TCD8_DADDR          volatile.Register32 // 0x1110
	TCD8_DOFF           volatile.Register16 // 0x1114
	TCD8_CITER_ELINKNO  volatile.Register16 // 0x1116
	TCD8_DLASTSGA       volatile.Register32 // 0x1118
	TCD8_CSR            volatile.Register16 // 0x111C
	TCD8_BITER_ELINKNO  volatile.Register16 // 0x111E
	TCD9_SADDR          volatile.Register32 // 0x1120
	TCD9_SOFF           volatile.Register16 // 0x1124
	TCD9_ATTR           volatile.Register16 // 0x1126
	TCD9_NBYTES_MLNO    volatile.Register32 // 0x1128
	TCD9_SLAST          volatile.Register32 // 0x112C
	TCD9_DADDR          volatile.Register32 // 0x1130
	TCD9_DOFF           volatile.Register16 // 0x1134
	TCD9_CITER_ELINKNO  volatile.Register16 // 0x1136
	TCD9_DLASTSGA       volatile.Register32 // 0x1138
	TCD9_CSR            volatile.Register16 // 0x113C
	TCD9_BITER_ELINKNO  volatile.Register16 // 0x113E
	TCD10_SADDR         volatile.Register32 // 0x1140
	TCD10_SOFF          volatile.Register16 // 0x1144
	TCD10_ATTR          volatile.Register16 // 0x1146
	TCD10_NBYTES_MLNO   volatile.Register32 // 0x1148
	TCD10_SLAST         volatile.Register32 // 0x114C
	TCD10_DADDR         volatile.Register32 // 0x1150
	TCD10_DOFF          volatile.Register16 // 0x1154
	TCD10_CITER_ELINKNO volatile.Register16 // 0x1156
	TCD10_DLASTSGA      volatile.Register32 // 0x1158
	TCD10_CSR           volatile.Register16 // 0x115C
	TCD10_BITER_ELINKNO volatile.Register16 // 0x115E
	TCD11_SADDR         volatile.Register32 // 0x1160
	TCD11_SOFF          volatile.Register16 // 0x1164
	TCD11_ATTR          volatile.Register16 // 0x1166
	TCD11_NBYTES_MLNO   volatile.Register32 // 0x1168
	TCD11_SLAST         volatile.Register32 // 0x116C
	TCD11_DADDR         volatile.Register32 // 0x1170
	TCD11_DOFF          volatile.Register16 // 0x1174
	TCD11_CITER_ELINKNO volatile.Register16 // 0x1176
	TCD11_DLASTSGA      volatile.Register32 // 0x1178
	TCD11_CSR           volatile.Register16 // 0x117C
	TCD11_BITER_ELINKNO volatile.Register16 // 0x117E
	TCD12_SADDR         volatile.Register32 // 0x1180
	TCD12_SOFF          volatile.Register16 // 0x1184
	TCD12_ATTR          volatile.Register16 // 0x1186
	TCD12_NBYTES_MLNO   volatile.Register32 // 0x1188
	TCD12_SLAST         volatile.Register32 // 0x118C
	TCD12_DADDR         volatile.Register32 // 0x1190
	TCD12_DOFF          volatile.Register16 // 0x1194
	TCD12_CITER_ELINKNO volatile.Register16 // 0x1196
	TCD12_DLASTSGA      volatile.Register32 // 0x1198
	TCD12_CSR           volatile.Register16 // 0x119C
	TCD12_BITER_ELINKNO volatile.Register16 // 0x119E
	TCD13_SADDR         volatile.Register32 // 0x11A0
	TCD13_SOFF          volatile.Register16 // 0x11A4
	TCD13_ATTR          volatile.Register16 // 0x11A6
	TCD13_NBYTES_MLNO   volatile.Register32 // 0x11A8
	TCD13_SLAST         volatile.Register32 // 0x11AC
	TCD13_DADDR         volatile.Register32 // 0x11B0
	TCD13_DOFF          volatile.Register16 // 0x11B4
	TCD13_CITER_ELINKNO volatile.Register16 // 0x11B6
	TCD13_DLASTSGA      volatile.Register32 // 0x11B8
	TCD13_CSR           volatile.Register16 // 0x11BC
	TCD13_BITER_ELINKNO volatile.Register16 // 0x11BE
	TCD14_SADDR         volatile.Register32 // 0x11C0
	TCD14_SOFF          volatile.Register16 // 0x11C4
	TCD14_ATTR          volatile.Register16 // 0x11C6
	TCD14_NBYTES_MLNO   volatile.Register32 // 0x11C8
	TCD14_SLAST         volatile.Register32 // 0x11CC
	TCD14_DADDR         volatile.Register32 // 0x11D0
	TCD14_DOFF          volatile.Register16 // 0x11D4
	TCD14_CITER_ELINKNO volatile.Register16 // 0x11D6
	TCD14_DLASTSGA      volatile.Register32 // 0x11D8
	TCD14_CSR           volatile.Register16 // 0x11DC
	TCD14_BITER_ELINKNO volatile.Register16 // 0x11DE
	TCD15_SADDR         volatile.Register32 // 0x11E0
	TCD15_SOFF          volatile.Register16 // 0x11E4
	TCD15_ATTR          volatile.Register16 // 0x11E6
	TCD15_NBYTES_MLNO   volatile.Register32 // 0x11E8
	TCD15_SLAST         volatile.Register32 // 0x11EC
	TCD15_DADDR         volatile.Register32 // 0x11F0
	TCD15_DOFF          volatile.Register16 // 0x11F4
	TCD15_CITER_ELINKNO volatile.Register16 // 0x11F6
	TCD15_DLASTSGA      volatile.Register32 // 0x11F8
	TCD15_CSR           volatile.Register16 // 0x11FC
	TCD15_BITER_ELINKNO volatile.Register16 // 0x11FE
	TCD16_SADDR         volatile.Register32 // 0x1200
	TCD16_SOFF          volatile.Register16 // 0x1204
	TCD16_ATTR          volatile.Register16 // 0x1206
	TCD16_NBYTES_MLNO   volatile.Register32 // 0x1208
	TCD16_SLAST         volatile.Register32 // 0x120C
	TCD16_DADDR         volatile.Register32 // 0x1210
	TCD16_DOFF          volatile.Register16 // 0x1214
	TCD16_CITER_ELINKNO volatile.Register16 // 0x1216
	TCD16_DLASTSGA      volatile.Register32 // 0x1218
	TCD16_CSR           volatile.Register16 // 0x121C
	TCD16_BITER_ELINKNO volatile.Register16 // 0x121E
	TCD17_SADDR         volatile.Register32 // 0x1220
	TCD17_SOFF          volatile.Register16 // 0x1224
	TCD17_ATTR          volatile.Register16 // 0x1226
	TCD17_NBYTES_MLNO   volatile.Register32 // 0x1228
	TCD17_SLAST         volatile.Register32 // 0x122C
	TCD17_DADDR         volatile.Register32 // 0x1230
	TCD17_DOFF          volatile.Register16 // 0x1234
	TCD17_CITER_ELINKNO volatile.Register16 // 0x1236
	TCD17_DLASTSGA      volatile.Register32 // 0x1238
	TCD17_CSR           volatile.Register16 // 0x123C
	TCD17_BITER_ELINKNO volatile.Register16 // 0x123E
	TCD18_SADDR         volatile.Register32 // 0x1240
	TCD18_SOFF          volatile.Register16 // 0x1244
	TCD18_ATTR          volatile.Register16 // 0x1246
	TCD18_NBYTES_MLNO   volatile.Register32 // 0x1248
	TCD18_SLAST         volatile.Register32 // 0x124C
	TCD18_DADDR         volatile.Register32 // 0x1250
	TCD18_DOFF          volatile.Register16 // 0x1254
	TCD18_CITER_ELINKNO volatile.Register16 // 0x1256
	TCD18_DLASTSGA      volatile.Register32 // 0x1258
	TCD18_CSR           volatile.Register16 // 0x125C
	TCD18_BITER_ELINKNO volatile.Register16 // 0x125E
	TCD19_SADDR         volatile.Register32 // 0x1260
	TCD19_SOFF          volatile.Register16 // 0x1264
	TCD19_ATTR          volatile.Register16 // 0x1266
	TCD19_NBYTES_MLNO   volatile.Register32 // 0x1268
	TCD19_SLAST         volatile.Register32 // 0x126C
	TCD19_DADDR         volatile.Register32 // 0x1270
	TCD19_DOFF          volatile.Register16 // 0x1274
	TCD19_CITER_ELINKNO volatile.Register16 // 0x1276
	TCD19_DLASTSGA      volatile.Register32 // 0x1278
	TCD19_CSR           volatile.Register16 // 0x127C
	TCD19_BITER_ELINKNO volatile.Register16 // 0x127E
	TCD20_SADDR         volatile.Register32 // 0x1280
	TCD20_SOFF          volatile.Register16 // 0x1284
	TCD20_ATTR          volatile.Register16 // 0x1286
	TCD20_NBYTES_MLNO   volatile.Register32 // 0x1288
	TCD20_SLAST         volatile.Register32 // 0x128C
	TCD20_DADDR         volatile.Register32 // 0x1290
	TCD20_DOFF          volatile.Register16 // 0x1294
	TCD20_CITER_ELINKNO volatile.Register16 // 0x1296
	TCD20_DLASTSGA      volatile.Register32 // 0x1298
	TCD20_CSR           volatile.Register16 // 0x129C
	TCD20_BITER_ELINKNO volatile.Register16 // 0x129E
	TCD21_SADDR         volatile.Register32 // 0x12A0
	TCD21_SOFF          volatile.Register16 // 0x12A4
	TCD21_ATTR          volatile.Register16 // 0x12A6
	TCD21_NBYTES_MLNO   volatile.Register32 // 0x12A8
	TCD21_SLAST         volatile.Register32 // 0x12AC
	TCD21_DADDR         volatile.Register32 // 0x12B0
	TCD21_DOFF          volatile.Register16 // 0x12B4
	TCD21_CITER_ELINKNO volatile.Register16 // 0x12B6
	TCD21_DLASTSGA      volatile.Register32 // 0x12B8
	TCD21_CSR           volatile.Register16 // 0x12BC
	TCD21_BITER_ELINKNO volatile.Register16 // 0x12BE
	TCD22_SADDR         volatile.Register32 // 0x12C0
	TCD22_SOFF          volatile.Register16 // 0x12C4
	TCD22_ATTR          volatile.Register16 // 0x12C6
	TCD22_NBYTES_MLNO   volatile.Register32 // 0x12C8
	TCD22_SLAST         volatile.Register32 // 0x12CC
	TCD22_DADDR         volatile.Register32 // 0x12D0
	TCD22_DOFF          volatile.Register16 // 0x12D4
	TCD22_CITER_ELINKNO volatile.Register16 // 0x12D6
	TCD22_DLASTSGA      volatile.Register32 // 0x12D8
	TCD22_CSR           volatile.Register16 // 0x12DC
	TCD22_BITER_ELINKNO volatile.Register16 // 0x12DE
	TCD23_SADDR         volatile.Register32 // 0x12E0
	TCD23_SOFF          volatile.Register16 // 0x12E4
	TCD23_ATTR          volatile.Register16 // 0x12E6
	TCD23_NBYTES_MLNO   volatile.Register32 // 0x12E8
	TCD23_SLAST         volatile.Register32 // 0x12EC
	TCD23_DADDR         volatile.Register32 // 0x12F0
	TCD23_DOFF          volatile.Register16 // 0x12F4
	TCD23_CITER_ELINKNO volatile.Register16 // 0x12F6
	TCD23_DLASTSGA      volatile.Register32 // 0x12F8
	TCD23_CSR           volatile.Register16 // 0x12FC
	TCD23_BITER_ELINKNO volatile.Register16 // 0x12FE
	TCD24_SADDR         volatile.Register32 // 0x1300
	TCD24_SOFF          volatile.Register16 // 0x1304
	TCD24_ATTR          volatile.Register16 // 0x1306
	TCD24_NBYTES_MLNO   volatile.Register32 // 0x1308
	TCD24_SLAST         volatile.Register32 // 0x130C
	TCD24_DADDR         volatile.Register32 // 0x1310
	TCD24_DOFF          volatile.Register16 // 0x1314
	TCD24_CITER_ELINKNO volatile.Register16 // 0x1316
	TCD24_DLASTSGA      volatile.Register32 // 0x1318
	TCD24_CSR           volatile.Register16 // 0x131C
	TCD24_BITER_ELINKNO volatile.Register16 // 0x131E
	TCD25_SADDR         volatile.Register32 // 0x1320
	TCD25_SOFF          volatile.Register16 // 0x1324
	TCD25_ATTR          volatile.Register16 // 0x1326
	TCD25_NBYTES_MLNO   volatile.Register32 // 0x1328
	TCD25_SLAST         volatile.Register32 // 0x132C
	TCD25_DADDR         volatile.Register32 // 0x1330
	TCD25_DOFF          volatile.Register16 // 0x1334
	TCD25_CITER_ELINKNO volatile.Register16 // 0x1336
	TCD25_DLASTSGA      volatile.Register32 // 0x1338
	TCD25_CSR           volatile.Register16 // 0x133C
	TCD25_BITER_ELINKNO volatile.Register16 // 0x133E
	TCD26_SADDR         volatile.Register32 // 0x1340
	TCD26_SOFF          volatile.Register16 // 0x1344
	TCD26_ATTR          volatile.Register16 // 0x1346
	TCD26_NBYTES_MLNO   volatile.Register32 // 0x1348
	TCD26_SLAST         volatile.Register32 // 0x134C
	TCD26_DADDR         volatile.Register32 // 0x1350
	TCD26_DOFF          volatile.Register16 // 0x1354
	TCD26_CITER_ELINKNO volatile.Register16 // 0x1356
	TCD26_DLASTSGA      volatile.Register32 // 0x1358
	TCD26_CSR           volatile.Register16 // 0x135C
	TCD26_BITER_ELINKNO volatile.Register16 // 0x135E
	TCD27_SADDR         volatile.Register32 // 0x1360
	TCD27_SOFF          volatile.Register16 // 0x1364
	TCD27_ATTR          volatile.Register16 // 0x1366
	TCD27_NBYTES_MLNO   volatile.Register32 // 0x1368
	TCD27_SLAST         volatile.Register32 // 0x136C
	TCD27_DADDR         volatile.Register32 // 0x1370
	TCD27_DOFF          volatile.Register16 // 0x1374
	TCD27_CITER_ELINKNO volatile.Register16 // 0x1376
	TCD27_DLASTSGA      volatile.Register32 // 0x1378
	TCD27_CSR           volatile.Register16 // 0x137C
	TCD27_BITER_ELINKNO volatile.Register16 // 0x137E
	TCD28_SADDR         volatile.Register32 // 0x1380
	TCD28_SOFF          volatile.Register16 // 0x1384
	TCD28_ATTR          volatile.Register16 // 0x1386
	TCD28_NBYTES_MLNO   volatile.Register32 // 0x1388
	TCD28_SLAST         volatile.Register32 // 0x138C
	TCD28_DADDR         volatile.Register32 // 0x1390
	TCD28_DOFF          volatile.Register16 // 0x1394
	TCD28_CITER_ELINKNO volatile.Register16 // 0x1396
	TCD28_DLASTSGA      volatile.Register32 // 0x1398
	TCD28_CSR           volatile.Register16 // 0x139C
	TCD28_BITER_ELINKNO volatile.Register16 // 0x139E
	TCD29_SADDR         volatile.Register32 // 0x13A0
	TCD29_SOFF          volatile.Register16 // 0x13A4
	TCD29_ATTR          volatile.Register16 // 0x13A6
	TCD29_NBYTES_MLNO   volatile.Register32 // 0x13A8
	TCD29_SLAST         volatile.Register32 // 0x13AC
	TCD29_DADDR         volatile.Register32 // 0x13B0
	TCD29_DOFF          volatile.Register16 // 0x13B4
	TCD29_CITER_ELINKNO volatile.Register16 // 0x13B6
	TCD29_DLASTSGA      volatile.Register32 // 0x13B8
	TCD29_CSR           volatile.Register16 // 0x13BC
	TCD29_BITER_ELINKNO volatile.Register16 // 0x13BE
	TCD30_SADDR         volatile.Register32 // 0x13C0
	TCD30_SOFF          volatile.Register16 // 0x13C4
	TCD30_ATTR          volatile.Register16 // 0x13C6
	TCD30_NBYTES_MLNO   volatile.Register32 // 0x13C8
	TCD30_SLAST         volatile.Register32 // 0x13CC
	TCD30_DADDR         volatile.Register32 // 0x13D0
	TCD30_DOFF          volatile.Register16 // 0x13D4
	TCD30_CITER_ELINKNO volatile.Register16 // 0x13D6
	TCD30_DLASTSGA      volatile.Register32 // 0x13D8
	TCD30_CSR           volatile.Register16 // 0x13DC
	TCD30_BITER_ELINKNO volatile.Register16 // 0x13DE
	TCD31_SADDR         volatile.Register32 // 0x13E0
	TCD31_SOFF          volatile.Register16 // 0x13E4
	TCD31_ATTR          volatile.Register16 // 0x13E6
	TCD31_NBYTES_MLNO   volatile.Register32 // 0x13E8
	TCD31_SLAST         volatile.Register32 // 0x13EC
	TCD31_DADDR         volatile.Register32 // 0x13F0
	TCD31_DOFF          volatile.Register16 // 0x13F4
	TCD31_CITER_ELINKNO volatile.Register16 // 0x13F6
	TCD31_DLASTSGA      volatile.Register32 // 0x13F8
	TCD31_CSR           volatile.Register16 // 0x13FC
	TCD31_BITER_ELINKNO volatile.Register16 // 0x13FE
}

// DMA_CH_MUX
type DMAMUX_Type struct {
	CHCFG [32]volatile.Register32 // 0x0
}

// GPC
type GPC_Type struct {
	CNTR volatile.Register32 // 0x0
	_    [4]byte
	IMR1 volatile.Register32 // 0x8
	IMR2 volatile.Register32 // 0xC
	IMR3 volatile.Register32 // 0x10
	IMR4 volatile.Register32 // 0x14
	ISR1 volatile.Register32 // 0x18
	ISR2 volatile.Register32 // 0x1C
	ISR3 volatile.Register32 // 0x20
	ISR4 volatile.Register32 // 0x24
	_    [12]byte
	IMR5 volatile.Register32 // 0x34
	ISR5 volatile.Register32 // 0x38
}

// PGC
type PGC_Type struct {
	_           [544]byte
	MEGA_CTRL   volatile.Register32 // 0x220
	MEGA_PUPSCR volatile.Register32 // 0x224
	MEGA_PDNSCR volatile.Register32 // 0x228
	MEGA_SR     volatile.Register32 // 0x22C
	_           [112]byte
	CPU_CTRL    volatile.Register32 // 0x2A0
	CPU_PUPSCR  volatile.Register32 // 0x2A4
	CPU_PDNSCR  volatile.Register32 // 0x2A8
	CPU_SR      volatile.Register32 // 0x2AC
}

// SRC
type SRC_Type struct {
	SCR   volatile.Register32 // 0x0
	SBMR1 volatile.Register32 // 0x4
	SRSR  volatile.Register32 // 0x8
	_     [16]byte
	SBMR2 volatile.Register32 // 0x1C
	GPR1  volatile.Register32 // 0x20
	GPR2  volatile.Register32 // 0x24
	GPR3  volatile.Register32 // 0x28
	GPR4  volatile.Register32 // 0x2C
	GPR5  volatile.Register32 // 0x30
	GPR6  volatile.Register32 // 0x34
	GPR7  volatile.Register32 // 0x38
	GPR8  volatile.Register32 // 0x3C
	GPR9  volatile.Register32 // 0x40
	GPR10 volatile.Register32 // 0x44
}

// CCM
type CCM_Type struct {
	CCR    volatile.Register32 // 0x0
	_      [4]byte
	CSR    volatile.Register32 // 0x8
	CCSR   volatile.Register32 // 0xC
	CACRR  volatile.Register32 // 0x10
	CBCDR  volatile.Register32 // 0x14
	CBCMR  volatile.Register32 // 0x18
	CSCMR1 volatile.Register32 // 0x1C
	CSCMR2 volatile.Register32 // 0x20
	CSCDR1 volatile.Register32 // 0x24
	CS1CDR volatile.Register32 // 0x28
	CS2CDR volatile.Register32 // 0x2C
	CDCDR  volatile.Register32 // 0x30
	_      [4]byte
	CSCDR2 volatile.Register32 // 0x38
	CSCDR3 volatile.Register32 // 0x3C
	_      [8]byte
	CDHIPR volatile.Register32 // 0x48
	_      [8]byte
	CLPCR  volatile.Register32 // 0x54
	CISR   volatile.Register32 // 0x58
	CIMR   volatile.Register32 // 0x5C
	CCOSR  volatile.Register32 // 0x60
	CGPR   volatile.Register32 // 0x64
	CCGR0  volatile.Register32 // 0x68
	CCGR1  volatile.Register32 // 0x6C
	CCGR2  volatile.Register32 // 0x70
	CCGR3  volatile.Register32 // 0x74
	CCGR4  volatile.Register32 // 0x78
	CCGR5  volatile.Register32 // 0x7C
	CCGR6  volatile.Register32 // 0x80
	CCGR7  volatile.Register32 // 0x84
	CMEOR  volatile.Register32 // 0x88
}

// ROMC
type ROMC_Type struct {
	_            [212]byte
	ROMPATCH7D   volatile.Register32 // 0xD4
	ROMPATCH6D   volatile.Register32 // 0xD8
	ROMPATCH5D   volatile.Register32 // 0xDC
	ROMPATCH4D   volatile.Register32 // 0xE0
	ROMPATCH3D   volatile.Register32 // 0xE4
	ROMPATCH2D   volatile.Register32 // 0xE8
	ROMPATCH1D   volatile.Register32 // 0xEC
	ROMPATCH0D   volatile.Register32 // 0xF0
	ROMPATCHCNTL volatile.Register32 // 0xF4
	ROMPATCHENH  volatile.Register32 // 0xF8
	ROMPATCHENL  volatile.Register32 // 0xFC
	ROMPATCH0A   volatile.Register32 // 0x100
	ROMPATCH1A   volatile.Register32 // 0x104
	ROMPATCH2A   volatile.Register32 // 0x108
	ROMPATCH3A   volatile.Register32 // 0x10C
	ROMPATCH4A   volatile.Register32 // 0x110
	ROMPATCH5A   volatile.Register32 // 0x114
	ROMPATCH6A   volatile.Register32 // 0x118
	ROMPATCH7A   volatile.Register32 // 0x11C
	ROMPATCH8A   volatile.Register32 // 0x120
	ROMPATCH9A   volatile.Register32 // 0x124
	ROMPATCH10A  volatile.Register32 // 0x128
	ROMPATCH11A  volatile.Register32 // 0x12C
	ROMPATCH12A  volatile.Register32 // 0x130
	ROMPATCH13A  volatile.Register32 // 0x134
	ROMPATCH14A  volatile.Register32 // 0x138
	ROMPATCH15A  volatile.Register32 // 0x13C
	_            [200]byte
	ROMPATCHSR   volatile.Register32 // 0x208
}

// LPUART
type LPUART_Type struct {
	VERID  volatile.Register32 // 0x0
	PARAM  volatile.Register32 // 0x4
	GLOBAL volatile.Register32 // 0x8
	PINCFG volatile.Register32 // 0xC
	BAUD   volatile.Register32 // 0x10
	STAT   volatile.Register32 // 0x14
	CTRL   volatile.Register32 // 0x18
	DATA   volatile.Register32 // 0x1C
	MATCH  volatile.Register32 // 0x20
	MODIR  volatile.Register32 // 0x24
	FIFO   volatile.Register32 // 0x28
	WATER  volatile.Register32 // 0x2C
}

// FLEXIO
type FLEXIO_Type struct {
	VERID       volatile.Register32 // 0x0
	PARAM       volatile.Register32 // 0x4
	CTRL        volatile.Register32 // 0x8
	PIN         volatile.Register32 // 0xC
	SHIFTSTAT   volatile.Register32 // 0x10
	SHIFTERR    volatile.Register32 // 0x14
	TIMSTAT     volatile.Register32 // 0x18
	_           [4]byte
	SHIFTSIEN   volatile.Register32 // 0x20
	SHIFTEIEN   volatile.Register32 // 0x24
	TIMIEN      volatile.Register32 // 0x28
	_           [4]byte
	SHIFTSDEN   volatile.Register32 // 0x30
	_           [12]byte
	SHIFTSTATE  volatile.Register32 // 0x40
	_           [60]byte
	SHIFTCTL    [4]volatile.Register32 // 0x80
	_           [112]byte
	SHIFTCFG    [4]volatile.Register32 // 0x100
	_           [240]byte
	SHIFTBUF    [4]volatile.Register32 // 0x200
	_           [112]byte
	SHIFTBUFBIS [4]volatile.Register32 // 0x280
	_           [112]byte
	SHIFTBUFBYS [4]volatile.Register32 // 0x300
	_           [112]byte
	SHIFTBUFBBS [4]volatile.Register32 // 0x380
	_           [112]byte
	TIMCTL      [4]volatile.Register32 // 0x400
	_           [112]byte
	TIMCFG      [4]volatile.Register32 // 0x480
	_           [112]byte
	TIMCMP      [4]volatile.Register32 // 0x500
	_           [368]byte
	SHIFTBUFNBS [4]volatile.Register32 // 0x680
	_           [112]byte
	SHIFTBUFHWS [4]volatile.Register32 // 0x700
	_           [112]byte
	SHIFTBUFNIS [4]volatile.Register32 // 0x780
}

// GPIO
type GPIO_Type struct {
	DR        volatile.Register32 // 0x0
	GDIR      volatile.Register32 // 0x4
	PSR       volatile.Register32 // 0x8
	ICR1      volatile.Register32 // 0xC
	ICR2      volatile.Register32 // 0x10
	IMR       volatile.Register32 // 0x14
	ISR       volatile.Register32 // 0x18
	EDGE_SEL  volatile.Register32 // 0x1C
	_         [100]byte
	DR_SET    volatile.Register32 // 0x84
	DR_CLEAR  volatile.Register32 // 0x88
	DR_TOGGLE volatile.Register32 // 0x8C
}

// FLEXCAN
type CAN_Type struct {
	MCR      volatile.Register32 // 0x0
	CTRL1    volatile.Register32 // 0x4
	TIMER    volatile.Register32 // 0x8
	_        [4]byte
	RXMGMASK volatile.Register32 // 0x10
	RX14MASK volatile.Register32 // 0x14
	RX15MASK volatile.Register32 // 0x18
	ECR      volatile.Register32 // 0x1C
	ESR1     volatile.Register32 // 0x20
	IMASK2   volatile.Register32 // 0x24
	IMASK1   volatile.Register32 // 0x28
	IFLAG2   volatile.Register32 // 0x2C
	IFLAG1   volatile.Register32 // 0x30
	CTRL2    volatile.Register32 // 0x34
	ESR2     volatile.Register32 // 0x38
	_        [8]byte
	CRCR     volatile.Register32 // 0x44
	RXFGMASK volatile.Register32 // 0x48
	RXFIR    volatile.Register32 // 0x4C
	_        [8]byte
	DBG1     volatile.Register32 // 0x58
	DBG2     volatile.Register32 // 0x5C
	_        [2080]byte
	RXIMR0   volatile.Register32 // 0x880
	RXIMR1   volatile.Register32 // 0x884
	RXIMR2   volatile.Register32 // 0x888
	RXIMR3   volatile.Register32 // 0x88C
	RXIMR4   volatile.Register32 // 0x890
	RXIMR5   volatile.Register32 // 0x894
	RXIMR6   volatile.Register32 // 0x898
	RXIMR7   volatile.Register32 // 0x89C
	RXIMR8   volatile.Register32 // 0x8A0
	RXIMR9   volatile.Register32 // 0x8A4
	RXIMR10  volatile.Register32 // 0x8A8
	RXIMR11  volatile.Register32 // 0x8AC
	RXIMR12  volatile.Register32 // 0x8B0
	RXIMR13  volatile.Register32 // 0x8B4
	RXIMR14  volatile.Register32 // 0x8B8
	RXIMR15  volatile.Register32 // 0x8BC
	RXIMR16  volatile.Register32 // 0x8C0
	RXIMR17  volatile.Register32 // 0x8C4
	RXIMR18  volatile.Register32 // 0x8C8
	RXIMR19  volatile.Register32 // 0x8CC
	RXIMR20  volatile.Register32 // 0x8D0
	RXIMR21  volatile.Register32 // 0x8D4
	RXIMR22  volatile.Register32 // 0x8D8
	RXIMR23  volatile.Register32 // 0x8DC
	RXIMR24  volatile.Register32 // 0x8E0
	RXIMR25  volatile.Register32 // 0x8E4
	RXIMR26  volatile.Register32 // 0x8E8
	RXIMR27  volatile.Register32 // 0x8EC
	RXIMR28  volatile.Register32 // 0x8F0
	RXIMR29  volatile.Register32 // 0x8F4
	RXIMR30  volatile.Register32 // 0x8F8
	RXIMR31  volatile.Register32 // 0x8FC
	RXIMR32  volatile.Register32 // 0x900
	RXIMR33  volatile.Register32 // 0x904
	RXIMR34  volatile.Register32 // 0x908
	RXIMR35  volatile.Register32 // 0x90C
	RXIMR36  volatile.Register32 // 0x910
	RXIMR37  volatile.Register32 // 0x914
	RXIMR38  volatile.Register32 // 0x918
	RXIMR39  volatile.Register32 // 0x91C
	RXIMR40  volatile.Register32 // 0x920
	RXIMR41  volatile.Register32 // 0x924
	RXIMR42  volatile.Register32 // 0x928
	RXIMR43  volatile.Register32 // 0x92C
	RXIMR44  volatile.Register32 // 0x930
	RXIMR45  volatile.Register32 // 0x934
	RXIMR46  volatile.Register32 // 0x938
	RXIMR47  volatile.Register32 // 0x93C
	RXIMR48  volatile.Register32 // 0x940
	RXIMR49  volatile.Register32 // 0x944
	RXIMR50  volatile.Register32 // 0x948
	RXIMR51  volatile.Register32 // 0x94C
	RXIMR52  volatile.Register32 // 0x950
	RXIMR53  volatile.Register32 // 0x954
	RXIMR54  volatile.Register32 // 0x958
	RXIMR55  volatile.Register32 // 0x95C
	RXIMR56  volatile.Register32 // 0x960
	RXIMR57  volatile.Register32 // 0x964
	RXIMR58  volatile.Register32 // 0x968
	RXIMR59  volatile.Register32 // 0x96C
	RXIMR60  volatile.Register32 // 0x970
	RXIMR61  volatile.Register32 // 0x974
	RXIMR62  volatile.Register32 // 0x978
	RXIMR63  volatile.Register32 // 0x97C
	_        [96]byte
	GFWR     volatile.Register32 // 0x9E0
}

// Quad Timer
type TMR_Type struct {
	COMP10  volatile.Register16 // 0x0
	COMP20  volatile.Register16 // 0x2
	CAPT0   volatile.Register16 // 0x4
	LOAD0   volatile.Register16 // 0x6
	HOLD0   volatile.Register16 // 0x8
	CNTR0   volatile.Register16 // 0xA
	CTRL0   volatile.Register16 // 0xC
	SCTRL0  volatile.Register16 // 0xE
	CMPLD10 volatile.Register16 // 0x10
	CMPLD20 volatile.Register16 // 0x12
	CSCTRL0 volatile.Register16 // 0x14
	FILT0   volatile.Register16 // 0x16
	DMA0    volatile.Register16 // 0x18
	_       [4]byte
	ENBL    volatile.Register16 // 0x1E
	COMP11  volatile.Register16 // 0x20
	COMP21  volatile.Register16 // 0x22
	CAPT1   volatile.Register16 // 0x24
	LOAD1   volatile.Register16 // 0x26
	HOLD1   volatile.Register16 // 0x28
	CNTR1   volatile.Register16 // 0x2A
	CTRL1   volatile.Register16 // 0x2C
	SCTRL1  volatile.Register16 // 0x2E
	CMPLD11 volatile.Register16 // 0x30
	CMPLD21 volatile.Register16 // 0x32
	CSCTRL1 volatile.Register16 // 0x34
	FILT1   volatile.Register16 // 0x36
	DMA1    volatile.Register16 // 0x38
	_       [6]byte
	COMP12  volatile.Register16 // 0x40
	COMP22  volatile.Register16 // 0x42
	CAPT2   volatile.Register16 // 0x44
	LOAD2   volatile.Register16 // 0x46
	HOLD2   volatile.Register16 // 0x48
	CNTR2   volatile.Register16 // 0x4A
	CTRL2   volatile.Register16 // 0x4C
	SCTRL2  volatile.Register16 // 0x4E
	CMPLD12 volatile.Register16 // 0x50
	CMPLD22 volatile.Register16 // 0x52
	CSCTRL2 volatile.Register16 // 0x54
	FILT2   volatile.Register16 // 0x56
	DMA2    volatile.Register16 // 0x58
	_       [6]byte
	COMP13  volatile.Register16 // 0x60
	COMP23  volatile.Register16 // 0x62
	CAPT3   volatile.Register16 // 0x64
	LOAD3   volatile.Register16 // 0x66
	HOLD3   volatile.Register16 // 0x68
	CNTR3   volatile.Register16 // 0x6A
	CTRL3   volatile.Register16 // 0x6C
	SCTRL3  volatile.Register16 // 0x6E
	CMPLD13 volatile.Register16 // 0x70
	CMPLD23 volatile.Register16 // 0x72
	CSCTRL3 volatile.Register16 // 0x74
	FILT3   volatile.Register16 // 0x76
	DMA3    volatile.Register16 // 0x78
}

// GPT
type GPT_Type struct {
	CR   volatile.Register32 // 0x0
	PR   volatile.Register32 // 0x4
	SR   volatile.Register32 // 0x8
	IR   volatile.Register32 // 0xC
	OCR1 volatile.Register32 // 0x10
	OCR2 volatile.Register32 // 0x14
	OCR3 volatile.Register32 // 0x18
	ICR1 volatile.Register32 // 0x1C
	ICR2 volatile.Register32 // 0x20
	CNT  volatile.Register32 // 0x24
}

// OCOTP
type OCOTP_Type struct {
	CTRL           volatile.Register32 // 0x0
	CTRL_SET       volatile.Register32 // 0x4
	CTRL_CLR       volatile.Register32 // 0x8
	CTRL_TOG       volatile.Register32 // 0xC
	TIMING         volatile.Register32 // 0x10
	_              [12]byte
	DATA           volatile.Register32 // 0x20
	_              [12]byte
	READ_CTRL      volatile.Register32 // 0x30
	_              [12]byte
	READ_FUSE_DATA volatile.Register32 // 0x40
	_              [12]byte
	SW_STICKY      volatile.Register32 // 0x50
	_              [12]byte
	SCS            volatile.Register32 // 0x60
	SCS_SET        volatile.Register32 // 0x64
	SCS_CLR        volatile.Register32 // 0x68
	SCS_TOG        volatile.Register32 // 0x6C
	CRC_ADDR       volatile.Register32 // 0x70
	_              [12]byte
	CRC_VALUE      volatile.Register32 // 0x80
	_              [12]byte
	VERSION        volatile.Register32 // 0x90
	_              [108]byte
	TIMING2        volatile.Register32 // 0x100
	_              [764]byte
	LOCK           volatile.Register32 // 0x400
	_              [12]byte
	CFG0           volatile.Register32 // 0x410
	_              [12]byte
	CFG1           volatile.Register32 // 0x420
	_              [12]byte
	CFG2           volatile.Register32 // 0x430
	_              [12]byte
	CFG3           volatile.Register32 // 0x440
	_              [12]byte
	CFG4           volatile.Register32 // 0x450
	_              [12]byte
	CFG5           volatile.Register32 // 0x460
	_              [12]byte
	CFG6           volatile.Register32 // 0x470
	_              [12]byte
	MEM0           volatile.Register32 // 0x480
	_              [12]byte
	MEM1           volatile.Register32 // 0x490
	_              [12]byte
	MEM2           volatile.Register32 // 0x4A0
	_              [12]byte
	MEM3           volatile.Register32 // 0x4B0
	_              [12]byte
	MEM4           volatile.Register32 // 0x4C0
	_              [12]byte
	ANA0           volatile.Register32 // 0x4D0
	_              [12]byte
	ANA1           volatile.Register32 // 0x4E0
	_              [12]byte
	ANA2           volatile.Register32 // 0x4F0
	_              [12]byte
	OTPMK0         volatile.Register32 // 0x500
	_              [12]byte
	OTPMK1         volatile.Register32 // 0x510
	_              [12]byte
	OTPMK2         volatile.Register32 // 0x520
	_              [12]byte
	OTPMK3         volatile.Register32 // 0x530
	_              [12]byte
	OTPMK4         volatile.Register32 // 0x540
	_              [12]byte
	OTPMK5         volatile.Register32 // 0x550
	_              [12]byte
	OTPMK6         volatile.Register32 // 0x560
	_              [12]byte
	OTPMK7         volatile.Register32 // 0x570
	_              [12]byte
	SRK0           volatile.Register32 // 0x580
	_              [12]byte
	SRK1           volatile.Register32 // 0x590
	_              [12]byte
	SRK2           volatile.Register32 // 0x5A0
	_              [12]byte
	SRK3           volatile.Register32 // 0x5B0
	_              [12]byte
	SRK4           volatile.Register32 // 0x5C0
	_              [12]byte
	SRK5           volatile.Register32 // 0x5D0
	_              [12]byte
	SRK6           volatile.Register32 // 0x5E0
	_              [12]byte
	SRK7           volatile.Register32 // 0x5F0
	_              [12]byte
	SJC_RESP0      volatile.Register32 // 0x600
	_              [12]byte
	SJC_RESP1      volatile.Register32 // 0x610
	_              [12]byte
	MAC0           volatile.Register32 // 0x620
	_              [12]byte
	MAC1           volatile.Register32 // 0x630
	_              [12]byte
	MAC2           volatile.Register32 // 0x640
	_              [12]byte
	OTPMK_CRC32    volatile.Register32 // 0x650
	_              [12]byte
	GP1            volatile.Register32 // 0x660
	_              [12]byte
	GP2            volatile.Register32 // 0x670
	_              [12]byte
	SW_GP1         volatile.Register32 // 0x680
	_              [12]byte
	SW_GP20        volatile.Register32 // 0x690
	_              [12]byte
	SW_GP21        volatile.Register32 // 0x6A0
	_              [12]byte
	SW_GP22        volatile.Register32 // 0x6B0
	_              [12]byte
	SW_GP23        volatile.Register32 // 0x6C0
	_              [12]byte
	MISC_CONF0     volatile.Register32 // 0x6D0
	_              [12]byte
	MISC_CONF1     volatile.Register32 // 0x6E0
	_              [12]byte
	SRK_REVOKE     volatile.Register32 // 0x6F0
	_              [268]byte
	ROM_PATCH0     volatile.Register32 // 0x800
	_              [12]byte
	ROM_PATCH1     volatile.Register32 // 0x810
	_              [12]byte
	ROM_PATCH2     volatile.Register32 // 0x820
	_              [12]byte
	ROM_PATCH3     volatile.Register32 // 0x830
	_              [12]byte
	ROM_PATCH4     volatile.Register32 // 0x840
	_              [12]byte
	ROM_PATCH5     volatile.Register32 // 0x850
	_              [12]byte
	ROM_PATCH6     volatile.Register32 // 0x860
	_              [12]byte
	ROM_PATCH7     volatile.Register32 // 0x870
	_              [12]byte
	GP30           volatile.Register32 // 0x880
	_              [12]byte
	GP31           volatile.Register32 // 0x890
	_              [12]byte
	GP32           volatile.Register32 // 0x8A0
	_              [12]byte
	GP33           volatile.Register32 // 0x8B0
	_              [12]byte
	GP40           volatile.Register32 // 0x8C0
	_              [12]byte
	GP41           volatile.Register32 // 0x8D0
	_              [12]byte
	GP42           volatile.Register32 // 0x8E0
	_              [12]byte
	GP43           volatile.Register32 // 0x8F0
}

// IOMUXC
type IOMUXC_Type struct {
	_                                        [20]byte
	SW_MUX_CTL_PAD_GPIO_EMC_00               volatile.Register32 // 0x14
	SW_MUX_CTL_PAD_GPIO_EMC_01               volatile.Register32 // 0x18
	SW_MUX_CTL_PAD_GPIO_EMC_02               volatile.Register32 // 0x1C
	SW_MUX_CTL_PAD_GPIO_EMC_03               volatile.Register32 // 0x20
	SW_MUX_CTL_PAD_GPIO_EMC_04               volatile.Register32 // 0x24
	SW_MUX_CTL_PAD_GPIO_EMC_05               volatile.Register32 // 0x28
	SW_MUX_CTL_PAD_GPIO_EMC_06               volatile.Register32 // 0x2C
	SW_MUX_CTL_PAD_GPIO_EMC_07               volatile.Register32 // 0x30
	SW_MUX_CTL_PAD_GPIO_EMC_08               volatile.Register32 // 0x34
	SW_MUX_CTL_PAD_GPIO_EMC_09               volatile.Register32 // 0x38
	SW_MUX_CTL_PAD_GPIO_EMC_10               volatile.Register32 // 0x3C
	SW_MUX_CTL_PAD_GPIO_EMC_11               volatile.Register32 // 0x40
	SW_MUX_CTL_PAD_GPIO_EMC_12               volatile.Register32 // 0x44
	SW_MUX_CTL_PAD_GPIO_EMC_13               volatile.Register32 // 0x48
	SW_MUX_CTL_PAD_GPIO_EMC_14               volatile.Register32 // 0x4C
	SW_MUX_CTL_PAD_GPIO_EMC_15               volatile.Register32 // 0x50
	SW_MUX_CTL_PAD_GPIO_EMC_16               volatile.Register32 // 0x54
	SW_MUX_CTL_PAD_GPIO_EMC_17               volatile.Register32 // 0x58
	SW_MUX_CTL_PAD_GPIO_EMC_18               volatile.Register32 // 0x5C
	SW_MUX_CTL_PAD_GPIO_EMC_19               volatile.Register32 // 0x60
	SW_MUX_CTL_PAD_GPIO_EMC_20               volatile.Register32 // 0x64
	SW_MUX_CTL_PAD_GPIO_EMC_21               volatile.Register32 // 0x68
	SW_MUX_CTL_PAD_GPIO_EMC_22               volatile.Register32 // 0x6C
	SW_MUX_CTL_PAD_GPIO_EMC_23               volatile.Register32 // 0x70
	SW_MUX_CTL_PAD_GPIO_EMC_24               volatile.Register32 // 0x74
	SW_MUX_CTL_PAD_GPIO_EMC_25               volatile.Register32 // 0x78
	SW_MUX_CTL_PAD_GPIO_EMC_26               volatile.Register32 // 0x7C
	SW_MUX_CTL_PAD_GPIO_EMC_27               volatile.Register32 // 0x80
	SW_MUX_CTL_PAD_GPIO_EMC_28               volatile.Register32 // 0x84
	SW_MUX_CTL_PAD_GPIO_EMC_29               volatile.Register32 // 0x88
	SW_MUX_CTL_PAD_GPIO_EMC_30               volatile.Register32 // 0x8C
	SW_MUX_CTL_PAD_GPIO_EMC_31               volatile.Register32 // 0x90
	SW_MUX_CTL_PAD_GPIO_EMC_32               volatile.Register32 // 0x94
	SW_MUX_CTL_PAD_GPIO_EMC_33               volatile.Register32 // 0x98
	SW_MUX_CTL_PAD_GPIO_EMC_34               volatile.Register32 // 0x9C
	SW_MUX_CTL_PAD_GPIO_EMC_35               volatile.Register32 // 0xA0
	SW_MUX_CTL_PAD_GPIO_EMC_36               volatile.Register32 // 0xA4
	SW_MUX_CTL_PAD_GPIO_EMC_37               volatile.Register32 // 0xA8
	SW_MUX_CTL_PAD_GPIO_EMC_38               volatile.Register32 // 0xAC
	SW_MUX_CTL_PAD_GPIO_EMC_39               volatile.Register32 // 0xB0
	SW_MUX_CTL_PAD_GPIO_EMC_40               volatile.Register32 // 0xB4
	SW_MUX_CTL_PAD_GPIO_EMC_41               volatile.Register32 // 0xB8
	SW_MUX_CTL_PAD_GPIO_AD_B0_00             volatile.Register32 // 0xBC
	SW_MUX_CTL_PAD_GPIO_AD_B0_01             volatile.Register32 // 0xC0
	SW_MUX_CTL_PAD_GPIO_AD_B0_02             volatile.Register32 // 0xC4
	SW_MUX_CTL_PAD_GPIO_AD_B0_03             volatile.Register32 // 0xC8
	SW_MUX_CTL_PAD_GPIO_AD_B0_04             volatile.Register32 // 0xCC
	SW_MUX_CTL_PAD_GPIO_AD_B0_05             volatile.Register32 // 0xD0
	SW_MUX_CTL_PAD_GPIO_AD_B0_06             volatile.Register32 // 0xD4
	SW_MUX_CTL_PAD_GPIO_AD_B0_07             volatile.Register32 // 0xD8
	SW_MUX_CTL_PAD_GPIO_AD_B0_08             volatile.Register32 // 0xDC
	SW_MUX_CTL_PAD_GPIO_AD_B0_09             volatile.Register32 // 0xE0
	SW_MUX_CTL_PAD_GPIO_AD_B0_10             volatile.Register32 // 0xE4
	SW_MUX_CTL_PAD_GPIO_AD_B0_11             volatile.Register32 // 0xE8
	SW_MUX_CTL_PAD_GPIO_AD_B0_12             volatile.Register32 // 0xEC
	SW_MUX_CTL_PAD_GPIO_AD_B0_13             volatile.Register32 // 0xF0
	SW_MUX_CTL_PAD_GPIO_AD_B0_14             volatile.Register32 // 0xF4
	SW_MUX_CTL_PAD_GPIO_AD_B0_15             volatile.Register32 // 0xF8
	SW_MUX_CTL_PAD_GPIO_AD_B1_00             volatile.Register32 // 0xFC
	SW_MUX_CTL_PAD_GPIO_AD_B1_01             volatile.Register32 // 0x100
	SW_MUX_CTL_PAD_GPIO_AD_B1_02             volatile.Register32 // 0x104
	SW_MUX_CTL_PAD_GPIO_AD_B1_03             volatile.Register32 // 0x108
	SW_MUX_CTL_PAD_GPIO_AD_B1_04             volatile.Register32 // 0x10C
	SW_MUX_CTL_PAD_GPIO_AD_B1_05             volatile.Register32 // 0x110
	SW_MUX_CTL_PAD_GPIO_AD_B1_06             volatile.Register32 // 0x114
	SW_MUX_CTL_PAD_GPIO_AD_B1_07             volatile.Register32 // 0x118
	SW_MUX_CTL_PAD_GPIO_AD_B1_08             volatile.Register32 // 0x11C
	SW_MUX_CTL_PAD_GPIO_AD_B1_09             volatile.Register32 // 0x120
	SW_MUX_CTL_PAD_GPIO_AD_B1_10             volatile.Register32 // 0x124
	SW_MUX_CTL_PAD_GPIO_AD_B1_11             volatile.Register32 // 0x128
	SW_MUX_CTL_PAD_GPIO_AD_B1_12             volatile.Register32 // 0x12C
	SW_MUX_CTL_PAD_GPIO_AD_B1_13             volatile.Register32 // 0x130
	SW_MUX_CTL_PAD_GPIO_AD_B1_14             volatile.Register32 // 0x134
	SW_MUX_CTL_PAD_GPIO_AD_B1_15             volatile.Register32 // 0x138
	SW_MUX_CTL_PAD_GPIO_B0_00                volatile.Register32 // 0x13C
	SW_MUX_CTL_PAD_GPIO_B0_01                volatile.Register32 // 0x140
	SW_MUX_CTL_PAD_GPIO_B0_02                volatile.Register32 // 0x144
	SW_MUX_CTL_PAD_GPIO_B0_03                volatile.Register32 // 0x148
	SW_MUX_CTL_PAD_GPIO_B0_04                volatile.Register32 // 0x14C
	SW_MUX_CTL_PAD_GPIO_B0_05                volatile.Register32 // 0x150
	SW_MUX_CTL_PAD_GPIO_B0_06                volatile.Register32 // 0x154
	SW_MUX_CTL_PAD_GPIO_B0_07                volatile.Register32 // 0x158
	SW_MUX_CTL_PAD_GPIO_B0_08                volatile.Register32 // 0x15C
	SW_MUX_CTL_PAD_GPIO_B0_09                volatile.Register32 // 0x160
	SW_MUX_CTL_PAD_GPIO_B0_10                volatile.Register32 // 0x164
	SW_MUX_CTL_PAD_GPIO_B0_11                volatile.Register32 // 0x168
	SW_MUX_CTL_PAD_GPIO_B0_12                volatile.Register32 // 0x16C
	SW_MUX_CTL_PAD_GPIO_B0_13                volatile.Register32 // 0x170
	SW_MUX_CTL_PAD_GPIO_B0_14                volatile.Register32 // 0x174
	SW_MUX_CTL_PAD_GPIO_B0_15                volatile.Register32 // 0x178
	SW_MUX_CTL_PAD_GPIO_B1_00                volatile.Register32 // 0x17C
	SW_MUX_CTL_PAD_GPIO_B1_01                volatile.Register32 // 0x180
	SW_MUX_CTL_PAD_GPIO_B1_02                volatile.Register32 // 0x184
	SW_MUX_CTL_PAD_GPIO_B1_03                volatile.Register32 // 0x188
	SW_MUX_CTL_PAD_GPIO_B1_04                volatile.Register32 // 0x18C
	SW_MUX_CTL_PAD_GPIO_B1_05                volatile.Register32 // 0x190
	SW_MUX_CTL_PAD_GPIO_B1_06                volatile.Register32 // 0x194
	SW_MUX_CTL_PAD_GPIO_B1_07                volatile.Register32 // 0x198
	SW_MUX_CTL_PAD_GPIO_B1_08                volatile.Register32 // 0x19C
	SW_MUX_CTL_PAD_GPIO_B1_09                volatile.Register32 // 0x1A0
	SW_MUX_CTL_PAD_GPIO_B1_10                volatile.Register32 // 0x1A4
	SW_MUX_CTL_PAD_GPIO_B1_11                volatile.Register32 // 0x1A8
	SW_MUX_CTL_PAD_GPIO_B1_12                volatile.Register32 // 0x1AC
	SW_MUX_CTL_PAD_GPIO_B1_13                volatile.Register32 // 0x1B0
	SW_MUX_CTL_PAD_GPIO_B1_14                volatile.Register32 // 0x1B4
	SW_MUX_CTL_PAD_GPIO_B1_15                volatile.Register32 // 0x1B8
	SW_MUX_CTL_PAD_GPIO_SD_B0_00             volatile.Register32 // 0x1BC
	SW_MUX_CTL_PAD_GPIO_SD_B0_01             volatile.Register32 // 0x1C0
	SW_MUX_CTL_PAD_GPIO_SD_B0_02             volatile.Register32 // 0x1C4
	SW_MUX_CTL_PAD_GPIO_SD_B0_03             volatile.Register32 // 0x1C8
	SW_MUX_CTL_PAD_GPIO_SD_B0_04             volatile.Register32 // 0x1CC
	SW_MUX_CTL_PAD_GPIO_SD_B0_05             volatile.Register32 // 0x1D0
	SW_MUX_CTL_PAD_GPIO_SD_B1_00             volatile.Register32 // 0x1D4
	SW_MUX_CTL_PAD_GPIO_SD_B1_01             volatile.Register32 // 0x1D8
	SW_MUX_CTL_PAD_GPIO_SD_B1_02             volatile.Register32 // 0x1DC
	SW_MUX_CTL_PAD_GPIO_SD_B1_03             volatile.Register32 // 0x1E0
	SW_MUX_CTL_PAD_GPIO_SD_B1_04             volatile.Register32 // 0x1E4
	SW_MUX_CTL_PAD_GPIO_SD_B1_05             volatile.Register32 // 0x1E8
	SW_MUX_CTL_PAD_GPIO_SD_B1_06             volatile.Register32 // 0x1EC
	SW_MUX_CTL_PAD_GPIO_SD_B1_07             volatile.Register32 // 0x1F0
	SW_MUX_CTL_PAD_GPIO_SD_B1_08             volatile.Register32 // 0x1F4
	SW_MUX_CTL_PAD_GPIO_SD_B1_09             volatile.Register32 // 0x1F8
	SW_MUX_CTL_PAD_GPIO_SD_B1_10             volatile.Register32 // 0x1FC
	SW_MUX_CTL_PAD_GPIO_SD_B1_11             volatile.Register32 // 0x200
	SW_PAD_CTL_PAD_GPIO_EMC_00               volatile.Register32 // 0x204
	SW_PAD_CTL_PAD_GPIO_EMC_01               volatile.Register32 // 0x208
	SW_PAD_CTL_PAD_GPIO_EMC_02               volatile.Register32 // 0x20C
	SW_PAD_CTL_PAD_GPIO_EMC_03               volatile.Register32 // 0x210
	SW_PAD_CTL_PAD_GPIO_EMC_04               volatile.Register32 // 0x214
	SW_PAD_CTL_PAD_GPIO_EMC_05               volatile.Register32 // 0x218
	SW_PAD_CTL_PAD_GPIO_EMC_06               volatile.Register32 // 0x21C
	SW_PAD_CTL_PAD_GPIO_EMC_07               volatile.Register32 // 0x220
	SW_PAD_CTL_PAD_GPIO_EMC_08               volatile.Register32 // 0x224
	SW_PAD_CTL_PAD_GPIO_EMC_09               volatile.Register32 // 0x228
	SW_PAD_CTL_PAD_GPIO_EMC_10               volatile.Register32 // 0x22C
	SW_PAD_CTL_PAD_GPIO_EMC_11               volatile.Register32 // 0x230
	SW_PAD_CTL_PAD_GPIO_EMC_12               volatile.Register32 // 0x234
	SW_PAD_CTL_PAD_GPIO_EMC_13               volatile.Register32 // 0x238
	SW_PAD_CTL_PAD_GPIO_EMC_14               volatile.Register32 // 0x23C
	SW_PAD_CTL_PAD_GPIO_EMC_15               volatile.Register32 // 0x240
	SW_PAD_CTL_PAD_GPIO_EMC_16               volatile.Register32 // 0x244
	SW_PAD_CTL_PAD_GPIO_EMC_17               volatile.Register32 // 0x248
	SW_PAD_CTL_PAD_GPIO_EMC_18               volatile.Register32 // 0x24C
	SW_PAD_CTL_PAD_GPIO_EMC_19               volatile.Register32 // 0x250
	SW_PAD_CTL_PAD_GPIO_EMC_20               volatile.Register32 // 0x254
	SW_PAD_CTL_PAD_GPIO_EMC_21               volatile.Register32 // 0x258
	SW_PAD_CTL_PAD_GPIO_EMC_22               volatile.Register32 // 0x25C
	SW_PAD_CTL_PAD_GPIO_EMC_23               volatile.Register32 // 0x260
	SW_PAD_CTL_PAD_GPIO_EMC_24               volatile.Register32 // 0x264
	SW_PAD_CTL_PAD_GPIO_EMC_25               volatile.Register32 // 0x268
	SW_PAD_CTL_PAD_GPIO_EMC_26               volatile.Register32 // 0x26C
	SW_PAD_CTL_PAD_GPIO_EMC_27               volatile.Register32 // 0x270
	SW_PAD_CTL_PAD_GPIO_EMC_28               volatile.Register32 // 0x274
	SW_PAD_CTL_PAD_GPIO_EMC_29               volatile.Register32 // 0x278
	SW_PAD_CTL_PAD_GPIO_EMC_30               volatile.Register32 // 0x27C
	SW_PAD_CTL_PAD_GPIO_EMC_31               volatile.Register32 // 0x280
	SW_PAD_CTL_PAD_GPIO_EMC_32               volatile.Register32 // 0x284
	SW_PAD_CTL_PAD_GPIO_EMC_33               volatile.Register32 // 0x288
	SW_PAD_CTL_PAD_GPIO_EMC_34               volatile.Register32 // 0x28C
	SW_PAD_CTL_PAD_GPIO_EMC_35               volatile.Register32 // 0x290
	SW_PAD_CTL_PAD_GPIO_EMC_36               volatile.Register32 // 0x294
	SW_PAD_CTL_PAD_GPIO_EMC_37               volatile.Register32 // 0x298
	SW_PAD_CTL_PAD_GPIO_EMC_38               volatile.Register32 // 0x29C
	SW_PAD_CTL_PAD_GPIO_EMC_39               volatile.Register32 // 0x2A0
	SW_PAD_CTL_PAD_GPIO_EMC_40               volatile.Register32 // 0x2A4
	SW_PAD_CTL_PAD_GPIO_EMC_41               volatile.Register32 // 0x2A8
	SW_PAD_CTL_PAD_GPIO_AD_B0_00             volatile.Register32 // 0x2AC
	SW_PAD_CTL_PAD_GPIO_AD_B0_01             volatile.Register32 // 0x2B0
	SW_PAD_CTL_PAD_GPIO_AD_B0_02             volatile.Register32 // 0x2B4
	SW_PAD_CTL_PAD_GPIO_AD_B0_03             volatile.Register32 // 0x2B8
	SW_PAD_CTL_PAD_GPIO_AD_B0_04             volatile.Register32 // 0x2BC
	SW_PAD_CTL_PAD_GPIO_AD_B0_05             volatile.Register32 // 0x2C0
	SW_PAD_CTL_PAD_GPIO_AD_B0_06             volatile.Register32 // 0x2C4
	SW_PAD_CTL_PAD_GPIO_AD_B0_07             volatile.Register32 // 0x2C8
	SW_PAD_CTL_PAD_GPIO_AD_B0_08             volatile.Register32 // 0x2CC
	SW_PAD_CTL_PAD_GPIO_AD_B0_09             volatile.Register32 // 0x2D0
	SW_PAD_CTL_PAD_GPIO_AD_B0_10             volatile.Register32 // 0x2D4
	SW_PAD_CTL_PAD_GPIO_AD_B0_11             volatile.Register32 // 0x2D8
	SW_PAD_CTL_PAD_GPIO_AD_B0_12             volatile.Register32 // 0x2DC
	SW_PAD_CTL_PAD_GPIO_AD_B0_13             volatile.Register32 // 0x2E0
	SW_PAD_CTL_PAD_GPIO_AD_B0_14             volatile.Register32 // 0x2E4
	SW_PAD_CTL_PAD_GPIO_AD_B0_15             volatile.Register32 // 0x2E8
	SW_PAD_CTL_PAD_GPIO_AD_B1_00             volatile.Register32 // 0x2EC
	SW_PAD_CTL_PAD_GPIO_AD_B1_01             volatile.Register32 // 0x2F0
	SW_PAD_CTL_PAD_GPIO_AD_B1_02             volatile.Register32 // 0x2F4
	SW_PAD_CTL_PAD_GPIO_AD_B1_03             volatile.Register32 // 0x2F8
	SW_PAD_CTL_PAD_GPIO_AD_B1_04             volatile.Register32 // 0x2FC
	SW_PAD_CTL_PAD_GPIO_AD_B1_05             volatile.Register32 // 0x300
	SW_PAD_CTL_PAD_GPIO_AD_B1_06             volatile.Register32 // 0x304
	SW_PAD_CTL_PAD_GPIO_AD_B1_07             volatile.Register32 // 0x308
	SW_PAD_CTL_PAD_GPIO_AD_B1_08             volatile.Register32 // 0x30C
	SW_PAD_CTL_PAD_GPIO_AD_B1_09             volatile.Register32 // 0x310
	SW_PAD_CTL_PAD_GPIO_AD_B1_10             volatile.Register32 // 0x314
	SW_PAD_CTL_PAD_GPIO_AD_B1_11             volatile.Register32 // 0x318
	SW_PAD_CTL_PAD_GPIO_AD_B1_12             volatile.Register32 // 0x31C
	SW_PAD_CTL_PAD_GPIO_AD_B1_13             volatile.Register32 // 0x320
	SW_PAD_CTL_PAD_GPIO_AD_B1_14             volatile.Register32 // 0x324
	SW_PAD_CTL_PAD_GPIO_AD_B1_15             volatile.Register32 // 0x328
	SW_PAD_CTL_PAD_GPIO_B0_00                volatile.Register32 // 0x32C
	SW_PAD_CTL_PAD_GPIO_B0_01                volatile.Register32 // 0x330
	SW_PAD_CTL_PAD_GPIO_B0_02                volatile.Register32 // 0x334
	SW_PAD_CTL_PAD_GPIO_B0_03                volatile.Register32 // 0x338
	SW_PAD_CTL_PAD_GPIO_B0_04                volatile.Register32 // 0x33C
	SW_PAD_CTL_PAD_GPIO_B0_05                volatile.Register32 // 0x340
	SW_PAD_CTL_PAD_GPIO_B0_06                volatile.Register32 // 0x344
	SW_PAD_CTL_PAD_GPIO_B0_07                volatile.Register32 // 0x348
	SW_PAD_CTL_PAD_GPIO_B0_08                volatile.Register32 // 0x34C
	SW_PAD_CTL_PAD_GPIO_B0_09                volatile.Register32 // 0x350
	SW_PAD_CTL_PAD_GPIO_B0_10                volatile.Register32 // 0x354
	SW_PAD_CTL_PAD_GPIO_B0_11                volatile.Register32 // 0x358
	SW_PAD_CTL_PAD_GPIO_B0_12                volatile.Register32 // 0x35C
	SW_PAD_CTL_PAD_GPIO_B0_13                volatile.Register32 // 0x360
	SW_PAD_CTL_PAD_GPIO_B0_14                volatile.Register32 // 0x364
	SW_PAD_CTL_PAD_GPIO_B0_15                volatile.Register32 // 0x368
	SW_PAD_CTL_PAD_GPIO_B1_00                volatile.Register32 // 0x36C
	SW_PAD_CTL_PAD_GPIO_B1_01                volatile.Register32 // 0x370
	SW_PAD_CTL_PAD_GPIO_B1_02                volatile.Register32 // 0x374
	SW_PAD_CTL_PAD_GPIO_B1_03                volatile.Register32 // 0x378
	SW_PAD_CTL_PAD_GPIO_B1_04                volatile.Register32 // 0x37C
	SW_PAD_CTL_PAD_GPIO_B1_05                volatile.Register32 // 0x380
	SW_PAD_CTL_PAD_GPIO_B1_06                volatile.Register32 // 0x384
	SW_PAD_CTL_PAD_GPIO_B1_07                volatile.Register32 // 0x388
	SW_PAD_CTL_PAD_GPIO_B1_08                volatile.Register32 // 0x38C
	SW_PAD_CTL_PAD_GPIO_B1_09                volatile.Register32 // 0x390
	SW_PAD_CTL_PAD_GPIO_B1_10                volatile.Register32 // 0x394
	SW_PAD_CTL_PAD_GPIO_B1_11                volatile.Register32 // 0x398
	SW_PAD_CTL_PAD_GPIO_B1_12                volatile.Register32 // 0x39C
	SW_PAD_CTL_PAD_GPIO_B1_13                volatile.Register32 // 0x3A0
	SW_PAD_CTL_PAD_GPIO_B1_14                volatile.Register32 // 0x3A4
	SW_PAD_CTL_PAD_GPIO_B1_15                volatile.Register32 // 0x3A8
	SW_PAD_CTL_PAD_GPIO_SD_B0_00             volatile.Register32 // 0x3AC
	SW_PAD_CTL_PAD_GPIO_SD_B0_01             volatile.Register32 // 0x3B0
	SW_PAD_CTL_PAD_GPIO_SD_B0_02             volatile.Register32 // 0x3B4
	SW_PAD_CTL_PAD_GPIO_SD_B0_03             volatile.Register32 // 0x3B8
	SW_PAD_CTL_PAD_GPIO_SD_B0_04             volatile.Register32 // 0x3BC
	SW_PAD_CTL_PAD_GPIO_SD_B0_05             volatile.Register32 // 0x3C0
	SW_PAD_CTL_PAD_GPIO_SD_B1_00             volatile.Register32 // 0x3C4
	SW_PAD_CTL_PAD_GPIO_SD_B1_01             volatile.Register32 // 0x3C8
	SW_PAD_CTL_PAD_GPIO_SD_B1_02             volatile.Register32 // 0x3CC
	SW_PAD_CTL_PAD_GPIO_SD_B1_03             volatile.Register32 // 0x3D0
	SW_PAD_CTL_PAD_GPIO_SD_B1_04             volatile.Register32 // 0x3D4
	SW_PAD_CTL_PAD_GPIO_SD_B1_05             volatile.Register32 // 0x3D8
	SW_PAD_CTL_PAD_GPIO_SD_B1_06             volatile.Register32 // 0x3DC
	SW_PAD_CTL_PAD_GPIO_SD_B1_07             volatile.Register32 // 0x3E0
	SW_PAD_CTL_PAD_GPIO_SD_B1_08             volatile.Register32 // 0x3E4
	SW_PAD_CTL_PAD_GPIO_SD_B1_09             volatile.Register32 // 0x3E8
	SW_PAD_CTL_PAD_GPIO_SD_B1_10             volatile.Register32 // 0x3EC
	SW_PAD_CTL_PAD_GPIO_SD_B1_11             volatile.Register32 // 0x3F0
	ANATOP_USB_OTG1_ID_SELECT_INPUT          volatile.Register32 // 0x3F4
	ANATOP_USB_OTG2_ID_SELECT_INPUT          volatile.Register32 // 0x3F8
	CCM_PMIC_READY_SELECT_INPUT              volatile.Register32 // 0x3FC
	CSI_DATA02_SELECT_INPUT                  volatile.Register32 // 0x400
	CSI_DATA03_SELECT_INPUT                  volatile.Register32 // 0x404
	CSI_DATA04_SELECT_INPUT                  volatile.Register32 // 0x408
	CSI_DATA05_SELECT_INPUT                  volatile.Register32 // 0x40C
	CSI_DATA06_SELECT_INPUT                  volatile.Register32 // 0x410
	CSI_DATA07_SELECT_INPUT                  volatile.Register32 // 0x414
	CSI_DATA08_SELECT_INPUT                  volatile.Register32 // 0x418
	CSI_DATA09_SELECT_INPUT                  volatile.Register32 // 0x41C
	CSI_HSYNC_SELECT_INPUT                   volatile.Register32 // 0x420
	CSI_PIXCLK_SELECT_INPUT                  volatile.Register32 // 0x424
	CSI_VSYNC_SELECT_INPUT                   volatile.Register32 // 0x428
	ENET_IPG_CLK_RMII_SELECT_INPUT           volatile.Register32 // 0x42C
	ENET_MDIO_SELECT_INPUT                   volatile.Register32 // 0x430
	ENET0_RXDATA_SELECT_INPUT                volatile.Register32 // 0x434
	ENET1_RXDATA_SELECT_INPUT                volatile.Register32 // 0x438
	ENET_RXEN_SELECT_INPUT                   volatile.Register32 // 0x43C
	ENET_RXERR_SELECT_INPUT                  volatile.Register32 // 0x440
	ENET0_TIMER_SELECT_INPUT                 volatile.Register32 // 0x444
	ENET_TXCLK_SELECT_INPUT                  volatile.Register32 // 0x448
	FLEXCAN1_RX_SELECT_INPUT                 volatile.Register32 // 0x44C
	FLEXCAN2_RX_SELECT_INPUT                 volatile.Register32 // 0x450
	FLEXPWM1_PWMA3_SELECT_INPUT              volatile.Register32 // 0x454
	FLEXPWM1_PWMA0_SELECT_INPUT              volatile.Register32 // 0x458
	FLEXPWM1_PWMA1_SELECT_INPUT              volatile.Register32 // 0x45C
	FLEXPWM1_PWMA2_SELECT_INPUT              volatile.Register32 // 0x460
	FLEXPWM1_PWMB3_SELECT_INPUT              volatile.Register32 // 0x464
	FLEXPWM1_PWMB0_SELECT_INPUT              volatile.Register32 // 0x468
	FLEXPWM1_PWMB1_SELECT_INPUT              volatile.Register32 // 0x46C
	FLEXPWM1_PWMB2_SELECT_INPUT              volatile.Register32 // 0x470
	FLEXPWM2_PWMA3_SELECT_INPUT              volatile.Register32 // 0x474
	FLEXPWM2_PWMA0_SELECT_INPUT              volatile.Register32 // 0x478
	FLEXPWM2_PWMA1_SELECT_INPUT              volatile.Register32 // 0x47C
	FLEXPWM2_PWMA2_SELECT_INPUT              volatile.Register32 // 0x480
	FLEXPWM2_PWMB3_SELECT_INPUT              volatile.Register32 // 0x484
	FLEXPWM2_PWMB0_SELECT_INPUT              volatile.Register32 // 0x488
	FLEXPWM2_PWMB1_SELECT_INPUT              volatile.Register32 // 0x48C
	FLEXPWM2_PWMB2_SELECT_INPUT              volatile.Register32 // 0x490
	FLEXPWM4_PWMA0_SELECT_INPUT              volatile.Register32 // 0x494
	FLEXPWM4_PWMA1_SELECT_INPUT              volatile.Register32 // 0x498
	FLEXPWM4_PWMA2_SELECT_INPUT              volatile.Register32 // 0x49C
	FLEXPWM4_PWMA3_SELECT_INPUT              volatile.Register32 // 0x4A0
	FLEXSPIA_DQS_SELECT_INPUT                volatile.Register32 // 0x4A4
	FLEXSPIA_DATA0_SELECT_INPUT              volatile.Register32 // 0x4A8
	FLEXSPIA_DATA1_SELECT_INPUT              volatile.Register32 // 0x4AC
	FLEXSPIA_DATA2_SELECT_INPUT              volatile.Register32 // 0x4B0
	FLEXSPIA_DATA3_SELECT_INPUT              volatile.Register32 // 0x4B4
	FLEXSPIB_DATA0_SELECT_INPUT              volatile.Register32 // 0x4B8
	FLEXSPIB_DATA1_SELECT_INPUT              volatile.Register32 // 0x4BC
	FLEXSPIB_DATA2_SELECT_INPUT              volatile.Register32 // 0x4C0
	FLEXSPIB_DATA3_SELECT_INPUT              volatile.Register32 // 0x4C4
	FLEXSPIA_SCK_SELECT_INPUT                volatile.Register32 // 0x4C8
	LPI2C1_SCL_SELECT_INPUT                  volatile.Register32 // 0x4CC
	LPI2C1_SDA_SELECT_INPUT                  volatile.Register32 // 0x4D0
	LPI2C2_SCL_SELECT_INPUT                  volatile.Register32 // 0x4D4
	LPI2C2_SDA_SELECT_INPUT                  volatile.Register32 // 0x4D8
	LPI2C3_SCL_SELECT_INPUT                  volatile.Register32 // 0x4DC
	LPI2C3_SDA_SELECT_INPUT                  volatile.Register32 // 0x4E0
	LPI2C4_SCL_SELECT_INPUT                  volatile.Register32 // 0x4E4
	LPI2C4_SDA_SELECT_INPUT                  volatile.Register32 // 0x4E8
	LPSPI1_PCS0_SELECT_INPUT                 volatile.Register32 // 0x4EC
	LPSPI1_SCK_SELECT_INPUT                  volatile.Register32 // 0x4F0
	LPSPI1_SDI_SELECT_INPUT                  volatile.Register32 // 0x4F4
	LPSPI1_SDO_SELECT_INPUT                  volatile.Register32 // 0x4F8
	LPSPI2_PCS0_SELECT_INPUT                 volatile.Register32 // 0x4FC
	LPSPI2_SCK_SELECT_INPUT                  volatile.Register32 // 0x500
	LPSPI2_SDI_SELECT_INPUT                  volatile.Register32 // 0x504
	LPSPI2_SDO_SELECT_INPUT                  volatile.Register32 // 0x508
	LPSPI3_PCS0_SELECT_INPUT                 volatile.Register32 // 0x50C
	LPSPI3_SCK_SELECT_INPUT                  volatile.Register32 // 0x510
	LPSPI3_SDI_SELECT_INPUT                  volatile.Register32 // 0x514
	LPSPI3_SDO_SELECT_INPUT                  volatile.Register32 // 0x518
	LPSPI4_PCS0_SELECT_INPUT                 volatile.Register32 // 0x51C
	LPSPI4_SCK_SELECT_INPUT                  volatile.Register32 // 0x520
	LPSPI4_SDI_SELECT_INPUT                  volatile.Register32 // 0x524
	LPSPI4_SDO_SELECT_INPUT                  volatile.Register32 // 0x528
	LPUART2_RX_SELECT_INPUT                  volatile.Register32 // 0x52C
	LPUART2_TX_SELECT_INPUT                  volatile.Register32 // 0x530
	LPUART3_CTS_B_SELECT_INPUT               volatile.Register32 // 0x534
	LPUART3_RX_SELECT_INPUT                  volatile.Register32 // 0x538
	LPUART3_TX_SELECT_INPUT                  volatile.Register32 // 0x53C
	LPUART4_RX_SELECT_INPUT                  volatile.Register32 // 0x540
	LPUART4_TX_SELECT_INPUT                  volatile.Register32 // 0x544
	LPUART5_RX_SELECT_INPUT                  volatile.Register32 // 0x548
	LPUART5_TX_SELECT_INPUT                  volatile.Register32 // 0x54C
	LPUART6_RX_SELECT_INPUT                  volatile.Register32 // 0x550
	LPUART6_TX_SELECT_INPUT                  volatile.Register32 // 0x554
	LPUART7_RX_SELECT_INPUT                  volatile.Register32 // 0x558
	LPUART7_TX_SELECT_INPUT                  volatile.Register32 // 0x55C
	LPUART8_RX_SELECT_INPUT                  volatile.Register32 // 0x560
	LPUART8_TX_SELECT_INPUT                  volatile.Register32 // 0x564
	NMI_SELECT_INPUT                         volatile.Register32 // 0x568
	QTIMER2_TIMER0_SELECT_INPUT              volatile.Register32 // 0x56C
	QTIMER2_TIMER1_SELECT_INPUT              volatile.Register32 // 0x570
	QTIMER2_TIMER2_SELECT_INPUT              volatile.Register32 // 0x574
	QTIMER2_TIMER3_SELECT_INPUT              volatile.Register32 // 0x578
	QTIMER3_TIMER0_SELECT_INPUT              volatile.Register32 // 0x57C
	QTIMER3_TIMER1_SELECT_INPUT              volatile.Register32 // 0x580
	QTIMER3_TIMER2_SELECT_INPUT              volatile.Register32 // 0x584
	QTIMER3_TIMER3_SELECT_INPUT              volatile.Register32 // 0x588
	SAI1_MCLK2_SELECT_INPUT                  volatile.Register32 // 0x58C
	SAI1_RX_BCLK_SELECT_INPUT                volatile.Register32 // 0x590
	SAI1_RX_DATA0_SELECT_INPUT               volatile.Register32 // 0x594
	SAI1_RX_DATA1_SELECT_INPUT               volatile.Register32 // 0x598
	SAI1_RX_DATA2_SELECT_INPUT               volatile.Register32 // 0x59C
	SAI1_RX_DATA3_SELECT_INPUT               volatile.Register32 // 0x5A0
	SAI1_RX_SYNC_SELECT_INPUT                volatile.Register32 // 0x5A4
	SAI1_TX_BCLK_SELECT_INPUT                volatile.Register32 // 0x5A8
	SAI1_TX_SYNC_SELECT_INPUT                volatile.Register32 // 0x5AC
	SAI2_MCLK2_SELECT_INPUT                  volatile.Register32 // 0x5B0
	SAI2_RX_BCLK_SELECT_INPUT                volatile.Register32 // 0x5B4
	SAI2_RX_DATA0_SELECT_INPUT               volatile.Register32 // 0x5B8
	SAI2_RX_SYNC_SELECT_INPUT                volatile.Register32 // 0x5BC
	SAI2_TX_BCLK_SELECT_INPUT                volatile.Register32 // 0x5C0
	SAI2_TX_SYNC_SELECT_INPUT                volatile.Register32 // 0x5C4
	SPDIF_IN_SELECT_INPUT                    volatile.Register32 // 0x5C8
	USB_OTG2_OC_SELECT_INPUT                 volatile.Register32 // 0x5CC
	USB_OTG1_OC_SELECT_INPUT                 volatile.Register32 // 0x5D0
	USDHC1_CD_B_SELECT_INPUT                 volatile.Register32 // 0x5D4
	USDHC1_WP_SELECT_INPUT                   volatile.Register32 // 0x5D8
	USDHC2_CLK_SELECT_INPUT                  volatile.Register32 // 0x5DC
	USDHC2_CD_B_SELECT_INPUT                 volatile.Register32 // 0x5E0
	USDHC2_CMD_SELECT_INPUT                  volatile.Register32 // 0x5E4
	USDHC2_DATA0_SELECT_INPUT                volatile.Register32 // 0x5E8
	USDHC2_DATA1_SELECT_INPUT                volatile.Register32 // 0x5EC
	USDHC2_DATA2_SELECT_INPUT                volatile.Register32 // 0x5F0
	USDHC2_DATA3_SELECT_INPUT                volatile.Register32 // 0x5F4
	USDHC2_DATA4_SELECT_INPUT                volatile.Register32 // 0x5F8
	USDHC2_DATA5_SELECT_INPUT                volatile.Register32 // 0x5FC
	USDHC2_DATA6_SELECT_INPUT                volatile.Register32 // 0x600
	USDHC2_DATA7_SELECT_INPUT                volatile.Register32 // 0x604
	USDHC2_WP_SELECT_INPUT                   volatile.Register32 // 0x608
	XBAR1_IN02_SELECT_INPUT                  volatile.Register32 // 0x60C
	XBAR1_IN03_SELECT_INPUT                  volatile.Register32 // 0x610
	XBAR1_IN04_SELECT_INPUT                  volatile.Register32 // 0x614
	XBAR1_IN05_SELECT_INPUT                  volatile.Register32 // 0x618
	XBAR1_IN06_SELECT_INPUT                  volatile.Register32 // 0x61C
	XBAR1_IN07_SELECT_INPUT                  volatile.Register32 // 0x620
	XBAR1_IN08_SELECT_INPUT                  volatile.Register32 // 0x624
	XBAR1_IN09_SELECT_INPUT                  volatile.Register32 // 0x628
	XBAR1_IN17_SELECT_INPUT                  volatile.Register32 // 0x62C
	XBAR1_IN18_SELECT_INPUT                  volatile.Register32 // 0x630
	XBAR1_IN20_SELECT_INPUT                  volatile.Register32 // 0x634
	XBAR1_IN22_SELECT_INPUT                  volatile.Register32 // 0x638
	XBAR1_IN23_SELECT_INPUT                  volatile.Register32 // 0x63C
	XBAR1_IN24_SELECT_INPUT                  volatile.Register32 // 0x640
	XBAR1_IN14_SELECT_INPUT                  volatile.Register32 // 0x644
	XBAR1_IN15_SELECT_INPUT                  volatile.Register32 // 0x648
	XBAR1_IN16_SELECT_INPUT                  volatile.Register32 // 0x64C
	XBAR1_IN25_SELECT_INPUT                  volatile.Register32 // 0x650
	XBAR1_IN19_SELECT_INPUT                  volatile.Register32 // 0x654
	XBAR1_IN21_SELECT_INPUT                  volatile.Register32 // 0x658
	SW_MUX_CTL_PAD_GPIO_SPI_B0_00            volatile.Register32 // 0x65C
	SW_MUX_CTL_PAD_GPIO_SPI_B0_01            volatile.Register32 // 0x660
	SW_MUX_CTL_PAD_GPIO_SPI_B0_02            volatile.Register32 // 0x664
	SW_MUX_CTL_PAD_GPIO_SPI_B0_03            volatile.Register32 // 0x668
	SW_MUX_CTL_PAD_GPIO_SPI_B0_04            volatile.Register32 // 0x66C
	SW_MUX_CTL_PAD_GPIO_SPI_B0_05            volatile.Register32 // 0x670
	SW_MUX_CTL_PAD_GPIO_SPI_B0_06            volatile.Register32 // 0x674
	SW_MUX_CTL_PAD_GPIO_SPI_B0_07            volatile.Register32 // 0x678
	SW_MUX_CTL_PAD_GPIO_SPI_B0_08            volatile.Register32 // 0x67C
	SW_MUX_CTL_PAD_GPIO_SPI_B0_09            volatile.Register32 // 0x680
	SW_MUX_CTL_PAD_GPIO_SPI_B0_10            volatile.Register32 // 0x684
	SW_MUX_CTL_PAD_GPIO_SPI_B0_11            volatile.Register32 // 0x688
	SW_MUX_CTL_PAD_GPIO_SPI_B0_12            volatile.Register32 // 0x68C
	SW_MUX_CTL_PAD_GPIO_SPI_B0_13            volatile.Register32 // 0x690
	SW_MUX_CTL_PAD_GPIO_SPI_B1_00            volatile.Register32 // 0x694
	SW_MUX_CTL_PAD_GPIO_SPI_B1_01            volatile.Register32 // 0x698
	SW_MUX_CTL_PAD_GPIO_SPI_B1_02            volatile.Register32 // 0x69C
	SW_MUX_CTL_PAD_GPIO_SPI_B1_03            volatile.Register32 // 0x6A0
	SW_MUX_CTL_PAD_GPIO_SPI_B1_04            volatile.Register32 // 0x6A4
	SW_MUX_CTL_PAD_GPIO_SPI_B1_05            volatile.Register32 // 0x6A8
	SW_MUX_CTL_PAD_GPIO_SPI_B1_06            volatile.Register32 // 0x6AC
	SW_MUX_CTL_PAD_GPIO_SPI_B1_07            volatile.Register32 // 0x6B0
	SW_PAD_CTL_PAD_GPIO_SPI_B0_00            volatile.Register32 // 0x6B4
	SW_PAD_CTL_PAD_GPIO_SPI_B0_01            volatile.Register32 // 0x6B8
	SW_PAD_CTL_PAD_GPIO_SPI_B0_02            volatile.Register32 // 0x6BC
	SW_PAD_CTL_PAD_GPIO_SPI_B0_03            volatile.Register32 // 0x6C0
	SW_PAD_CTL_PAD_GPIO_SPI_B0_04            volatile.Register32 // 0x6C4
	SW_PAD_CTL_PAD_GPIO_SPI_B0_05            volatile.Register32 // 0x6C8
	SW_PAD_CTL_PAD_GPIO_SPI_B0_06            volatile.Register32 // 0x6CC
	SW_PAD_CTL_PAD_GPIO_SPI_B0_07            volatile.Register32 // 0x6D0
	SW_PAD_CTL_PAD_GPIO_SPI_B0_08            volatile.Register32 // 0x6D4
	SW_PAD_CTL_PAD_GPIO_SPI_B0_09            volatile.Register32 // 0x6D8
	SW_PAD_CTL_PAD_GPIO_SPI_B0_10            volatile.Register32 // 0x6DC
	SW_PAD_CTL_PAD_GPIO_SPI_B0_11            volatile.Register32 // 0x6E0
	SW_PAD_CTL_PAD_GPIO_SPI_B0_12            volatile.Register32 // 0x6E4
	SW_PAD_CTL_PAD_GPIO_SPI_B0_13            volatile.Register32 // 0x6E8
	SW_PAD_CTL_PAD_GPIO_SPI_B1_00            volatile.Register32 // 0x6EC
	SW_PAD_CTL_PAD_GPIO_SPI_B1_01            volatile.Register32 // 0x6F0
	SW_PAD_CTL_PAD_GPIO_SPI_B1_02            volatile.Register32 // 0x6F4
	SW_PAD_CTL_PAD_GPIO_SPI_B1_03            volatile.Register32 // 0x6F8
	SW_PAD_CTL_PAD_GPIO_SPI_B1_04            volatile.Register32 // 0x6FC
	SW_PAD_CTL_PAD_GPIO_SPI_B1_05            volatile.Register32 // 0x700
	SW_PAD_CTL_PAD_GPIO_SPI_B1_06            volatile.Register32 // 0x704
	SW_PAD_CTL_PAD_GPIO_SPI_B1_07            volatile.Register32 // 0x708
	ENET2_IPG_CLK_RMII_SELECT_INPUT          volatile.Register32 // 0x70C
	ENET2_IPP_IND_MAC0_MDIO_SELECT_INPUT     volatile.Register32 // 0x710
	ENET2_IPP_IND_MAC0_RXDATA_SELECT_INPUT_0 volatile.Register32 // 0x714
	ENET2_IPP_IND_MAC0_RXDATA_SELECT_INPUT_1 volatile.Register32 // 0x718
	ENET2_IPP_IND_MAC0_RXEN_SELECT_INPUT     volatile.Register32 // 0x71C
	ENET2_IPP_IND_MAC0_RXERR_SELECT_INPUT    volatile.Register32 // 0x720
	ENET2_IPP_IND_MAC0_TIMER_SELECT_INPUT_0  volatile.Register32 // 0x724
	ENET2_IPP_IND_MAC0_TXCLK_SELECT_INPUT    volatile.Register32 // 0x728
	FLEXSPI2_IPP_IND_DQS_FA_SELECT_INPUT     volatile.Register32 // 0x72C
	FLEXSPI2_IPP_IND_IO_FA_BIT0_SELECT_INPUT volatile.Register32 // 0x730
	FLEXSPI2_IPP_IND_IO_FA_BIT1_SELECT_INPUT volatile.Register32 // 0x734
	FLEXSPI2_IPP_IND_IO_FA_BIT2_SELECT_INPUT volatile.Register32 // 0x738
	FLEXSPI2_IPP_IND_IO_FA_BIT3_SELECT_INPUT volatile.Register32 // 0x73C
	FLEXSPI2_IPP_IND_IO_FB_BIT0_SELECT_INPUT volatile.Register32 // 0x740
	FLEXSPI2_IPP_IND_IO_FB_BIT1_SELECT_INPUT volatile.Register32 // 0x744
	FLEXSPI2_IPP_IND_IO_FB_BIT2_SELECT_INPUT volatile.Register32 // 0x748
	FLEXSPI2_IPP_IND_IO_FB_BIT3_SELECT_INPUT volatile.Register32 // 0x74C
	FLEXSPI2_IPP_IND_SCK_FA_SELECT_INPUT     volatile.Register32 // 0x750
	FLEXSPI2_IPP_IND_SCK_FB_SELECT_INPUT     volatile.Register32 // 0x754
	GPT1_IPP_IND_CAPIN1_SELECT_INPUT         volatile.Register32 // 0x758
	GPT1_IPP_IND_CAPIN2_SELECT_INPUT         volatile.Register32 // 0x75C
	GPT1_IPP_IND_CLKIN_SELECT_INPUT          volatile.Register32 // 0x760
	GPT2_IPP_IND_CAPIN1_SELECT_INPUT         volatile.Register32 // 0x764
	GPT2_IPP_IND_CAPIN2_SELECT_INPUT         volatile.Register32 // 0x768
	GPT2_IPP_IND_CLKIN_SELECT_INPUT          volatile.Register32 // 0x76C
	SAI3_IPG_CLK_SAI_MCLK_SELECT_INPUT_2     volatile.Register32 // 0x770
	SAI3_IPP_IND_SAI_RXBCLK_SELECT_INPUT     volatile.Register32 // 0x774
	SAI3_IPP_IND_SAI_RXDATA_SELECT_INPUT_0   volatile.Register32 // 0x778
	SAI3_IPP_IND_SAI_RXSYNC_SELECT_INPUT     volatile.Register32 // 0x77C
	SAI3_IPP_IND_SAI_TXBCLK_SELECT_INPUT     volatile.Register32 // 0x780
	SAI3_IPP_IND_SAI_TXSYNC_SELECT_INPUT     volatile.Register32 // 0x784
	SEMC_I_IPP_IND_DQS4_SELECT_INPUT         volatile.Register32 // 0x788
	CANFD_IPP_IND_CANRX_SELECT_INPUT         volatile.Register32 // 0x78C
}

// KPP Registers
type KPP_Type struct {
	KPCR volatile.Register16 // 0x0
	KPSR volatile.Register16 // 0x2
	KDDR volatile.Register16 // 0x4
	KPDR volatile.Register16 // 0x6
}

// FlexSPI
type FlexSPI_Type struct {
	MCR0         volatile.Register32 // 0x0
	MCR1         volatile.Register32 // 0x4
	MCR2         volatile.Register32 // 0x8
	AHBCR        volatile.Register32 // 0xC
	INTEN        volatile.Register32 // 0x10
	INTR         volatile.Register32 // 0x14
	LUTKEY       volatile.Register32 // 0x18
	LUTCR        volatile.Register32 // 0x1C
	AHBRXBUF0CR0 volatile.Register32 // 0x20
	AHBRXBUF1CR0 volatile.Register32 // 0x24
	AHBRXBUF2CR0 volatile.Register32 // 0x28
	AHBRXBUF3CR0 volatile.Register32 // 0x2C
	_            [48]byte
	FLSHA1CR0    volatile.Register32 // 0x60
	FLSHA2CR0    volatile.Register32 // 0x64
	FLSHB1CR0    volatile.Register32 // 0x68
	FLSHB2CR0    volatile.Register32 // 0x6C
	FLSHCR1A1    volatile.Register32 // 0x70
	FLSHCR1A2    volatile.Register32 // 0x74
	FLSHCR1B1    volatile.Register32 // 0x78
	FLSHCR1B2    volatile.Register32 // 0x7C
	FLSHCR2A1    volatile.Register32 // 0x80
	FLSHCR2A2    volatile.Register32 // 0x84
	FLSHCR2B1    volatile.Register32 // 0x88
	FLSHCR2B2    volatile.Register32 // 0x8C
	_            [4]byte
	FLSHCR4      volatile.Register32 // 0x94
	_            [8]byte
	IPCR0        volatile.Register32 // 0xA0
	IPCR1        volatile.Register32 // 0xA4
	_            [8]byte
	IPCMD        volatile.Register32 // 0xB0
	_            [4]byte
	IPRXFCR      volatile.Register32 // 0xB8
	IPTXFCR      volatile.Register32 // 0xBC
	DLLCRA       volatile.Register32 // 0xC0
	DLLCRB       volatile.Register32 // 0xC4
	_            [24]byte
	STS0         volatile.Register32 // 0xE0
	STS1         volatile.Register32 // 0xE4
	STS2         volatile.Register32 // 0xE8
	AHBSPNDSTS   volatile.Register32 // 0xEC
	IPRXFSTS     volatile.Register32 // 0xF0
	IPTXFSTS     volatile.Register32 // 0xF4
	_            [8]byte
	RFDR         [32]volatile.Register32 // 0x100
	TFDR         [32]volatile.Register32 // 0x180
	LUT          [64]volatile.Register32 // 0x200
}

// PXP v2.0 Register Reference Index
type PXP_Type struct {
	CTRL             volatile.Register32 // 0x0
	CTRL_SET         volatile.Register32 // 0x4
	CTRL_CLR         volatile.Register32 // 0x8
	CTRL_TOG         volatile.Register32 // 0xC
	STAT             volatile.Register32 // 0x10
	STAT_SET         volatile.Register32 // 0x14
	STAT_CLR         volatile.Register32 // 0x18
	STAT_TOG         volatile.Register32 // 0x1C
	OUT_CTRL         volatile.Register32 // 0x20
	OUT_CTRL_SET     volatile.Register32 // 0x24
	OUT_CTRL_CLR     volatile.Register32 // 0x28
	OUT_CTRL_TOG     volatile.Register32 // 0x2C
	OUT_BUF          volatile.Register32 // 0x30
	_                [12]byte
	OUT_BUF2         volatile.Register32 // 0x40
	_                [12]byte
	OUT_PITCH        volatile.Register32 // 0x50
	_                [12]byte
	OUT_LRC          volatile.Register32 // 0x60
	_                [12]byte
	OUT_PS_ULC       volatile.Register32 // 0x70
	_                [12]byte
	OUT_PS_LRC       volatile.Register32 // 0x80
	_                [12]byte
	OUT_AS_ULC       volatile.Register32 // 0x90
	_                [12]byte
	OUT_AS_LRC       volatile.Register32 // 0xA0
	_                [12]byte
	PS_CTRL          volatile.Register32 // 0xB0
	PS_CTRL_SET      volatile.Register32 // 0xB4
	PS_CTRL_CLR      volatile.Register32 // 0xB8
	PS_CTRL_TOG      volatile.Register32 // 0xBC
	PS_BUF           volatile.Register32 // 0xC0
	_                [12]byte
	PS_UBUF          volatile.Register32 // 0xD0
	_                [12]byte
	PS_VBUF          volatile.Register32 // 0xE0
	_                [12]byte
	PS_PITCH         volatile.Register32 // 0xF0
	_                [12]byte
	PS_BACKGROUND    volatile.Register32 // 0x100
	_                [12]byte
	PS_SCALE         volatile.Register32 // 0x110
	_                [12]byte
	PS_OFFSET        volatile.Register32 // 0x120
	_                [12]byte
	PS_CLRKEYLOW     volatile.Register32 // 0x130
	_                [12]byte
	PS_CLRKEYHIGH    volatile.Register32 // 0x140
	_                [12]byte
	AS_CTRL          volatile.Register32 // 0x150
	_                [12]byte
	AS_BUF           volatile.Register32 // 0x160
	_                [12]byte
	AS_PITCH         volatile.Register32 // 0x170
	_                [12]byte
	AS_CLRKEYLOW     volatile.Register32 // 0x180
	_                [12]byte
	AS_CLRKEYHIGH    volatile.Register32 // 0x190
	_                [12]byte
	CSC1_COEF0       volatile.Register32 // 0x1A0
	_                [12]byte
	CSC1_COEF1       volatile.Register32 // 0x1B0
	_                [12]byte
	CSC1_COEF2       volatile.Register32 // 0x1C0
	_                [348]byte
	POWER            volatile.Register32 // 0x320
	_                [220]byte
	NEXT             volatile.Register32 // 0x400
	_                [60]byte
	PORTER_DUFF_CTRL volatile.Register32 // 0x440
}

// LCDIF Register Reference Index
type LCDIF_Type struct {
	CTRL            volatile.Register32 // 0x0
	CTRL_SET        volatile.Register32 // 0x4
	CTRL_CLR        volatile.Register32 // 0x8
	CTRL_TOG        volatile.Register32 // 0xC
	CTRL1           volatile.Register32 // 0x10
	CTRL1_SET       volatile.Register32 // 0x14
	CTRL1_CLR       volatile.Register32 // 0x18
	CTRL1_TOG       volatile.Register32 // 0x1C
	CTRL2           volatile.Register32 // 0x20
	CTRL2_SET       volatile.Register32 // 0x24
	CTRL2_CLR       volatile.Register32 // 0x28
	CTRL2_TOG       volatile.Register32 // 0x2C
	TRANSFER_COUNT  volatile.Register32 // 0x30
	_               [12]byte
	CUR_BUF         volatile.Register32 // 0x40
	_               [12]byte
	NEXT_BUF        volatile.Register32 // 0x50
	_               [28]byte
	VDCTRL0         volatile.Register32 // 0x70
	VDCTRL0_SET     volatile.Register32 // 0x74
	VDCTRL0_CLR     volatile.Register32 // 0x78
	VDCTRL0_TOG     volatile.Register32 // 0x7C
	VDCTRL1         volatile.Register32 // 0x80
	_               [12]byte
	VDCTRL2         volatile.Register32 // 0x90
	_               [12]byte
	VDCTRL3         volatile.Register32 // 0xA0
	_               [12]byte
	VDCTRL4         volatile.Register32 // 0xB0
	_               [220]byte
	BM_ERROR_STAT   volatile.Register32 // 0x190
	_               [12]byte
	CRC_STAT        volatile.Register32 // 0x1A0
	_               [12]byte
	STAT            volatile.Register32 // 0x1B0
	_               [460]byte
	PIGEONCTRL0     volatile.Register32 // 0x380
	PIGEONCTRL0_SET volatile.Register32 // 0x384
	PIGEONCTRL0_CLR volatile.Register32 // 0x388
	PIGEONCTRL0_TOG volatile.Register32 // 0x38C
	PIGEONCTRL1     volatile.Register32 // 0x390
	PIGEONCTRL1_SET volatile.Register32 // 0x394
	PIGEONCTRL1_CLR volatile.Register32 // 0x398
	PIGEONCTRL1_TOG volatile.Register32 // 0x39C
	PIGEONCTRL2     volatile.Register32 // 0x3A0
	PIGEONCTRL2_SET volatile.Register32 // 0x3A4
	PIGEONCTRL2_CLR volatile.Register32 // 0x3A8
	PIGEONCTRL2_TOG volatile.Register32 // 0x3AC
	_               [1104]byte
	PIGEON_0_0      volatile.Register32 // 0x800
	_               [12]byte
	PIGEON_0_1      volatile.Register32 // 0x810
	_               [12]byte
	PIGEON_0_2      volatile.Register32 // 0x820
	_               [28]byte
	PIGEON_1_0      volatile.Register32 // 0x840
	_               [12]byte
	PIGEON_1_1      volatile.Register32 // 0x850
	_               [12]byte
	PIGEON_1_2      volatile.Register32 // 0x860
	_               [28]byte
	PIGEON_2_0      volatile.Register32 // 0x880
	_               [12]byte
	PIGEON_2_1      volatile.Register32 // 0x890
	_               [12]byte
	PIGEON_2_2      volatile.Register32 // 0x8A0
	_               [28]byte
	PIGEON_3_0      volatile.Register32 // 0x8C0
	_               [12]byte
	PIGEON_3_1      volatile.Register32 // 0x8D0
	_               [12]byte
	PIGEON_3_2      volatile.Register32 // 0x8E0
	_               [28]byte
	PIGEON_4_0      volatile.Register32 // 0x900
	_               [12]byte
	PIGEON_4_1      volatile.Register32 // 0x910
	_               [12]byte
	PIGEON_4_2      volatile.Register32 // 0x920
	_               [28]byte
	PIGEON_5_0      volatile.Register32 // 0x940
	_               [12]byte
	PIGEON_5_1      volatile.Register32 // 0x950
	_               [12]byte
	PIGEON_5_2      volatile.Register32 // 0x960
	_               [28]byte
	PIGEON_6_0      volatile.Register32 // 0x980
	_               [12]byte
	PIGEON_6_1      volatile.Register32 // 0x990
	_               [12]byte
	PIGEON_6_2      volatile.Register32 // 0x9A0
	_               [28]byte
	PIGEON_7_0      volatile.Register32 // 0x9C0
	_               [12]byte
	PIGEON_7_1      volatile.Register32 // 0x9D0
	_               [12]byte
	PIGEON_7_2      volatile.Register32 // 0x9E0
	_               [28]byte
	PIGEON_8_0      volatile.Register32 // 0xA00
	_               [12]byte
	PIGEON_8_1      volatile.Register32 // 0xA10
	_               [12]byte
	PIGEON_8_2      volatile.Register32 // 0xA20
	_               [28]byte
	PIGEON_9_0      volatile.Register32 // 0xA40
	_               [12]byte
	PIGEON_9_1      volatile.Register32 // 0xA50
	_               [12]byte
	PIGEON_9_2      volatile.Register32 // 0xA60
	_               [28]byte
	PIGEON_10_0     volatile.Register32 // 0xA80
	_               [12]byte
	PIGEON_10_1     volatile.Register32 // 0xA90
	_               [12]byte
	PIGEON_10_2     volatile.Register32 // 0xAA0
	_               [28]byte
	PIGEON_11_0     volatile.Register32 // 0xAC0
	_               [12]byte
	PIGEON_11_1     volatile.Register32 // 0xAD0
	_               [12]byte
	PIGEON_11_2     volatile.Register32 // 0xAE0
	_               [28]byte
	LUT_CTRL        volatile.Register32 // 0xB00
	_               [12]byte
	LUT0_ADDR       volatile.Register32 // 0xB10
	_               [12]byte
	LUT0_DATA       volatile.Register32 // 0xB20
	_               [12]byte
	LUT1_ADDR       volatile.Register32 // 0xB30
	_               [12]byte
	LUT1_DATA       volatile.Register32 // 0xB40
}

// CSI
type CSI_Type struct {
	CSICR1            volatile.Register32 // 0x0
	CSICR2            volatile.Register32 // 0x4
	CSICR3            volatile.Register32 // 0x8
	CSISTATFIFO       volatile.Register32 // 0xC
	CSIRFIFO          volatile.Register32 // 0x10
	CSIRXCNT          volatile.Register32 // 0x14
	CSISR             volatile.Register32 // 0x18
	_                 [4]byte
	CSIDMASA_STATFIFO volatile.Register32 // 0x20
	CSIDMATS_STATFIFO volatile.Register32 // 0x24
	CSIDMASA_FB1      volatile.Register32 // 0x28
	CSIDMASA_FB2      volatile.Register32 // 0x2C
	CSIFBUF_PARA      volatile.Register32 // 0x30
	CSIIMAG_PARA      volatile.Register32 // 0x34
	_                 [16]byte
	CSICR18           volatile.Register32 // 0x48
	CSICR19           volatile.Register32 // 0x4C
}

// uSDHC
type USDHC_Type struct {
	DS_ADDR              volatile.Register32 // 0x0
	BLK_ATT              volatile.Register32 // 0x4
	CMD_ARG              volatile.Register32 // 0x8
	CMD_XFR_TYP          volatile.Register32 // 0xC
	CMD_RSP0             volatile.Register32 // 0x10
	CMD_RSP1             volatile.Register32 // 0x14
	CMD_RSP2             volatile.Register32 // 0x18
	CMD_RSP3             volatile.Register32 // 0x1C
	DATA_BUFF_ACC_PORT   volatile.Register32 // 0x20
	PRES_STATE           volatile.Register32 // 0x24
	PROT_CTRL            volatile.Register32 // 0x28
	SYS_CTRL             volatile.Register32 // 0x2C
	INT_STATUS           volatile.Register32 // 0x30
	INT_STATUS_EN        volatile.Register32 // 0x34
	INT_SIGNAL_EN        volatile.Register32 // 0x38
	AUTOCMD12_ERR_STATUS volatile.Register32 // 0x3C
	HOST_CTRL_CAP        volatile.Register32 // 0x40
	WTMK_LVL             volatile.Register32 // 0x44
	MIX_CTRL             volatile.Register32 // 0x48
	_                    [4]byte
	FORCE_EVENT          volatile.Register32 // 0x50
	ADMA_ERR_STATUS      volatile.Register32 // 0x54
	ADMA_SYS_ADDR        volatile.Register32 // 0x58
	_                    [4]byte
	DLL_CTRL             volatile.Register32 // 0x60
	DLL_STATUS           volatile.Register32 // 0x64
	CLK_TUNE_CTRL_STATUS volatile.Register32 // 0x68
	_                    [84]byte
	VEND_SPEC            volatile.Register32 // 0xC0
	MMC_BOOT             volatile.Register32 // 0xC4
	VEND_SPEC2           volatile.Register32 // 0xC8
	TUNING_CTRL          volatile.Register32 // 0xCC
}

// Ethernet MAC-NET Core
type ENET_Type struct {
	_                  [4]byte
	EIR                volatile.Register32 // 0x4
	EIMR               volatile.Register32 // 0x8
	_                  [4]byte
	RDAR               volatile.Register32 // 0x10
	TDAR               volatile.Register32 // 0x14
	_                  [12]byte
	ECR                volatile.Register32 // 0x24
	_                  [24]byte
	MMFR               volatile.Register32 // 0x40
	MSCR               volatile.Register32 // 0x44
	_                  [28]byte
	MIBC               volatile.Register32 // 0x64
	_                  [28]byte
	RCR                volatile.Register32 // 0x84
	_                  [60]byte
	TCR                volatile.Register32 // 0xC4
	_                  [28]byte
	PALR               volatile.Register32 // 0xE4
	PAUR               volatile.Register32 // 0xE8
	OPD                volatile.Register32 // 0xEC
	TXIC               volatile.Register32 // 0xF0
	_                  [12]byte
	RXIC               volatile.Register32 // 0x100
	_                  [20]byte
	IAUR               volatile.Register32 // 0x118
	IALR               volatile.Register32 // 0x11C
	GAUR               volatile.Register32 // 0x120
	GALR               volatile.Register32 // 0x124
	_                  [28]byte
	TFWR               volatile.Register32 // 0x144
	_                  [56]byte
	RDSR               volatile.Register32 // 0x180
	TDSR               volatile.Register32 // 0x184
	MRBR               volatile.Register32 // 0x188
	_                  [4]byte
	RSFL               volatile.Register32 // 0x190
	RSEM               volatile.Register32 // 0x194
	RAEM               volatile.Register32 // 0x198
	RAFL               volatile.Register32 // 0x19C
	TSEM               volatile.Register32 // 0x1A0
	TAEM               volatile.Register32 // 0x1A4
	TAFL               volatile.Register32 // 0x1A8
	TIPG               volatile.Register32 // 0x1AC
	FTRL               volatile.Register32 // 0x1B0
	_                  [12]byte
	TACC               volatile.Register32 // 0x1C0
	RACC               volatile.Register32 // 0x1C4
	_                  [56]byte
	RMON_T_DROP        volatile.Register32 // 0x200
	RMON_T_PACKETS     volatile.Register32 // 0x204
	RMON_T_BC_PKT      volatile.Register32 // 0x208
	RMON_T_MC_PKT      volatile.Register32 // 0x20C
	RMON_T_CRC_ALIGN   volatile.Register32 // 0x210
	RMON_T_UNDERSIZE   volatile.Register32 // 0x214
	RMON_T_OVERSIZE    volatile.Register32 // 0x218
	RMON_T_FRAG        volatile.Register32 // 0x21C
	RMON_T_JAB         volatile.Register32 // 0x220
	RMON_T_COL         volatile.Register32 // 0x224
	RMON_T_P64         volatile.Register32 // 0x228
	RMON_T_P65TO127    volatile.Register32 // 0x22C
	RMON_T_P128TO255   volatile.Register32 // 0x230
	RMON_T_P256TO511   volatile.Register32 // 0x234
	RMON_T_P512TO1023  volatile.Register32 // 0x238
	RMON_T_P1024TO2047 volatile.Register32 // 0x23C
	RMON_T_P_GTE2048   volatile.Register32 // 0x240
	RMON_T_OCTETS      volatile.Register32 // 0x244
	IEEE_T_DROP        volatile.Register32 // 0x248
	IEEE_T_FRAME_OK    volatile.Register32 // 0x24C
	IEEE_T_1COL        volatile.Register32 // 0x250
	IEEE_T_MCOL        volatile.Register32 // 0x254
	IEEE_T_DEF         volatile.Register32 // 0x258
	IEEE_T_LCOL        volatile.Register32 // 0x25C
	IEEE_T_EXCOL       volatile.Register32 // 0x260
	IEEE_T_MACERR      volatile.Register32 // 0x264
	IEEE_T_CSERR       volatile.Register32 // 0x268
	IEEE_T_SQE         volatile.Register32 // 0x26C
	IEEE_T_FDXFC       volatile.Register32 // 0x270
	IEEE_T_OCTETS_OK   volatile.Register32 // 0x274
	_                  [12]byte
	RMON_R_PACKETS     volatile.Register32 // 0x284
	RMON_R_BC_PKT      volatile.Register32 // 0x288
	RMON_R_MC_PKT      volatile.Register32 // 0x28C
	RMON_R_CRC_ALIGN   volatile.Register32 // 0x290
	RMON_R_UNDERSIZE   volatile.Register32 // 0x294
	RMON_R_OVERSIZE    volatile.Register32 // 0x298
	RMON_R_FRAG        volatile.Register32 // 0x29C
	RMON_R_JAB         volatile.Register32 // 0x2A0
	RMON_R_RESVD_0     volatile.Register32 // 0x2A4
	RMON_R_P64         volatile.Register32 // 0x2A8
	RMON_R_P65TO127    volatile.Register32 // 0x2AC
	RMON_R_P128TO255   volatile.Register32 // 0x2B0
	RMON_R_P256TO511   volatile.Register32 // 0x2B4
	RMON_R_P512TO1023  volatile.Register32 // 0x2B8
	RMON_R_P1024TO2047 volatile.Register32 // 0x2BC
	RMON_R_P_GTE2048   volatile.Register32 // 0x2C0
	RMON_R_OCTETS      volatile.Register32 // 0x2C4
	IEEE_R_DROP        volatile.Register32 // 0x2C8
	IEEE_R_FRAME_OK    volatile.Register32 // 0x2CC
	IEEE_R_CRC         volatile.Register32 // 0x2D0
	IEEE_R_ALIGN       volatile.Register32 // 0x2D4
	IEEE_R_MACERR      volatile.Register32 // 0x2D8
	IEEE_R_FDXFC       volatile.Register32 // 0x2DC
	IEEE_R_OCTETS_OK   volatile.Register32 // 0x2E0
	_                  [284]byte
	ATCR               volatile.Register32 // 0x400
	ATVR               volatile.Register32 // 0x404
	ATOFF              volatile.Register32 // 0x408
	ATPER              volatile.Register32 // 0x40C
	ATCOR              volatile.Register32 // 0x410
	ATINC              volatile.Register32 // 0x414
	ATSTMP             volatile.Register32 // 0x418
	_                  [488]byte
	TGSR               volatile.Register32 // 0x604
	TCSR0              volatile.Register32 // 0x608
	TCCR0              volatile.Register32 // 0x60C
	TCSR1              volatile.Register32 // 0x610
	TCCR1              volatile.Register32 // 0x614
	TCSR2              volatile.Register32 // 0x618
	TCCR2              volatile.Register32 // 0x61C
	TCSR3              volatile.Register32 // 0x620
	TCCR3              volatile.Register32 // 0x624
}

// USB
type USB_Type struct {
	ID             volatile.Register32 // 0x0
	HWGENERAL      volatile.Register32 // 0x4
	HWHOST         volatile.Register32 // 0x8
	HWDEVICE       volatile.Register32 // 0xC
	HWTXBUF        volatile.Register32 // 0x10
	HWRXBUF        volatile.Register32 // 0x14
	_              [104]byte
	GPTIMER0LD     volatile.Register32 // 0x80
	GPTIMER0CTRL   volatile.Register32 // 0x84
	GPTIMER1LD     volatile.Register32 // 0x88
	GPTIMER1CTRL   volatile.Register32 // 0x8C
	SBUSCFG        volatile.Register32 // 0x90
	_              [108]byte
	CAPLENGTH      volatile.Register8 // 0x100
	_              byte
	HCIVERSION     volatile.Register16 // 0x102
	HCSPARAMS      volatile.Register32 // 0x104
	HCCPARAMS      volatile.Register32 // 0x108
	_              [20]byte
	DCIVERSION     volatile.Register16 // 0x120
	_              [2]byte
	DCCPARAMS      volatile.Register32 // 0x124
	_              [24]byte
	USBCMD         volatile.Register32 // 0x140
	USBSTS         volatile.Register32 // 0x144
	USBINTR        volatile.Register32 // 0x148
	FRINDEX        volatile.Register32 // 0x14C
	_              [4]byte
	DEVICEADDR     volatile.Register32 // 0x154
	ASYNCLISTADDR  volatile.Register32 // 0x158
	_              [4]byte
	BURSTSIZE      volatile.Register32 // 0x160
	TXFILLTUNING   volatile.Register32 // 0x164
	_              [16]byte
	ENDPTNAK       volatile.Register32 // 0x178
	ENDPTNAKEN     volatile.Register32 // 0x17C
	CONFIGFLAG     volatile.Register32 // 0x180
	PORTSC1        volatile.Register32 // 0x184
	_              [28]byte
	OTGSC          volatile.Register32 // 0x1A4
	USBMODE        volatile.Register32 // 0x1A8
	ENDPTSETUPSTAT volatile.Register32 // 0x1AC
	ENDPTPRIME     volatile.Register32 // 0x1B0
	ENDPTFLUSH     volatile.Register32 // 0x1B4
	ENDPTSTAT      volatile.Register32 // 0x1B8
	ENDPTCOMPLETE  volatile.Register32 // 0x1BC
	ENDPTCTRL0     volatile.Register32 // 0x1C0
	ENDPTCTRL1     volatile.Register32 // 0x1C4
	ENDPTCTRL2     volatile.Register32 // 0x1C8
	ENDPTCTRL3     volatile.Register32 // 0x1CC
	ENDPTCTRL4     volatile.Register32 // 0x1D0
	ENDPTCTRL5     volatile.Register32 // 0x1D4
	ENDPTCTRL6     volatile.Register32 // 0x1D8
	ENDPTCTRL7     volatile.Register32 // 0x1DC
}

// USB
type USBNC_Type struct {
	_                   [2048]byte
	USB_OTG1_CTRL       volatile.Register32 // 0x800
	_                   [20]byte
	USB_OTG1_PHY_CTRL_0 volatile.Register32 // 0x818
}

// SEMC
type SEMC_Type struct {
	MCR      volatile.Register32 // 0x0
	IOCR     volatile.Register32 // 0x4
	BMCR0    volatile.Register32 // 0x8
	BMCR1    volatile.Register32 // 0xC
	BR0      volatile.Register32 // 0x10
	BR1      volatile.Register32 // 0x14
	BR2      volatile.Register32 // 0x18
	BR3      volatile.Register32 // 0x1C
	BR4      volatile.Register32 // 0x20
	BR5      volatile.Register32 // 0x24
	BR6      volatile.Register32 // 0x28
	BR7      volatile.Register32 // 0x2C
	BR8      volatile.Register32 // 0x30
	DLLCR    volatile.Register32 // 0x34
	INTEN    volatile.Register32 // 0x38
	INTR     volatile.Register32 // 0x3C
	SDRAMCR0 volatile.Register32 // 0x40
	SDRAMCR1 volatile.Register32 // 0x44
	SDRAMCR2 volatile.Register32 // 0x48
	SDRAMCR3 volatile.Register32 // 0x4C
	NANDCR0  volatile.Register32 // 0x50
	NANDCR1  volatile.Register32 // 0x54
	NANDCR2  volatile.Register32 // 0x58
	NANDCR3  volatile.Register32 // 0x5C
	NORCR0   volatile.Register32 // 0x60
	NORCR1   volatile.Register32 // 0x64
	NORCR2   volatile.Register32 // 0x68
	NORCR3   volatile.Register32 // 0x6C
	SRAMCR0  volatile.Register32 // 0x70
	SRAMCR1  volatile.Register32 // 0x74
	SRAMCR2  volatile.Register32 // 0x78
	SRAMCR3  volatile.Register32 // 0x7C
	DBICR0   volatile.Register32 // 0x80
	DBICR1   volatile.Register32 // 0x84
	_        [8]byte
	IPCR0    volatile.Register32 // 0x90
	IPCR1    volatile.Register32 // 0x94
	IPCR2    volatile.Register32 // 0x98
	IPCMD    volatile.Register32 // 0x9C
	IPTXDAT  volatile.Register32 // 0xA0
	_        [12]byte
	IPRXDAT  volatile.Register32 // 0xB0
	_        [12]byte
	STS0     volatile.Register32 // 0xC0
	STS1     volatile.Register32 // 0xC4
	STS2     volatile.Register32 // 0xC8
	STS3     volatile.Register32 // 0xCC
	STS4     volatile.Register32 // 0xD0
	STS5     volatile.Register32 // 0xD4
	STS6     volatile.Register32 // 0xD8
	STS7     volatile.Register32 // 0xDC
	STS8     volatile.Register32 // 0xE0
	STS9     volatile.Register32 // 0xE4
	STS10    volatile.Register32 // 0xE8
	STS11    volatile.Register32 // 0xEC
	STS12    volatile.Register32 // 0xF0
	STS13    volatile.Register32 // 0xF4
	STS14    volatile.Register32 // 0xF8
	STS15    volatile.Register32 // 0xFC
}

// DCP register reference index
type DCP_Type struct {
	CTRL            volatile.Register32 // 0x0
	CTRL_SET        volatile.Register32 // 0x4
	CTRL_CLR        volatile.Register32 // 0x8
	CTRL_TOG        volatile.Register32 // 0xC
	STAT            volatile.Register32 // 0x10
	STAT_SET        volatile.Register32 // 0x14
	STAT_CLR        volatile.Register32 // 0x18
	STAT_TOG        volatile.Register32 // 0x1C
	CHANNELCTRL     volatile.Register32 // 0x20
	CHANNELCTRL_SET volatile.Register32 // 0x24
	CHANNELCTRL_CLR volatile.Register32 // 0x28
	CHANNELCTRL_TOG volatile.Register32 // 0x2C
	CAPABILITY0     volatile.Register32 // 0x30
	_               [12]byte
	CAPABILITY1     volatile.Register32 // 0x40
	_               [12]byte
	CONTEXT         volatile.Register32 // 0x50
	_               [12]byte
	KEY             volatile.Register32 // 0x60
	_               [12]byte
	KEYDATA         volatile.Register32 // 0x70
	_               [12]byte
	PACKET0         volatile.Register32 // 0x80
	_               [12]byte
	PACKET1         volatile.Register32 // 0x90
	_               [12]byte
	PACKET2         volatile.Register32 // 0xA0
	_               [12]byte
	PACKET3         volatile.Register32 // 0xB0
	_               [12]byte
	PACKET4         volatile.Register32 // 0xC0
	_               [12]byte
	PACKET5         volatile.Register32 // 0xD0
	_               [12]byte
	PACKET6         volatile.Register32 // 0xE0
	_               [28]byte
	CH0CMDPTR       volatile.Register32 // 0x100
	_               [12]byte
	CH0SEMA         volatile.Register32 // 0x110
	_               [12]byte
	CH0STAT         volatile.Register32 // 0x120
	CH0STAT_SET     volatile.Register32 // 0x124
	CH0STAT_CLR     volatile.Register32 // 0x128
	CH0STAT_TOG     volatile.Register32 // 0x12C
	CH0OPTS         volatile.Register32 // 0x130
	CH0OPTS_SET     volatile.Register32 // 0x134
	CH0OPTS_CLR     volatile.Register32 // 0x138
	CH0OPTS_TOG     volatile.Register32 // 0x13C
	CH1CMDPTR       volatile.Register32 // 0x140
	_               [12]byte
	CH1SEMA         volatile.Register32 // 0x150
	_               [12]byte
	CH1STAT         volatile.Register32 // 0x160
	CH1STAT_SET     volatile.Register32 // 0x164
	CH1STAT_CLR     volatile.Register32 // 0x168
	CH1STAT_TOG     volatile.Register32 // 0x16C
	CH1OPTS         volatile.Register32 // 0x170
	CH1OPTS_SET     volatile.Register32 // 0x174
	CH1OPTS_CLR     volatile.Register32 // 0x178
	CH1OPTS_TOG     volatile.Register32 // 0x17C
	CH2CMDPTR       volatile.Register32 // 0x180
	_               [12]byte
	CH2SEMA         volatile.Register32 // 0x190
	_               [12]byte
	CH2STAT         volatile.Register32 // 0x1A0
	CH2STAT_SET     volatile.Register32 // 0x1A4
	CH2STAT_CLR     volatile.Register32 // 0x1A8
	CH2STAT_TOG     volatile.Register32 // 0x1AC
	CH2OPTS         volatile.Register32 // 0x1B0
	CH2OPTS_SET     volatile.Register32 // 0x1B4
	CH2OPTS_CLR     volatile.Register32 // 0x1B8
	CH2OPTS_TOG     volatile.Register32 // 0x1BC
	CH3CMDPTR       volatile.Register32 // 0x1C0
	_               [12]byte
	CH3SEMA         volatile.Register32 // 0x1D0
	_               [12]byte
	CH3STAT         volatile.Register32 // 0x1E0
	CH3STAT_SET     volatile.Register32 // 0x1E4
	CH3STAT_CLR     volatile.Register32 // 0x1E8
	CH3STAT_TOG     volatile.Register32 // 0x1EC
	CH3OPTS         volatile.Register32 // 0x1F0
	CH3OPTS_SET     volatile.Register32 // 0x1F4
	CH3OPTS_CLR     volatile.Register32 // 0x1F8
	CH3OPTS_TOG     volatile.Register32 // 0x1FC
	_               [512]byte
	DBGSELECT       volatile.Register32 // 0x400
	_               [12]byte
	DBGDATA         volatile.Register32 // 0x410
	_               [12]byte
	PAGETABLE       volatile.Register32 // 0x420
	_               [12]byte
	VERSION         volatile.Register32 // 0x430
}

// SPDIF
type SPDIF_Type struct {
	SCR    volatile.Register32 // 0x0
	SRCD   volatile.Register32 // 0x4
	SRPC   volatile.Register32 // 0x8
	SIE    volatile.Register32 // 0xC
	SIC    volatile.Register32 // 0x10
	SRL    volatile.Register32 // 0x14
	SRR    volatile.Register32 // 0x18
	SRCSH  volatile.Register32 // 0x1C
	SRCSL  volatile.Register32 // 0x20
	SRU    volatile.Register32 // 0x24
	SRQ    volatile.Register32 // 0x28
	STL    volatile.Register32 // 0x2C
	STR    volatile.Register32 // 0x30
	STCSCH volatile.Register32 // 0x34
	STCSCL volatile.Register32 // 0x38
	_      [8]byte
	SRFM   volatile.Register32 // 0x44
	_      [8]byte
	STC    volatile.Register32 // 0x50
}

// I2S
type I2S_Type struct {
	VERID volatile.Register32    // 0x0
	PARAM volatile.Register32    // 0x4
	TCSR  volatile.Register32    // 0x8
	TCR1  volatile.Register32    // 0xC
	TCR2  volatile.Register32    // 0x10
	TCR3  volatile.Register32    // 0x14
	TCR4  volatile.Register32    // 0x18
	TCR5  volatile.Register32    // 0x1C
	TDR   [4]volatile.Register32 // 0x20
	_     [16]byte
	TFR   [4]volatile.Register32 // 0x40
	_     [16]byte
	TMR   volatile.Register32 // 0x60
	_     [36]byte
	RCSR  volatile.Register32    // 0x88
	RCR1  volatile.Register32    // 0x8C
	RCR2  volatile.Register32    // 0x90
	RCR3  volatile.Register32    // 0x94
	RCR4  volatile.Register32    // 0x98
	RCR5  volatile.Register32    // 0x9C
	RDR   [4]volatile.Register32 // 0xA0
	_     [16]byte
	RFR   [4]volatile.Register32 // 0xC0
	_     [16]byte
	RMR   volatile.Register32 // 0xE0
}

// LPSPI
type LPSPI_Type struct {
	VERID volatile.Register32 // 0x0
	PARAM volatile.Register32 // 0x4
	_     [8]byte
	CR    volatile.Register32 // 0x10
	SR    volatile.Register32 // 0x14
	IER   volatile.Register32 // 0x18
	DER   volatile.Register32 // 0x1C
	CFGR0 volatile.Register32 // 0x20
	CFGR1 volatile.Register32 // 0x24
	_     [8]byte
	DMR0  volatile.Register32 // 0x30
	DMR1  volatile.Register32 // 0x34
	_     [8]byte
	CCR   volatile.Register32 // 0x40
	_     [20]byte
	FCR   volatile.Register32 // 0x58
	FSR   volatile.Register32 // 0x5C
	TCR   volatile.Register32 // 0x60
	TDR   volatile.Register32 // 0x64
	_     [8]byte
	RSR   volatile.Register32 // 0x70
	RDR   volatile.Register32 // 0x74
}

// ADC_ETC
type ADC_ETC_Type struct {
	CTRL             volatile.Register32 // 0x0
	DONE0_1_IRQ      volatile.Register32 // 0x4
	DONE2_ERR_IRQ    volatile.Register32 // 0x8
	DMA_CTRL         volatile.Register32 // 0xC
	TRIG0_CTRL       volatile.Register32 // 0x10
	TRIG0_COUNTER    volatile.Register32 // 0x14
	TRIG0_CHAIN_1_0  volatile.Register32 // 0x18
	TRIG0_CHAIN_3_2  volatile.Register32 // 0x1C
	TRIG0_CHAIN_5_4  volatile.Register32 // 0x20
	TRIG0_CHAIN_7_6  volatile.Register32 // 0x24
	TRIG0_RESULT_1_0 volatile.Register32 // 0x28
	TRIG0_RESULT_3_2 volatile.Register32 // 0x2C
	TRIG0_RESULT_5_4 volatile.Register32 // 0x30
	TRIG0_RESULT_7_6 volatile.Register32 // 0x34
	TRIG1_CTRL       volatile.Register32 // 0x38
	TRIG1_COUNTER    volatile.Register32 // 0x3C
	TRIG1_CHAIN_1_0  volatile.Register32 // 0x40
	TRIG1_CHAIN_3_2  volatile.Register32 // 0x44
	TRIG1_CHAIN_5_4  volatile.Register32 // 0x48
	TRIG1_CHAIN_7_6  volatile.Register32 // 0x4C
	TRIG1_RESULT_1_0 volatile.Register32 // 0x50
	TRIG1_RESULT_3_2 volatile.Register32 // 0x54
	TRIG1_RESULT_5_4 volatile.Register32 // 0x58
	TRIG1_RESULT_7_6 volatile.Register32 // 0x5C
	TRIG2_CTRL       volatile.Register32 // 0x60
	TRIG2_COUNTER    volatile.Register32 // 0x64
	TRIG2_CHAIN_1_0  volatile.Register32 // 0x68
	TRIG2_CHAIN_3_2  volatile.Register32 // 0x6C
	TRIG2_CHAIN_5_4  volatile.Register32 // 0x70
	TRIG2_CHAIN_7_6  volatile.Register32 // 0x74
	TRIG2_RESULT_1_0 volatile.Register32 // 0x78
	TRIG2_RESULT_3_2 volatile.Register32 // 0x7C
	TRIG2_RESULT_5_4 volatile.Register32 // 0x80
	TRIG2_RESULT_7_6 volatile.Register32 // 0x84
	TRIG3_CTRL       volatile.Register32 // 0x88
	TRIG3_COUNTER    volatile.Register32 // 0x8C
	TRIG3_CHAIN_1_0  volatile.Register32 // 0x90
	TRIG3_CHAIN_3_2  volatile.Register32 // 0x94
	TRIG3_CHAIN_5_4  volatile.Register32 // 0x98
	TRIG3_CHAIN_7_6  volatile.Register32 // 0x9C
	TRIG3_RESULT_1_0 volatile.Register32 // 0xA0
	TRIG3_RESULT_3_2 volatile.Register32 // 0xA4
	TRIG3_RESULT_5_4 volatile.Register32 // 0xA8
	TRIG3_RESULT_7_6 volatile.Register32 // 0xAC
	TRIG4_CTRL       volatile.Register32 // 0xB0
	TRIG4_COUNTER    volatile.Register32 // 0xB4
	TRIG4_CHAIN_1_0  volatile.Register32 // 0xB8
	TRIG4_CHAIN_3_2  volatile.Register32 // 0xBC
	TRIG4_CHAIN_5_4  volatile.Register32 // 0xC0
	TRIG4_CHAIN_7_6  volatile.Register32 // 0xC4
	TRIG4_RESULT_1_0 volatile.Register32 // 0xC8
	TRIG4_RESULT_3_2 volatile.Register32 // 0xCC
	TRIG4_RESULT_5_4 volatile.Register32 // 0xD0
	TRIG4_RESULT_7_6 volatile.Register32 // 0xD4
	TRIG5_CTRL       volatile.Register32 // 0xD8
	TRIG5_COUNTER    volatile.Register32 // 0xDC
	TRIG5_CHAIN_1_0  volatile.Register32 // 0xE0
	TRIG5_CHAIN_3_2  volatile.Register32 // 0xE4
	TRIG5_CHAIN_5_4  volatile.Register32 // 0xE8
	TRIG5_CHAIN_7_6  volatile.Register32 // 0xEC
	TRIG5_RESULT_1_0 volatile.Register32 // 0xF0
	TRIG5_RESULT_3_2 volatile.Register32 // 0xF4
	TRIG5_RESULT_5_4 volatile.Register32 // 0xF8
	TRIG5_RESULT_7_6 volatile.Register32 // 0xFC
	TRIG6_CTRL       volatile.Register32 // 0x100
	TRIG6_COUNTER    volatile.Register32 // 0x104
	TRIG6_CHAIN_1_0  volatile.Register32 // 0x108
	TRIG6_CHAIN_3_2  volatile.Register32 // 0x10C
	TRIG6_CHAIN_5_4  volatile.Register32 // 0x110
	TRIG6_CHAIN_7_6  volatile.Register32 // 0x114
	TRIG6_RESULT_1_0 volatile.Register32 // 0x118
	TRIG6_RESULT_3_2 volatile.Register32 // 0x11C
	TRIG6_RESULT_5_4 volatile.Register32 // 0x120
	TRIG6_RESULT_7_6 volatile.Register32 // 0x124
	TRIG7_CTRL       volatile.Register32 // 0x128
	TRIG7_COUNTER    volatile.Register32 // 0x12C
	TRIG7_CHAIN_1_0  volatile.Register32 // 0x130
	TRIG7_CHAIN_3_2  volatile.Register32 // 0x134
	TRIG7_CHAIN_5_4  volatile.Register32 // 0x138
	TRIG7_CHAIN_7_6  volatile.Register32 // 0x13C
	TRIG7_RESULT_1_0 volatile.Register32 // 0x140
	TRIG7_RESULT_3_2 volatile.Register32 // 0x144
	TRIG7_RESULT_5_4 volatile.Register32 // 0x148
	TRIG7_RESULT_7_6 volatile.Register32 // 0x14C
}

// AND/OR/INVERT module
type AOI_Type struct {
	BFCRT010 volatile.Register16 // 0x0
	BFCRT230 volatile.Register16 // 0x2
	BFCRT011 volatile.Register16 // 0x4
	BFCRT231 volatile.Register16 // 0x6
	BFCRT012 volatile.Register16 // 0x8
	BFCRT232 volatile.Register16 // 0xA
	BFCRT013 volatile.Register16 // 0xC
	BFCRT233 volatile.Register16 // 0xE
}

// Crossbar Switch
type XBARA_Type struct {
	SEL0  volatile.Register16 // 0x0
	SEL1  volatile.Register16 // 0x2
	SEL2  volatile.Register16 // 0x4
	SEL3  volatile.Register16 // 0x6
	SEL4  volatile.Register16 // 0x8
	SEL5  volatile.Register16 // 0xA
	SEL6  volatile.Register16 // 0xC
	SEL7  volatile.Register16 // 0xE
	SEL8  volatile.Register16 // 0x10
	SEL9  volatile.Register16 // 0x12
	SEL10 volatile.Register16 // 0x14
	SEL11 volatile.Register16 // 0x16
	SEL12 volatile.Register16 // 0x18
	SEL13 volatile.Register16 // 0x1A
	SEL14 volatile.Register16 // 0x1C
	SEL15 volatile.Register16 // 0x1E
	SEL16 volatile.Register16 // 0x20
	SEL17 volatile.Register16 // 0x22
	SEL18 volatile.Register16 // 0x24
	SEL19 volatile.Register16 // 0x26
	SEL20 volatile.Register16 // 0x28
	SEL21 volatile.Register16 // 0x2A
	SEL22 volatile.Register16 // 0x2C
	SEL23 volatile.Register16 // 0x2E
	SEL24 volatile.Register16 // 0x30
	SEL25 volatile.Register16 // 0x32
	SEL26 volatile.Register16 // 0x34
	SEL27 volatile.Register16 // 0x36
	SEL28 volatile.Register16 // 0x38
	SEL29 volatile.Register16 // 0x3A
	SEL30 volatile.Register16 // 0x3C
	SEL31 volatile.Register16 // 0x3E
	SEL32 volatile.Register16 // 0x40
	SEL33 volatile.Register16 // 0x42
	SEL34 volatile.Register16 // 0x44
	SEL35 volatile.Register16 // 0x46
	SEL36 volatile.Register16 // 0x48
	SEL37 volatile.Register16 // 0x4A
	SEL38 volatile.Register16 // 0x4C
	SEL39 volatile.Register16 // 0x4E
	SEL40 volatile.Register16 // 0x50
	SEL41 volatile.Register16 // 0x52
	SEL42 volatile.Register16 // 0x54
	SEL43 volatile.Register16 // 0x56
	SEL44 volatile.Register16 // 0x58
	SEL45 volatile.Register16 // 0x5A
	SEL46 volatile.Register16 // 0x5C
	SEL47 volatile.Register16 // 0x5E
	SEL48 volatile.Register16 // 0x60
	SEL49 volatile.Register16 // 0x62
	SEL50 volatile.Register16 // 0x64
	SEL51 volatile.Register16 // 0x66
	SEL52 volatile.Register16 // 0x68
	SEL53 volatile.Register16 // 0x6A
	SEL54 volatile.Register16 // 0x6C
	SEL55 volatile.Register16 // 0x6E
	SEL56 volatile.Register16 // 0x70
	SEL57 volatile.Register16 // 0x72
	SEL58 volatile.Register16 // 0x74
	SEL59 volatile.Register16 // 0x76
	SEL60 volatile.Register16 // 0x78
	SEL61 volatile.Register16 // 0x7A
	SEL62 volatile.Register16 // 0x7C
	SEL63 volatile.Register16 // 0x7E
	SEL64 volatile.Register16 // 0x80
	SEL65 volatile.Register16 // 0x82
	CTRL0 volatile.Register16 // 0x84
	CTRL1 volatile.Register16 // 0x86
}

// Quadrature Decoder
type ENC_Type struct {
	CTRL  volatile.Register16 // 0x0
	FILT  volatile.Register16 // 0x2
	WTR   volatile.Register16 // 0x4
	POSD  volatile.Register16 // 0x6
	POSDH volatile.Register16 // 0x8
	REV   volatile.Register16 // 0xA
	REVH  volatile.Register16 // 0xC
	UPOS  volatile.Register16 // 0xE
	LPOS  volatile.Register16 // 0x10
	UPOSH volatile.Register16 // 0x12
	LPOSH volatile.Register16 // 0x14
	UINIT volatile.Register16 // 0x16
	LINIT volatile.Register16 // 0x18
	IMR   volatile.Register16 // 0x1A
	TST   volatile.Register16 // 0x1C
	CTRL2 volatile.Register16 // 0x1E
	UMOD  volatile.Register16 // 0x20
	LMOD  volatile.Register16 // 0x22
	UCOMP volatile.Register16 // 0x24
	LCOMP volatile.Register16 // 0x26
}

// PWM
type PWM_Type struct {
	SM0CNT       volatile.Register16 // 0x0
	SM0INIT      volatile.Register16 // 0x2
	SM0CTRL2     volatile.Register16 // 0x4
	SM0CTRL      volatile.Register16 // 0x6
	_            [2]byte
	SM0VAL0      volatile.Register16 // 0xA
	SM0FRACVAL1  volatile.Register16 // 0xC
	SM0VAL1      volatile.Register16 // 0xE
	SM0FRACVAL2  volatile.Register16 // 0x10
	SM0VAL2      volatile.Register16 // 0x12
	SM0FRACVAL3  volatile.Register16 // 0x14
	SM0VAL3      volatile.Register16 // 0x16
	SM0FRACVAL4  volatile.Register16 // 0x18
	SM0VAL4      volatile.Register16 // 0x1A
	SM0FRACVAL5  volatile.Register16 // 0x1C
	SM0VAL5      volatile.Register16 // 0x1E
	SM0FRCTRL    volatile.Register16 // 0x20
	SM0OCTRL     volatile.Register16 // 0x22
	SM0STS       volatile.Register16 // 0x24
	SM0INTEN     volatile.Register16 // 0x26
	SM0DMAEN     volatile.Register16 // 0x28
	SM0TCTRL     volatile.Register16 // 0x2A
	SM0DISMAP0   volatile.Register16 // 0x2C
	SM0DISMAP1   volatile.Register16 // 0x2E
	SM0DTCNT0    volatile.Register16 // 0x30
	SM0DTCNT1    volatile.Register16 // 0x32
	SM0CAPTCTRLA volatile.Register16 // 0x34
	SM0CAPTCOMPA volatile.Register16 // 0x36
	SM0CAPTCTRLB volatile.Register16 // 0x38
	SM0CAPTCOMPB volatile.Register16 // 0x3A
	SM0CAPTCTRLX volatile.Register16 // 0x3C
	SM0CAPTCOMPX volatile.Register16 // 0x3E
	SM0CVAL0     volatile.Register16 // 0x40
	SM0CVAL0CYC  volatile.Register16 // 0x42
	SM0CVAL1     volatile.Register16 // 0x44
	SM0CVAL1CYC  volatile.Register16 // 0x46
	SM0CVAL2     volatile.Register16 // 0x48
	SM0CVAL2CYC  volatile.Register16 // 0x4A
	SM0CVAL3     volatile.Register16 // 0x4C
	SM0CVAL3CYC  volatile.Register16 // 0x4E
	SM0CVAL4     volatile.Register16 // 0x50
	SM0CVAL4CYC  volatile.Register16 // 0x52
	SM0CVAL5     volatile.Register16 // 0x54
	SM0CVAL5CYC  volatile.Register16 // 0x56
	_            [8]byte
	SM1CNT       volatile.Register16 // 0x60
	SM1INIT      volatile.Register16 // 0x62
	SM1CTRL2     volatile.Register16 // 0x64
	SM1CTRL      volatile.Register16 // 0x66
	_            [2]byte
	SM1VAL0      volatile.Register16 // 0x6A
	SM1FRACVAL1  volatile.Register16 // 0x6C
	SM1VAL1      volatile.Register16 // 0x6E
	SM1FRACVAL2  volatile.Register16 // 0x70
	SM1VAL2      volatile.Register16 // 0x72
	SM1FRACVAL3  volatile.Register16 // 0x74
	SM1VAL3      volatile.Register16 // 0x76
	SM1FRACVAL4  volatile.Register16 // 0x78
	SM1VAL4      volatile.Register16 // 0x7A
	SM1FRACVAL5  volatile.Register16 // 0x7C
	SM1VAL5      volatile.Register16 // 0x7E
	SM1FRCTRL    volatile.Register16 // 0x80
	SM1OCTRL     volatile.Register16 // 0x82
	SM1STS       volatile.Register16 // 0x84
	SM1INTEN     volatile.Register16 // 0x86
	SM1DMAEN     volatile.Register16 // 0x88
	SM1TCTRL     volatile.Register16 // 0x8A
	SM1DISMAP0   volatile.Register16 // 0x8C
	SM1DISMAP1   volatile.Register16 // 0x8E
	SM1DTCNT0    volatile.Register16 // 0x90
	SM1DTCNT1    volatile.Register16 // 0x92
	SM1CAPTCTRLA volatile.Register16 // 0x94
	SM1CAPTCOMPA volatile.Register16 // 0x96
	SM1CAPTCTRLB volatile.Register16 // 0x98
	SM1CAPTCOMPB volatile.Register16 // 0x9A
	SM1CAPTCTRLX volatile.Register16 // 0x9C
	SM1CAPTCOMPX volatile.Register16 // 0x9E
	SM1CVAL0     volatile.Register16 // 0xA0
	SM1CVAL0CYC  volatile.Register16 // 0xA2
	SM1CVAL1     volatile.Register16 // 0xA4
	SM1CVAL1CYC  volatile.Register16 // 0xA6
	SM1CVAL2     volatile.Register16 // 0xA8
	SM1CVAL2CYC  volatile.Register16 // 0xAA
	SM1CVAL3     volatile.Register16 // 0xAC
	SM1CVAL3CYC  volatile.Register16 // 0xAE
	SM1CVAL4     volatile.Register16 // 0xB0
	SM1CVAL4CYC  volatile.Register16 // 0xB2
	SM1CVAL5     volatile.Register16 // 0xB4
	SM1CVAL5CYC  volatile.Register16 // 0xB6
	_            [8]byte
	SM2CNT       volatile.Register16 // 0xC0
	SM2INIT      volatile.Register16 // 0xC2
	SM2CTRL2     volatile.Register16 // 0xC4
	SM2CTRL      volatile.Register16 // 0xC6
	_            [2]byte
	SM2VAL0      volatile.Register16 // 0xCA
	SM2FRACVAL1  volatile.Register16 // 0xCC
	SM2VAL1      volatile.Register16 // 0xCE
	SM2FRACVAL2  volatile.Register16 // 0xD0
	SM2VAL2      volatile.Register16 // 0xD2
	SM2FRACVAL3  volatile.Register16 // 0xD4
	SM2VAL3      volatile.Register16 // 0xD6
	SM2FRACVAL4  volatile.Register16 // 0xD8
	SM2VAL4      volatile.Register16 // 0xDA
	SM2FRACVAL5  volatile.Register16 // 0xDC
	SM2VAL5      volatile.Register16 // 0xDE
	SM2FRCTRL    volatile.Register16 // 0xE0
	SM2OCTRL     volatile.Register16 // 0xE2
	SM2STS       volatile.Register16 // 0xE4
	SM2INTEN     volatile.Register16 // 0xE6
	SM2DMAEN     volatile.Register16 // 0xE8
	SM2TCTRL     volatile.Register16 // 0xEA
	SM2DISMAP0   volatile.Register16 // 0xEC
	SM2DISMAP1   volatile.Register16 // 0xEE
	SM2DTCNT0    volatile.Register16 // 0xF0
	SM2DTCNT1    volatile.Register16 // 0xF2
	SM2CAPTCTRLA volatile.Register16 // 0xF4
	SM2CAPTCOMPA volatile.Register16 // 0xF6
	SM2CAPTCTRLB volatile.Register16 // 0xF8
	SM2CAPTCOMPB volatile.Register16 // 0xFA
	SM2CAPTCTRLX volatile.Register16 // 0xFC
	SM2CAPTCOMPX volatile.Register16 // 0xFE
	SM2CVAL0     volatile.Register16 // 0x100
	SM2CVAL0CYC  volatile.Register16 // 0x102
	SM2CVAL1     volatile.Register16 // 0x104
	SM2CVAL1CYC  volatile.Register16 // 0x106
	SM2CVAL2     volatile.Register16 // 0x108
	SM2CVAL2CYC  volatile.Register16 // 0x10A
	SM2CVAL3     volatile.Register16 // 0x10C
	SM2CVAL3CYC  volatile.Register16 // 0x10E
	SM2CVAL4     volatile.Register16 // 0x110
	SM2CVAL4CYC  volatile.Register16 // 0x112
	SM2CVAL5     volatile.Register16 // 0x114
	SM2CVAL5CYC  volatile.Register16 // 0x116
	_            [8]byte
	SM3CNT       volatile.Register16 // 0x120
	SM3INIT      volatile.Register16 // 0x122
	SM3CTRL2     volatile.Register16 // 0x124
	SM3CTRL      volatile.Register16 // 0x126
	_            [2]byte
	SM3VAL0      volatile.Register16 // 0x12A
	SM3FRACVAL1  volatile.Register16 // 0x12C
	SM3VAL1      volatile.Register16 // 0x12E
	SM3FRACVAL2  volatile.Register16 // 0x130
	SM3VAL2      volatile.Register16 // 0x132
	SM3FRACVAL3  volatile.Register16 // 0x134
	SM3VAL3      volatile.Register16 // 0x136
	SM3FRACVAL4  volatile.Register16 // 0x138
	SM3VAL4      volatile.Register16 // 0x13A
	SM3FRACVAL5  volatile.Register16 // 0x13C
	SM3VAL5      volatile.Register16 // 0x13E
	SM3FRCTRL    volatile.Register16 // 0x140
	SM3OCTRL     volatile.Register16 // 0x142
	SM3STS       volatile.Register16 // 0x144
	SM3INTEN     volatile.Register16 // 0x146
	SM3DMAEN     volatile.Register16 // 0x148
	SM3TCTRL     volatile.Register16 // 0x14A
	SM3DISMAP0   volatile.Register16 // 0x14C
	SM3DISMAP1   volatile.Register16 // 0x14E
	SM3DTCNT0    volatile.Register16 // 0x150
	SM3DTCNT1    volatile.Register16 // 0x152
	SM3CAPTCTRLA volatile.Register16 // 0x154
	SM3CAPTCOMPA volatile.Register16 // 0x156
	SM3CAPTCTRLB volatile.Register16 // 0x158
	SM3CAPTCOMPB volatile.Register16 // 0x15A
	SM3CAPTCTRLX volatile.Register16 // 0x15C
	SM3CAPTCOMPX volatile.Register16 // 0x15E
	SM3CVAL0     volatile.Register16 // 0x160
	SM3CVAL0CYC  volatile.Register16 // 0x162
	SM3CVAL1     volatile.Register16 // 0x164
	SM3CVAL1CYC  volatile.Register16 // 0x166
	SM3CVAL2     volatile.Register16 // 0x168
	SM3CVAL2CYC  volatile.Register16 // 0x16A
	SM3CVAL3     volatile.Register16 // 0x16C
	SM3CVAL3CYC  volatile.Register16 // 0x16E
	SM3CVAL4     volatile.Register16 // 0x170
	SM3CVAL4CYC  volatile.Register16 // 0x172
	SM3CVAL5     volatile.Register16 // 0x174
	SM3CVAL5CYC  volatile.Register16 // 0x176
	_            [8]byte
	OUTEN        volatile.Register16 // 0x180
	MASK         volatile.Register16 // 0x182
	SWCOUT       volatile.Register16 // 0x184
	DTSRCSEL     volatile.Register16 // 0x186
	MCTRL        volatile.Register16 // 0x188
	MCTRL2       volatile.Register16 // 0x18A
	FCTRL0       volatile.Register16 // 0x18C
	FSTS0        volatile.Register16 // 0x18E
	FFILT0       volatile.Register16 // 0x190
	FTST0        volatile.Register16 // 0x192
	FCTRL20      volatile.Register16 // 0x194
}

// Bus Encryption Engine
type BEE_Type struct {
	CTRL          volatile.Register32 // 0x0
	ADDR_OFFSET0  volatile.Register32 // 0x4
	ADDR_OFFSET1  volatile.Register32 // 0x8
	AES_KEY0_W0   volatile.Register32 // 0xC
	AES_KEY0_W1   volatile.Register32 // 0x10
	AES_KEY0_W2   volatile.Register32 // 0x14
	AES_KEY0_W3   volatile.Register32 // 0x18
	STATUS        volatile.Register32 // 0x1C
	CTR_NONCE0_W0 volatile.Register32 // 0x20
	CTR_NONCE0_W1 volatile.Register32 // 0x24
	CTR_NONCE0_W2 volatile.Register32 // 0x28
	CTR_NONCE0_W3 volatile.Register32 // 0x2C
	CTR_NONCE1_W0 volatile.Register32 // 0x30
	CTR_NONCE1_W1 volatile.Register32 // 0x34
	CTR_NONCE1_W2 volatile.Register32 // 0x38
	CTR_NONCE1_W3 volatile.Register32 // 0x3C
	REGION1_TOP   volatile.Register32 // 0x40
	REGION1_BOT   volatile.Register32 // 0x44
}

// LPI2C
type LPI2C_Type struct {
	VERID  volatile.Register32 // 0x0
	PARAM  volatile.Register32 // 0x4
	_      [8]byte
	MCR    volatile.Register32 // 0x10
	MSR    volatile.Register32 // 0x14
	MIER   volatile.Register32 // 0x18
	MDER   volatile.Register32 // 0x1C
	MCFGR0 volatile.Register32 // 0x20
	MCFGR1 volatile.Register32 // 0x24
	MCFGR2 volatile.Register32 // 0x28
	MCFGR3 volatile.Register32 // 0x2C
	_      [16]byte
	MDMR   volatile.Register32 // 0x40
	_      [4]byte
	MCCR0  volatile.Register32 // 0x48
	_      [4]byte
	MCCR1  volatile.Register32 // 0x50
	_      [4]byte
	MFCR   volatile.Register32 // 0x58
	MFSR   volatile.Register32 // 0x5C
	MTDR   volatile.Register32 // 0x60
	_      [12]byte
	MRDR   volatile.Register32 // 0x70
	_      [156]byte
	SCR    volatile.Register32 // 0x110
	SSR    volatile.Register32 // 0x114
	SIER   volatile.Register32 // 0x118
	SDER   volatile.Register32 // 0x11C
	_      [4]byte
	SCFGR1 volatile.Register32 // 0x124
	SCFGR2 volatile.Register32 // 0x128
	_      [20]byte
	SAMR   volatile.Register32 // 0x140
	_      [12]byte
	SASR   volatile.Register32 // 0x150
	STAR   volatile.Register32 // 0x154
	_      [8]byte
	STDR   volatile.Register32 // 0x160
	_      [12]byte
	SRDR   volatile.Register32 // 0x170
}

// System Control Block
type SCB_Type struct {
	_          [8]byte
	ACTLR      volatile.Register32 // 0x8
	_          [3316]byte
	CPUID      volatile.Register32 // 0xD00
	ICSR       volatile.Register32 // 0xD04
	VTOR       volatile.Register32 // 0xD08
	AIRCR      volatile.Register32 // 0xD0C
	SCR        volatile.Register32 // 0xD10
	CCR        volatile.Register32 // 0xD14
	SHPR1      volatile.Register32 // 0xD18
	SHPR2      volatile.Register32 // 0xD1C
	SHPR3      volatile.Register32 // 0xD20
	SHCSR      volatile.Register32 // 0xD24
	CFSR       volatile.Register32 // 0xD28
	HFSR       volatile.Register32 // 0xD2C
	DFSR       volatile.Register32 // 0xD30
	MMFAR      volatile.Register32 // 0xD34
	BFAR       volatile.Register32 // 0xD38
	_          [4]byte
	ID_PFR0    volatile.Register32 // 0xD40
	ID_PFR1    volatile.Register32 // 0xD44
	ID_DFR0    volatile.Register32 // 0xD48
	ID_AFR0    volatile.Register32 // 0xD4C
	ID_MMFR0   volatile.Register32 // 0xD50
	ID_MMFR1   volatile.Register32 // 0xD54
	ID_MMFR2   volatile.Register32 // 0xD58
	ID_MMFR3   volatile.Register32 // 0xD5C
	ID_ISAR0   volatile.Register32 // 0xD60
	ID_ISAR1   volatile.Register32 // 0xD64
	ID_ISAR2   volatile.Register32 // 0xD68
	ID_ISAR3   volatile.Register32 // 0xD6C
	ID_ISAR4   volatile.Register32 // 0xD70
	_          [4]byte
	CLIDR      volatile.Register32 // 0xD78
	CTR        volatile.Register32 // 0xD7C
	CCSIDR     volatile.Register32 // 0xD80
	CSSELR     volatile.Register32 // 0xD84
	CPACR      volatile.Register32 // 0xD88
	_          [372]byte
	STIR       volatile.Register32 // 0xF00
	_          [76]byte
	ICIALLU    volatile.Register32 // 0xF50
	_          [4]byte
	ICIMVAU    volatile.Register32 // 0xF58
	DCIMVAC    volatile.Register32 // 0xF5C
	DCISW      volatile.Register32 // 0xF60
	DCCMVAU    volatile.Register32 // 0xF64
	DCCMVAC    volatile.Register32 // 0xF68
	DCCSW      volatile.Register32 // 0xF6C
	DCCIMVAC   volatile.Register32 // 0xF70
	DCCISW     volatile.Register32 // 0xF74
	_          [24]byte
	CM7_ITCMCR volatile.Register32 // 0xF90
	CM7_DTCMCR volatile.Register32 // 0xF94
	CM7_AHBPCR volatile.Register32 // 0xF98
	CM7_CACR   volatile.Register32 // 0xF9C
	CM7_AHBSCR volatile.Register32 // 0xFA0
	_          [4]byte
	CM7_ABFSR  volatile.Register32 // 0xFA8
}

// Nested Vectored Interrupt Controller
type NVIC_Type struct {
	NVICISER0 volatile.Register32 // 0x0
	NVICISER1 volatile.Register32 // 0x4
	NVICISER2 volatile.Register32 // 0x8
	NVICISER3 volatile.Register32 // 0xC
	NVICISER4 volatile.Register32 // 0x10
	_         [108]byte
	NVICICER0 volatile.Register32 // 0x80
	NVICICER1 volatile.Register32 // 0x84
	NVICICER2 volatile.Register32 // 0x88
	NVICICER3 volatile.Register32 // 0x8C
	NVICICER4 volatile.Register32 // 0x90
	_         [108]byte
	NVICISPR0 volatile.Register32 // 0x100
	NVICISPR1 volatile.Register32 // 0x104
	NVICISPR2 volatile.Register32 // 0x108
	NVICISPR3 volatile.Register32 // 0x10C
	NVICISPR4 volatile.Register32 // 0x110
	_         [108]byte
	NVICICPR0 volatile.Register32 // 0x180
	NVICICPR1 volatile.Register32 // 0x184
	NVICICPR2 volatile.Register32 // 0x188
	NVICICPR3 volatile.Register32 // 0x18C
	NVICICPR4 volatile.Register32 // 0x190
	_         [108]byte
	NVICIABR0 volatile.Register32 // 0x200
	NVICIABR1 volatile.Register32 // 0x204
	NVICIABR2 volatile.Register32 // 0x208
	NVICIABR3 volatile.Register32 // 0x20C
	NVICIABR4 volatile.Register32 // 0x210
	_         [236]byte
	NVICIP0   volatile.Register8 // 0x300
	NVICIP1   volatile.Register8 // 0x301
	NVICIP2   volatile.Register8 // 0x302
	NVICIP3   volatile.Register8 // 0x303
	NVICIP4   volatile.Register8 // 0x304
	NVICIP5   volatile.Register8 // 0x305
	NVICIP6   volatile.Register8 // 0x306
	NVICIP7   volatile.Register8 // 0x307
	NVICIP8   volatile.Register8 // 0x308
	NVICIP9   volatile.Register8 // 0x309
	NVICIP10  volatile.Register8 // 0x30A
	NVICIP11  volatile.Register8 // 0x30B
	NVICIP12  volatile.Register8 // 0x30C
	NVICIP13  volatile.Register8 // 0x30D
	NVICIP14  volatile.Register8 // 0x30E
	NVICIP15  volatile.Register8 // 0x30F
	NVICIP16  volatile.Register8 // 0x310
	NVICIP17  volatile.Register8 // 0x311
	NVICIP18  volatile.Register8 // 0x312
	NVICIP19  volatile.Register8 // 0x313
	NVICIP20  volatile.Register8 // 0x314
	NVICIP21  volatile.Register8 // 0x315
	NVICIP22  volatile.Register8 // 0x316
	NVICIP23  volatile.Register8 // 0x317
	NVICIP24  volatile.Register8 // 0x318
	NVICIP25  volatile.Register8 // 0x319
	NVICIP26  volatile.Register8 // 0x31A
	NVICIP27  volatile.Register8 // 0x31B
	NVICIP28  volatile.Register8 // 0x31C
	NVICIP29  volatile.Register8 // 0x31D
	NVICIP30  volatile.Register8 // 0x31E
	NVICIP31  volatile.Register8 // 0x31F
	NVICIP32  volatile.Register8 // 0x320
	NVICIP33  volatile.Register8 // 0x321
	NVICIP34  volatile.Register8 // 0x322
	NVICIP35  volatile.Register8 // 0x323
	NVICIP36  volatile.Register8 // 0x324
	NVICIP37  volatile.Register8 // 0x325
	NVICIP38  volatile.Register8 // 0x326
	NVICIP39  volatile.Register8 // 0x327
	NVICIP40  volatile.Register8 // 0x328
	NVICIP41  volatile.Register8 // 0x329
	NVICIP42  volatile.Register8 // 0x32A
	NVICIP43  volatile.Register8 // 0x32B
	NVICIP44  volatile.Register8 // 0x32C
	NVICIP45  volatile.Register8 // 0x32D
	NVICIP46  volatile.Register8 // 0x32E
	NVICIP47  volatile.Register8 // 0x32F
	NVICIP48  volatile.Register8 // 0x330
	NVICIP49  volatile.Register8 // 0x331
	NVICIP50  volatile.Register8 // 0x332
	NVICIP51  volatile.Register8 // 0x333
	NVICIP52  volatile.Register8 // 0x334
	NVICIP53  volatile.Register8 // 0x335
	NVICIP54  volatile.Register8 // 0x336
	NVICIP55  volatile.Register8 // 0x337
	NVICIP56  volatile.Register8 // 0x338
	NVICIP57  volatile.Register8 // 0x339
	NVICIP58  volatile.Register8 // 0x33A
	NVICIP59  volatile.Register8 // 0x33B
	NVICIP60  volatile.Register8 // 0x33C
	NVICIP61  volatile.Register8 // 0x33D
	NVICIP62  volatile.Register8 // 0x33E
	NVICIP63  volatile.Register8 // 0x33F
	NVICIP64  volatile.Register8 // 0x340
	NVICIP65  volatile.Register8 // 0x341
	NVICIP66  volatile.Register8 // 0x342
	NVICIP67  volatile.Register8 // 0x343
	NVICIP68  volatile.Register8 // 0x344
	NVICIP69  volatile.Register8 // 0x345
	NVICIP70  volatile.Register8 // 0x346
	NVICIP71  volatile.Register8 // 0x347
	NVICIP72  volatile.Register8 // 0x348
	NVICIP73  volatile.Register8 // 0x349
	NVICIP74  volatile.Register8 // 0x34A
	NVICIP75  volatile.Register8 // 0x34B
	NVICIP76  volatile.Register8 // 0x34C
	NVICIP77  volatile.Register8 // 0x34D
	NVICIP78  volatile.Register8 // 0x34E
	NVICIP79  volatile.Register8 // 0x34F
	NVICIP80  volatile.Register8 // 0x350
	NVICIP81  volatile.Register8 // 0x351
	NVICIP82  volatile.Register8 // 0x352
	NVICIP83  volatile.Register8 // 0x353
	NVICIP84  volatile.Register8 // 0x354
	NVICIP85  volatile.Register8 // 0x355
	NVICIP86  volatile.Register8 // 0x356
	NVICIP87  volatile.Register8 // 0x357
	NVICIP88  volatile.Register8 // 0x358
	NVICIP89  volatile.Register8 // 0x359
	NVICIP90  volatile.Register8 // 0x35A
	NVICIP91  volatile.Register8 // 0x35B
	NVICIP92  volatile.Register8 // 0x35C
	NVICIP93  volatile.Register8 // 0x35D
	NVICIP94  volatile.Register8 // 0x35E
	NVICIP95  volatile.Register8 // 0x35F
	NVICIP96  volatile.Register8 // 0x360
	NVICIP97  volatile.Register8 // 0x361
	NVICIP98  volatile.Register8 // 0x362
	NVICIP99  volatile.Register8 // 0x363
	NVICIP100 volatile.Register8 // 0x364
	NVICIP101 volatile.Register8 // 0x365
	NVICIP102 volatile.Register8 // 0x366
	NVICIP103 volatile.Register8 // 0x367
	NVICIP104 volatile.Register8 // 0x368
	NVICIP105 volatile.Register8 // 0x369
	NVICIP106 volatile.Register8 // 0x36A
	NVICIP107 volatile.Register8 // 0x36B
	NVICIP108 volatile.Register8 // 0x36C
	NVICIP109 volatile.Register8 // 0x36D
	NVICIP110 volatile.Register8 // 0x36E
	NVICIP111 volatile.Register8 // 0x36F
	NVICIP112 volatile.Register8 // 0x370
	NVICIP113 volatile.Register8 // 0x371
	NVICIP114 volatile.Register8 // 0x372
	NVICIP115 volatile.Register8 // 0x373
	NVICIP116 volatile.Register8 // 0x374
	NVICIP117 volatile.Register8 // 0x375
	NVICIP118 volatile.Register8 // 0x376
	NVICIP119 volatile.Register8 // 0x377
	NVICIP120 volatile.Register8 // 0x378
	NVICIP121 volatile.Register8 // 0x379
	NVICIP122 volatile.Register8 // 0x37A
	NVICIP123 volatile.Register8 // 0x37B
	NVICIP124 volatile.Register8 // 0x37C
	NVICIP125 volatile.Register8 // 0x37D
	NVICIP126 volatile.Register8 // 0x37E
	NVICIP127 volatile.Register8 // 0x37F
	NVICIP128 volatile.Register8 // 0x380
	NVICIP129 volatile.Register8 // 0x381
	NVICIP130 volatile.Register8 // 0x382
	NVICIP131 volatile.Register8 // 0x383
	NVICIP132 volatile.Register8 // 0x384
	NVICIP133 volatile.Register8 // 0x385
	NVICIP134 volatile.Register8 // 0x386
	NVICIP135 volatile.Register8 // 0x387
	NVICIP136 volatile.Register8 // 0x388
	NVICIP137 volatile.Register8 // 0x389
	NVICIP138 volatile.Register8 // 0x38A
	NVICIP139 volatile.Register8 // 0x38B
	NVICIP140 volatile.Register8 // 0x38C
	NVICIP141 volatile.Register8 // 0x38D
	NVICIP142 volatile.Register8 // 0x38E
	NVICIP143 volatile.Register8 // 0x38F
	NVICIP144 volatile.Register8 // 0x390
	NVICIP145 volatile.Register8 // 0x391
	NVICIP146 volatile.Register8 // 0x392
	NVICIP147 volatile.Register8 // 0x393
	NVICIP148 volatile.Register8 // 0x394
	NVICIP149 volatile.Register8 // 0x395
	NVICIP150 volatile.Register8 // 0x396
	NVICIP151 volatile.Register8 // 0x397
	NVICIP152 volatile.Register8 // 0x398
	NVICIP153 volatile.Register8 // 0x399
	NVICIP154 volatile.Register8 // 0x39A
	NVICIP155 volatile.Register8 // 0x39B
	NVICIP156 volatile.Register8 // 0x39C
	NVICIP157 volatile.Register8 // 0x39D
	_         [2658]byte
	NVICSTIR  volatile.Register32 // 0xE00
}

// Bitfields for AIPSTZ1: AIPSTZ Control Registers
const (
	// MPR: Master Priviledge Registers
	// Position of MPROT5 field.
	AIPSTZ_MPR_MPROT5_Pos = 0x8
	// Bit mask of MPROT5 field.
	AIPSTZ_MPR_MPROT5_Msk = 0xf00
	// Accesses from this master are forced to user-mode (ips_supervisor_access is forced to zero) regardless of the hprot[1] access attribute.
	AIPSTZ_MPR_MPROT5_MPL0 = 0x0
	// Accesses from this master are not forced to user-mode. The hprot[1] access attribute is used directly to determine ips_supervisor_access.
	AIPSTZ_MPR_MPROT5_MPL1 = 0x1
	// Position of MPROT3 field.
	AIPSTZ_MPR_MPROT3_Pos = 0x10
	// Bit mask of MPROT3 field.
	AIPSTZ_MPR_MPROT3_Msk = 0xf0000
	// Accesses from this master are forced to user-mode (ips_supervisor_access is forced to zero) regardless of the hprot[1] access attribute.
	AIPSTZ_MPR_MPROT3_MPL0 = 0x0
	// Accesses from this master are not forced to user-mode. The hprot[1] access attribute is used directly to determine ips_supervisor_access.
	AIPSTZ_MPR_MPROT3_MPL1 = 0x1
	// Position of MPROT2 field.
	AIPSTZ_MPR_MPROT2_Pos = 0x14
	// Bit mask of MPROT2 field.
	AIPSTZ_MPR_MPROT2_Msk = 0xf00000
	// Accesses from this master are forced to user-mode (ips_supervisor_access is forced to zero) regardless of the hprot[1] access attribute.
	AIPSTZ_MPR_MPROT2_MPL0 = 0x0
	// Accesses from this master are not forced to user-mode. The hprot[1] access attribute is used directly to determine ips_supervisor_access.
	AIPSTZ_MPR_MPROT2_MPL1 = 0x1
	// Position of MPROT1 field.
	AIPSTZ_MPR_MPROT1_Pos = 0x18
	// Bit mask of MPROT1 field.
	AIPSTZ_MPR_MPROT1_Msk = 0xf000000
	// Accesses from this master are forced to user-mode (ips_supervisor_access is forced to zero) regardless of the hprot[1] access attribute.
	AIPSTZ_MPR_MPROT1_MPL0 = 0x0
	// Accesses from this master are not forced to user-mode. The hprot[1] access attribute is used directly to determine ips_supervisor_access.
	AIPSTZ_MPR_MPROT1_MPL1 = 0x1
	// Position of MPROT0 field.
	AIPSTZ_MPR_MPROT0_Pos = 0x1c
	// Bit mask of MPROT0 field.
	AIPSTZ_MPR_MPROT0_Msk = 0xf0000000
	// Accesses from this master are forced to user-mode (ips_supervisor_access is forced to zero) regardless of the hprot[1] access attribute.
	AIPSTZ_MPR_MPROT0_MPL0 = 0x0
	// Accesses from this master are not forced to user-mode. The hprot[1] access attribute is used directly to determine ips_supervisor_access.
	AIPSTZ_MPR_MPROT0_MPL1 = 0x1

	// OPACR: Off-Platform Peripheral Access Control Registers
	// Position of OPAC7 field.
	AIPSTZ_OPACR_OPAC7_Pos = 0x0
	// Bit mask of OPAC7 field.
	AIPSTZ_OPACR_OPAC7_Msk = 0xf
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR_OPAC7_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR_OPAC7_TP1 = 0x1
	// Position of OPAC6 field.
	AIPSTZ_OPACR_OPAC6_Pos = 0x4
	// Bit mask of OPAC6 field.
	AIPSTZ_OPACR_OPAC6_Msk = 0xf0
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR_OPAC6_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR_OPAC6_TP1 = 0x1
	// Position of OPAC5 field.
	AIPSTZ_OPACR_OPAC5_Pos = 0x8
	// Bit mask of OPAC5 field.
	AIPSTZ_OPACR_OPAC5_Msk = 0xf00
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR_OPAC5_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR_OPAC5_TP1 = 0x1
	// Position of OPAC4 field.
	AIPSTZ_OPACR_OPAC4_Pos = 0xc
	// Bit mask of OPAC4 field.
	AIPSTZ_OPACR_OPAC4_Msk = 0xf000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR_OPAC4_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR_OPAC4_TP1 = 0x1
	// Position of OPAC3 field.
	AIPSTZ_OPACR_OPAC3_Pos = 0x10
	// Bit mask of OPAC3 field.
	AIPSTZ_OPACR_OPAC3_Msk = 0xf0000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR_OPAC3_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR_OPAC3_TP1 = 0x1
	// Position of OPAC2 field.
	AIPSTZ_OPACR_OPAC2_Pos = 0x14
	// Bit mask of OPAC2 field.
	AIPSTZ_OPACR_OPAC2_Msk = 0xf00000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR_OPAC2_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR_OPAC2_TP1 = 0x1
	// Position of OPAC1 field.
	AIPSTZ_OPACR_OPAC1_Pos = 0x18
	// Bit mask of OPAC1 field.
	AIPSTZ_OPACR_OPAC1_Msk = 0xf000000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR_OPAC1_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR_OPAC1_TP1 = 0x1
	// Position of OPAC0 field.
	AIPSTZ_OPACR_OPAC0_Pos = 0x1c
	// Bit mask of OPAC0 field.
	AIPSTZ_OPACR_OPAC0_Msk = 0xf0000000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR_OPAC0_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR_OPAC0_TP1 = 0x1

	// OPACR1: Off-Platform Peripheral Access Control Registers
	// Position of OPAC15 field.
	AIPSTZ_OPACR1_OPAC15_Pos = 0x0
	// Bit mask of OPAC15 field.
	AIPSTZ_OPACR1_OPAC15_Msk = 0xf
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR1_OPAC15_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR1_OPAC15_TP1 = 0x1
	// Position of OPAC14 field.
	AIPSTZ_OPACR1_OPAC14_Pos = 0x4
	// Bit mask of OPAC14 field.
	AIPSTZ_OPACR1_OPAC14_Msk = 0xf0
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR1_OPAC14_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR1_OPAC14_TP1 = 0x1
	// Position of OPAC13 field.
	AIPSTZ_OPACR1_OPAC13_Pos = 0x8
	// Bit mask of OPAC13 field.
	AIPSTZ_OPACR1_OPAC13_Msk = 0xf00
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR1_OPAC13_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR1_OPAC13_TP1 = 0x1
	// Position of OPAC12 field.
	AIPSTZ_OPACR1_OPAC12_Pos = 0xc
	// Bit mask of OPAC12 field.
	AIPSTZ_OPACR1_OPAC12_Msk = 0xf000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR1_OPAC12_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR1_OPAC12_TP1 = 0x1
	// Position of OPAC11 field.
	AIPSTZ_OPACR1_OPAC11_Pos = 0x10
	// Bit mask of OPAC11 field.
	AIPSTZ_OPACR1_OPAC11_Msk = 0xf0000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR1_OPAC11_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR1_OPAC11_TP1 = 0x1
	// Position of OPAC10 field.
	AIPSTZ_OPACR1_OPAC10_Pos = 0x14
	// Bit mask of OPAC10 field.
	AIPSTZ_OPACR1_OPAC10_Msk = 0xf00000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR1_OPAC10_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR1_OPAC10_TP1 = 0x1
	// Position of OPAC9 field.
	AIPSTZ_OPACR1_OPAC9_Pos = 0x18
	// Bit mask of OPAC9 field.
	AIPSTZ_OPACR1_OPAC9_Msk = 0xf000000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR1_OPAC9_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR1_OPAC9_TP1 = 0x1
	// Position of OPAC8 field.
	AIPSTZ_OPACR1_OPAC8_Pos = 0x1c
	// Bit mask of OPAC8 field.
	AIPSTZ_OPACR1_OPAC8_Msk = 0xf0000000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR1_OPAC8_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR1_OPAC8_TP1 = 0x1

	// OPACR2: Off-Platform Peripheral Access Control Registers
	// Position of OPAC23 field.
	AIPSTZ_OPACR2_OPAC23_Pos = 0x0
	// Bit mask of OPAC23 field.
	AIPSTZ_OPACR2_OPAC23_Msk = 0xf
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR2_OPAC23_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR2_OPAC23_TP1 = 0x1
	// Position of OPAC22 field.
	AIPSTZ_OPACR2_OPAC22_Pos = 0x4
	// Bit mask of OPAC22 field.
	AIPSTZ_OPACR2_OPAC22_Msk = 0xf0
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR2_OPAC22_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR2_OPAC22_TP1 = 0x1
	// Position of OPAC21 field.
	AIPSTZ_OPACR2_OPAC21_Pos = 0x8
	// Bit mask of OPAC21 field.
	AIPSTZ_OPACR2_OPAC21_Msk = 0xf00
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR2_OPAC21_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR2_OPAC21_TP1 = 0x1
	// Position of OPAC20 field.
	AIPSTZ_OPACR2_OPAC20_Pos = 0xc
	// Bit mask of OPAC20 field.
	AIPSTZ_OPACR2_OPAC20_Msk = 0xf000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR2_OPAC20_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR2_OPAC20_TP1 = 0x1
	// Position of OPAC19 field.
	AIPSTZ_OPACR2_OPAC19_Pos = 0x10
	// Bit mask of OPAC19 field.
	AIPSTZ_OPACR2_OPAC19_Msk = 0xf0000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR2_OPAC19_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR2_OPAC19_TP1 = 0x1
	// Position of OPAC18 field.
	AIPSTZ_OPACR2_OPAC18_Pos = 0x14
	// Bit mask of OPAC18 field.
	AIPSTZ_OPACR2_OPAC18_Msk = 0xf00000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR2_OPAC18_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR2_OPAC18_TP1 = 0x1
	// Position of OPAC17 field.
	AIPSTZ_OPACR2_OPAC17_Pos = 0x18
	// Bit mask of OPAC17 field.
	AIPSTZ_OPACR2_OPAC17_Msk = 0xf000000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR2_OPAC17_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR2_OPAC17_TP1 = 0x1
	// Position of OPAC16 field.
	AIPSTZ_OPACR2_OPAC16_Pos = 0x1c
	// Bit mask of OPAC16 field.
	AIPSTZ_OPACR2_OPAC16_Msk = 0xf0000000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR2_OPAC16_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR2_OPAC16_TP1 = 0x1

	// OPACR3: Off-Platform Peripheral Access Control Registers
	// Position of OPAC31 field.
	AIPSTZ_OPACR3_OPAC31_Pos = 0x0
	// Bit mask of OPAC31 field.
	AIPSTZ_OPACR3_OPAC31_Msk = 0xf
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR3_OPAC31_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR3_OPAC31_TP1 = 0x1
	// Position of OPAC30 field.
	AIPSTZ_OPACR3_OPAC30_Pos = 0x4
	// Bit mask of OPAC30 field.
	AIPSTZ_OPACR3_OPAC30_Msk = 0xf0
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR3_OPAC30_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR3_OPAC30_TP1 = 0x1
	// Position of OPAC29 field.
	AIPSTZ_OPACR3_OPAC29_Pos = 0x8
	// Bit mask of OPAC29 field.
	AIPSTZ_OPACR3_OPAC29_Msk = 0xf00
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR3_OPAC29_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR3_OPAC29_TP1 = 0x1
	// Position of OPAC28 field.
	AIPSTZ_OPACR3_OPAC28_Pos = 0xc
	// Bit mask of OPAC28 field.
	AIPSTZ_OPACR3_OPAC28_Msk = 0xf000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR3_OPAC28_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR3_OPAC28_TP1 = 0x1
	// Position of OPAC27 field.
	AIPSTZ_OPACR3_OPAC27_Pos = 0x10
	// Bit mask of OPAC27 field.
	AIPSTZ_OPACR3_OPAC27_Msk = 0xf0000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR3_OPAC27_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR3_OPAC27_TP1 = 0x1
	// Position of OPAC26 field.
	AIPSTZ_OPACR3_OPAC26_Pos = 0x14
	// Bit mask of OPAC26 field.
	AIPSTZ_OPACR3_OPAC26_Msk = 0xf00000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR3_OPAC26_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR3_OPAC26_TP1 = 0x1
	// Position of OPAC25 field.
	AIPSTZ_OPACR3_OPAC25_Pos = 0x18
	// Bit mask of OPAC25 field.
	AIPSTZ_OPACR3_OPAC25_Msk = 0xf000000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR3_OPAC25_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR3_OPAC25_TP1 = 0x1
	// Position of OPAC24 field.
	AIPSTZ_OPACR3_OPAC24_Pos = 0x1c
	// Bit mask of OPAC24 field.
	AIPSTZ_OPACR3_OPAC24_Msk = 0xf0000000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR3_OPAC24_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR3_OPAC24_TP1 = 0x1

	// OPACR4: Off-Platform Peripheral Access Control Registers
	// Position of OPAC33 field.
	AIPSTZ_OPACR4_OPAC33_Pos = 0x18
	// Bit mask of OPAC33 field.
	AIPSTZ_OPACR4_OPAC33_Msk = 0xf000000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR4_OPAC33_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR4_OPAC33_TP1 = 0x1
	// Position of OPAC32 field.
	AIPSTZ_OPACR4_OPAC32_Pos = 0x1c
	// Bit mask of OPAC32 field.
	AIPSTZ_OPACR4_OPAC32_Msk = 0xf0000000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR4_OPAC32_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR4_OPAC32_TP1 = 0x1
)

// Bitfields for DCDC: DCDC
const (
	// REG0: DCDC Register 0
	// Position of PWD_ZCD field.
	DCDC_REG0_PWD_ZCD_Pos = 0x0
	// Bit mask of PWD_ZCD field.
	DCDC_REG0_PWD_ZCD_Msk = 0x1
	// Bit PWD_ZCD.
	DCDC_REG0_PWD_ZCD = 0x1
	// Position of DISABLE_AUTO_CLK_SWITCH field.
	DCDC_REG0_DISABLE_AUTO_CLK_SWITCH_Pos = 0x1
	// Bit mask of DISABLE_AUTO_CLK_SWITCH field.
	DCDC_REG0_DISABLE_AUTO_CLK_SWITCH_Msk = 0x2
	// Bit DISABLE_AUTO_CLK_SWITCH.
	DCDC_REG0_DISABLE_AUTO_CLK_SWITCH = 0x2
	// Position of SEL_CLK field.
	DCDC_REG0_SEL_CLK_Pos = 0x2
	// Bit mask of SEL_CLK field.
	DCDC_REG0_SEL_CLK_Msk = 0x4
	// Bit SEL_CLK.
	DCDC_REG0_SEL_CLK = 0x4
	// Position of PWD_OSC_INT field.
	DCDC_REG0_PWD_OSC_INT_Pos = 0x3
	// Bit mask of PWD_OSC_INT field.
	DCDC_REG0_PWD_OSC_INT_Msk = 0x8
	// Bit PWD_OSC_INT.
	DCDC_REG0_PWD_OSC_INT = 0x8
	// Position of PWD_CUR_SNS_CMP field.
	DCDC_REG0_PWD_CUR_SNS_CMP_Pos = 0x4
	// Bit mask of PWD_CUR_SNS_CMP field.
	DCDC_REG0_PWD_CUR_SNS_CMP_Msk = 0x10
	// Bit PWD_CUR_SNS_CMP.
	DCDC_REG0_PWD_CUR_SNS_CMP = 0x10
	// Position of CUR_SNS_THRSH field.
	DCDC_REG0_CUR_SNS_THRSH_Pos = 0x5
	// Bit mask of CUR_SNS_THRSH field.
	DCDC_REG0_CUR_SNS_THRSH_Msk = 0xe0
	// Position of PWD_OVERCUR_DET field.
	DCDC_REG0_PWD_OVERCUR_DET_Pos = 0x8
	// Bit mask of PWD_OVERCUR_DET field.
	DCDC_REG0_PWD_OVERCUR_DET_Msk = 0x100
	// Bit PWD_OVERCUR_DET.
	DCDC_REG0_PWD_OVERCUR_DET = 0x100
	// Position of OVERCUR_TRIG_ADJ field.
	DCDC_REG0_OVERCUR_TRIG_ADJ_Pos = 0x9
	// Bit mask of OVERCUR_TRIG_ADJ field.
	DCDC_REG0_OVERCUR_TRIG_ADJ_Msk = 0x600
	// Position of PWD_CMP_BATT_DET field.
	DCDC_REG0_PWD_CMP_BATT_DET_Pos = 0xb
	// Bit mask of PWD_CMP_BATT_DET field.
	DCDC_REG0_PWD_CMP_BATT_DET_Msk = 0x800
	// Bit PWD_CMP_BATT_DET.
	DCDC_REG0_PWD_CMP_BATT_DET = 0x800
	// Position of ADJ_POSLIMIT_BUCK field.
	DCDC_REG0_ADJ_POSLIMIT_BUCK_Pos = 0xc
	// Bit mask of ADJ_POSLIMIT_BUCK field.
	DCDC_REG0_ADJ_POSLIMIT_BUCK_Msk = 0xf000
	// Position of EN_LP_OVERLOAD_SNS field.
	DCDC_REG0_EN_LP_OVERLOAD_SNS_Pos = 0x10
	// Bit mask of EN_LP_OVERLOAD_SNS field.
	DCDC_REG0_EN_LP_OVERLOAD_SNS_Msk = 0x10000
	// Bit EN_LP_OVERLOAD_SNS.
	DCDC_REG0_EN_LP_OVERLOAD_SNS = 0x10000
	// Position of PWD_HIGH_VOLT_DET field.
	DCDC_REG0_PWD_HIGH_VOLT_DET_Pos = 0x11
	// Bit mask of PWD_HIGH_VOLT_DET field.
	DCDC_REG0_PWD_HIGH_VOLT_DET_Msk = 0x20000
	// Bit PWD_HIGH_VOLT_DET.
	DCDC_REG0_PWD_HIGH_VOLT_DET = 0x20000
	// Position of LP_OVERLOAD_THRSH field.
	DCDC_REG0_LP_OVERLOAD_THRSH_Pos = 0x12
	// Bit mask of LP_OVERLOAD_THRSH field.
	DCDC_REG0_LP_OVERLOAD_THRSH_Msk = 0xc0000
	// Position of LP_OVERLOAD_FREQ_SEL field.
	DCDC_REG0_LP_OVERLOAD_FREQ_SEL_Pos = 0x14
	// Bit mask of LP_OVERLOAD_FREQ_SEL field.
	DCDC_REG0_LP_OVERLOAD_FREQ_SEL_Msk = 0x100000
	// Bit LP_OVERLOAD_FREQ_SEL.
	DCDC_REG0_LP_OVERLOAD_FREQ_SEL = 0x100000
	// Position of LP_HIGH_HYS field.
	DCDC_REG0_LP_HIGH_HYS_Pos = 0x15
	// Bit mask of LP_HIGH_HYS field.
	DCDC_REG0_LP_HIGH_HYS_Msk = 0x200000
	// Bit LP_HIGH_HYS.
	DCDC_REG0_LP_HIGH_HYS = 0x200000
	// Position of PWD_CMP_OFFSET field.
	DCDC_REG0_PWD_CMP_OFFSET_Pos = 0x1a
	// Bit mask of PWD_CMP_OFFSET field.
	DCDC_REG0_PWD_CMP_OFFSET_Msk = 0x4000000
	// Bit PWD_CMP_OFFSET.
	DCDC_REG0_PWD_CMP_OFFSET = 0x4000000
	// Position of XTALOK_DISABLE field.
	DCDC_REG0_XTALOK_DISABLE_Pos = 0x1b
	// Bit mask of XTALOK_DISABLE field.
	DCDC_REG0_XTALOK_DISABLE_Msk = 0x8000000
	// Bit XTALOK_DISABLE.
	DCDC_REG0_XTALOK_DISABLE = 0x8000000
	// Position of CURRENT_ALERT_RESET field.
	DCDC_REG0_CURRENT_ALERT_RESET_Pos = 0x1c
	// Bit mask of CURRENT_ALERT_RESET field.
	DCDC_REG0_CURRENT_ALERT_RESET_Msk = 0x10000000
	// Bit CURRENT_ALERT_RESET.
	DCDC_REG0_CURRENT_ALERT_RESET = 0x10000000
	// Position of XTAL_24M_OK field.
	DCDC_REG0_XTAL_24M_OK_Pos = 0x1d
	// Bit mask of XTAL_24M_OK field.
	DCDC_REG0_XTAL_24M_OK_Msk = 0x20000000
	// Bit XTAL_24M_OK.
	DCDC_REG0_XTAL_24M_OK = 0x20000000
	// Position of STS_DC_OK field.
	DCDC_REG0_STS_DC_OK_Pos = 0x1f
	// Bit mask of STS_DC_OK field.
	DCDC_REG0_STS_DC_OK_Msk = 0x80000000
	// Bit STS_DC_OK.
	DCDC_REG0_STS_DC_OK = 0x80000000

	// REG1: DCDC Register 1
	// Position of REG_FBK_SEL field.
	DCDC_REG1_REG_FBK_SEL_Pos = 0x7
	// Bit mask of REG_FBK_SEL field.
	DCDC_REG1_REG_FBK_SEL_Msk = 0x180
	// Position of REG_RLOAD_SW field.
	DCDC_REG1_REG_RLOAD_SW_Pos = 0x9
	// Bit mask of REG_RLOAD_SW field.
	DCDC_REG1_REG_RLOAD_SW_Msk = 0x200
	// Bit REG_RLOAD_SW.
	DCDC_REG1_REG_RLOAD_SW = 0x200
	// Position of LP_CMP_ISRC_SEL field.
	DCDC_REG1_LP_CMP_ISRC_SEL_Pos = 0xc
	// Bit mask of LP_CMP_ISRC_SEL field.
	DCDC_REG1_LP_CMP_ISRC_SEL_Msk = 0x3000
	// Position of LOOPCTRL_HST_THRESH field.
	DCDC_REG1_LOOPCTRL_HST_THRESH_Pos = 0x15
	// Bit mask of LOOPCTRL_HST_THRESH field.
	DCDC_REG1_LOOPCTRL_HST_THRESH_Msk = 0x200000
	// Bit LOOPCTRL_HST_THRESH.
	DCDC_REG1_LOOPCTRL_HST_THRESH = 0x200000
	// Position of LOOPCTRL_EN_HYST field.
	DCDC_REG1_LOOPCTRL_EN_HYST_Pos = 0x17
	// Bit mask of LOOPCTRL_EN_HYST field.
	DCDC_REG1_LOOPCTRL_EN_HYST_Msk = 0x800000
	// Bit LOOPCTRL_EN_HYST.
	DCDC_REG1_LOOPCTRL_EN_HYST = 0x800000
	// Position of VBG_TRIM field.
	DCDC_REG1_VBG_TRIM_Pos = 0x18
	// Bit mask of VBG_TRIM field.
	DCDC_REG1_VBG_TRIM_Msk = 0x1f000000

	// REG2: DCDC Register 2
	// Position of LOOPCTRL_DC_C field.
	DCDC_REG2_LOOPCTRL_DC_C_Pos = 0x0
	// Bit mask of LOOPCTRL_DC_C field.
	DCDC_REG2_LOOPCTRL_DC_C_Msk = 0x3
	// Position of LOOPCTRL_DC_R field.
	DCDC_REG2_LOOPCTRL_DC_R_Pos = 0x2
	// Bit mask of LOOPCTRL_DC_R field.
	DCDC_REG2_LOOPCTRL_DC_R_Msk = 0x3c
	// Position of LOOPCTRL_DC_FF field.
	DCDC_REG2_LOOPCTRL_DC_FF_Pos = 0x6
	// Bit mask of LOOPCTRL_DC_FF field.
	DCDC_REG2_LOOPCTRL_DC_FF_Msk = 0x1c0
	// Position of LOOPCTRL_EN_RCSCALE field.
	DCDC_REG2_LOOPCTRL_EN_RCSCALE_Pos = 0x9
	// Bit mask of LOOPCTRL_EN_RCSCALE field.
	DCDC_REG2_LOOPCTRL_EN_RCSCALE_Msk = 0xe00
	// Position of LOOPCTRL_RCSCALE_THRSH field.
	DCDC_REG2_LOOPCTRL_RCSCALE_THRSH_Pos = 0xc
	// Bit mask of LOOPCTRL_RCSCALE_THRSH field.
	DCDC_REG2_LOOPCTRL_RCSCALE_THRSH_Msk = 0x1000
	// Bit LOOPCTRL_RCSCALE_THRSH.
	DCDC_REG2_LOOPCTRL_RCSCALE_THRSH = 0x1000
	// Position of LOOPCTRL_HYST_SIGN field.
	DCDC_REG2_LOOPCTRL_HYST_SIGN_Pos = 0xd
	// Bit mask of LOOPCTRL_HYST_SIGN field.
	DCDC_REG2_LOOPCTRL_HYST_SIGN_Msk = 0x2000
	// Bit LOOPCTRL_HYST_SIGN.
	DCDC_REG2_LOOPCTRL_HYST_SIGN = 0x2000
	// Position of DISABLE_PULSE_SKIP field.
	DCDC_REG2_DISABLE_PULSE_SKIP_Pos = 0x1b
	// Bit mask of DISABLE_PULSE_SKIP field.
	DCDC_REG2_DISABLE_PULSE_SKIP_Msk = 0x8000000
	// Bit DISABLE_PULSE_SKIP.
	DCDC_REG2_DISABLE_PULSE_SKIP = 0x8000000
	// Position of DCM_SET_CTRL field.
	DCDC_REG2_DCM_SET_CTRL_Pos = 0x1c
	// Bit mask of DCM_SET_CTRL field.
	DCDC_REG2_DCM_SET_CTRL_Msk = 0x10000000
	// Bit DCM_SET_CTRL.
	DCDC_REG2_DCM_SET_CTRL = 0x10000000

	// REG3: DCDC Register 3
	// Position of TRG field.
	DCDC_REG3_TRG_Pos = 0x0
	// Bit mask of TRG field.
	DCDC_REG3_TRG_Msk = 0x1f
	// Position of TARGET_LP field.
	DCDC_REG3_TARGET_LP_Pos = 0x8
	// Bit mask of TARGET_LP field.
	DCDC_REG3_TARGET_LP_Msk = 0x700
	// Position of MINPWR_DC_HALFCLK field.
	DCDC_REG3_MINPWR_DC_HALFCLK_Pos = 0x18
	// Bit mask of MINPWR_DC_HALFCLK field.
	DCDC_REG3_MINPWR_DC_HALFCLK_Msk = 0x1000000
	// Bit MINPWR_DC_HALFCLK.
	DCDC_REG3_MINPWR_DC_HALFCLK = 0x1000000
	// Position of MISC_DELAY_TIMING field.
	DCDC_REG3_MISC_DELAY_TIMING_Pos = 0x1b
	// Bit mask of MISC_DELAY_TIMING field.
	DCDC_REG3_MISC_DELAY_TIMING_Msk = 0x8000000
	// Bit MISC_DELAY_TIMING.
	DCDC_REG3_MISC_DELAY_TIMING = 0x8000000
	// Position of MISC_DISABLEFET_LOGIC field.
	DCDC_REG3_MISC_DISABLEFET_LOGIC_Pos = 0x1c
	// Bit mask of MISC_DISABLEFET_LOGIC field.
	DCDC_REG3_MISC_DISABLEFET_LOGIC_Msk = 0x10000000
	// Bit MISC_DISABLEFET_LOGIC.
	DCDC_REG3_MISC_DISABLEFET_LOGIC = 0x10000000
	// Position of DISABLE_STEP field.
	DCDC_REG3_DISABLE_STEP_Pos = 0x1e
	// Bit mask of DISABLE_STEP field.
	DCDC_REG3_DISABLE_STEP_Msk = 0x40000000
	// Bit DISABLE_STEP.
	DCDC_REG3_DISABLE_STEP = 0x40000000
)

// Bitfields for PIT: PIT
const (
	// MCR: PIT Module Control Register
	// Position of FRZ field.
	PIT_MCR_FRZ_Pos = 0x0
	// Bit mask of FRZ field.
	PIT_MCR_FRZ_Msk = 0x1
	// Bit FRZ.
	PIT_MCR_FRZ = 0x1
	// Timers continue to run in Debug mode.
	PIT_MCR_FRZ_FRZ_0 = 0x0
	// Timers are stopped in Debug mode.
	PIT_MCR_FRZ_FRZ_1 = 0x1
	// Position of MDIS field.
	PIT_MCR_MDIS_Pos = 0x1
	// Bit mask of MDIS field.
	PIT_MCR_MDIS_Msk = 0x2
	// Bit MDIS.
	PIT_MCR_MDIS = 0x2
	// Clock for standard PIT timers is enabled.
	PIT_MCR_MDIS_MDIS_0 = 0x0
	// Clock for standard PIT timers is disabled.
	PIT_MCR_MDIS_MDIS_1 = 0x1

	// LTMR64H: PIT Upper Lifetime Timer Register
	// Position of LTH field.
	PIT_LTMR64H_LTH_Pos = 0x0
	// Bit mask of LTH field.
	PIT_LTMR64H_LTH_Msk = 0xffffffff

	// LTMR64L: PIT Lower Lifetime Timer Register
	// Position of LTL field.
	PIT_LTMR64L_LTL_Pos = 0x0
	// Bit mask of LTL field.
	PIT_LTMR64L_LTL_Msk = 0xffffffff

	// TIMER.LDVAL: Timer Load Value Register
	// Position of TSV field.
	PIT_TIMER_LDVAL_TSV_Pos = 0x0
	// Bit mask of TSV field.
	PIT_TIMER_LDVAL_TSV_Msk = 0xffffffff

	// TIMER.CVAL: Current Timer Value Register
	// Position of TVL field.
	PIT_TIMER_CVAL_TVL_Pos = 0x0
	// Bit mask of TVL field.
	PIT_TIMER_CVAL_TVL_Msk = 0xffffffff

	// TIMER.TCTRL: Timer Control Register
	// Position of TEN field.
	PIT_TIMER_TCTRL_TEN_Pos = 0x0
	// Bit mask of TEN field.
	PIT_TIMER_TCTRL_TEN_Msk = 0x1
	// Bit TEN.
	PIT_TIMER_TCTRL_TEN = 0x1
	// Timer n is disabled.
	PIT_TIMER_TCTRL_TEN_TEN_0 = 0x0
	// Timer n is enabled.
	PIT_TIMER_TCTRL_TEN_TEN_1 = 0x1
	// Position of TIE field.
	PIT_TIMER_TCTRL_TIE_Pos = 0x1
	// Bit mask of TIE field.
	PIT_TIMER_TCTRL_TIE_Msk = 0x2
	// Bit TIE.
	PIT_TIMER_TCTRL_TIE = 0x2
	// Interrupt requests from Timer n are disabled.
	PIT_TIMER_TCTRL_TIE_TIE_0 = 0x0
	// Interrupt will be requested whenever TIF is set.
	PIT_TIMER_TCTRL_TIE_TIE_1 = 0x1
	// Position of CHN field.
	PIT_TIMER_TCTRL_CHN_Pos = 0x2
	// Bit mask of CHN field.
	PIT_TIMER_TCTRL_CHN_Msk = 0x4
	// Bit CHN.
	PIT_TIMER_TCTRL_CHN = 0x4
	// Timer is not chained.
	PIT_TIMER_TCTRL_CHN_CHN_0 = 0x0
	// Timer is chained to previous timer. For example, for Channel 2, if this field is set, Timer 2 is chained to Timer 1.
	PIT_TIMER_TCTRL_CHN_CHN_1 = 0x1

	// TIMER.TFLG: Timer Flag Register
	// Position of TIF field.
	PIT_TIMER_TFLG_TIF_Pos = 0x0
	// Bit mask of TIF field.
	PIT_TIMER_TFLG_TIF_Msk = 0x1
	// Bit TIF.
	PIT_TIMER_TFLG_TIF = 0x1
	// Timeout has not yet occurred.
	PIT_TIMER_TFLG_TIF_TIF_0 = 0x0
	// Timeout has occurred.
	PIT_TIMER_TFLG_TIF_TIF_1 = 0x1
)

// Bitfields for CMP1: High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
const (
	// CR0: CMP Control Register 0
	// Position of HYSTCTR field.
	ACMP_CR0_HYSTCTR_Pos = 0x0
	// Bit mask of HYSTCTR field.
	ACMP_CR0_HYSTCTR_Msk = 0x3
	// Level 0
	ACMP_CR0_HYSTCTR_HYSTCTR_0 = 0x0
	// Level 1
	ACMP_CR0_HYSTCTR_HYSTCTR_1 = 0x1
	// Level 2
	ACMP_CR0_HYSTCTR_HYSTCTR_2 = 0x2
	// Level 3
	ACMP_CR0_HYSTCTR_HYSTCTR_3 = 0x3
	// Position of FILTER_CNT field.
	ACMP_CR0_FILTER_CNT_Pos = 0x4
	// Bit mask of FILTER_CNT field.
	ACMP_CR0_FILTER_CNT_Msk = 0x70
	// Filter is disabled. If SE = 1, then COUT is a logic 0. This is not a legal state, and is not recommended. If SE = 0, COUT = COUTA.
	ACMP_CR0_FILTER_CNT_FILTER_CNT_0 = 0x0
	// One sample must agree. The comparator output is simply sampled.
	ACMP_CR0_FILTER_CNT_FILTER_CNT_1 = 0x1
	// 2 consecutive samples must agree.
	ACMP_CR0_FILTER_CNT_FILTER_CNT_2 = 0x2
	// 3 consecutive samples must agree.
	ACMP_CR0_FILTER_CNT_FILTER_CNT_3 = 0x3
	// 4 consecutive samples must agree.
	ACMP_CR0_FILTER_CNT_FILTER_CNT_4 = 0x4
	// 5 consecutive samples must agree.
	ACMP_CR0_FILTER_CNT_FILTER_CNT_5 = 0x5
	// 6 consecutive samples must agree.
	ACMP_CR0_FILTER_CNT_FILTER_CNT_6 = 0x6
	// 7 consecutive samples must agree.
	ACMP_CR0_FILTER_CNT_FILTER_CNT_7 = 0x7

	// CR1: CMP Control Register 1
	// Position of EN field.
	ACMP_CR1_EN_Pos = 0x0
	// Bit mask of EN field.
	ACMP_CR1_EN_Msk = 0x1
	// Bit EN.
	ACMP_CR1_EN = 0x1
	// Analog Comparator is disabled.
	ACMP_CR1_EN_EN_0 = 0x0
	// Analog Comparator is enabled.
	ACMP_CR1_EN_EN_1 = 0x1
	// Position of OPE field.
	ACMP_CR1_OPE_Pos = 0x1
	// Bit mask of OPE field.
	ACMP_CR1_OPE_Msk = 0x2
	// Bit OPE.
	ACMP_CR1_OPE = 0x2
	// CMPO is not available on the associated CMPO output pin. If the comparator does not own the pin, this field has no effect.
	ACMP_CR1_OPE_OPE_0 = 0x0
	// CMPO is available on the associated CMPO output pin. The comparator output (CMPO) is driven out on the associated CMPO output pin if the comparator owns the pin. If the comparator does not own the field, this bit has no effect.
	ACMP_CR1_OPE_OPE_1 = 0x1
	// Position of COS field.
	ACMP_CR1_COS_Pos = 0x2
	// Bit mask of COS field.
	ACMP_CR1_COS_Msk = 0x4
	// Bit COS.
	ACMP_CR1_COS = 0x4
	// Set the filtered comparator output (CMPO) to equal COUT.
	ACMP_CR1_COS_COS_0 = 0x0
	// Set the unfiltered comparator output (CMPO) to equal COUTA.
	ACMP_CR1_COS_COS_1 = 0x1
	// Position of INV field.
	ACMP_CR1_INV_Pos = 0x3
	// Bit mask of INV field.
	ACMP_CR1_INV_Msk = 0x8
	// Bit INV.
	ACMP_CR1_INV = 0x8
	// Does not invert the comparator output.
	ACMP_CR1_INV_INV_0 = 0x0
	// Inverts the comparator output.
	ACMP_CR1_INV_INV_1 = 0x1
	// Position of PMODE field.
	ACMP_CR1_PMODE_Pos = 0x4
	// Bit mask of PMODE field.
	ACMP_CR1_PMODE_Msk = 0x10
	// Bit PMODE.
	ACMP_CR1_PMODE = 0x10
	// Low-Speed (LS) Comparison mode selected. In this mode, CMP has slower output propagation delay and lower current consumption.
	ACMP_CR1_PMODE_PMODE_0 = 0x0
	// High-Speed (HS) Comparison mode selected. In this mode, CMP has faster output propagation delay and higher current consumption.
	ACMP_CR1_PMODE_PMODE_1 = 0x1
	// Position of WE field.
	ACMP_CR1_WE_Pos = 0x6
	// Bit mask of WE field.
	ACMP_CR1_WE_Msk = 0x40
	// Bit WE.
	ACMP_CR1_WE = 0x40
	// Windowing mode is not selected.
	ACMP_CR1_WE_WE_0 = 0x0
	// Windowing mode is selected.
	ACMP_CR1_WE_WE_1 = 0x1
	// Position of SE field.
	ACMP_CR1_SE_Pos = 0x7
	// Bit mask of SE field.
	ACMP_CR1_SE_Msk = 0x80
	// Bit SE.
	ACMP_CR1_SE = 0x80
	// Sampling mode is not selected.
	ACMP_CR1_SE_SE_0 = 0x0
	// Sampling mode is selected.
	ACMP_CR1_SE_SE_1 = 0x1

	// FPR: CMP Filter Period Register
	// Position of FILT_PER field.
	ACMP_FPR_FILT_PER_Pos = 0x0
	// Bit mask of FILT_PER field.
	ACMP_FPR_FILT_PER_Msk = 0xff

	// SCR: CMP Status and Control Register
	// Position of COUT field.
	ACMP_SCR_COUT_Pos = 0x0
	// Bit mask of COUT field.
	ACMP_SCR_COUT_Msk = 0x1
	// Bit COUT.
	ACMP_SCR_COUT = 0x1
	// Position of CFF field.
	ACMP_SCR_CFF_Pos = 0x1
	// Bit mask of CFF field.
	ACMP_SCR_CFF_Msk = 0x2
	// Bit CFF.
	ACMP_SCR_CFF = 0x2
	// Falling-edge on COUT has not been detected.
	ACMP_SCR_CFF_CFF_0 = 0x0
	// Falling-edge on COUT has occurred.
	ACMP_SCR_CFF_CFF_1 = 0x1
	// Position of CFR field.
	ACMP_SCR_CFR_Pos = 0x2
	// Bit mask of CFR field.
	ACMP_SCR_CFR_Msk = 0x4
	// Bit CFR.
	ACMP_SCR_CFR = 0x4
	// Rising-edge on COUT has not been detected.
	ACMP_SCR_CFR_CFR_0 = 0x0
	// Rising-edge on COUT has occurred.
	ACMP_SCR_CFR_CFR_1 = 0x1
	// Position of IEF field.
	ACMP_SCR_IEF_Pos = 0x3
	// Bit mask of IEF field.
	ACMP_SCR_IEF_Msk = 0x8
	// Bit IEF.
	ACMP_SCR_IEF = 0x8
	// Interrupt is disabled.
	ACMP_SCR_IEF_IEF_0 = 0x0
	// Interrupt is enabled.
	ACMP_SCR_IEF_IEF_1 = 0x1
	// Position of IER field.
	ACMP_SCR_IER_Pos = 0x4
	// Bit mask of IER field.
	ACMP_SCR_IER_Msk = 0x10
	// Bit IER.
	ACMP_SCR_IER = 0x10
	// Interrupt is disabled.
	ACMP_SCR_IER_IER_0 = 0x0
	// Interrupt is enabled.
	ACMP_SCR_IER_IER_1 = 0x1
	// Position of DMAEN field.
	ACMP_SCR_DMAEN_Pos = 0x6
	// Bit mask of DMAEN field.
	ACMP_SCR_DMAEN_Msk = 0x40
	// Bit DMAEN.
	ACMP_SCR_DMAEN = 0x40
	// DMA is disabled.
	ACMP_SCR_DMAEN_DMAEN_0 = 0x0
	// DMA is enabled.
	ACMP_SCR_DMAEN_DMAEN_1 = 0x1

	// DACCR: DAC Control Register
	// Position of VOSEL field.
	ACMP_DACCR_VOSEL_Pos = 0x0
	// Bit mask of VOSEL field.
	ACMP_DACCR_VOSEL_Msk = 0x3f
	// Position of VRSEL field.
	ACMP_DACCR_VRSEL_Pos = 0x6
	// Bit mask of VRSEL field.
	ACMP_DACCR_VRSEL_Msk = 0x40
	// Bit VRSEL.
	ACMP_DACCR_VRSEL = 0x40
	// Vin1 is selected as resistor ladder network supply reference.
	ACMP_DACCR_VRSEL_VRSEL_0 = 0x0
	// Vin2 is selected as resistor ladder network supply reference.
	ACMP_DACCR_VRSEL_VRSEL_1 = 0x1
	// Position of DACEN field.
	ACMP_DACCR_DACEN_Pos = 0x7
	// Bit mask of DACEN field.
	ACMP_DACCR_DACEN_Msk = 0x80
	// Bit DACEN.
	ACMP_DACCR_DACEN = 0x80
	// DAC is disabled.
	ACMP_DACCR_DACEN_DACEN_0 = 0x0
	// DAC is enabled.
	ACMP_DACCR_DACEN_DACEN_1 = 0x1

	// MUXCR: MUX Control Register
	// Position of MSEL field.
	ACMP_MUXCR_MSEL_Pos = 0x0
	// Bit mask of MSEL field.
	ACMP_MUXCR_MSEL_Msk = 0x7
	// IN0
	ACMP_MUXCR_MSEL_MSEL_0 = 0x0
	// IN1
	ACMP_MUXCR_MSEL_MSEL_1 = 0x1
	// IN2
	ACMP_MUXCR_MSEL_MSEL_2 = 0x2
	// IN3
	ACMP_MUXCR_MSEL_MSEL_3 = 0x3
	// IN4
	ACMP_MUXCR_MSEL_MSEL_4 = 0x4
	// IN5
	ACMP_MUXCR_MSEL_MSEL_5 = 0x5
	// IN6
	ACMP_MUXCR_MSEL_MSEL_6 = 0x6
	// IN7
	ACMP_MUXCR_MSEL_MSEL_7 = 0x7
	// Position of PSEL field.
	ACMP_MUXCR_PSEL_Pos = 0x3
	// Bit mask of PSEL field.
	ACMP_MUXCR_PSEL_Msk = 0x38
	// IN0
	ACMP_MUXCR_PSEL_PSEL_0 = 0x0
	// IN1
	ACMP_MUXCR_PSEL_PSEL_1 = 0x1
	// IN2
	ACMP_MUXCR_PSEL_PSEL_2 = 0x2
	// IN3
	ACMP_MUXCR_PSEL_PSEL_3 = 0x3
	// IN4
	ACMP_MUXCR_PSEL_PSEL_4 = 0x4
	// IN5
	ACMP_MUXCR_PSEL_PSEL_5 = 0x5
	// IN6
	ACMP_MUXCR_PSEL_PSEL_6 = 0x6
	// IN7
	ACMP_MUXCR_PSEL_PSEL_7 = 0x7
)

// Bitfields for IOMUXC_SNVS_GPR: IOMUXC
const (
	// GPR3: GPR3 General Purpose Register
	// Position of LPSR_MODE_ENABLE field.
	IOMUXC_SNVS_GPR_GPR3_LPSR_MODE_ENABLE_Pos = 0x0
	// Bit mask of LPSR_MODE_ENABLE field.
	IOMUXC_SNVS_GPR_GPR3_LPSR_MODE_ENABLE_Msk = 0x1
	// Bit LPSR_MODE_ENABLE.
	IOMUXC_SNVS_GPR_GPR3_LPSR_MODE_ENABLE = 0x1
	// Position of DCDC_STATUS_CAPT_CLR field.
	IOMUXC_SNVS_GPR_GPR3_DCDC_STATUS_CAPT_CLR_Pos = 0x1
	// Bit mask of DCDC_STATUS_CAPT_CLR field.
	IOMUXC_SNVS_GPR_GPR3_DCDC_STATUS_CAPT_CLR_Msk = 0x2
	// Bit DCDC_STATUS_CAPT_CLR.
	IOMUXC_SNVS_GPR_GPR3_DCDC_STATUS_CAPT_CLR = 0x2
	// Position of POR_PULL_TYPE field.
	IOMUXC_SNVS_GPR_GPR3_POR_PULL_TYPE_Pos = 0x2
	// Bit mask of POR_PULL_TYPE field.
	IOMUXC_SNVS_GPR_GPR3_POR_PULL_TYPE_Msk = 0xc
	// Position of DCDC_IN_LOW_VOL field.
	IOMUXC_SNVS_GPR_GPR3_DCDC_IN_LOW_VOL_Pos = 0x10
	// Bit mask of DCDC_IN_LOW_VOL field.
	IOMUXC_SNVS_GPR_GPR3_DCDC_IN_LOW_VOL_Msk = 0x10000
	// Bit DCDC_IN_LOW_VOL.
	IOMUXC_SNVS_GPR_GPR3_DCDC_IN_LOW_VOL = 0x10000
	// Position of DCDC_OVER_CUR field.
	IOMUXC_SNVS_GPR_GPR3_DCDC_OVER_CUR_Pos = 0x11
	// Bit mask of DCDC_OVER_CUR field.
	IOMUXC_SNVS_GPR_GPR3_DCDC_OVER_CUR_Msk = 0x20000
	// Bit DCDC_OVER_CUR.
	IOMUXC_SNVS_GPR_GPR3_DCDC_OVER_CUR = 0x20000
	// Position of DCDC_OVER_VOL field.
	IOMUXC_SNVS_GPR_GPR3_DCDC_OVER_VOL_Pos = 0x12
	// Bit mask of DCDC_OVER_VOL field.
	IOMUXC_SNVS_GPR_GPR3_DCDC_OVER_VOL_Msk = 0x40000
	// Bit DCDC_OVER_VOL.
	IOMUXC_SNVS_GPR_GPR3_DCDC_OVER_VOL = 0x40000
	// Position of DCDC_STS_DC_OK field.
	IOMUXC_SNVS_GPR_GPR3_DCDC_STS_DC_OK_Pos = 0x13
	// Bit mask of DCDC_STS_DC_OK field.
	IOMUXC_SNVS_GPR_GPR3_DCDC_STS_DC_OK_Msk = 0x80000
	// Bit DCDC_STS_DC_OK.
	IOMUXC_SNVS_GPR_GPR3_DCDC_STS_DC_OK = 0x80000
)

// Bitfields for IOMUXC_SNVS: IOMUXC_SNVS
const (
	// SW_MUX_CTL_PAD_WAKEUP: SW_MUX_CTL_PAD_WAKEUP SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SNVS_SW_MUX_CTL_PAD_WAKEUP_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SNVS_SW_MUX_CTL_PAD_WAKEUP_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT5 mux port: GPIO5_IO00 of instance: gpio5
	IOMUXC_SNVS_SW_MUX_CTL_PAD_WAKEUP_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT7 mux port: NMI_GLUE_NMI of instance: nmi_glue
	IOMUXC_SNVS_SW_MUX_CTL_PAD_WAKEUP_MUX_MODE_ALT7 = 0x7
	// Position of SION field.
	IOMUXC_SNVS_SW_MUX_CTL_PAD_WAKEUP_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SNVS_SW_MUX_CTL_PAD_WAKEUP_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SNVS_SW_MUX_CTL_PAD_WAKEUP_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SNVS_SW_MUX_CTL_PAD_WAKEUP_SION_DISABLED = 0x0
	// Force input path of pad WAKEUP
	IOMUXC_SNVS_SW_MUX_CTL_PAD_WAKEUP_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_PMIC_ON_REQ: SW_MUX_CTL_PAD_PMIC_ON_REQ SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SNVS_SW_MUX_CTL_PAD_PMIC_ON_REQ_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SNVS_SW_MUX_CTL_PAD_PMIC_ON_REQ_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: SNVS_LP_PMIC_ON_REQ of instance: snvs_lp
	IOMUXC_SNVS_SW_MUX_CTL_PAD_PMIC_ON_REQ_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT5 mux port: GPIO5_IO01 of instance: gpio5
	IOMUXC_SNVS_SW_MUX_CTL_PAD_PMIC_ON_REQ_MUX_MODE_ALT5 = 0x5
	// Position of SION field.
	IOMUXC_SNVS_SW_MUX_CTL_PAD_PMIC_ON_REQ_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SNVS_SW_MUX_CTL_PAD_PMIC_ON_REQ_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SNVS_SW_MUX_CTL_PAD_PMIC_ON_REQ_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SNVS_SW_MUX_CTL_PAD_PMIC_ON_REQ_SION_DISABLED = 0x0
	// Force input path of pad PMIC_ON_REQ
	IOMUXC_SNVS_SW_MUX_CTL_PAD_PMIC_ON_REQ_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_PMIC_STBY_REQ: SW_MUX_CTL_PAD_PMIC_STBY_REQ SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SNVS_SW_MUX_CTL_PAD_PMIC_STBY_REQ_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SNVS_SW_MUX_CTL_PAD_PMIC_STBY_REQ_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: CCM_PMIC_VSTBY_REQ of instance: ccm
	IOMUXC_SNVS_SW_MUX_CTL_PAD_PMIC_STBY_REQ_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT5 mux port: GPIO5_IO02 of instance: gpio5
	IOMUXC_SNVS_SW_MUX_CTL_PAD_PMIC_STBY_REQ_MUX_MODE_ALT5 = 0x5
	// Position of SION field.
	IOMUXC_SNVS_SW_MUX_CTL_PAD_PMIC_STBY_REQ_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SNVS_SW_MUX_CTL_PAD_PMIC_STBY_REQ_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SNVS_SW_MUX_CTL_PAD_PMIC_STBY_REQ_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SNVS_SW_MUX_CTL_PAD_PMIC_STBY_REQ_SION_DISABLED = 0x0
	// Force input path of pad PMIC_STBY_REQ
	IOMUXC_SNVS_SW_MUX_CTL_PAD_PMIC_STBY_REQ_SION_ENABLED = 0x1

	// SW_PAD_CTL_PAD_TEST_MODE: SW_PAD_CTL_PAD_TEST_MODE SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(260 Ohm @ 3.3V, 150 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_DSE_DSE_1_R0_260_Ohm___3_3V__150_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_SPEED_Msk = 0xc0
	// medium(100MHz)
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_SPEED_SPEED = 0x2
	// Position of ODE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_PUE = 0x2000
	// Keeper
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_POR_B: SW_PAD_CTL_PAD_POR_B SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(260 Ohm @ 3.3V, 150 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_DSE_DSE_1_R0_260_Ohm___3_3V__150_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_SPEED_Msk = 0xc0
	// medium(100MHz)
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_SPEED_SPEED = 0x2
	// Position of ODE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_PUE = 0x2000
	// Keeper
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_ONOFF: SW_PAD_CTL_PAD_ONOFF SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(260 Ohm @ 3.3V, 150 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_DSE_DSE_1_R0_260_Ohm___3_3V__150_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_SPEED_Msk = 0xc0
	// medium(100MHz)
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_SPEED_SPEED = 0x2
	// Position of ODE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_PUE = 0x2000
	// Keeper
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_WAKEUP: SW_PAD_CTL_PAD_WAKEUP SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(260 Ohm @ 3.3V, 150 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_DSE_DSE_1_R0_260_Ohm___3_3V__150_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_SPEED_Msk = 0xc0
	// medium(100MHz)
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_SPEED_SPEED = 0x2
	// Position of ODE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_PUE = 0x2000
	// Keeper
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_PMIC_ON_REQ: SW_PAD_CTL_PAD_PMIC_ON_REQ SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(260 Ohm @ 3.3V, 150 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_DSE_DSE_1_R0_260_Ohm___3_3V__150_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_SPEED_Msk = 0xc0
	// medium(100MHz)
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_SPEED_SPEED = 0x2
	// Position of ODE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_PUE = 0x2000
	// Keeper
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_PMIC_STBY_REQ: SW_PAD_CTL_PAD_PMIC_STBY_REQ SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(260 Ohm @ 3.3V, 150 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_DSE_DSE_1_R0_260_Ohm___3_3V__150_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_SPEED_Msk = 0xc0
	// medium(100MHz)
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_SPEED_SPEED = 0x2
	// Position of ODE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_PUE = 0x2000
	// Keeper
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ_HYS_HYS_1_Hysteresis_Enabled = 0x1
)

// Bitfields for IOMUXC_GPR: IOMUXC_GPR
const (
	// GPR1: GPR1 General Purpose Register
	// Position of SAI1_MCLK1_SEL field.
	IOMUXC_GPR_GPR1_SAI1_MCLK1_SEL_Pos = 0x0
	// Bit mask of SAI1_MCLK1_SEL field.
	IOMUXC_GPR_GPR1_SAI1_MCLK1_SEL_Msk = 0x7
	// ccm.ssi1_clk_root
	IOMUXC_GPR_GPR1_SAI1_MCLK1_SEL_SAI1_MCLK1_SEL_0 = 0x0
	// ccm.ssi2_clk_root
	IOMUXC_GPR_GPR1_SAI1_MCLK1_SEL_SAI1_MCLK1_SEL_1 = 0x1
	// ccm.ssi3_clk_root
	IOMUXC_GPR_GPR1_SAI1_MCLK1_SEL_SAI1_MCLK1_SEL_2 = 0x2
	// iomux.sai1_ipg_clk_sai_mclk
	IOMUXC_GPR_GPR1_SAI1_MCLK1_SEL_SAI1_MCLK1_SEL_3 = 0x3
	// iomux.sai2_ipg_clk_sai_mclk
	IOMUXC_GPR_GPR1_SAI1_MCLK1_SEL_SAI1_MCLK1_SEL_4 = 0x4
	// iomux.sai3_ipg_clk_sai_mclk
	IOMUXC_GPR_GPR1_SAI1_MCLK1_SEL_SAI1_MCLK1_SEL_5 = 0x5
	// Position of SAI1_MCLK2_SEL field.
	IOMUXC_GPR_GPR1_SAI1_MCLK2_SEL_Pos = 0x3
	// Bit mask of SAI1_MCLK2_SEL field.
	IOMUXC_GPR_GPR1_SAI1_MCLK2_SEL_Msk = 0x38
	// ccm.ssi1_clk_root
	IOMUXC_GPR_GPR1_SAI1_MCLK2_SEL_SAI1_MCLK2_SEL_0 = 0x0
	// ccm.ssi2_clk_root
	IOMUXC_GPR_GPR1_SAI1_MCLK2_SEL_SAI1_MCLK2_SEL_1 = 0x1
	// ccm.ssi3_clk_root
	IOMUXC_GPR_GPR1_SAI1_MCLK2_SEL_SAI1_MCLK2_SEL_2 = 0x2
	// iomux.sai1_ipg_clk_sai_mclk
	IOMUXC_GPR_GPR1_SAI1_MCLK2_SEL_SAI1_MCLK2_SEL_3 = 0x3
	// iomux.sai2_ipg_clk_sai_mclk
	IOMUXC_GPR_GPR1_SAI1_MCLK2_SEL_SAI1_MCLK2_SEL_4 = 0x4
	// iomux.sai3_ipg_clk_sai_mclk
	IOMUXC_GPR_GPR1_SAI1_MCLK2_SEL_SAI1_MCLK2_SEL_5 = 0x5
	// Position of SAI1_MCLK3_SEL field.
	IOMUXC_GPR_GPR1_SAI1_MCLK3_SEL_Pos = 0x6
	// Bit mask of SAI1_MCLK3_SEL field.
	IOMUXC_GPR_GPR1_SAI1_MCLK3_SEL_Msk = 0xc0
	// ccm.spdif0_clk_root
	IOMUXC_GPR_GPR1_SAI1_MCLK3_SEL_SAI1_MCLK3_SEL_0 = 0x0
	// iomux.spdif_tx_clk2
	IOMUXC_GPR_GPR1_SAI1_MCLK3_SEL_SAI1_MCLK3_SEL_1 = 0x1
	// spdif.spdif_srclk
	IOMUXC_GPR_GPR1_SAI1_MCLK3_SEL_SAI1_MCLK3_SEL_2 = 0x2
	// spdif.spdif_outclock
	IOMUXC_GPR_GPR1_SAI1_MCLK3_SEL_SAI1_MCLK3_SEL_3 = 0x3
	// Position of SAI2_MCLK3_SEL field.
	IOMUXC_GPR_GPR1_SAI2_MCLK3_SEL_Pos = 0x8
	// Bit mask of SAI2_MCLK3_SEL field.
	IOMUXC_GPR_GPR1_SAI2_MCLK3_SEL_Msk = 0x300
	// ccm.spdif0_clk_root
	IOMUXC_GPR_GPR1_SAI2_MCLK3_SEL_SAI2_MCLK3_SEL_0 = 0x0
	// iomux.spdif_tx_clk2
	IOMUXC_GPR_GPR1_SAI2_MCLK3_SEL_SAI2_MCLK3_SEL_1 = 0x1
	// spdif.spdif_srclk
	IOMUXC_GPR_GPR1_SAI2_MCLK3_SEL_SAI2_MCLK3_SEL_2 = 0x2
	// spdif.spdif_outclock
	IOMUXC_GPR_GPR1_SAI2_MCLK3_SEL_SAI2_MCLK3_SEL_3 = 0x3
	// Position of SAI3_MCLK3_SEL field.
	IOMUXC_GPR_GPR1_SAI3_MCLK3_SEL_Pos = 0xa
	// Bit mask of SAI3_MCLK3_SEL field.
	IOMUXC_GPR_GPR1_SAI3_MCLK3_SEL_Msk = 0xc00
	// ccm.spdif0_clk_root
	IOMUXC_GPR_GPR1_SAI3_MCLK3_SEL_SAI3_MCLK3_SEL_0 = 0x0
	// iomux.spdif_tx_clk2
	IOMUXC_GPR_GPR1_SAI3_MCLK3_SEL_SAI3_MCLK3_SEL_1 = 0x1
	// spdif.spdif_srclk
	IOMUXC_GPR_GPR1_SAI3_MCLK3_SEL_SAI3_MCLK3_SEL_2 = 0x2
	// spdif.spdif_outclock
	IOMUXC_GPR_GPR1_SAI3_MCLK3_SEL_SAI3_MCLK3_SEL_3 = 0x3
	// Position of GINT field.
	IOMUXC_GPR_GPR1_GINT_Pos = 0xc
	// Bit mask of GINT field.
	IOMUXC_GPR_GPR1_GINT_Msk = 0x1000
	// Bit GINT.
	IOMUXC_GPR_GPR1_GINT = 0x1000
	// Global interrupt request is not asserted.
	IOMUXC_GPR_GPR1_GINT_GINT_0 = 0x0
	// Global interrupt request is asserted.
	IOMUXC_GPR_GPR1_GINT_GINT_1 = 0x1
	// Position of ENET1_CLK_SEL field.
	IOMUXC_GPR_GPR1_ENET1_CLK_SEL_Pos = 0xd
	// Bit mask of ENET1_CLK_SEL field.
	IOMUXC_GPR_GPR1_ENET1_CLK_SEL_Msk = 0x2000
	// Bit ENET1_CLK_SEL.
	IOMUXC_GPR_GPR1_ENET1_CLK_SEL = 0x2000
	// ENET1 TX reference clock driven by ref_enetpll. This clock is also output to pins via the IOMUX. ENET_REF_CLK1 function.
	IOMUXC_GPR_GPR1_ENET1_CLK_SEL_ENET1_CLK_SEL_0 = 0x0
	// Gets ENET1 TX reference clock from the ENET1_TX_CLK pin. In this use case, an external OSC provides the clock for both the external PHY and the internal controller.
	IOMUXC_GPR_GPR1_ENET1_CLK_SEL_ENET1_CLK_SEL_1 = 0x1
	// Position of ENET2_CLK_SEL field.
	IOMUXC_GPR_GPR1_ENET2_CLK_SEL_Pos = 0xe
	// Bit mask of ENET2_CLK_SEL field.
	IOMUXC_GPR_GPR1_ENET2_CLK_SEL_Msk = 0x4000
	// Bit ENET2_CLK_SEL.
	IOMUXC_GPR_GPR1_ENET2_CLK_SEL = 0x4000
	// ENET2 TX reference clock driven by ref_enetpll. This clock is also output to pins via the IOMUX. ENET2_REF_CLK function.
	IOMUXC_GPR_GPR1_ENET2_CLK_SEL_ENET2_CLK_SEL_0 = 0x0
	// Gets ENET2 TX reference clock from the ENET2_TX_CLK pin. In this use case, an external OSC provides the clock for both the external PHY and the internal controller.
	IOMUXC_GPR_GPR1_ENET2_CLK_SEL_ENET2_CLK_SEL_1 = 0x1
	// Position of USB_EXP_MODE field.
	IOMUXC_GPR_GPR1_USB_EXP_MODE_Pos = 0xf
	// Bit mask of USB_EXP_MODE field.
	IOMUXC_GPR_GPR1_USB_EXP_MODE_Msk = 0x8000
	// Bit USB_EXP_MODE.
	IOMUXC_GPR_GPR1_USB_EXP_MODE = 0x8000
	// Exposure mode is disabled.
	IOMUXC_GPR_GPR1_USB_EXP_MODE_USB_EXP_MODE_0 = 0x0
	// Exposure mode is enabled.
	IOMUXC_GPR_GPR1_USB_EXP_MODE_USB_EXP_MODE_1 = 0x1
	// Position of ENET1_TX_CLK_DIR field.
	IOMUXC_GPR_GPR1_ENET1_TX_CLK_DIR_Pos = 0x11
	// Bit mask of ENET1_TX_CLK_DIR field.
	IOMUXC_GPR_GPR1_ENET1_TX_CLK_DIR_Msk = 0x20000
	// Bit ENET1_TX_CLK_DIR.
	IOMUXC_GPR_GPR1_ENET1_TX_CLK_DIR = 0x20000
	// ENET1_TX_CLK output driver is disabled
	IOMUXC_GPR_GPR1_ENET1_TX_CLK_DIR_ENET1_TX_CLK_DIR_0 = 0x0
	// ENET1_TX_CLK output driver is enabled
	IOMUXC_GPR_GPR1_ENET1_TX_CLK_DIR_ENET1_TX_CLK_DIR_1 = 0x1
	// Position of ENET2_TX_CLK_DIR field.
	IOMUXC_GPR_GPR1_ENET2_TX_CLK_DIR_Pos = 0x12
	// Bit mask of ENET2_TX_CLK_DIR field.
	IOMUXC_GPR_GPR1_ENET2_TX_CLK_DIR_Msk = 0x40000
	// Bit ENET2_TX_CLK_DIR.
	IOMUXC_GPR_GPR1_ENET2_TX_CLK_DIR = 0x40000
	// ENET2_TX_CLK output driver is disabled
	IOMUXC_GPR_GPR1_ENET2_TX_CLK_DIR_ENET2_TX_CLK_DIR_0 = 0x0
	// ENET2_TX_CLK output driver is enabled
	IOMUXC_GPR_GPR1_ENET2_TX_CLK_DIR_ENET2_TX_CLK_DIR_1 = 0x1
	// Position of SAI1_MCLK_DIR field.
	IOMUXC_GPR_GPR1_SAI1_MCLK_DIR_Pos = 0x13
	// Bit mask of SAI1_MCLK_DIR field.
	IOMUXC_GPR_GPR1_SAI1_MCLK_DIR_Msk = 0x80000
	// Bit SAI1_MCLK_DIR.
	IOMUXC_GPR_GPR1_SAI1_MCLK_DIR = 0x80000
	// sai1.MCLK is input signal
	IOMUXC_GPR_GPR1_SAI1_MCLK_DIR_SAI1_MCLK_DIR_0 = 0x0
	// sai1.MCLK is output signal
	IOMUXC_GPR_GPR1_SAI1_MCLK_DIR_SAI1_MCLK_DIR_1 = 0x1
	// Position of SAI2_MCLK_DIR field.
	IOMUXC_GPR_GPR1_SAI2_MCLK_DIR_Pos = 0x14
	// Bit mask of SAI2_MCLK_DIR field.
	IOMUXC_GPR_GPR1_SAI2_MCLK_DIR_Msk = 0x100000
	// Bit SAI2_MCLK_DIR.
	IOMUXC_GPR_GPR1_SAI2_MCLK_DIR = 0x100000
	// sai2.MCLK is input signal
	IOMUXC_GPR_GPR1_SAI2_MCLK_DIR_SAI2_MCLK_DIR_0 = 0x0
	// sai2.MCLK is output signal
	IOMUXC_GPR_GPR1_SAI2_MCLK_DIR_SAI2_MCLK_DIR_1 = 0x1
	// Position of SAI3_MCLK_DIR field.
	IOMUXC_GPR_GPR1_SAI3_MCLK_DIR_Pos = 0x15
	// Bit mask of SAI3_MCLK_DIR field.
	IOMUXC_GPR_GPR1_SAI3_MCLK_DIR_Msk = 0x200000
	// Bit SAI3_MCLK_DIR.
	IOMUXC_GPR_GPR1_SAI3_MCLK_DIR = 0x200000
	// sai3.MCLK is input signal
	IOMUXC_GPR_GPR1_SAI3_MCLK_DIR_SAI3_MCLK_DIR_0 = 0x0
	// sai3.MCLK is output signal
	IOMUXC_GPR_GPR1_SAI3_MCLK_DIR_SAI3_MCLK_DIR_1 = 0x1
	// Position of EXC_MON field.
	IOMUXC_GPR_GPR1_EXC_MON_Pos = 0x16
	// Bit mask of EXC_MON field.
	IOMUXC_GPR_GPR1_EXC_MON_Msk = 0x400000
	// Bit EXC_MON.
	IOMUXC_GPR_GPR1_EXC_MON = 0x400000
	// OKAY response
	IOMUXC_GPR_GPR1_EXC_MON_EXC_MON_0 = 0x0
	// SLVError response (default)
	IOMUXC_GPR_GPR1_EXC_MON_EXC_MON_1 = 0x1
	// Position of ENET_IPG_CLK_S_EN field.
	IOMUXC_GPR_GPR1_ENET_IPG_CLK_S_EN_Pos = 0x17
	// Bit mask of ENET_IPG_CLK_S_EN field.
	IOMUXC_GPR_GPR1_ENET_IPG_CLK_S_EN_Msk = 0x800000
	// Bit ENET_IPG_CLK_S_EN.
	IOMUXC_GPR_GPR1_ENET_IPG_CLK_S_EN = 0x800000
	// ipg_clk_s is gated when there is no IPS access
	IOMUXC_GPR_GPR1_ENET_IPG_CLK_S_EN_ENET_IPG_CLK_S_EN_0 = 0x0
	// ipg_clk_s is always on
	IOMUXC_GPR_GPR1_ENET_IPG_CLK_S_EN_ENET_IPG_CLK_S_EN_1 = 0x1
	// Position of CM7_FORCE_HCLK_EN field.
	IOMUXC_GPR_GPR1_CM7_FORCE_HCLK_EN_Pos = 0x1f
	// Bit mask of CM7_FORCE_HCLK_EN field.
	IOMUXC_GPR_GPR1_CM7_FORCE_HCLK_EN_Msk = 0x80000000
	// Bit CM7_FORCE_HCLK_EN.
	IOMUXC_GPR_GPR1_CM7_FORCE_HCLK_EN = 0x80000000
	// AHB clock is not running (gated)
	IOMUXC_GPR_GPR1_CM7_FORCE_HCLK_EN_CM7_FORCE_HCLK_EN_0 = 0x0
	// AHB clock is running (enabled)
	IOMUXC_GPR_GPR1_CM7_FORCE_HCLK_EN_CM7_FORCE_HCLK_EN_1 = 0x1

	// GPR2: GPR2 General Purpose Register
	// Position of AXBS_L_AHBXL_HIGH_PRIORITY field.
	IOMUXC_GPR_GPR2_AXBS_L_AHBXL_HIGH_PRIORITY_Pos = 0x0
	// Bit mask of AXBS_L_AHBXL_HIGH_PRIORITY field.
	IOMUXC_GPR_GPR2_AXBS_L_AHBXL_HIGH_PRIORITY_Msk = 0x1
	// Bit AXBS_L_AHBXL_HIGH_PRIORITY.
	IOMUXC_GPR_GPR2_AXBS_L_AHBXL_HIGH_PRIORITY = 0x1
	// AXBS_L AHBXL master does not have high priority
	IOMUXC_GPR_GPR2_AXBS_L_AHBXL_HIGH_PRIORITY_AXBS_L_AHBXL_HIGH_PRIORITY_0 = 0x0
	// AXBS_P AHBXL master has high priority
	IOMUXC_GPR_GPR2_AXBS_L_AHBXL_HIGH_PRIORITY_AXBS_L_AHBXL_HIGH_PRIORITY_1 = 0x1
	// Position of AXBS_L_DMA_HIGH_PRIORITY field.
	IOMUXC_GPR_GPR2_AXBS_L_DMA_HIGH_PRIORITY_Pos = 0x1
	// Bit mask of AXBS_L_DMA_HIGH_PRIORITY field.
	IOMUXC_GPR_GPR2_AXBS_L_DMA_HIGH_PRIORITY_Msk = 0x2
	// Bit AXBS_L_DMA_HIGH_PRIORITY.
	IOMUXC_GPR_GPR2_AXBS_L_DMA_HIGH_PRIORITY = 0x2
	// AXBS_L DMA master does not have high priority
	IOMUXC_GPR_GPR2_AXBS_L_DMA_HIGH_PRIORITY_AXBS_L_DMA_HIGH_PRIORITY_0 = 0x0
	// AXBS_L DMA master has high priority
	IOMUXC_GPR_GPR2_AXBS_L_DMA_HIGH_PRIORITY_AXBS_L_DMA_HIGH_PRIORITY_1 = 0x1
	// Position of AXBS_L_FORCE_ROUND_ROBIN field.
	IOMUXC_GPR_GPR2_AXBS_L_FORCE_ROUND_ROBIN_Pos = 0x2
	// Bit mask of AXBS_L_FORCE_ROUND_ROBIN field.
	IOMUXC_GPR_GPR2_AXBS_L_FORCE_ROUND_ROBIN_Msk = 0x4
	// Bit AXBS_L_FORCE_ROUND_ROBIN.
	IOMUXC_GPR_GPR2_AXBS_L_FORCE_ROUND_ROBIN = 0x4
	// AXBS_L masters are not arbitored in round robin, depending on DMA and AHBXL master priority settings.
	IOMUXC_GPR_GPR2_AXBS_L_FORCE_ROUND_ROBIN_AXBS_L_FORCE_ROUND_ROBIN_0 = 0x0
	// AXBS_L masters are arbitored in round robin
	IOMUXC_GPR_GPR2_AXBS_L_FORCE_ROUND_ROBIN_AXBS_L_FORCE_ROUND_ROBIN_1 = 0x1
	// Position of AXBS_P_M0_HIGH_PRIORITY field.
	IOMUXC_GPR_GPR2_AXBS_P_M0_HIGH_PRIORITY_Pos = 0x3
	// Bit mask of AXBS_P_M0_HIGH_PRIORITY field.
	IOMUXC_GPR_GPR2_AXBS_P_M0_HIGH_PRIORITY_Msk = 0x8
	// Bit AXBS_P_M0_HIGH_PRIORITY.
	IOMUXC_GPR_GPR2_AXBS_P_M0_HIGH_PRIORITY = 0x8
	// AXBS_P M0 master doesn't have high priority
	IOMUXC_GPR_GPR2_AXBS_P_M0_HIGH_PRIORITY_AXBS_P_M0_HIGH_PRIORITY_0 = 0x0
	// AXBS_P M0 master has high priority
	IOMUXC_GPR_GPR2_AXBS_P_M0_HIGH_PRIORITY_AXBS_P_M0_HIGH_PRIORITY_1 = 0x1
	// Position of AXBS_P_M1_HIGH_PRIORITY field.
	IOMUXC_GPR_GPR2_AXBS_P_M1_HIGH_PRIORITY_Pos = 0x4
	// Bit mask of AXBS_P_M1_HIGH_PRIORITY field.
	IOMUXC_GPR_GPR2_AXBS_P_M1_HIGH_PRIORITY_Msk = 0x10
	// Bit AXBS_P_M1_HIGH_PRIORITY.
	IOMUXC_GPR_GPR2_AXBS_P_M1_HIGH_PRIORITY = 0x10
	// AXBS_P M1 master does not have high priority
	IOMUXC_GPR_GPR2_AXBS_P_M1_HIGH_PRIORITY_AXBS_P_M1_HIGH_PRIORITY_0 = 0x0
	// AXBS_P M1 master has high priority
	IOMUXC_GPR_GPR2_AXBS_P_M1_HIGH_PRIORITY_AXBS_P_M1_HIGH_PRIORITY_1 = 0x1
	// Position of AXBS_P_FORCE_ROUND_ROBIN field.
	IOMUXC_GPR_GPR2_AXBS_P_FORCE_ROUND_ROBIN_Pos = 0x5
	// Bit mask of AXBS_P_FORCE_ROUND_ROBIN field.
	IOMUXC_GPR_GPR2_AXBS_P_FORCE_ROUND_ROBIN_Msk = 0x20
	// Bit AXBS_P_FORCE_ROUND_ROBIN.
	IOMUXC_GPR_GPR2_AXBS_P_FORCE_ROUND_ROBIN = 0x20
	// AXBS_P masters are not arbitored in round robin, depending on M0/M1 master priority settings.
	IOMUXC_GPR_GPR2_AXBS_P_FORCE_ROUND_ROBIN_AXBS_P_FORCE_ROUND_ROBIN_0 = 0x0
	// AXBS_P masters are arbitored in round robin
	IOMUXC_GPR_GPR2_AXBS_P_FORCE_ROUND_ROBIN_AXBS_P_FORCE_ROUND_ROBIN_1 = 0x1
	// Position of CANFD_FILTER_BYPASS field.
	IOMUXC_GPR_GPR2_CANFD_FILTER_BYPASS_Pos = 0x6
	// Bit mask of CANFD_FILTER_BYPASS field.
	IOMUXC_GPR_GPR2_CANFD_FILTER_BYPASS_Msk = 0x40
	// Bit CANFD_FILTER_BYPASS.
	IOMUXC_GPR_GPR2_CANFD_FILTER_BYPASS = 0x40
	// enable CANFD filter
	IOMUXC_GPR_GPR2_CANFD_FILTER_BYPASS_CANFD_FILTER_BYPASS_0 = 0x0
	// disable CANFD filter
	IOMUXC_GPR_GPR2_CANFD_FILTER_BYPASS_CANFD_FILTER_BYPASS_1 = 0x1
	// Position of L2_MEM_EN_POWERSAVING field.
	IOMUXC_GPR_GPR2_L2_MEM_EN_POWERSAVING_Pos = 0xc
	// Bit mask of L2_MEM_EN_POWERSAVING field.
	IOMUXC_GPR_GPR2_L2_MEM_EN_POWERSAVING_Msk = 0x1000
	// Bit L2_MEM_EN_POWERSAVING.
	IOMUXC_GPR_GPR2_L2_MEM_EN_POWERSAVING = 0x1000
	// none memory power saving features enabled, SHUTDOWN/DEEPSLEEP/LIGHTSLEEP will have no effect
	IOMUXC_GPR_GPR2_L2_MEM_EN_POWERSAVING_L2_MEM_EN_POWERSAVING_0 = 0x0
	// memory power saving features enabled, set SHUTDOWN/DEEPSLEEP/LIGHTSLEEP (priority high to low) to enable power saving levels
	IOMUXC_GPR_GPR2_L2_MEM_EN_POWERSAVING_L2_MEM_EN_POWERSAVING_1 = 0x1
	// Position of RAM_AUTO_CLK_GATING_EN field.
	IOMUXC_GPR_GPR2_RAM_AUTO_CLK_GATING_EN_Pos = 0xd
	// Bit mask of RAM_AUTO_CLK_GATING_EN field.
	IOMUXC_GPR_GPR2_RAM_AUTO_CLK_GATING_EN_Msk = 0x2000
	// Bit RAM_AUTO_CLK_GATING_EN.
	IOMUXC_GPR_GPR2_RAM_AUTO_CLK_GATING_EN = 0x2000
	// disable automatically gate off RAM clock
	IOMUXC_GPR_GPR2_RAM_AUTO_CLK_GATING_EN_RAM_AUTO_CLK_GATING_EN_0 = 0x0
	// enable automatically gate off RAM clock
	IOMUXC_GPR_GPR2_RAM_AUTO_CLK_GATING_EN_RAM_AUTO_CLK_GATING_EN_1 = 0x1
	// Position of L2_MEM_DEEPSLEEP field.
	IOMUXC_GPR_GPR2_L2_MEM_DEEPSLEEP_Pos = 0xe
	// Bit mask of L2_MEM_DEEPSLEEP field.
	IOMUXC_GPR_GPR2_L2_MEM_DEEPSLEEP_Msk = 0x4000
	// Bit L2_MEM_DEEPSLEEP.
	IOMUXC_GPR_GPR2_L2_MEM_DEEPSLEEP = 0x4000
	// no force sleep control supported, memory deep sleep mode only entered when whole system in stop mode
	IOMUXC_GPR_GPR2_L2_MEM_DEEPSLEEP_L2_MEM_DEEPSLEEP_0 = 0x0
	// force memory into deep sleep mode
	IOMUXC_GPR_GPR2_L2_MEM_DEEPSLEEP_L2_MEM_DEEPSLEEP_1 = 0x1
	// Position of MQS_CLK_DIV field.
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_Pos = 0x10
	// Bit mask of MQS_CLK_DIV field.
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_Msk = 0xff0000
	// mclk frequency = 1/1 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_1 = 0x0
	// mclk frequency = 1/2 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_2 = 0x1
	// mclk frequency = 1/3 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_3 = 0x2
	// mclk frequency = 1/4 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_4 = 0x3
	// mclk frequency = 1/5 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_5 = 0x4
	// mclk frequency = 1/6 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_6 = 0x5
	// mclk frequency = 1/7 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_7 = 0x6
	// mclk frequency = 1/8 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_8 = 0x7
	// mclk frequency = 1/9 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_9 = 0x8
	// mclk frequency = 1/10 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_10 = 0x9
	// mclk frequency = 1/11 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_11 = 0xa
	// mclk frequency = 1/12 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_12 = 0xb
	// mclk frequency = 1/13 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_13 = 0xc
	// mclk frequency = 1/14 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_14 = 0xd
	// mclk frequency = 1/15 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_15 = 0xe
	// mclk frequency = 1/16 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_16 = 0xf
	// mclk frequency = 1/17 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_17 = 0x10
	// mclk frequency = 1/18 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_18 = 0x11
	// mclk frequency = 1/19 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_19 = 0x12
	// mclk frequency = 1/20 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_20 = 0x13
	// mclk frequency = 1/21 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_21 = 0x14
	// mclk frequency = 1/22 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_22 = 0x15
	// mclk frequency = 1/23 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_23 = 0x16
	// mclk frequency = 1/24 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_24 = 0x17
	// mclk frequency = 1/25 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_25 = 0x18
	// mclk frequency = 1/26 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_26 = 0x19
	// mclk frequency = 1/27 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_27 = 0x1a
	// mclk frequency = 1/28 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_28 = 0x1b
	// mclk frequency = 1/29 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_29 = 0x1c
	// mclk frequency = 1/30 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_30 = 0x1d
	// mclk frequency = 1/31 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_31 = 0x1e
	// mclk frequency = 1/32 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_32 = 0x1f
	// mclk frequency = 1/33 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_33 = 0x20
	// mclk frequency = 1/34 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_34 = 0x21
	// mclk frequency = 1/35 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_35 = 0x22
	// mclk frequency = 1/36 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_36 = 0x23
	// mclk frequency = 1/37 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_37 = 0x24
	// mclk frequency = 1/38 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_38 = 0x25
	// mclk frequency = 1/39 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_39 = 0x26
	// mclk frequency = 1/40 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_40 = 0x27
	// mclk frequency = 1/41 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_41 = 0x28
	// mclk frequency = 1/42 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_42 = 0x29
	// mclk frequency = 1/43 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_43 = 0x2a
	// mclk frequency = 1/44 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_44 = 0x2b
	// mclk frequency = 1/45 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_45 = 0x2c
	// mclk frequency = 1/46 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_46 = 0x2d
	// mclk frequency = 1/47 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_47 = 0x2e
	// mclk frequency = 1/48 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_48 = 0x2f
	// mclk frequency = 1/49 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_49 = 0x30
	// mclk frequency = 1/50 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_50 = 0x31
	// mclk frequency = 1/51 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_51 = 0x32
	// mclk frequency = 1/52 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_52 = 0x33
	// mclk frequency = 1/53 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_53 = 0x34
	// mclk frequency = 1/54 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_54 = 0x35
	// mclk frequency = 1/55 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_55 = 0x36
	// mclk frequency = 1/56 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_56 = 0x37
	// mclk frequency = 1/57 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_57 = 0x38
	// mclk frequency = 1/58 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_58 = 0x39
	// mclk frequency = 1/59 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_59 = 0x3a
	// mclk frequency = 1/60 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_60 = 0x3b
	// mclk frequency = 1/61 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_61 = 0x3c
	// mclk frequency = 1/62 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_62 = 0x3d
	// mclk frequency = 1/63 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_63 = 0x3e
	// mclk frequency = 1/64 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_64 = 0x3f
	// mclk frequency = 1/65 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_65 = 0x40
	// mclk frequency = 1/66 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_66 = 0x41
	// mclk frequency = 1/67 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_67 = 0x42
	// mclk frequency = 1/68 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_68 = 0x43
	// mclk frequency = 1/69 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_69 = 0x44
	// mclk frequency = 1/70 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_70 = 0x45
	// mclk frequency = 1/71 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_71 = 0x46
	// mclk frequency = 1/72 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_72 = 0x47
	// mclk frequency = 1/73 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_73 = 0x48
	// mclk frequency = 1/74 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_74 = 0x49
	// mclk frequency = 1/75 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_75 = 0x4a
	// mclk frequency = 1/76 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_76 = 0x4b
	// mclk frequency = 1/77 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_77 = 0x4c
	// mclk frequency = 1/78 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_78 = 0x4d
	// mclk frequency = 1/79 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_79 = 0x4e
	// mclk frequency = 1/80 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_80 = 0x4f
	// mclk frequency = 1/81 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_81 = 0x50
	// mclk frequency = 1/82 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_82 = 0x51
	// mclk frequency = 1/83 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_83 = 0x52
	// mclk frequency = 1/84 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_84 = 0x53
	// mclk frequency = 1/85 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_85 = 0x54
	// mclk frequency = 1/86 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_86 = 0x55
	// mclk frequency = 1/87 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_87 = 0x56
	// mclk frequency = 1/88 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_88 = 0x57
	// mclk frequency = 1/89 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_89 = 0x58
	// mclk frequency = 1/90 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_90 = 0x59
	// mclk frequency = 1/91 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_91 = 0x5a
	// mclk frequency = 1/92 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_92 = 0x5b
	// mclk frequency = 1/93 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_93 = 0x5c
	// mclk frequency = 1/94 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_94 = 0x5d
	// mclk frequency = 1/95 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_95 = 0x5e
	// mclk frequency = 1/96 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_96 = 0x5f
	// mclk frequency = 1/97 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_97 = 0x60
	// mclk frequency = 1/98 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_98 = 0x61
	// mclk frequency = 1/99 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_99 = 0x62
	// mclk frequency = 1/100 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_100 = 0x63
	// mclk frequency = 1/101 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_101 = 0x64
	// mclk frequency = 1/102 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_102 = 0x65
	// mclk frequency = 1/103 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_103 = 0x66
	// mclk frequency = 1/104 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_104 = 0x67
	// mclk frequency = 1/105 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_105 = 0x68
	// mclk frequency = 1/106 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_106 = 0x69
	// mclk frequency = 1/107 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_107 = 0x6a
	// mclk frequency = 1/108 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_108 = 0x6b
	// mclk frequency = 1/109 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_109 = 0x6c
	// mclk frequency = 1/110 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_110 = 0x6d
	// mclk frequency = 1/111 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_111 = 0x6e
	// mclk frequency = 1/112 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_112 = 0x6f
	// mclk frequency = 1/113 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_113 = 0x70
	// mclk frequency = 1/114 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_114 = 0x71
	// mclk frequency = 1/115 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_115 = 0x72
	// mclk frequency = 1/116 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_116 = 0x73
	// mclk frequency = 1/117 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_117 = 0x74
	// mclk frequency = 1/118 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_118 = 0x75
	// mclk frequency = 1/119 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_119 = 0x76
	// mclk frequency = 1/120 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_120 = 0x77
	// mclk frequency = 1/121 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_121 = 0x78
	// mclk frequency = 1/122 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_122 = 0x79
	// mclk frequency = 1/123 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_123 = 0x7a
	// mclk frequency = 1/124 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_124 = 0x7b
	// mclk frequency = 1/125 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_125 = 0x7c
	// mclk frequency = 1/126 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_126 = 0x7d
	// mclk frequency = 1/127 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_127 = 0x7e
	// mclk frequency = 1/128 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_128 = 0x7f
	// mclk frequency = 1/129 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_129 = 0x80
	// mclk frequency = 1/130 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_130 = 0x81
	// mclk frequency = 1/131 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_131 = 0x82
	// mclk frequency = 1/132 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_132 = 0x83
	// mclk frequency = 1/133 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_133 = 0x84
	// mclk frequency = 1/134 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_134 = 0x85
	// mclk frequency = 1/135 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_135 = 0x86
	// mclk frequency = 1/136 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_136 = 0x87
	// mclk frequency = 1/137 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_137 = 0x88
	// mclk frequency = 1/138 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_138 = 0x89
	// mclk frequency = 1/139 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_139 = 0x8a
	// mclk frequency = 1/140 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_140 = 0x8b
	// mclk frequency = 1/141 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_141 = 0x8c
	// mclk frequency = 1/142 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_142 = 0x8d
	// mclk frequency = 1/143 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_143 = 0x8e
	// mclk frequency = 1/144 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_144 = 0x8f
	// mclk frequency = 1/145 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_145 = 0x90
	// mclk frequency = 1/146 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_146 = 0x91
	// mclk frequency = 1/147 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_147 = 0x92
	// mclk frequency = 1/148 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_148 = 0x93
	// mclk frequency = 1/149 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_149 = 0x94
	// mclk frequency = 1/150 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_150 = 0x95
	// mclk frequency = 1/151 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_151 = 0x96
	// mclk frequency = 1/152 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_152 = 0x97
	// mclk frequency = 1/153 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_153 = 0x98
	// mclk frequency = 1/154 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_154 = 0x99
	// mclk frequency = 1/155 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_155 = 0x9a
	// mclk frequency = 1/156 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_156 = 0x9b
	// mclk frequency = 1/157 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_157 = 0x9c
	// mclk frequency = 1/158 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_158 = 0x9d
	// mclk frequency = 1/159 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_159 = 0x9e
	// mclk frequency = 1/160 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_160 = 0x9f
	// mclk frequency = 1/161 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_161 = 0xa0
	// mclk frequency = 1/162 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_162 = 0xa1
	// mclk frequency = 1/163 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_163 = 0xa2
	// mclk frequency = 1/164 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_164 = 0xa3
	// mclk frequency = 1/165 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_165 = 0xa4
	// mclk frequency = 1/166 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_166 = 0xa5
	// mclk frequency = 1/167 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_167 = 0xa6
	// mclk frequency = 1/168 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_168 = 0xa7
	// mclk frequency = 1/169 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_169 = 0xa8
	// mclk frequency = 1/170 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_170 = 0xa9
	// mclk frequency = 1/171 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_171 = 0xaa
	// mclk frequency = 1/172 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_172 = 0xab
	// mclk frequency = 1/173 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_173 = 0xac
	// mclk frequency = 1/174 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_174 = 0xad
	// mclk frequency = 1/175 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_175 = 0xae
	// mclk frequency = 1/176 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_176 = 0xaf
	// mclk frequency = 1/177 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_177 = 0xb0
	// mclk frequency = 1/178 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_178 = 0xb1
	// mclk frequency = 1/179 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_179 = 0xb2
	// mclk frequency = 1/180 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_180 = 0xb3
	// mclk frequency = 1/181 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_181 = 0xb4
	// mclk frequency = 1/182 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_182 = 0xb5
	// mclk frequency = 1/183 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_183 = 0xb6
	// mclk frequency = 1/184 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_184 = 0xb7
	// mclk frequency = 1/185 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_185 = 0xb8
	// mclk frequency = 1/186 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_186 = 0xb9
	// mclk frequency = 1/187 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_187 = 0xba
	// mclk frequency = 1/188 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_188 = 0xbb
	// mclk frequency = 1/189 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_189 = 0xbc
	// mclk frequency = 1/190 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_190 = 0xbd
	// mclk frequency = 1/191 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_191 = 0xbe
	// mclk frequency = 1/192 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_192 = 0xbf
	// mclk frequency = 1/193 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_193 = 0xc0
	// mclk frequency = 1/194 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_194 = 0xc1
	// mclk frequency = 1/195 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_195 = 0xc2
	// mclk frequency = 1/196 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_196 = 0xc3
	// mclk frequency = 1/197 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_197 = 0xc4
	// mclk frequency = 1/198 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_198 = 0xc5
	// mclk frequency = 1/199 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_199 = 0xc6
	// mclk frequency = 1/200 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_200 = 0xc7
	// mclk frequency = 1/201 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_201 = 0xc8
	// mclk frequency = 1/202 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_202 = 0xc9
	// mclk frequency = 1/203 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_203 = 0xca
	// mclk frequency = 1/204 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_204 = 0xcb
	// mclk frequency = 1/205 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_205 = 0xcc
	// mclk frequency = 1/206 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_206 = 0xcd
	// mclk frequency = 1/207 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_207 = 0xce
	// mclk frequency = 1/208 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_208 = 0xcf
	// mclk frequency = 1/209 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_209 = 0xd0
	// mclk frequency = 1/210 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_210 = 0xd1
	// mclk frequency = 1/211 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_211 = 0xd2
	// mclk frequency = 1/212 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_212 = 0xd3
	// mclk frequency = 1/213 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_213 = 0xd4
	// mclk frequency = 1/214 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_214 = 0xd5
	// mclk frequency = 1/215 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_215 = 0xd6
	// mclk frequency = 1/216 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_216 = 0xd7
	// mclk frequency = 1/217 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_217 = 0xd8
	// mclk frequency = 1/218 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_218 = 0xd9
	// mclk frequency = 1/219 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_219 = 0xda
	// mclk frequency = 1/220 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_220 = 0xdb
	// mclk frequency = 1/221 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_221 = 0xdc
	// mclk frequency = 1/222 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_222 = 0xdd
	// mclk frequency = 1/223 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_223 = 0xde
	// mclk frequency = 1/224 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_224 = 0xdf
	// mclk frequency = 1/225 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_225 = 0xe0
	// mclk frequency = 1/226 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_226 = 0xe1
	// mclk frequency = 1/227 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_227 = 0xe2
	// mclk frequency = 1/228 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_228 = 0xe3
	// mclk frequency = 1/229 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_229 = 0xe4
	// mclk frequency = 1/230 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_230 = 0xe5
	// mclk frequency = 1/231 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_231 = 0xe6
	// mclk frequency = 1/232 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_232 = 0xe7
	// mclk frequency = 1/233 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_233 = 0xe8
	// mclk frequency = 1/234 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_234 = 0xe9
	// mclk frequency = 1/235 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_235 = 0xea
	// mclk frequency = 1/236 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_236 = 0xeb
	// mclk frequency = 1/237 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_237 = 0xec
	// mclk frequency = 1/238 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_238 = 0xed
	// mclk frequency = 1/239 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_239 = 0xee
	// mclk frequency = 1/240 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_240 = 0xef
	// mclk frequency = 1/241 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_241 = 0xf0
	// mclk frequency = 1/242 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_242 = 0xf1
	// mclk frequency = 1/243 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_243 = 0xf2
	// mclk frequency = 1/244 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_244 = 0xf3
	// mclk frequency = 1/245 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_245 = 0xf4
	// mclk frequency = 1/246 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_246 = 0xf5
	// mclk frequency = 1/247 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_247 = 0xf6
	// mclk frequency = 1/248 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_248 = 0xf7
	// mclk frequency = 1/249 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_249 = 0xf8
	// mclk frequency = 1/250 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_250 = 0xf9
	// mclk frequency = 1/251 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_251 = 0xfa
	// mclk frequency = 1/252 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_252 = 0xfb
	// mclk frequency = 1/253 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_253 = 0xfc
	// mclk frequency = 1/254 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_254 = 0xfd
	// mclk frequency = 1/255 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_255 = 0xfe
	// mclk frequency = 1/256 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_DIVIDE_256 = 0xff
	// Position of MQS_SW_RST field.
	IOMUXC_GPR_GPR2_MQS_SW_RST_Pos = 0x18
	// Bit mask of MQS_SW_RST field.
	IOMUXC_GPR_GPR2_MQS_SW_RST_Msk = 0x1000000
	// Bit MQS_SW_RST.
	IOMUXC_GPR_GPR2_MQS_SW_RST = 0x1000000
	// Exit software reset for MQS
	IOMUXC_GPR_GPR2_MQS_SW_RST_MQS_SW_RST_0 = 0x0
	// Enable software reset for MQS
	IOMUXC_GPR_GPR2_MQS_SW_RST_MQS_SW_RST_1 = 0x1
	// Position of MQS_EN field.
	IOMUXC_GPR_GPR2_MQS_EN_Pos = 0x19
	// Bit mask of MQS_EN field.
	IOMUXC_GPR_GPR2_MQS_EN_Msk = 0x2000000
	// Bit MQS_EN.
	IOMUXC_GPR_GPR2_MQS_EN = 0x2000000
	// Disable MQS
	IOMUXC_GPR_GPR2_MQS_EN_MQS_EN_0 = 0x0
	// Enable MQS
	IOMUXC_GPR_GPR2_MQS_EN_MQS_EN_1 = 0x1
	// Position of MQS_OVERSAMPLE field.
	IOMUXC_GPR_GPR2_MQS_OVERSAMPLE_Pos = 0x1a
	// Bit mask of MQS_OVERSAMPLE field.
	IOMUXC_GPR_GPR2_MQS_OVERSAMPLE_Msk = 0x4000000
	// Bit MQS_OVERSAMPLE.
	IOMUXC_GPR_GPR2_MQS_OVERSAMPLE = 0x4000000
	// 32
	IOMUXC_GPR_GPR2_MQS_OVERSAMPLE_MQS_OVERSAMPLE_0 = 0x0
	// 64
	IOMUXC_GPR_GPR2_MQS_OVERSAMPLE_MQS_OVERSAMPLE_1 = 0x1
	// Position of QTIMER1_TMR_CNTS_FREEZE field.
	IOMUXC_GPR_GPR2_QTIMER1_TMR_CNTS_FREEZE_Pos = 0x1c
	// Bit mask of QTIMER1_TMR_CNTS_FREEZE field.
	IOMUXC_GPR_GPR2_QTIMER1_TMR_CNTS_FREEZE_Msk = 0x10000000
	// Bit QTIMER1_TMR_CNTS_FREEZE.
	IOMUXC_GPR_GPR2_QTIMER1_TMR_CNTS_FREEZE = 0x10000000
	// timer counter work normally
	IOMUXC_GPR_GPR2_QTIMER1_TMR_CNTS_FREEZE_QTIMER1_TMR_CNTS_FREEZE_0 = 0x0
	// reset counter and ouput flags
	IOMUXC_GPR_GPR2_QTIMER1_TMR_CNTS_FREEZE_QTIMER1_TMR_CNTS_FREEZE_1 = 0x1
	// Position of QTIMER2_TMR_CNTS_FREEZE field.
	IOMUXC_GPR_GPR2_QTIMER2_TMR_CNTS_FREEZE_Pos = 0x1d
	// Bit mask of QTIMER2_TMR_CNTS_FREEZE field.
	IOMUXC_GPR_GPR2_QTIMER2_TMR_CNTS_FREEZE_Msk = 0x20000000
	// Bit QTIMER2_TMR_CNTS_FREEZE.
	IOMUXC_GPR_GPR2_QTIMER2_TMR_CNTS_FREEZE = 0x20000000
	// timer counter work normally
	IOMUXC_GPR_GPR2_QTIMER2_TMR_CNTS_FREEZE_QTIMER2_TMR_CNTS_FREEZE_0 = 0x0
	// reset counter and ouput flags
	IOMUXC_GPR_GPR2_QTIMER2_TMR_CNTS_FREEZE_QTIMER2_TMR_CNTS_FREEZE_1 = 0x1
	// Position of QTIMER3_TMR_CNTS_FREEZE field.
	IOMUXC_GPR_GPR2_QTIMER3_TMR_CNTS_FREEZE_Pos = 0x1e
	// Bit mask of QTIMER3_TMR_CNTS_FREEZE field.
	IOMUXC_GPR_GPR2_QTIMER3_TMR_CNTS_FREEZE_Msk = 0x40000000
	// Bit QTIMER3_TMR_CNTS_FREEZE.
	IOMUXC_GPR_GPR2_QTIMER3_TMR_CNTS_FREEZE = 0x40000000
	// timer counter work normally
	IOMUXC_GPR_GPR2_QTIMER3_TMR_CNTS_FREEZE_QTIMER3_TMR_CNTS_FREEZE_0 = 0x0
	// reset counter and ouput flags
	IOMUXC_GPR_GPR2_QTIMER3_TMR_CNTS_FREEZE_QTIMER3_TMR_CNTS_FREEZE_1 = 0x1
	// Position of QTIMER4_TMR_CNTS_FREEZE field.
	IOMUXC_GPR_GPR2_QTIMER4_TMR_CNTS_FREEZE_Pos = 0x1f
	// Bit mask of QTIMER4_TMR_CNTS_FREEZE field.
	IOMUXC_GPR_GPR2_QTIMER4_TMR_CNTS_FREEZE_Msk = 0x80000000
	// Bit QTIMER4_TMR_CNTS_FREEZE.
	IOMUXC_GPR_GPR2_QTIMER4_TMR_CNTS_FREEZE = 0x80000000
	// timer counter work normally
	IOMUXC_GPR_GPR2_QTIMER4_TMR_CNTS_FREEZE_QTIMER4_TMR_CNTS_FREEZE_0 = 0x0
	// reset counter and ouput flags
	IOMUXC_GPR_GPR2_QTIMER4_TMR_CNTS_FREEZE_QTIMER4_TMR_CNTS_FREEZE_1 = 0x1

	// GPR3: GPR3 General Purpose Register
	// Position of OCRAM_CTL field.
	IOMUXC_GPR_GPR3_OCRAM_CTL_Pos = 0x0
	// Bit mask of OCRAM_CTL field.
	IOMUXC_GPR_GPR3_OCRAM_CTL_Msk = 0xf
	// Position of DCP_KEY_SEL field.
	IOMUXC_GPR_GPR3_DCP_KEY_SEL_Pos = 0x4
	// Bit mask of DCP_KEY_SEL field.
	IOMUXC_GPR_GPR3_DCP_KEY_SEL_Msk = 0x10
	// Bit DCP_KEY_SEL.
	IOMUXC_GPR_GPR3_DCP_KEY_SEL = 0x10
	// Select [127:0] from snvs/ocotp key as dcp key
	IOMUXC_GPR_GPR3_DCP_KEY_SEL_DCP_KEY_SEL_0 = 0x0
	// Select [255:128] from snvs/ocotp key as dcp key
	IOMUXC_GPR_GPR3_DCP_KEY_SEL_DCP_KEY_SEL_1 = 0x1
	// Position of OCRAM2_CTL field.
	IOMUXC_GPR_GPR3_OCRAM2_CTL_Pos = 0x8
	// Bit mask of OCRAM2_CTL field.
	IOMUXC_GPR_GPR3_OCRAM2_CTL_Msk = 0xf00
	// Position of AXBS_L_HALT_REQ field.
	IOMUXC_GPR_GPR3_AXBS_L_HALT_REQ_Pos = 0xf
	// Bit mask of AXBS_L_HALT_REQ field.
	IOMUXC_GPR_GPR3_AXBS_L_HALT_REQ_Msk = 0x8000
	// Bit AXBS_L_HALT_REQ.
	IOMUXC_GPR_GPR3_AXBS_L_HALT_REQ = 0x8000
	// axbs_l normal run
	IOMUXC_GPR_GPR3_AXBS_L_HALT_REQ_AXBS_L_HALT_REQ_0 = 0x0
	// request to halt axbs_l
	IOMUXC_GPR_GPR3_AXBS_L_HALT_REQ_AXBS_L_HALT_REQ_1 = 0x1
	// Position of OCRAM_STATUS field.
	IOMUXC_GPR_GPR3_OCRAM_STATUS_Pos = 0x10
	// Bit mask of OCRAM_STATUS field.
	IOMUXC_GPR_GPR3_OCRAM_STATUS_Msk = 0xf0000
	// Position of OCRAM2_STATUS field.
	IOMUXC_GPR_GPR3_OCRAM2_STATUS_Pos = 0x18
	// Bit mask of OCRAM2_STATUS field.
	IOMUXC_GPR_GPR3_OCRAM2_STATUS_Msk = 0xf000000
	// Position of AXBS_L_HALTED field.
	IOMUXC_GPR_GPR3_AXBS_L_HALTED_Pos = 0x1f
	// Bit mask of AXBS_L_HALTED field.
	IOMUXC_GPR_GPR3_AXBS_L_HALTED_Msk = 0x80000000
	// Bit AXBS_L_HALTED.
	IOMUXC_GPR_GPR3_AXBS_L_HALTED = 0x80000000
	// axbs_l is not halted
	IOMUXC_GPR_GPR3_AXBS_L_HALTED_AXBS_L_HALTED_0 = 0x0
	// axbs_l is in halted status
	IOMUXC_GPR_GPR3_AXBS_L_HALTED_AXBS_L_HALTED_1 = 0x1

	// GPR4: GPR4 General Purpose Register
	// Position of EDMA_STOP_REQ field.
	IOMUXC_GPR_GPR4_EDMA_STOP_REQ_Pos = 0x0
	// Bit mask of EDMA_STOP_REQ field.
	IOMUXC_GPR_GPR4_EDMA_STOP_REQ_Msk = 0x1
	// Bit EDMA_STOP_REQ.
	IOMUXC_GPR_GPR4_EDMA_STOP_REQ = 0x1
	// stop request off
	IOMUXC_GPR_GPR4_EDMA_STOP_REQ_EDMA_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR4_EDMA_STOP_REQ_EDMA_STOP_REQ_1 = 0x1
	// Position of CAN1_STOP_REQ field.
	IOMUXC_GPR_GPR4_CAN1_STOP_REQ_Pos = 0x1
	// Bit mask of CAN1_STOP_REQ field.
	IOMUXC_GPR_GPR4_CAN1_STOP_REQ_Msk = 0x2
	// Bit CAN1_STOP_REQ.
	IOMUXC_GPR_GPR4_CAN1_STOP_REQ = 0x2
	// stop request off
	IOMUXC_GPR_GPR4_CAN1_STOP_REQ_CAN1_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR4_CAN1_STOP_REQ_CAN1_STOP_REQ_1 = 0x1
	// Position of CAN2_STOP_REQ field.
	IOMUXC_GPR_GPR4_CAN2_STOP_REQ_Pos = 0x2
	// Bit mask of CAN2_STOP_REQ field.
	IOMUXC_GPR_GPR4_CAN2_STOP_REQ_Msk = 0x4
	// Bit CAN2_STOP_REQ.
	IOMUXC_GPR_GPR4_CAN2_STOP_REQ = 0x4
	// stop request off
	IOMUXC_GPR_GPR4_CAN2_STOP_REQ_CAN2_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR4_CAN2_STOP_REQ_CAN2_STOP_REQ_1 = 0x1
	// Position of TRNG_STOP_REQ field.
	IOMUXC_GPR_GPR4_TRNG_STOP_REQ_Pos = 0x3
	// Bit mask of TRNG_STOP_REQ field.
	IOMUXC_GPR_GPR4_TRNG_STOP_REQ_Msk = 0x8
	// Bit TRNG_STOP_REQ.
	IOMUXC_GPR_GPR4_TRNG_STOP_REQ = 0x8
	// stop request off
	IOMUXC_GPR_GPR4_TRNG_STOP_REQ_TRNG_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR4_TRNG_STOP_REQ_TRNG_STOP_REQ_1 = 0x1
	// Position of ENET_STOP_REQ field.
	IOMUXC_GPR_GPR4_ENET_STOP_REQ_Pos = 0x4
	// Bit mask of ENET_STOP_REQ field.
	IOMUXC_GPR_GPR4_ENET_STOP_REQ_Msk = 0x10
	// Bit ENET_STOP_REQ.
	IOMUXC_GPR_GPR4_ENET_STOP_REQ = 0x10
	// stop request off
	IOMUXC_GPR_GPR4_ENET_STOP_REQ_ENET_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR4_ENET_STOP_REQ_ENET_STOP_REQ_1 = 0x1
	// Position of SAI1_STOP_REQ field.
	IOMUXC_GPR_GPR4_SAI1_STOP_REQ_Pos = 0x5
	// Bit mask of SAI1_STOP_REQ field.
	IOMUXC_GPR_GPR4_SAI1_STOP_REQ_Msk = 0x20
	// Bit SAI1_STOP_REQ.
	IOMUXC_GPR_GPR4_SAI1_STOP_REQ = 0x20
	// stop request off
	IOMUXC_GPR_GPR4_SAI1_STOP_REQ_SAI1_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR4_SAI1_STOP_REQ_SAI1_STOP_REQ_1 = 0x1
	// Position of SAI2_STOP_REQ field.
	IOMUXC_GPR_GPR4_SAI2_STOP_REQ_Pos = 0x6
	// Bit mask of SAI2_STOP_REQ field.
	IOMUXC_GPR_GPR4_SAI2_STOP_REQ_Msk = 0x40
	// Bit SAI2_STOP_REQ.
	IOMUXC_GPR_GPR4_SAI2_STOP_REQ = 0x40
	// stop request off
	IOMUXC_GPR_GPR4_SAI2_STOP_REQ_SAI2_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR4_SAI2_STOP_REQ_SAI2_STOP_REQ_1 = 0x1
	// Position of SAI3_STOP_REQ field.
	IOMUXC_GPR_GPR4_SAI3_STOP_REQ_Pos = 0x7
	// Bit mask of SAI3_STOP_REQ field.
	IOMUXC_GPR_GPR4_SAI3_STOP_REQ_Msk = 0x80
	// Bit SAI3_STOP_REQ.
	IOMUXC_GPR_GPR4_SAI3_STOP_REQ = 0x80
	// stop request off
	IOMUXC_GPR_GPR4_SAI3_STOP_REQ_SAI3_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR4_SAI3_STOP_REQ_SAI3_STOP_REQ_1 = 0x1
	// Position of ENET2_STOP_REQ field.
	IOMUXC_GPR_GPR4_ENET2_STOP_REQ_Pos = 0x8
	// Bit mask of ENET2_STOP_REQ field.
	IOMUXC_GPR_GPR4_ENET2_STOP_REQ_Msk = 0x100
	// Bit ENET2_STOP_REQ.
	IOMUXC_GPR_GPR4_ENET2_STOP_REQ = 0x100
	// stop request off
	IOMUXC_GPR_GPR4_ENET2_STOP_REQ_ENET2_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR4_ENET2_STOP_REQ_ENET2_STOP_REQ_1 = 0x1
	// Position of SEMC_STOP_REQ field.
	IOMUXC_GPR_GPR4_SEMC_STOP_REQ_Pos = 0x9
	// Bit mask of SEMC_STOP_REQ field.
	IOMUXC_GPR_GPR4_SEMC_STOP_REQ_Msk = 0x200
	// Bit SEMC_STOP_REQ.
	IOMUXC_GPR_GPR4_SEMC_STOP_REQ = 0x200
	// stop request off
	IOMUXC_GPR_GPR4_SEMC_STOP_REQ_SEMC_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR4_SEMC_STOP_REQ_SEMC_STOP_REQ_1 = 0x1
	// Position of PIT_STOP_REQ field.
	IOMUXC_GPR_GPR4_PIT_STOP_REQ_Pos = 0xa
	// Bit mask of PIT_STOP_REQ field.
	IOMUXC_GPR_GPR4_PIT_STOP_REQ_Msk = 0x400
	// Bit PIT_STOP_REQ.
	IOMUXC_GPR_GPR4_PIT_STOP_REQ = 0x400
	// stop request off
	IOMUXC_GPR_GPR4_PIT_STOP_REQ_PIT_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR4_PIT_STOP_REQ_PIT_STOP_REQ_1 = 0x1
	// Position of FLEXSPI_STOP_REQ field.
	IOMUXC_GPR_GPR4_FLEXSPI_STOP_REQ_Pos = 0xb
	// Bit mask of FLEXSPI_STOP_REQ field.
	IOMUXC_GPR_GPR4_FLEXSPI_STOP_REQ_Msk = 0x800
	// Bit FLEXSPI_STOP_REQ.
	IOMUXC_GPR_GPR4_FLEXSPI_STOP_REQ = 0x800
	// stop request off
	IOMUXC_GPR_GPR4_FLEXSPI_STOP_REQ_FLEXSPI_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR4_FLEXSPI_STOP_REQ_FLEXSPI_STOP_REQ_1 = 0x1
	// Position of FLEXIO1_STOP_REQ field.
	IOMUXC_GPR_GPR4_FLEXIO1_STOP_REQ_Pos = 0xc
	// Bit mask of FLEXIO1_STOP_REQ field.
	IOMUXC_GPR_GPR4_FLEXIO1_STOP_REQ_Msk = 0x1000
	// Bit FLEXIO1_STOP_REQ.
	IOMUXC_GPR_GPR4_FLEXIO1_STOP_REQ = 0x1000
	// stop request off
	IOMUXC_GPR_GPR4_FLEXIO1_STOP_REQ_FLEXIO1_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR4_FLEXIO1_STOP_REQ_FLEXIO1_STOP_REQ_1 = 0x1
	// Position of FLEXIO2_STOP_REQ field.
	IOMUXC_GPR_GPR4_FLEXIO2_STOP_REQ_Pos = 0xd
	// Bit mask of FLEXIO2_STOP_REQ field.
	IOMUXC_GPR_GPR4_FLEXIO2_STOP_REQ_Msk = 0x2000
	// Bit FLEXIO2_STOP_REQ.
	IOMUXC_GPR_GPR4_FLEXIO2_STOP_REQ = 0x2000
	// stop request off
	IOMUXC_GPR_GPR4_FLEXIO2_STOP_REQ_FLEXIO2_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR4_FLEXIO2_STOP_REQ_FLEXIO2_STOP_REQ_1 = 0x1
	// Position of FLEXIO3_STOP_REQ field.
	IOMUXC_GPR_GPR4_FLEXIO3_STOP_REQ_Pos = 0xe
	// Bit mask of FLEXIO3_STOP_REQ field.
	IOMUXC_GPR_GPR4_FLEXIO3_STOP_REQ_Msk = 0x4000
	// Bit FLEXIO3_STOP_REQ.
	IOMUXC_GPR_GPR4_FLEXIO3_STOP_REQ = 0x4000
	// stop request off
	IOMUXC_GPR_GPR4_FLEXIO3_STOP_REQ_FLEXIO3_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR4_FLEXIO3_STOP_REQ_FLEXIO3_STOP_REQ_1 = 0x1
	// Position of FLEXSPI2_STOP_REQ field.
	IOMUXC_GPR_GPR4_FLEXSPI2_STOP_REQ_Pos = 0xf
	// Bit mask of FLEXSPI2_STOP_REQ field.
	IOMUXC_GPR_GPR4_FLEXSPI2_STOP_REQ_Msk = 0x8000
	// Bit FLEXSPI2_STOP_REQ.
	IOMUXC_GPR_GPR4_FLEXSPI2_STOP_REQ = 0x8000
	// stop request off
	IOMUXC_GPR_GPR4_FLEXSPI2_STOP_REQ_FLEXSPI2_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR4_FLEXSPI2_STOP_REQ_FLEXSPI2_STOP_REQ_1 = 0x1
	// Position of EDMA_STOP_ACK field.
	IOMUXC_GPR_GPR4_EDMA_STOP_ACK_Pos = 0x10
	// Bit mask of EDMA_STOP_ACK field.
	IOMUXC_GPR_GPR4_EDMA_STOP_ACK_Msk = 0x10000
	// Bit EDMA_STOP_ACK.
	IOMUXC_GPR_GPR4_EDMA_STOP_ACK = 0x10000
	// EDMA stop acknowledge is not asserted
	IOMUXC_GPR_GPR4_EDMA_STOP_ACK_EDMA_STOP_ACK_0 = 0x0
	// EDMA stop acknowledge is asserted (EDMA is in STOP mode).
	IOMUXC_GPR_GPR4_EDMA_STOP_ACK_EDMA_STOP_ACK_1 = 0x1
	// Position of CAN1_STOP_ACK field.
	IOMUXC_GPR_GPR4_CAN1_STOP_ACK_Pos = 0x11
	// Bit mask of CAN1_STOP_ACK field.
	IOMUXC_GPR_GPR4_CAN1_STOP_ACK_Msk = 0x20000
	// Bit CAN1_STOP_ACK.
	IOMUXC_GPR_GPR4_CAN1_STOP_ACK = 0x20000
	// CAN1 stop acknowledge is not asserted
	IOMUXC_GPR_GPR4_CAN1_STOP_ACK_CAN1_STOP_ACK_0 = 0x0
	// CAN1 stop acknowledge is asserted
	IOMUXC_GPR_GPR4_CAN1_STOP_ACK_CAN1_STOP_ACK_1 = 0x1
	// Position of CAN2_STOP_ACK field.
	IOMUXC_GPR_GPR4_CAN2_STOP_ACK_Pos = 0x12
	// Bit mask of CAN2_STOP_ACK field.
	IOMUXC_GPR_GPR4_CAN2_STOP_ACK_Msk = 0x40000
	// Bit CAN2_STOP_ACK.
	IOMUXC_GPR_GPR4_CAN2_STOP_ACK = 0x40000
	// CAN2 stop acknowledge is not asserted
	IOMUXC_GPR_GPR4_CAN2_STOP_ACK_CAN2_STOP_ACK_0 = 0x0
	// CAN2 stop acknowledge is asserted
	IOMUXC_GPR_GPR4_CAN2_STOP_ACK_CAN2_STOP_ACK_1 = 0x1
	// Position of TRNG_STOP_ACK field.
	IOMUXC_GPR_GPR4_TRNG_STOP_ACK_Pos = 0x13
	// Bit mask of TRNG_STOP_ACK field.
	IOMUXC_GPR_GPR4_TRNG_STOP_ACK_Msk = 0x80000
	// Bit TRNG_STOP_ACK.
	IOMUXC_GPR_GPR4_TRNG_STOP_ACK = 0x80000
	// TRNG stop acknowledge is not asserted
	IOMUXC_GPR_GPR4_TRNG_STOP_ACK_TRNG_STOP_ACK_0 = 0x0
	// TRNG stop acknowledge is asserted
	IOMUXC_GPR_GPR4_TRNG_STOP_ACK_TRNG_STOP_ACK_1 = 0x1
	// Position of ENET_STOP_ACK field.
	IOMUXC_GPR_GPR4_ENET_STOP_ACK_Pos = 0x14
	// Bit mask of ENET_STOP_ACK field.
	IOMUXC_GPR_GPR4_ENET_STOP_ACK_Msk = 0x100000
	// Bit ENET_STOP_ACK.
	IOMUXC_GPR_GPR4_ENET_STOP_ACK = 0x100000
	// ENET1 stop acknowledge is not asserted
	IOMUXC_GPR_GPR4_ENET_STOP_ACK_ENET_STOP_ACK_0 = 0x0
	// ENET1 stop acknowledge is asserted
	IOMUXC_GPR_GPR4_ENET_STOP_ACK_ENET_STOP_ACK_1 = 0x1
	// Position of SAI1_STOP_ACK field.
	IOMUXC_GPR_GPR4_SAI1_STOP_ACK_Pos = 0x15
	// Bit mask of SAI1_STOP_ACK field.
	IOMUXC_GPR_GPR4_SAI1_STOP_ACK_Msk = 0x200000
	// Bit SAI1_STOP_ACK.
	IOMUXC_GPR_GPR4_SAI1_STOP_ACK = 0x200000
	// SAI1 stop acknowledge is not asserted
	IOMUXC_GPR_GPR4_SAI1_STOP_ACK_SAI1_STOP_ACK_0 = 0x0
	// SAI1 stop acknowledge is asserted
	IOMUXC_GPR_GPR4_SAI1_STOP_ACK_SAI1_STOP_ACK_1 = 0x1
	// Position of SAI2_STOP_ACK field.
	IOMUXC_GPR_GPR4_SAI2_STOP_ACK_Pos = 0x16
	// Bit mask of SAI2_STOP_ACK field.
	IOMUXC_GPR_GPR4_SAI2_STOP_ACK_Msk = 0x400000
	// Bit SAI2_STOP_ACK.
	IOMUXC_GPR_GPR4_SAI2_STOP_ACK = 0x400000
	// SAI2 stop acknowledge is not asserted
	IOMUXC_GPR_GPR4_SAI2_STOP_ACK_SAI2_STOP_ACK_0 = 0x0
	// SAI2 stop acknowledge is asserted
	IOMUXC_GPR_GPR4_SAI2_STOP_ACK_SAI2_STOP_ACK_1 = 0x1
	// Position of SAI3_STOP_ACK field.
	IOMUXC_GPR_GPR4_SAI3_STOP_ACK_Pos = 0x17
	// Bit mask of SAI3_STOP_ACK field.
	IOMUXC_GPR_GPR4_SAI3_STOP_ACK_Msk = 0x800000
	// Bit SAI3_STOP_ACK.
	IOMUXC_GPR_GPR4_SAI3_STOP_ACK = 0x800000
	// SAI3 stop acknowledge is not asserted
	IOMUXC_GPR_GPR4_SAI3_STOP_ACK_SAI3_STOP_ACK_0 = 0x0
	// SAI3 stop acknowledge is asserted
	IOMUXC_GPR_GPR4_SAI3_STOP_ACK_SAI3_STOP_ACK_1 = 0x1
	// Position of ENET2_STOP_ACK field.
	IOMUXC_GPR_GPR4_ENET2_STOP_ACK_Pos = 0x18
	// Bit mask of ENET2_STOP_ACK field.
	IOMUXC_GPR_GPR4_ENET2_STOP_ACK_Msk = 0x1000000
	// Bit ENET2_STOP_ACK.
	IOMUXC_GPR_GPR4_ENET2_STOP_ACK = 0x1000000
	// ENET2 stop acknowledge is not asserted
	IOMUXC_GPR_GPR4_ENET2_STOP_ACK_ENET2_STOP_ACK_0 = 0x0
	// ENET2 stop acknowledge is asserted
	IOMUXC_GPR_GPR4_ENET2_STOP_ACK_ENET2_STOP_ACK_1 = 0x1
	// Position of SEMC_STOP_ACK field.
	IOMUXC_GPR_GPR4_SEMC_STOP_ACK_Pos = 0x19
	// Bit mask of SEMC_STOP_ACK field.
	IOMUXC_GPR_GPR4_SEMC_STOP_ACK_Msk = 0x2000000
	// Bit SEMC_STOP_ACK.
	IOMUXC_GPR_GPR4_SEMC_STOP_ACK = 0x2000000
	// SEMC stop acknowledge is not asserted
	IOMUXC_GPR_GPR4_SEMC_STOP_ACK_SEMC_STOP_ACK_0 = 0x0
	// SEMC stop acknowledge is asserted
	IOMUXC_GPR_GPR4_SEMC_STOP_ACK_SEMC_STOP_ACK_1 = 0x1
	// Position of PIT_STOP_ACK field.
	IOMUXC_GPR_GPR4_PIT_STOP_ACK_Pos = 0x1a
	// Bit mask of PIT_STOP_ACK field.
	IOMUXC_GPR_GPR4_PIT_STOP_ACK_Msk = 0x4000000
	// Bit PIT_STOP_ACK.
	IOMUXC_GPR_GPR4_PIT_STOP_ACK = 0x4000000
	// PIT stop acknowledge is not asserted
	IOMUXC_GPR_GPR4_PIT_STOP_ACK_PIT_STOP_ACK_0 = 0x0
	// PIT stop acknowledge is asserted
	IOMUXC_GPR_GPR4_PIT_STOP_ACK_PIT_STOP_ACK_1 = 0x1
	// Position of FLEXSPI_STOP_ACK field.
	IOMUXC_GPR_GPR4_FLEXSPI_STOP_ACK_Pos = 0x1b
	// Bit mask of FLEXSPI_STOP_ACK field.
	IOMUXC_GPR_GPR4_FLEXSPI_STOP_ACK_Msk = 0x8000000
	// Bit FLEXSPI_STOP_ACK.
	IOMUXC_GPR_GPR4_FLEXSPI_STOP_ACK = 0x8000000
	// FLEXSPI stop acknowledge is not asserted
	IOMUXC_GPR_GPR4_FLEXSPI_STOP_ACK_FLEXSPI_STOP_ACK_0 = 0x0
	// FLEXSPI stop acknowledge is asserted
	IOMUXC_GPR_GPR4_FLEXSPI_STOP_ACK_FLEXSPI_STOP_ACK_1 = 0x1
	// Position of FLEXIO1_STOP_ACK field.
	IOMUXC_GPR_GPR4_FLEXIO1_STOP_ACK_Pos = 0x1c
	// Bit mask of FLEXIO1_STOP_ACK field.
	IOMUXC_GPR_GPR4_FLEXIO1_STOP_ACK_Msk = 0x10000000
	// Bit FLEXIO1_STOP_ACK.
	IOMUXC_GPR_GPR4_FLEXIO1_STOP_ACK = 0x10000000
	// FLEXIO1 stop acknowledge is not asserted
	IOMUXC_GPR_GPR4_FLEXIO1_STOP_ACK_FLEXIO1_STOP_ACK_0 = 0x0
	// FLEXIO1 stop acknowledge is asserted
	IOMUXC_GPR_GPR4_FLEXIO1_STOP_ACK_FLEXIO1_STOP_ACK_1 = 0x1
	// Position of FLEXIO2_STOP_ACK field.
	IOMUXC_GPR_GPR4_FLEXIO2_STOP_ACK_Pos = 0x1d
	// Bit mask of FLEXIO2_STOP_ACK field.
	IOMUXC_GPR_GPR4_FLEXIO2_STOP_ACK_Msk = 0x20000000
	// Bit FLEXIO2_STOP_ACK.
	IOMUXC_GPR_GPR4_FLEXIO2_STOP_ACK = 0x20000000
	// FLEXIO2 stop acknowledge is not asserted
	IOMUXC_GPR_GPR4_FLEXIO2_STOP_ACK_FLEXIO2_STOP_ACK_0 = 0x0
	// FLEXIO2 stop acknowledge is asserted (FLEXIO2 is in STOP mode)
	IOMUXC_GPR_GPR4_FLEXIO2_STOP_ACK_FLEXIO2_STOP_ACK_1 = 0x1
	// Position of FLEXIO3_STOP_ACK field.
	IOMUXC_GPR_GPR4_FLEXIO3_STOP_ACK_Pos = 0x1e
	// Bit mask of FLEXIO3_STOP_ACK field.
	IOMUXC_GPR_GPR4_FLEXIO3_STOP_ACK_Msk = 0x40000000
	// Bit FLEXIO3_STOP_ACK.
	IOMUXC_GPR_GPR4_FLEXIO3_STOP_ACK = 0x40000000
	// FLEXIO3 stop acknowledge is not asserted
	IOMUXC_GPR_GPR4_FLEXIO3_STOP_ACK_FLEXIO3_STOP_ACK_0 = 0x0
	// FLEXIO3 stop acknowledge is asserted
	IOMUXC_GPR_GPR4_FLEXIO3_STOP_ACK_FLEXIO3_STOP_ACK_1 = 0x1
	// Position of FLEXSPI2_STOP_ACK field.
	IOMUXC_GPR_GPR4_FLEXSPI2_STOP_ACK_Pos = 0x1f
	// Bit mask of FLEXSPI2_STOP_ACK field.
	IOMUXC_GPR_GPR4_FLEXSPI2_STOP_ACK_Msk = 0x80000000
	// Bit FLEXSPI2_STOP_ACK.
	IOMUXC_GPR_GPR4_FLEXSPI2_STOP_ACK = 0x80000000
	// FLEXSPI2 stop acknowledge is not asserted
	IOMUXC_GPR_GPR4_FLEXSPI2_STOP_ACK_FLEXSPI2_STOP_ACK_0 = 0x0
	// FLEXSPI2 stop acknowledge is asserted
	IOMUXC_GPR_GPR4_FLEXSPI2_STOP_ACK_FLEXSPI2_STOP_ACK_1 = 0x1

	// GPR5: GPR5 General Purpose Register
	// Position of WDOG1_MASK field.
	IOMUXC_GPR_GPR5_WDOG1_MASK_Pos = 0x6
	// Bit mask of WDOG1_MASK field.
	IOMUXC_GPR_GPR5_WDOG1_MASK_Msk = 0x40
	// Bit WDOG1_MASK.
	IOMUXC_GPR_GPR5_WDOG1_MASK = 0x40
	// WDOG1 Timeout behaves normally
	IOMUXC_GPR_GPR5_WDOG1_MASK_WDOG1_MASK_0 = 0x0
	// WDOG1 Timeout is masked
	IOMUXC_GPR_GPR5_WDOG1_MASK_WDOG1_MASK_1 = 0x1
	// Position of WDOG2_MASK field.
	IOMUXC_GPR_GPR5_WDOG2_MASK_Pos = 0x7
	// Bit mask of WDOG2_MASK field.
	IOMUXC_GPR_GPR5_WDOG2_MASK_Msk = 0x80
	// Bit WDOG2_MASK.
	IOMUXC_GPR_GPR5_WDOG2_MASK = 0x80
	// WDOG2 Timeout behaves normally
	IOMUXC_GPR_GPR5_WDOG2_MASK_WDOG2_MASK_0 = 0x0
	// WDOG2 Timeout is masked
	IOMUXC_GPR_GPR5_WDOG2_MASK_WDOG2_MASK_1 = 0x1
	// Position of GPT2_CAPIN1_SEL field.
	IOMUXC_GPR_GPR5_GPT2_CAPIN1_SEL_Pos = 0x17
	// Bit mask of GPT2_CAPIN1_SEL field.
	IOMUXC_GPR_GPR5_GPT2_CAPIN1_SEL_Msk = 0x800000
	// Bit GPT2_CAPIN1_SEL.
	IOMUXC_GPR_GPR5_GPT2_CAPIN1_SEL = 0x800000
	// source from GPT2_CAPTURE1
	IOMUXC_GPR_GPR5_GPT2_CAPIN1_SEL_GPT2_CAPIN1_SEL_0 = 0x0
	// source from ENET_1588_EVENT3_OUT (chnnal 3 of IEEE 1588 timer)
	IOMUXC_GPR_GPR5_GPT2_CAPIN1_SEL_GPT2_CAPIN1_SEL_1 = 0x1
	// Position of GPT2_CAPIN2_SEL field.
	IOMUXC_GPR_GPR5_GPT2_CAPIN2_SEL_Pos = 0x18
	// Bit mask of GPT2_CAPIN2_SEL field.
	IOMUXC_GPR_GPR5_GPT2_CAPIN2_SEL_Msk = 0x1000000
	// Bit GPT2_CAPIN2_SEL.
	IOMUXC_GPR_GPR5_GPT2_CAPIN2_SEL = 0x1000000
	// source from GPT2_CAPTURE2
	IOMUXC_GPR_GPR5_GPT2_CAPIN2_SEL_GPT2_CAPIN2_SEL_0 = 0x0
	// source from ENET2_1588_EVENT3_OUT (chnnal 3 of IEEE 1588 timer)
	IOMUXC_GPR_GPR5_GPT2_CAPIN2_SEL_GPT2_CAPIN2_SEL_1 = 0x1
	// Position of ENET_EVENT3IN_SEL field.
	IOMUXC_GPR_GPR5_ENET_EVENT3IN_SEL_Pos = 0x19
	// Bit mask of ENET_EVENT3IN_SEL field.
	IOMUXC_GPR_GPR5_ENET_EVENT3IN_SEL_Msk = 0x2000000
	// Bit ENET_EVENT3IN_SEL.
	IOMUXC_GPR_GPR5_ENET_EVENT3IN_SEL = 0x2000000
	// event3 source input from ENET_1588_EVENT3_IN
	IOMUXC_GPR_GPR5_ENET_EVENT3IN_SEL_ENET_EVENT3IN_SEL_0 = 0x0
	// event3 source input from GPT2.GPT_COMPARE1
	IOMUXC_GPR_GPR5_ENET_EVENT3IN_SEL_ENET_EVENT3IN_SEL_1 = 0x1
	// Position of ENET2_EVENT3IN_SEL field.
	IOMUXC_GPR_GPR5_ENET2_EVENT3IN_SEL_Pos = 0x1a
	// Bit mask of ENET2_EVENT3IN_SEL field.
	IOMUXC_GPR_GPR5_ENET2_EVENT3IN_SEL_Msk = 0x4000000
	// Bit ENET2_EVENT3IN_SEL.
	IOMUXC_GPR_GPR5_ENET2_EVENT3IN_SEL = 0x4000000
	// event3 source input from ENET2_1588_EVENT3_IN
	IOMUXC_GPR_GPR5_ENET2_EVENT3IN_SEL_ENET2_EVENT3IN_SEL_0 = 0x0
	// event3 source input from GPT2.GPT_COMPARE2
	IOMUXC_GPR_GPR5_ENET2_EVENT3IN_SEL_ENET2_EVENT3IN_SEL_1 = 0x1
	// Position of VREF_1M_CLK_GPT1 field.
	IOMUXC_GPR_GPR5_VREF_1M_CLK_GPT1_Pos = 0x1c
	// Bit mask of VREF_1M_CLK_GPT1 field.
	IOMUXC_GPR_GPR5_VREF_1M_CLK_GPT1_Msk = 0x10000000
	// Bit VREF_1M_CLK_GPT1.
	IOMUXC_GPR_GPR5_VREF_1M_CLK_GPT1 = 0x10000000
	// GPT1 ipg_clk_highfreq driven by IPG_PERCLK
	IOMUXC_GPR_GPR5_VREF_1M_CLK_GPT1_VREF_1M_CLK_GPT1_0 = 0x0
	// GPT1 ipg_clk_highfreq driven by anatop 1 MHz clock
	IOMUXC_GPR_GPR5_VREF_1M_CLK_GPT1_VREF_1M_CLK_GPT1_1 = 0x1
	// Position of VREF_1M_CLK_GPT2 field.
	IOMUXC_GPR_GPR5_VREF_1M_CLK_GPT2_Pos = 0x1d
	// Bit mask of VREF_1M_CLK_GPT2 field.
	IOMUXC_GPR_GPR5_VREF_1M_CLK_GPT2_Msk = 0x20000000
	// Bit VREF_1M_CLK_GPT2.
	IOMUXC_GPR_GPR5_VREF_1M_CLK_GPT2 = 0x20000000
	// GPT2 ipg_clk_highfreq driven by IPG_PERCLK
	IOMUXC_GPR_GPR5_VREF_1M_CLK_GPT2_VREF_1M_CLK_GPT2_0 = 0x0
	// GPT2 ipg_clk_highfreq driven by anatop 1 MHz clock
	IOMUXC_GPR_GPR5_VREF_1M_CLK_GPT2_VREF_1M_CLK_GPT2_1 = 0x1

	// GPR6: GPR6 General Purpose Register
	// Position of QTIMER1_TRM0_INPUT_SEL field.
	IOMUXC_GPR_GPR6_QTIMER1_TRM0_INPUT_SEL_Pos = 0x0
	// Bit mask of QTIMER1_TRM0_INPUT_SEL field.
	IOMUXC_GPR_GPR6_QTIMER1_TRM0_INPUT_SEL_Msk = 0x1
	// Bit QTIMER1_TRM0_INPUT_SEL.
	IOMUXC_GPR_GPR6_QTIMER1_TRM0_INPUT_SEL = 0x1
	// input from IOMUX
	IOMUXC_GPR_GPR6_QTIMER1_TRM0_INPUT_SEL_QTIMER1_TRM0_INPUT_SEL_0 = 0x0
	// input from XBAR
	IOMUXC_GPR_GPR6_QTIMER1_TRM0_INPUT_SEL_QTIMER1_TRM0_INPUT_SEL_1 = 0x1
	// Position of QTIMER1_TRM1_INPUT_SEL field.
	IOMUXC_GPR_GPR6_QTIMER1_TRM1_INPUT_SEL_Pos = 0x1
	// Bit mask of QTIMER1_TRM1_INPUT_SEL field.
	IOMUXC_GPR_GPR6_QTIMER1_TRM1_INPUT_SEL_Msk = 0x2
	// Bit QTIMER1_TRM1_INPUT_SEL.
	IOMUXC_GPR_GPR6_QTIMER1_TRM1_INPUT_SEL = 0x2
	// input from IOMUX
	IOMUXC_GPR_GPR6_QTIMER1_TRM1_INPUT_SEL_QTIMER1_TRM1_INPUT_SEL_0 = 0x0
	// input from XBAR
	IOMUXC_GPR_GPR6_QTIMER1_TRM1_INPUT_SEL_QTIMER1_TRM1_INPUT_SEL_1 = 0x1
	// Position of QTIMER1_TRM2_INPUT_SEL field.
	IOMUXC_GPR_GPR6_QTIMER1_TRM2_INPUT_SEL_Pos = 0x2
	// Bit mask of QTIMER1_TRM2_INPUT_SEL field.
	IOMUXC_GPR_GPR6_QTIMER1_TRM2_INPUT_SEL_Msk = 0x4
	// Bit QTIMER1_TRM2_INPUT_SEL.
	IOMUXC_GPR_GPR6_QTIMER1_TRM2_INPUT_SEL = 0x4
	// input from IOMUX
	IOMUXC_GPR_GPR6_QTIMER1_TRM2_INPUT_SEL_QTIMER1_TRM2_INPUT_SEL_0 = 0x0
	// input from XBAR
	IOMUXC_GPR_GPR6_QTIMER1_TRM2_INPUT_SEL_QTIMER1_TRM2_INPUT_SEL_1 = 0x1
	// Position of QTIMER1_TRM3_INPUT_SEL field.
	IOMUXC_GPR_GPR6_QTIMER1_TRM3_INPUT_SEL_Pos = 0x3
	// Bit mask of QTIMER1_TRM3_INPUT_SEL field.
	IOMUXC_GPR_GPR6_QTIMER1_TRM3_INPUT_SEL_Msk = 0x8
	// Bit QTIMER1_TRM3_INPUT_SEL.
	IOMUXC_GPR_GPR6_QTIMER1_TRM3_INPUT_SEL = 0x8
	// input from IOMUX
	IOMUXC_GPR_GPR6_QTIMER1_TRM3_INPUT_SEL_QTIMER1_TRM3_INPUT_SEL_0 = 0x0
	// input from XBAR
	IOMUXC_GPR_GPR6_QTIMER1_TRM3_INPUT_SEL_QTIMER1_TRM3_INPUT_SEL_1 = 0x1
	// Position of QTIMER2_TRM0_INPUT_SEL field.
	IOMUXC_GPR_GPR6_QTIMER2_TRM0_INPUT_SEL_Pos = 0x4
	// Bit mask of QTIMER2_TRM0_INPUT_SEL field.
	IOMUXC_GPR_GPR6_QTIMER2_TRM0_INPUT_SEL_Msk = 0x10
	// Bit QTIMER2_TRM0_INPUT_SEL.
	IOMUXC_GPR_GPR6_QTIMER2_TRM0_INPUT_SEL = 0x10
	// input from IOMUX
	IOMUXC_GPR_GPR6_QTIMER2_TRM0_INPUT_SEL_QTIMER2_TRM0_INPUT_SEL_0 = 0x0
	// input from XBAR
	IOMUXC_GPR_GPR6_QTIMER2_TRM0_INPUT_SEL_QTIMER2_TRM0_INPUT_SEL_1 = 0x1
	// Position of QTIMER2_TRM1_INPUT_SEL field.
	IOMUXC_GPR_GPR6_QTIMER2_TRM1_INPUT_SEL_Pos = 0x5
	// Bit mask of QTIMER2_TRM1_INPUT_SEL field.
	IOMUXC_GPR_GPR6_QTIMER2_TRM1_INPUT_SEL_Msk = 0x20
	// Bit QTIMER2_TRM1_INPUT_SEL.
	IOMUXC_GPR_GPR6_QTIMER2_TRM1_INPUT_SEL = 0x20
	// input from IOMUX
	IOMUXC_GPR_GPR6_QTIMER2_TRM1_INPUT_SEL_QTIMER2_TRM1_INPUT_SEL_0 = 0x0
	// input from XBAR
	IOMUXC_GPR_GPR6_QTIMER2_TRM1_INPUT_SEL_QTIMER2_TRM1_INPUT_SEL_1 = 0x1
	// Position of QTIMER2_TRM2_INPUT_SEL field.
	IOMUXC_GPR_GPR6_QTIMER2_TRM2_INPUT_SEL_Pos = 0x6
	// Bit mask of QTIMER2_TRM2_INPUT_SEL field.
	IOMUXC_GPR_GPR6_QTIMER2_TRM2_INPUT_SEL_Msk = 0x40
	// Bit QTIMER2_TRM2_INPUT_SEL.
	IOMUXC_GPR_GPR6_QTIMER2_TRM2_INPUT_SEL = 0x40
	// input from IOMUX
	IOMUXC_GPR_GPR6_QTIMER2_TRM2_INPUT_SEL_QTIMER2_TRM2_INPUT_SEL_0 = 0x0
	// input from XBAR
	IOMUXC_GPR_GPR6_QTIMER2_TRM2_INPUT_SEL_QTIMER2_TRM2_INPUT_SEL_1 = 0x1
	// Position of QTIMER2_TRM3_INPUT_SEL field.
	IOMUXC_GPR_GPR6_QTIMER2_TRM3_INPUT_SEL_Pos = 0x7
	// Bit mask of QTIMER2_TRM3_INPUT_SEL field.
	IOMUXC_GPR_GPR6_QTIMER2_TRM3_INPUT_SEL_Msk = 0x80
	// Bit QTIMER2_TRM3_INPUT_SEL.
	IOMUXC_GPR_GPR6_QTIMER2_TRM3_INPUT_SEL = 0x80
	// input from IOMUX
	IOMUXC_GPR_GPR6_QTIMER2_TRM3_INPUT_SEL_QTIMER2_TRM3_INPUT_SEL_0 = 0x0
	// input from XBAR
	IOMUXC_GPR_GPR6_QTIMER2_TRM3_INPUT_SEL_QTIMER2_TRM3_INPUT_SEL_1 = 0x1
	// Position of QTIMER3_TRM0_INPUT_SEL field.
	IOMUXC_GPR_GPR6_QTIMER3_TRM0_INPUT_SEL_Pos = 0x8
	// Bit mask of QTIMER3_TRM0_INPUT_SEL field.
	IOMUXC_GPR_GPR6_QTIMER3_TRM0_INPUT_SEL_Msk = 0x100
	// Bit QTIMER3_TRM0_INPUT_SEL.
	IOMUXC_GPR_GPR6_QTIMER3_TRM0_INPUT_SEL = 0x100
	// input from IOMUX
	IOMUXC_GPR_GPR6_QTIMER3_TRM0_INPUT_SEL_QTIMER3_TRM0_INPUT_SEL_0 = 0x0
	// input from XBAR
	IOMUXC_GPR_GPR6_QTIMER3_TRM0_INPUT_SEL_QTIMER3_TRM0_INPUT_SEL_1 = 0x1
	// Position of QTIMER3_TRM1_INPUT_SEL field.
	IOMUXC_GPR_GPR6_QTIMER3_TRM1_INPUT_SEL_Pos = 0x9
	// Bit mask of QTIMER3_TRM1_INPUT_SEL field.
	IOMUXC_GPR_GPR6_QTIMER3_TRM1_INPUT_SEL_Msk = 0x200
	// Bit QTIMER3_TRM1_INPUT_SEL.
	IOMUXC_GPR_GPR6_QTIMER3_TRM1_INPUT_SEL = 0x200
	// input from IOMUX
	IOMUXC_GPR_GPR6_QTIMER3_TRM1_INPUT_SEL_QTIMER3_TRM1_INPUT_SEL_0 = 0x0
	// input from XBAR
	IOMUXC_GPR_GPR6_QTIMER3_TRM1_INPUT_SEL_QTIMER3_TRM1_INPUT_SEL_1 = 0x1
	// Position of QTIMER3_TRM2_INPUT_SEL field.
	IOMUXC_GPR_GPR6_QTIMER3_TRM2_INPUT_SEL_Pos = 0xa
	// Bit mask of QTIMER3_TRM2_INPUT_SEL field.
	IOMUXC_GPR_GPR6_QTIMER3_TRM2_INPUT_SEL_Msk = 0x400
	// Bit QTIMER3_TRM2_INPUT_SEL.
	IOMUXC_GPR_GPR6_QTIMER3_TRM2_INPUT_SEL = 0x400
	// input from IOMUX
	IOMUXC_GPR_GPR6_QTIMER3_TRM2_INPUT_SEL_QTIMER3_TRM2_INPUT_SEL_0 = 0x0
	// input from XBAR
	IOMUXC_GPR_GPR6_QTIMER3_TRM2_INPUT_SEL_QTIMER3_TRM2_INPUT_SEL_1 = 0x1
	// Position of QTIMER3_TRM3_INPUT_SEL field.
	IOMUXC_GPR_GPR6_QTIMER3_TRM3_INPUT_SEL_Pos = 0xb
	// Bit mask of QTIMER3_TRM3_INPUT_SEL field.
	IOMUXC_GPR_GPR6_QTIMER3_TRM3_INPUT_SEL_Msk = 0x800
	// Bit QTIMER3_TRM3_INPUT_SEL.
	IOMUXC_GPR_GPR6_QTIMER3_TRM3_INPUT_SEL = 0x800
	// input from IOMUX
	IOMUXC_GPR_GPR6_QTIMER3_TRM3_INPUT_SEL_QTIMER3_TRM3_INPUT_SEL_0 = 0x0
	// input from XBAR
	IOMUXC_GPR_GPR6_QTIMER3_TRM3_INPUT_SEL_QTIMER3_TRM3_INPUT_SEL_1 = 0x1
	// Position of QTIMER4_TRM0_INPUT_SEL field.
	IOMUXC_GPR_GPR6_QTIMER4_TRM0_INPUT_SEL_Pos = 0xc
	// Bit mask of QTIMER4_TRM0_INPUT_SEL field.
	IOMUXC_GPR_GPR6_QTIMER4_TRM0_INPUT_SEL_Msk = 0x1000
	// Bit QTIMER4_TRM0_INPUT_SEL.
	IOMUXC_GPR_GPR6_QTIMER4_TRM0_INPUT_SEL = 0x1000
	// input from IOMUX
	IOMUXC_GPR_GPR6_QTIMER4_TRM0_INPUT_SEL_QTIMER4_TRM0_INPUT_SEL_0 = 0x0
	// input from XBAR
	IOMUXC_GPR_GPR6_QTIMER4_TRM0_INPUT_SEL_QTIMER4_TRM0_INPUT_SEL_1 = 0x1
	// Position of QTIMER4_TRM1_INPUT_SEL field.
	IOMUXC_GPR_GPR6_QTIMER4_TRM1_INPUT_SEL_Pos = 0xd
	// Bit mask of QTIMER4_TRM1_INPUT_SEL field.
	IOMUXC_GPR_GPR6_QTIMER4_TRM1_INPUT_SEL_Msk = 0x2000
	// Bit QTIMER4_TRM1_INPUT_SEL.
	IOMUXC_GPR_GPR6_QTIMER4_TRM1_INPUT_SEL = 0x2000
	// input from IOMUX
	IOMUXC_GPR_GPR6_QTIMER4_TRM1_INPUT_SEL_QTIMER4_TRM1_INPUT_SEL_0 = 0x0
	// input from XBAR
	IOMUXC_GPR_GPR6_QTIMER4_TRM1_INPUT_SEL_QTIMER4_TRM1_INPUT_SEL_1 = 0x1
	// Position of QTIMER4_TRM2_INPUT_SEL field.
	IOMUXC_GPR_GPR6_QTIMER4_TRM2_INPUT_SEL_Pos = 0xe
	// Bit mask of QTIMER4_TRM2_INPUT_SEL field.
	IOMUXC_GPR_GPR6_QTIMER4_TRM2_INPUT_SEL_Msk = 0x4000
	// Bit QTIMER4_TRM2_INPUT_SEL.
	IOMUXC_GPR_GPR6_QTIMER4_TRM2_INPUT_SEL = 0x4000
	// input from IOMUX
	IOMUXC_GPR_GPR6_QTIMER4_TRM2_INPUT_SEL_QTIMER4_TRM2_INPUT_SEL_0 = 0x0
	// input from XBAR
	IOMUXC_GPR_GPR6_QTIMER4_TRM2_INPUT_SEL_QTIMER4_TRM2_INPUT_SEL_1 = 0x1
	// Position of QTIMER4_TRM3_INPUT_SEL field.
	IOMUXC_GPR_GPR6_QTIMER4_TRM3_INPUT_SEL_Pos = 0xf
	// Bit mask of QTIMER4_TRM3_INPUT_SEL field.
	IOMUXC_GPR_GPR6_QTIMER4_TRM3_INPUT_SEL_Msk = 0x8000
	// Bit QTIMER4_TRM3_INPUT_SEL.
	IOMUXC_GPR_GPR6_QTIMER4_TRM3_INPUT_SEL = 0x8000
	// input from IOMUX
	IOMUXC_GPR_GPR6_QTIMER4_TRM3_INPUT_SEL_QTIMER4_TRM3_INPUT_SEL_0 = 0x0
	// input from XBAR
	IOMUXC_GPR_GPR6_QTIMER4_TRM3_INPUT_SEL_QTIMER4_TRM3_INPUT_SEL_1 = 0x1
	// Position of IOMUXC_XBAR_DIR_SEL_4 field.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_4_Pos = 0x10
	// Bit mask of IOMUXC_XBAR_DIR_SEL_4 field.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_4_Msk = 0x10000
	// Bit IOMUXC_XBAR_DIR_SEL_4.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_4 = 0x10000
	// XBAR_INOUT as input
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_4_IOMUXC_XBAR_DIR_SEL_4_0 = 0x0
	// XBAR_INOUT as output
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_4_IOMUXC_XBAR_DIR_SEL_4_1 = 0x1
	// Position of IOMUXC_XBAR_DIR_SEL_5 field.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_5_Pos = 0x11
	// Bit mask of IOMUXC_XBAR_DIR_SEL_5 field.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_5_Msk = 0x20000
	// Bit IOMUXC_XBAR_DIR_SEL_5.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_5 = 0x20000
	// XBAR_INOUT as input
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_5_IOMUXC_XBAR_DIR_SEL_5_0 = 0x0
	// XBAR_INOUT as output
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_5_IOMUXC_XBAR_DIR_SEL_5_1 = 0x1
	// Position of IOMUXC_XBAR_DIR_SEL_6 field.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_6_Pos = 0x12
	// Bit mask of IOMUXC_XBAR_DIR_SEL_6 field.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_6_Msk = 0x40000
	// Bit IOMUXC_XBAR_DIR_SEL_6.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_6 = 0x40000
	// XBAR_INOUT as input
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_6_IOMUXC_XBAR_DIR_SEL_6_0 = 0x0
	// XBAR_INOUT as output
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_6_IOMUXC_XBAR_DIR_SEL_6_1 = 0x1
	// Position of IOMUXC_XBAR_DIR_SEL_7 field.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_7_Pos = 0x13
	// Bit mask of IOMUXC_XBAR_DIR_SEL_7 field.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_7_Msk = 0x80000
	// Bit IOMUXC_XBAR_DIR_SEL_7.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_7 = 0x80000
	// XBAR_INOUT as input
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_7_IOMUXC_XBAR_DIR_SEL_7_0 = 0x0
	// XBAR_INOUT as output
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_7_IOMUXC_XBAR_DIR_SEL_7_1 = 0x1
	// Position of IOMUXC_XBAR_DIR_SEL_8 field.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_8_Pos = 0x14
	// Bit mask of IOMUXC_XBAR_DIR_SEL_8 field.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_8_Msk = 0x100000
	// Bit IOMUXC_XBAR_DIR_SEL_8.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_8 = 0x100000
	// XBAR_INOUT as input
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_8_IOMUXC_XBAR_DIR_SEL_8_0 = 0x0
	// XBAR_INOUT as output
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_8_IOMUXC_XBAR_DIR_SEL_8_1 = 0x1
	// Position of IOMUXC_XBAR_DIR_SEL_9 field.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_9_Pos = 0x15
	// Bit mask of IOMUXC_XBAR_DIR_SEL_9 field.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_9_Msk = 0x200000
	// Bit IOMUXC_XBAR_DIR_SEL_9.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_9 = 0x200000
	// XBAR_INOUT as input
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_9_IOMUXC_XBAR_DIR_SEL_9_0 = 0x0
	// XBAR_INOUT as output
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_9_IOMUXC_XBAR_DIR_SEL_9_1 = 0x1
	// Position of IOMUXC_XBAR_DIR_SEL_10 field.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_10_Pos = 0x16
	// Bit mask of IOMUXC_XBAR_DIR_SEL_10 field.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_10_Msk = 0x400000
	// Bit IOMUXC_XBAR_DIR_SEL_10.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_10 = 0x400000
	// XBAR_INOUT as input
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_10_IOMUXC_XBAR_DIR_SEL_10_0 = 0x0
	// XBAR_INOUT as output
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_10_IOMUXC_XBAR_DIR_SEL_10_1 = 0x1
	// Position of IOMUXC_XBAR_DIR_SEL_11 field.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_11_Pos = 0x17
	// Bit mask of IOMUXC_XBAR_DIR_SEL_11 field.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_11_Msk = 0x800000
	// Bit IOMUXC_XBAR_DIR_SEL_11.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_11 = 0x800000
	// XBAR_INOUT as input
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_11_IOMUXC_XBAR_DIR_SEL_11_0 = 0x0
	// XBAR_INOUT as output
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_11_IOMUXC_XBAR_DIR_SEL_11_1 = 0x1
	// Position of IOMUXC_XBAR_DIR_SEL_12 field.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_12_Pos = 0x18
	// Bit mask of IOMUXC_XBAR_DIR_SEL_12 field.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_12_Msk = 0x1000000
	// Bit IOMUXC_XBAR_DIR_SEL_12.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_12 = 0x1000000
	// XBAR_INOUT as input
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_12_IOMUXC_XBAR_DIR_SEL_12_0 = 0x0
	// XBAR_INOUT as output
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_12_IOMUXC_XBAR_DIR_SEL_12_1 = 0x1
	// Position of IOMUXC_XBAR_DIR_SEL_13 field.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_13_Pos = 0x19
	// Bit mask of IOMUXC_XBAR_DIR_SEL_13 field.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_13_Msk = 0x2000000
	// Bit IOMUXC_XBAR_DIR_SEL_13.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_13 = 0x2000000
	// XBAR_INOUT as input
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_13_IOMUXC_XBAR_DIR_SEL_13_0 = 0x0
	// XBAR_INOUT as output
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_13_IOMUXC_XBAR_DIR_SEL_13_1 = 0x1
	// Position of IOMUXC_XBAR_DIR_SEL_14 field.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_14_Pos = 0x1a
	// Bit mask of IOMUXC_XBAR_DIR_SEL_14 field.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_14_Msk = 0x4000000
	// Bit IOMUXC_XBAR_DIR_SEL_14.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_14 = 0x4000000
	// XBAR_INOUT as input
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_14_IOMUXC_XBAR_DIR_SEL_14_0 = 0x0
	// XBAR_INOUT as output
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_14_IOMUXC_XBAR_DIR_SEL_14_1 = 0x1
	// Position of IOMUXC_XBAR_DIR_SEL_15 field.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_15_Pos = 0x1b
	// Bit mask of IOMUXC_XBAR_DIR_SEL_15 field.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_15_Msk = 0x8000000
	// Bit IOMUXC_XBAR_DIR_SEL_15.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_15 = 0x8000000
	// XBAR_INOUT as input
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_15_IOMUXC_XBAR_DIR_SEL_15_0 = 0x0
	// XBAR_INOUT as output
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_15_IOMUXC_XBAR_DIR_SEL_15_1 = 0x1
	// Position of IOMUXC_XBAR_DIR_SEL_16 field.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_16_Pos = 0x1c
	// Bit mask of IOMUXC_XBAR_DIR_SEL_16 field.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_16_Msk = 0x10000000
	// Bit IOMUXC_XBAR_DIR_SEL_16.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_16 = 0x10000000
	// XBAR_INOUT as input
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_16_IOMUXC_XBAR_DIR_SEL_16_0 = 0x0
	// XBAR_INOUT as output
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_16_IOMUXC_XBAR_DIR_SEL_16_1 = 0x1
	// Position of IOMUXC_XBAR_DIR_SEL_17 field.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_17_Pos = 0x1d
	// Bit mask of IOMUXC_XBAR_DIR_SEL_17 field.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_17_Msk = 0x20000000
	// Bit IOMUXC_XBAR_DIR_SEL_17.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_17 = 0x20000000
	// XBAR_INOUT as input
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_17_IOMUXC_XBAR_DIR_SEL_17_0 = 0x0
	// XBAR_INOUT as output
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_17_IOMUXC_XBAR_DIR_SEL_17_1 = 0x1
	// Position of IOMUXC_XBAR_DIR_SEL_18 field.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_18_Pos = 0x1e
	// Bit mask of IOMUXC_XBAR_DIR_SEL_18 field.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_18_Msk = 0x40000000
	// Bit IOMUXC_XBAR_DIR_SEL_18.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_18 = 0x40000000
	// XBAR_INOUT as input
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_18_IOMUXC_XBAR_DIR_SEL_18_0 = 0x0
	// XBAR_INOUT as output
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_18_IOMUXC_XBAR_DIR_SEL_18_1 = 0x1
	// Position of IOMUXC_XBAR_DIR_SEL_19 field.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_19_Pos = 0x1f
	// Bit mask of IOMUXC_XBAR_DIR_SEL_19 field.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_19_Msk = 0x80000000
	// Bit IOMUXC_XBAR_DIR_SEL_19.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_19 = 0x80000000
	// XBAR_INOUT as input
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_19_IOMUXC_XBAR_DIR_SEL_19_0 = 0x0
	// XBAR_INOUT as output
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_19_IOMUXC_XBAR_DIR_SEL_19_1 = 0x1

	// GPR7: GPR7 General Purpose Register
	// Position of LPI2C1_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPI2C1_STOP_REQ_Pos = 0x0
	// Bit mask of LPI2C1_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPI2C1_STOP_REQ_Msk = 0x1
	// Bit LPI2C1_STOP_REQ.
	IOMUXC_GPR_GPR7_LPI2C1_STOP_REQ = 0x1
	// stop request off
	IOMUXC_GPR_GPR7_LPI2C1_STOP_REQ_LPI2C1_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR7_LPI2C1_STOP_REQ_LPI2C1_STOP_REQ_1 = 0x1
	// Position of LPI2C2_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPI2C2_STOP_REQ_Pos = 0x1
	// Bit mask of LPI2C2_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPI2C2_STOP_REQ_Msk = 0x2
	// Bit LPI2C2_STOP_REQ.
	IOMUXC_GPR_GPR7_LPI2C2_STOP_REQ = 0x2
	// stop request off
	IOMUXC_GPR_GPR7_LPI2C2_STOP_REQ_LPI2C2_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR7_LPI2C2_STOP_REQ_LPI2C2_STOP_REQ_1 = 0x1
	// Position of LPI2C3_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPI2C3_STOP_REQ_Pos = 0x2
	// Bit mask of LPI2C3_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPI2C3_STOP_REQ_Msk = 0x4
	// Bit LPI2C3_STOP_REQ.
	IOMUXC_GPR_GPR7_LPI2C3_STOP_REQ = 0x4
	// stop request off
	IOMUXC_GPR_GPR7_LPI2C3_STOP_REQ_LPI2C3_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR7_LPI2C3_STOP_REQ_LPI2C3_STOP_REQ_1 = 0x1
	// Position of LPI2C4_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPI2C4_STOP_REQ_Pos = 0x3
	// Bit mask of LPI2C4_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPI2C4_STOP_REQ_Msk = 0x8
	// Bit LPI2C4_STOP_REQ.
	IOMUXC_GPR_GPR7_LPI2C4_STOP_REQ = 0x8
	// stop request off
	IOMUXC_GPR_GPR7_LPI2C4_STOP_REQ_LPI2C4_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR7_LPI2C4_STOP_REQ_LPI2C4_STOP_REQ_1 = 0x1
	// Position of LPSPI1_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPSPI1_STOP_REQ_Pos = 0x4
	// Bit mask of LPSPI1_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPSPI1_STOP_REQ_Msk = 0x10
	// Bit LPSPI1_STOP_REQ.
	IOMUXC_GPR_GPR7_LPSPI1_STOP_REQ = 0x10
	// stop request off
	IOMUXC_GPR_GPR7_LPSPI1_STOP_REQ_LPSPI1_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR7_LPSPI1_STOP_REQ_LPSPI1_STOP_REQ_1 = 0x1
	// Position of LPSPI2_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPSPI2_STOP_REQ_Pos = 0x5
	// Bit mask of LPSPI2_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPSPI2_STOP_REQ_Msk = 0x20
	// Bit LPSPI2_STOP_REQ.
	IOMUXC_GPR_GPR7_LPSPI2_STOP_REQ = 0x20
	// stop request off
	IOMUXC_GPR_GPR7_LPSPI2_STOP_REQ_LPSPI2_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR7_LPSPI2_STOP_REQ_LPSPI2_STOP_REQ_1 = 0x1
	// Position of LPSPI3_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPSPI3_STOP_REQ_Pos = 0x6
	// Bit mask of LPSPI3_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPSPI3_STOP_REQ_Msk = 0x40
	// Bit LPSPI3_STOP_REQ.
	IOMUXC_GPR_GPR7_LPSPI3_STOP_REQ = 0x40
	// stop request off
	IOMUXC_GPR_GPR7_LPSPI3_STOP_REQ_LPSPI3_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR7_LPSPI3_STOP_REQ_LPSPI3_STOP_REQ_1 = 0x1
	// Position of LPSPI4_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPSPI4_STOP_REQ_Pos = 0x7
	// Bit mask of LPSPI4_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPSPI4_STOP_REQ_Msk = 0x80
	// Bit LPSPI4_STOP_REQ.
	IOMUXC_GPR_GPR7_LPSPI4_STOP_REQ = 0x80
	// stop request off
	IOMUXC_GPR_GPR7_LPSPI4_STOP_REQ_LPSPI4_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR7_LPSPI4_STOP_REQ_LPSPI4_STOP_REQ_1 = 0x1
	// Position of LPUART1_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPUART1_STOP_REQ_Pos = 0x8
	// Bit mask of LPUART1_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPUART1_STOP_REQ_Msk = 0x100
	// Bit LPUART1_STOP_REQ.
	IOMUXC_GPR_GPR7_LPUART1_STOP_REQ = 0x100
	// stop request off
	IOMUXC_GPR_GPR7_LPUART1_STOP_REQ_LPUART1_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR7_LPUART1_STOP_REQ_LPUART1_STOP_REQ_1 = 0x1
	// Position of LPUART2_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPUART2_STOP_REQ_Pos = 0x9
	// Bit mask of LPUART2_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPUART2_STOP_REQ_Msk = 0x200
	// Bit LPUART2_STOP_REQ.
	IOMUXC_GPR_GPR7_LPUART2_STOP_REQ = 0x200
	// stop request off
	IOMUXC_GPR_GPR7_LPUART2_STOP_REQ_LPUART2_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR7_LPUART2_STOP_REQ_LPUART2_STOP_REQ_1 = 0x1
	// Position of LPUART3_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPUART3_STOP_REQ_Pos = 0xa
	// Bit mask of LPUART3_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPUART3_STOP_REQ_Msk = 0x400
	// Bit LPUART3_STOP_REQ.
	IOMUXC_GPR_GPR7_LPUART3_STOP_REQ = 0x400
	// stop request off
	IOMUXC_GPR_GPR7_LPUART3_STOP_REQ_LPUART3_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR7_LPUART3_STOP_REQ_LPUART3_STOP_REQ_1 = 0x1
	// Position of LPUART4_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPUART4_STOP_REQ_Pos = 0xb
	// Bit mask of LPUART4_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPUART4_STOP_REQ_Msk = 0x800
	// Bit LPUART4_STOP_REQ.
	IOMUXC_GPR_GPR7_LPUART4_STOP_REQ = 0x800
	// stop request off
	IOMUXC_GPR_GPR7_LPUART4_STOP_REQ_LPUART4_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR7_LPUART4_STOP_REQ_LPUART4_STOP_REQ_1 = 0x1
	// Position of LPUART5_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPUART5_STOP_REQ_Pos = 0xc
	// Bit mask of LPUART5_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPUART5_STOP_REQ_Msk = 0x1000
	// Bit LPUART5_STOP_REQ.
	IOMUXC_GPR_GPR7_LPUART5_STOP_REQ = 0x1000
	// stop request off
	IOMUXC_GPR_GPR7_LPUART5_STOP_REQ_LPUART5_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR7_LPUART5_STOP_REQ_LPUART5_STOP_REQ_1 = 0x1
	// Position of LPUART6_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPUART6_STOP_REQ_Pos = 0xd
	// Bit mask of LPUART6_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPUART6_STOP_REQ_Msk = 0x2000
	// Bit LPUART6_STOP_REQ.
	IOMUXC_GPR_GPR7_LPUART6_STOP_REQ = 0x2000
	// stop request off
	IOMUXC_GPR_GPR7_LPUART6_STOP_REQ_LPUART6_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR7_LPUART6_STOP_REQ_LPUART6_STOP_REQ_1 = 0x1
	// Position of LPUART7_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPUART7_STOP_REQ_Pos = 0xe
	// Bit mask of LPUART7_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPUART7_STOP_REQ_Msk = 0x4000
	// Bit LPUART7_STOP_REQ.
	IOMUXC_GPR_GPR7_LPUART7_STOP_REQ = 0x4000
	// stop request off
	IOMUXC_GPR_GPR7_LPUART7_STOP_REQ_LPUART7_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR7_LPUART7_STOP_REQ_LPUART7_STOP_REQ_1 = 0x1
	// Position of LPUART8_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPUART8_STOP_REQ_Pos = 0xf
	// Bit mask of LPUART8_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPUART8_STOP_REQ_Msk = 0x8000
	// Bit LPUART8_STOP_REQ.
	IOMUXC_GPR_GPR7_LPUART8_STOP_REQ = 0x8000
	// stop request off
	IOMUXC_GPR_GPR7_LPUART8_STOP_REQ_LPUART8_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR7_LPUART8_STOP_REQ_LPUART8_STOP_REQ_1 = 0x1
	// Position of LPI2C1_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPI2C1_STOP_ACK_Pos = 0x10
	// Bit mask of LPI2C1_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPI2C1_STOP_ACK_Msk = 0x10000
	// Bit LPI2C1_STOP_ACK.
	IOMUXC_GPR_GPR7_LPI2C1_STOP_ACK = 0x10000
	// stop acknowledge is not asserted
	IOMUXC_GPR_GPR7_LPI2C1_STOP_ACK_LPI2C1_STOP_ACK_0 = 0x0
	// stop acknowledge is asserted (the module is in Stop mode)
	IOMUXC_GPR_GPR7_LPI2C1_STOP_ACK_LPI2C1_STOP_ACK_1 = 0x1
	// Position of LPI2C2_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPI2C2_STOP_ACK_Pos = 0x11
	// Bit mask of LPI2C2_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPI2C2_STOP_ACK_Msk = 0x20000
	// Bit LPI2C2_STOP_ACK.
	IOMUXC_GPR_GPR7_LPI2C2_STOP_ACK = 0x20000
	// stop acknowledge is not asserted
	IOMUXC_GPR_GPR7_LPI2C2_STOP_ACK_LPI2C2_STOP_ACK_0 = 0x0
	// stop acknowledge is asserted
	IOMUXC_GPR_GPR7_LPI2C2_STOP_ACK_LPI2C2_STOP_ACK_1 = 0x1
	// Position of LPI2C3_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPI2C3_STOP_ACK_Pos = 0x12
	// Bit mask of LPI2C3_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPI2C3_STOP_ACK_Msk = 0x40000
	// Bit LPI2C3_STOP_ACK.
	IOMUXC_GPR_GPR7_LPI2C3_STOP_ACK = 0x40000
	// stop acknowledge is not asserted
	IOMUXC_GPR_GPR7_LPI2C3_STOP_ACK_LPI2C3_STOP_ACK_0 = 0x0
	// stop acknowledge is asserted
	IOMUXC_GPR_GPR7_LPI2C3_STOP_ACK_LPI2C3_STOP_ACK_1 = 0x1
	// Position of LPI2C4_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPI2C4_STOP_ACK_Pos = 0x13
	// Bit mask of LPI2C4_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPI2C4_STOP_ACK_Msk = 0x80000
	// Bit LPI2C4_STOP_ACK.
	IOMUXC_GPR_GPR7_LPI2C4_STOP_ACK = 0x80000
	// stop acknowledge is not asserted
	IOMUXC_GPR_GPR7_LPI2C4_STOP_ACK_LPI2C4_STOP_ACK_0 = 0x0
	// stop acknowledge is asserted
	IOMUXC_GPR_GPR7_LPI2C4_STOP_ACK_LPI2C4_STOP_ACK_1 = 0x1
	// Position of LPSPI1_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPSPI1_STOP_ACK_Pos = 0x14
	// Bit mask of LPSPI1_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPSPI1_STOP_ACK_Msk = 0x100000
	// Bit LPSPI1_STOP_ACK.
	IOMUXC_GPR_GPR7_LPSPI1_STOP_ACK = 0x100000
	// stop acknowledge is not asserted
	IOMUXC_GPR_GPR7_LPSPI1_STOP_ACK_LPSPI1_STOP_ACK_0 = 0x0
	// stop acknowledge is asserted
	IOMUXC_GPR_GPR7_LPSPI1_STOP_ACK_LPSPI1_STOP_ACK_1 = 0x1
	// Position of LPSPI2_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPSPI2_STOP_ACK_Pos = 0x15
	// Bit mask of LPSPI2_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPSPI2_STOP_ACK_Msk = 0x200000
	// Bit LPSPI2_STOP_ACK.
	IOMUXC_GPR_GPR7_LPSPI2_STOP_ACK = 0x200000
	// stop acknowledge is not asserted
	IOMUXC_GPR_GPR7_LPSPI2_STOP_ACK_LPSPI2_STOP_ACK_0 = 0x0
	// stop acknowledge is asserted
	IOMUXC_GPR_GPR7_LPSPI2_STOP_ACK_LPSPI2_STOP_ACK_1 = 0x1
	// Position of LPSPI3_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPSPI3_STOP_ACK_Pos = 0x16
	// Bit mask of LPSPI3_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPSPI3_STOP_ACK_Msk = 0x400000
	// Bit LPSPI3_STOP_ACK.
	IOMUXC_GPR_GPR7_LPSPI3_STOP_ACK = 0x400000
	// stop acknowledge is not asserted
	IOMUXC_GPR_GPR7_LPSPI3_STOP_ACK_LPSPI3_STOP_ACK_0 = 0x0
	// stop acknowledge is asserted
	IOMUXC_GPR_GPR7_LPSPI3_STOP_ACK_LPSPI3_STOP_ACK_1 = 0x1
	// Position of LPSPI4_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPSPI4_STOP_ACK_Pos = 0x17
	// Bit mask of LPSPI4_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPSPI4_STOP_ACK_Msk = 0x800000
	// Bit LPSPI4_STOP_ACK.
	IOMUXC_GPR_GPR7_LPSPI4_STOP_ACK = 0x800000
	// stop acknowledge is not asserted
	IOMUXC_GPR_GPR7_LPSPI4_STOP_ACK_LPSPI4_STOP_ACK_0 = 0x0
	// stop acknowledge is asserted
	IOMUXC_GPR_GPR7_LPSPI4_STOP_ACK_LPSPI4_STOP_ACK_1 = 0x1
	// Position of LPUART1_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPUART1_STOP_ACK_Pos = 0x18
	// Bit mask of LPUART1_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPUART1_STOP_ACK_Msk = 0x1000000
	// Bit LPUART1_STOP_ACK.
	IOMUXC_GPR_GPR7_LPUART1_STOP_ACK = 0x1000000
	// stop acknowledge is not asserted
	IOMUXC_GPR_GPR7_LPUART1_STOP_ACK_LPUART1_STOP_ACK_0 = 0x0
	// stop acknowledge is asserted
	IOMUXC_GPR_GPR7_LPUART1_STOP_ACK_LPUART1_STOP_ACK_1 = 0x1
	// Position of LPUART2_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPUART2_STOP_ACK_Pos = 0x19
	// Bit mask of LPUART2_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPUART2_STOP_ACK_Msk = 0x2000000
	// Bit LPUART2_STOP_ACK.
	IOMUXC_GPR_GPR7_LPUART2_STOP_ACK = 0x2000000
	// stop acknowledge is not asserted
	IOMUXC_GPR_GPR7_LPUART2_STOP_ACK_LPUART2_STOP_ACK_0 = 0x0
	// stop acknowledge is asserted
	IOMUXC_GPR_GPR7_LPUART2_STOP_ACK_LPUART2_STOP_ACK_1 = 0x1
	// Position of LPUART3_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPUART3_STOP_ACK_Pos = 0x1a
	// Bit mask of LPUART3_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPUART3_STOP_ACK_Msk = 0x4000000
	// Bit LPUART3_STOP_ACK.
	IOMUXC_GPR_GPR7_LPUART3_STOP_ACK = 0x4000000
	// stop acknowledge is not asserted
	IOMUXC_GPR_GPR7_LPUART3_STOP_ACK_LPUART3_STOP_ACK_0 = 0x0
	// stop acknowledge is asserted
	IOMUXC_GPR_GPR7_LPUART3_STOP_ACK_LPUART3_STOP_ACK_1 = 0x1
	// Position of LPUART4_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPUART4_STOP_ACK_Pos = 0x1b
	// Bit mask of LPUART4_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPUART4_STOP_ACK_Msk = 0x8000000
	// Bit LPUART4_STOP_ACK.
	IOMUXC_GPR_GPR7_LPUART4_STOP_ACK = 0x8000000
	// stop acknowledge is not asserted
	IOMUXC_GPR_GPR7_LPUART4_STOP_ACK_LPUART4_STOP_ACK_0 = 0x0
	// stop acknowledge is asserted
	IOMUXC_GPR_GPR7_LPUART4_STOP_ACK_LPUART4_STOP_ACK_1 = 0x1
	// Position of LPUART5_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPUART5_STOP_ACK_Pos = 0x1c
	// Bit mask of LPUART5_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPUART5_STOP_ACK_Msk = 0x10000000
	// Bit LPUART5_STOP_ACK.
	IOMUXC_GPR_GPR7_LPUART5_STOP_ACK = 0x10000000
	// stop acknowledge is not asserted
	IOMUXC_GPR_GPR7_LPUART5_STOP_ACK_LPUART5_STOP_ACK_0 = 0x0
	// stop acknowledge is asserted
	IOMUXC_GPR_GPR7_LPUART5_STOP_ACK_LPUART5_STOP_ACK_1 = 0x1
	// Position of LPUART6_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPUART6_STOP_ACK_Pos = 0x1d
	// Bit mask of LPUART6_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPUART6_STOP_ACK_Msk = 0x20000000
	// Bit LPUART6_STOP_ACK.
	IOMUXC_GPR_GPR7_LPUART6_STOP_ACK = 0x20000000
	// stop acknowledge is not asserted
	IOMUXC_GPR_GPR7_LPUART6_STOP_ACK_LPUART6_STOP_ACK_0 = 0x0
	// stop acknowledge is asserted
	IOMUXC_GPR_GPR7_LPUART6_STOP_ACK_LPUART6_STOP_ACK_1 = 0x1
	// Position of LPUART7_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPUART7_STOP_ACK_Pos = 0x1e
	// Bit mask of LPUART7_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPUART7_STOP_ACK_Msk = 0x40000000
	// Bit LPUART7_STOP_ACK.
	IOMUXC_GPR_GPR7_LPUART7_STOP_ACK = 0x40000000
	// stop acknowledge is not asserted
	IOMUXC_GPR_GPR7_LPUART7_STOP_ACK_LPUART7_STOP_ACK_0 = 0x0
	// stop acknowledge is asserted
	IOMUXC_GPR_GPR7_LPUART7_STOP_ACK_LPUART7_STOP_ACK_1 = 0x1
	// Position of LPUART8_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPUART8_STOP_ACK_Pos = 0x1f
	// Bit mask of LPUART8_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPUART8_STOP_ACK_Msk = 0x80000000
	// Bit LPUART8_STOP_ACK.
	IOMUXC_GPR_GPR7_LPUART8_STOP_ACK = 0x80000000
	// stop acknowledge is not asserted
	IOMUXC_GPR_GPR7_LPUART8_STOP_ACK_LPUART8_STOP_ACK_0 = 0x0
	// stop acknowledge is asserted (the module is in Stop mode)
	IOMUXC_GPR_GPR7_LPUART8_STOP_ACK_LPUART8_STOP_ACK_1 = 0x1

	// GPR8: GPR8 General Purpose Register
	// Position of LPI2C1_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPI2C1_IPG_STOP_MODE_Pos = 0x0
	// Bit mask of LPI2C1_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPI2C1_IPG_STOP_MODE_Msk = 0x1
	// Bit LPI2C1_IPG_STOP_MODE.
	IOMUXC_GPR_GPR8_LPI2C1_IPG_STOP_MODE = 0x1
	// the module is functional in Stop mode
	IOMUXC_GPR_GPR8_LPI2C1_IPG_STOP_MODE_LPI2C1_IPG_STOP_MODE_0 = 0x0
	// the module is NOT functional in Stop mode, when this bit is equal to 1 and ipg_stop is asserted
	IOMUXC_GPR_GPR8_LPI2C1_IPG_STOP_MODE_LPI2C1_IPG_STOP_MODE_1 = 0x1
	// Position of LPI2C1_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPI2C1_IPG_DOZE_Pos = 0x1
	// Bit mask of LPI2C1_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPI2C1_IPG_DOZE_Msk = 0x2
	// Bit LPI2C1_IPG_DOZE.
	IOMUXC_GPR_GPR8_LPI2C1_IPG_DOZE = 0x2
	// not in doze mode
	IOMUXC_GPR_GPR8_LPI2C1_IPG_DOZE_LPI2C1_IPG_DOZE_0 = 0x0
	// in doze mode
	IOMUXC_GPR_GPR8_LPI2C1_IPG_DOZE_LPI2C1_IPG_DOZE_1 = 0x1
	// Position of LPI2C2_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPI2C2_IPG_STOP_MODE_Pos = 0x2
	// Bit mask of LPI2C2_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPI2C2_IPG_STOP_MODE_Msk = 0x4
	// Bit LPI2C2_IPG_STOP_MODE.
	IOMUXC_GPR_GPR8_LPI2C2_IPG_STOP_MODE = 0x4
	// the module is functional in Stop mode
	IOMUXC_GPR_GPR8_LPI2C2_IPG_STOP_MODE_LPI2C2_IPG_STOP_MODE_0 = 0x0
	// the module is NOT functional in Stop mode, when this bit is equal to 1 and ipg_stop is asserted
	IOMUXC_GPR_GPR8_LPI2C2_IPG_STOP_MODE_LPI2C2_IPG_STOP_MODE_1 = 0x1
	// Position of LPI2C2_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPI2C2_IPG_DOZE_Pos = 0x3
	// Bit mask of LPI2C2_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPI2C2_IPG_DOZE_Msk = 0x8
	// Bit LPI2C2_IPG_DOZE.
	IOMUXC_GPR_GPR8_LPI2C2_IPG_DOZE = 0x8
	// not in doze mode
	IOMUXC_GPR_GPR8_LPI2C2_IPG_DOZE_LPI2C2_IPG_DOZE_0 = 0x0
	// in doze mode
	IOMUXC_GPR_GPR8_LPI2C2_IPG_DOZE_LPI2C2_IPG_DOZE_1 = 0x1
	// Position of LPI2C3_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPI2C3_IPG_STOP_MODE_Pos = 0x4
	// Bit mask of LPI2C3_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPI2C3_IPG_STOP_MODE_Msk = 0x10
	// Bit LPI2C3_IPG_STOP_MODE.
	IOMUXC_GPR_GPR8_LPI2C3_IPG_STOP_MODE = 0x10
	// the module is functional in Stop mode
	IOMUXC_GPR_GPR8_LPI2C3_IPG_STOP_MODE_LPI2C3_IPG_STOP_MODE_0 = 0x0
	// the module is NOT functional in Stop mode, when this bit is equal to 1 and ipg_stop is asserted
	IOMUXC_GPR_GPR8_LPI2C3_IPG_STOP_MODE_LPI2C3_IPG_STOP_MODE_1 = 0x1
	// Position of LPI2C3_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPI2C3_IPG_DOZE_Pos = 0x5
	// Bit mask of LPI2C3_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPI2C3_IPG_DOZE_Msk = 0x20
	// Bit LPI2C3_IPG_DOZE.
	IOMUXC_GPR_GPR8_LPI2C3_IPG_DOZE = 0x20
	// not in doze mode
	IOMUXC_GPR_GPR8_LPI2C3_IPG_DOZE_LPI2C3_IPG_DOZE_0 = 0x0
	// in doze mode
	IOMUXC_GPR_GPR8_LPI2C3_IPG_DOZE_LPI2C3_IPG_DOZE_1 = 0x1
	// Position of LPI2C4_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPI2C4_IPG_STOP_MODE_Pos = 0x6
	// Bit mask of LPI2C4_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPI2C4_IPG_STOP_MODE_Msk = 0x40
	// Bit LPI2C4_IPG_STOP_MODE.
	IOMUXC_GPR_GPR8_LPI2C4_IPG_STOP_MODE = 0x40
	// the module is functional in Stop mode
	IOMUXC_GPR_GPR8_LPI2C4_IPG_STOP_MODE_LPI2C4_IPG_STOP_MODE_0 = 0x0
	// the module is NOT functional in Stop mode, when this bit is equal to 1 and ipg_stop is asserted
	IOMUXC_GPR_GPR8_LPI2C4_IPG_STOP_MODE_LPI2C4_IPG_STOP_MODE_1 = 0x1
	// Position of LPI2C4_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPI2C4_IPG_DOZE_Pos = 0x7
	// Bit mask of LPI2C4_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPI2C4_IPG_DOZE_Msk = 0x80
	// Bit LPI2C4_IPG_DOZE.
	IOMUXC_GPR_GPR8_LPI2C4_IPG_DOZE = 0x80
	// not in doze mode
	IOMUXC_GPR_GPR8_LPI2C4_IPG_DOZE_LPI2C4_IPG_DOZE_0 = 0x0
	// in doze mode
	IOMUXC_GPR_GPR8_LPI2C4_IPG_DOZE_LPI2C4_IPG_DOZE_1 = 0x1
	// Position of LPSPI1_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPSPI1_IPG_STOP_MODE_Pos = 0x8
	// Bit mask of LPSPI1_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPSPI1_IPG_STOP_MODE_Msk = 0x100
	// Bit LPSPI1_IPG_STOP_MODE.
	IOMUXC_GPR_GPR8_LPSPI1_IPG_STOP_MODE = 0x100
	// the module is functional in Stop mode
	IOMUXC_GPR_GPR8_LPSPI1_IPG_STOP_MODE_LPSPI1_IPG_STOP_MODE_0 = 0x0
	// the module is NOT functional in Stop mode, when this bit is equal to 1 and ipg_stop is asserted
	IOMUXC_GPR_GPR8_LPSPI1_IPG_STOP_MODE_LPSPI1_IPG_STOP_MODE_1 = 0x1
	// Position of LPSPI1_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPSPI1_IPG_DOZE_Pos = 0x9
	// Bit mask of LPSPI1_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPSPI1_IPG_DOZE_Msk = 0x200
	// Bit LPSPI1_IPG_DOZE.
	IOMUXC_GPR_GPR8_LPSPI1_IPG_DOZE = 0x200
	// not in doze mode
	IOMUXC_GPR_GPR8_LPSPI1_IPG_DOZE_LPSPI1_IPG_DOZE_0 = 0x0
	// in doze mode
	IOMUXC_GPR_GPR8_LPSPI1_IPG_DOZE_LPSPI1_IPG_DOZE_1 = 0x1
	// Position of LPSPI2_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPSPI2_IPG_STOP_MODE_Pos = 0xa
	// Bit mask of LPSPI2_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPSPI2_IPG_STOP_MODE_Msk = 0x400
	// Bit LPSPI2_IPG_STOP_MODE.
	IOMUXC_GPR_GPR8_LPSPI2_IPG_STOP_MODE = 0x400
	// the module is functional in Stop mode
	IOMUXC_GPR_GPR8_LPSPI2_IPG_STOP_MODE_LPSPI2_IPG_STOP_MODE_0 = 0x0
	// the module is NOT functional in Stop mode, when this bit is equal to 1 and ipg_stop is asserted
	IOMUXC_GPR_GPR8_LPSPI2_IPG_STOP_MODE_LPSPI2_IPG_STOP_MODE_1 = 0x1
	// Position of LPSPI2_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPSPI2_IPG_DOZE_Pos = 0xb
	// Bit mask of LPSPI2_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPSPI2_IPG_DOZE_Msk = 0x800
	// Bit LPSPI2_IPG_DOZE.
	IOMUXC_GPR_GPR8_LPSPI2_IPG_DOZE = 0x800
	// not in doze mode
	IOMUXC_GPR_GPR8_LPSPI2_IPG_DOZE_LPSPI2_IPG_DOZE_0 = 0x0
	// in doze mode
	IOMUXC_GPR_GPR8_LPSPI2_IPG_DOZE_LPSPI2_IPG_DOZE_1 = 0x1
	// Position of LPSPI3_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPSPI3_IPG_STOP_MODE_Pos = 0xc
	// Bit mask of LPSPI3_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPSPI3_IPG_STOP_MODE_Msk = 0x1000
	// Bit LPSPI3_IPG_STOP_MODE.
	IOMUXC_GPR_GPR8_LPSPI3_IPG_STOP_MODE = 0x1000
	// the module is functional in Stop mode
	IOMUXC_GPR_GPR8_LPSPI3_IPG_STOP_MODE_LPSPI3_IPG_STOP_MODE_0 = 0x0
	// the module is NOT functional in Stop mode, when this bit is equal to 1 and ipg_stop is asserted
	IOMUXC_GPR_GPR8_LPSPI3_IPG_STOP_MODE_LPSPI3_IPG_STOP_MODE_1 = 0x1
	// Position of LPSPI3_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPSPI3_IPG_DOZE_Pos = 0xd
	// Bit mask of LPSPI3_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPSPI3_IPG_DOZE_Msk = 0x2000
	// Bit LPSPI3_IPG_DOZE.
	IOMUXC_GPR_GPR8_LPSPI3_IPG_DOZE = 0x2000
	// not in doze mode
	IOMUXC_GPR_GPR8_LPSPI3_IPG_DOZE_LPSPI3_IPG_DOZE_0 = 0x0
	// in doze mode
	IOMUXC_GPR_GPR8_LPSPI3_IPG_DOZE_LPSPI3_IPG_DOZE_1 = 0x1
	// Position of LPSPI4_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPSPI4_IPG_STOP_MODE_Pos = 0xe
	// Bit mask of LPSPI4_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPSPI4_IPG_STOP_MODE_Msk = 0x4000
	// Bit LPSPI4_IPG_STOP_MODE.
	IOMUXC_GPR_GPR8_LPSPI4_IPG_STOP_MODE = 0x4000
	// the module is functional in Stop mode
	IOMUXC_GPR_GPR8_LPSPI4_IPG_STOP_MODE_LPSPI4_IPG_STOP_MODE_0 = 0x0
	// the module is NOT functional in Stop mode, when this bit is equal to 1 and ipg_stop is asserted
	IOMUXC_GPR_GPR8_LPSPI4_IPG_STOP_MODE_LPSPI4_IPG_STOP_MODE_1 = 0x1
	// Position of LPSPI4_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPSPI4_IPG_DOZE_Pos = 0xf
	// Bit mask of LPSPI4_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPSPI4_IPG_DOZE_Msk = 0x8000
	// Bit LPSPI4_IPG_DOZE.
	IOMUXC_GPR_GPR8_LPSPI4_IPG_DOZE = 0x8000
	// not in doze mode
	IOMUXC_GPR_GPR8_LPSPI4_IPG_DOZE_LPSPI4_IPG_DOZE_0 = 0x0
	// in doze mode
	IOMUXC_GPR_GPR8_LPSPI4_IPG_DOZE_LPSPI4_IPG_DOZE_1 = 0x1
	// Position of LPUART1_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPUART1_IPG_STOP_MODE_Pos = 0x10
	// Bit mask of LPUART1_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPUART1_IPG_STOP_MODE_Msk = 0x10000
	// Bit LPUART1_IPG_STOP_MODE.
	IOMUXC_GPR_GPR8_LPUART1_IPG_STOP_MODE = 0x10000
	// the module is functional in Stop mode
	IOMUXC_GPR_GPR8_LPUART1_IPG_STOP_MODE_LPUART1_IPG_STOP_MODE_0 = 0x0
	// the module is NOT functional in Stop mode, when this bit is equal to 1 and ipg_stop is asserted
	IOMUXC_GPR_GPR8_LPUART1_IPG_STOP_MODE_LPUART1_IPG_STOP_MODE_1 = 0x1
	// Position of LPUART1_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPUART1_IPG_DOZE_Pos = 0x11
	// Bit mask of LPUART1_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPUART1_IPG_DOZE_Msk = 0x20000
	// Bit LPUART1_IPG_DOZE.
	IOMUXC_GPR_GPR8_LPUART1_IPG_DOZE = 0x20000
	// not in doze mode
	IOMUXC_GPR_GPR8_LPUART1_IPG_DOZE_LPUART1_IPG_DOZE_0 = 0x0
	// in doze mode
	IOMUXC_GPR_GPR8_LPUART1_IPG_DOZE_LPUART1_IPG_DOZE_1 = 0x1
	// Position of LPUART2_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPUART2_IPG_STOP_MODE_Pos = 0x12
	// Bit mask of LPUART2_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPUART2_IPG_STOP_MODE_Msk = 0x40000
	// Bit LPUART2_IPG_STOP_MODE.
	IOMUXC_GPR_GPR8_LPUART2_IPG_STOP_MODE = 0x40000
	// the module is functional in Stop mode
	IOMUXC_GPR_GPR8_LPUART2_IPG_STOP_MODE_LPUART2_IPG_STOP_MODE_0 = 0x0
	// the module is NOT functional in Stop mode, when this bit is equal to 1 and ipg_stop is asserted
	IOMUXC_GPR_GPR8_LPUART2_IPG_STOP_MODE_LPUART2_IPG_STOP_MODE_1 = 0x1
	// Position of LPUART2_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPUART2_IPG_DOZE_Pos = 0x13
	// Bit mask of LPUART2_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPUART2_IPG_DOZE_Msk = 0x80000
	// Bit LPUART2_IPG_DOZE.
	IOMUXC_GPR_GPR8_LPUART2_IPG_DOZE = 0x80000
	// not in doze mode
	IOMUXC_GPR_GPR8_LPUART2_IPG_DOZE_LPUART2_IPG_DOZE_0 = 0x0
	// in doze mode
	IOMUXC_GPR_GPR8_LPUART2_IPG_DOZE_LPUART2_IPG_DOZE_1 = 0x1
	// Position of LPUART3_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPUART3_IPG_STOP_MODE_Pos = 0x14
	// Bit mask of LPUART3_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPUART3_IPG_STOP_MODE_Msk = 0x100000
	// Bit LPUART3_IPG_STOP_MODE.
	IOMUXC_GPR_GPR8_LPUART3_IPG_STOP_MODE = 0x100000
	// the module is functional in Stop mode
	IOMUXC_GPR_GPR8_LPUART3_IPG_STOP_MODE_LPUART3_IPG_STOP_MODE_0 = 0x0
	// the module is NOT functional in Stop mode, when this bit is equal to 1 and ipg_stop is asserted
	IOMUXC_GPR_GPR8_LPUART3_IPG_STOP_MODE_LPUART3_IPG_STOP_MODE_1 = 0x1
	// Position of LPUART3_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPUART3_IPG_DOZE_Pos = 0x15
	// Bit mask of LPUART3_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPUART3_IPG_DOZE_Msk = 0x200000
	// Bit LPUART3_IPG_DOZE.
	IOMUXC_GPR_GPR8_LPUART3_IPG_DOZE = 0x200000
	// not in doze mode
	IOMUXC_GPR_GPR8_LPUART3_IPG_DOZE_LPUART3_IPG_DOZE_0 = 0x0
	// in doze mode
	IOMUXC_GPR_GPR8_LPUART3_IPG_DOZE_LPUART3_IPG_DOZE_1 = 0x1
	// Position of LPUART4_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPUART4_IPG_STOP_MODE_Pos = 0x16
	// Bit mask of LPUART4_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPUART4_IPG_STOP_MODE_Msk = 0x400000
	// Bit LPUART4_IPG_STOP_MODE.
	IOMUXC_GPR_GPR8_LPUART4_IPG_STOP_MODE = 0x400000
	// the module is functional in Stop mode
	IOMUXC_GPR_GPR8_LPUART4_IPG_STOP_MODE_LPUART4_IPG_STOP_MODE_0 = 0x0
	// the module is NOT functional in Stop mode, when this bit is equal to 1 and ipg_stop is asserted
	IOMUXC_GPR_GPR8_LPUART4_IPG_STOP_MODE_LPUART4_IPG_STOP_MODE_1 = 0x1
	// Position of LPUART4_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPUART4_IPG_DOZE_Pos = 0x17
	// Bit mask of LPUART4_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPUART4_IPG_DOZE_Msk = 0x800000
	// Bit LPUART4_IPG_DOZE.
	IOMUXC_GPR_GPR8_LPUART4_IPG_DOZE = 0x800000
	// not in doze mode
	IOMUXC_GPR_GPR8_LPUART4_IPG_DOZE_LPUART4_IPG_DOZE_0 = 0x0
	// in doze mode
	IOMUXC_GPR_GPR8_LPUART4_IPG_DOZE_LPUART4_IPG_DOZE_1 = 0x1
	// Position of LPUART5_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPUART5_IPG_STOP_MODE_Pos = 0x18
	// Bit mask of LPUART5_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPUART5_IPG_STOP_MODE_Msk = 0x1000000
	// Bit LPUART5_IPG_STOP_MODE.
	IOMUXC_GPR_GPR8_LPUART5_IPG_STOP_MODE = 0x1000000
	// the module is functional in Stop mode
	IOMUXC_GPR_GPR8_LPUART5_IPG_STOP_MODE_LPUART5_IPG_STOP_MODE_0 = 0x0
	// the module is NOT functional in Stop mode, when this bit is equal to 1 and ipg_stop is asserted
	IOMUXC_GPR_GPR8_LPUART5_IPG_STOP_MODE_LPUART5_IPG_STOP_MODE_1 = 0x1
	// Position of LPUART5_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPUART5_IPG_DOZE_Pos = 0x19
	// Bit mask of LPUART5_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPUART5_IPG_DOZE_Msk = 0x2000000
	// Bit LPUART5_IPG_DOZE.
	IOMUXC_GPR_GPR8_LPUART5_IPG_DOZE = 0x2000000
	// not in doze mode
	IOMUXC_GPR_GPR8_LPUART5_IPG_DOZE_LPUART5_IPG_DOZE_0 = 0x0
	// in doze mode
	IOMUXC_GPR_GPR8_LPUART5_IPG_DOZE_LPUART5_IPG_DOZE_1 = 0x1
	// Position of LPUART6_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPUART6_IPG_STOP_MODE_Pos = 0x1a
	// Bit mask of LPUART6_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPUART6_IPG_STOP_MODE_Msk = 0x4000000
	// Bit LPUART6_IPG_STOP_MODE.
	IOMUXC_GPR_GPR8_LPUART6_IPG_STOP_MODE = 0x4000000
	// the module is functional in Stop mode
	IOMUXC_GPR_GPR8_LPUART6_IPG_STOP_MODE_LPUART6_IPG_STOP_MODE_0 = 0x0
	// the module is NOT functional in Stop mode, when this bit is equal to 1 and ipg_stop is asserted
	IOMUXC_GPR_GPR8_LPUART6_IPG_STOP_MODE_LPUART6_IPG_STOP_MODE_1 = 0x1
	// Position of LPUART6_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPUART6_IPG_DOZE_Pos = 0x1b
	// Bit mask of LPUART6_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPUART6_IPG_DOZE_Msk = 0x8000000
	// Bit LPUART6_IPG_DOZE.
	IOMUXC_GPR_GPR8_LPUART6_IPG_DOZE = 0x8000000
	// not in doze mode
	IOMUXC_GPR_GPR8_LPUART6_IPG_DOZE_LPUART6_IPG_DOZE_0 = 0x0
	// in doze mode
	IOMUXC_GPR_GPR8_LPUART6_IPG_DOZE_LPUART6_IPG_DOZE_1 = 0x1
	// Position of LPUART7_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPUART7_IPG_STOP_MODE_Pos = 0x1c
	// Bit mask of LPUART7_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPUART7_IPG_STOP_MODE_Msk = 0x10000000
	// Bit LPUART7_IPG_STOP_MODE.
	IOMUXC_GPR_GPR8_LPUART7_IPG_STOP_MODE = 0x10000000
	// the module is functional in Stop mode
	IOMUXC_GPR_GPR8_LPUART7_IPG_STOP_MODE_LPUART7_IPG_STOP_MODE_0 = 0x0
	// the module is NOT functional in Stop mode, when this bit is equal to 1 and ipg_stop is asserted
	IOMUXC_GPR_GPR8_LPUART7_IPG_STOP_MODE_LPUART7_IPG_STOP_MODE_1 = 0x1
	// Position of LPUART7_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPUART7_IPG_DOZE_Pos = 0x1d
	// Bit mask of LPUART7_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPUART7_IPG_DOZE_Msk = 0x20000000
	// Bit LPUART7_IPG_DOZE.
	IOMUXC_GPR_GPR8_LPUART7_IPG_DOZE = 0x20000000
	// not in doze mode
	IOMUXC_GPR_GPR8_LPUART7_IPG_DOZE_LPUART7_IPG_DOZE_0 = 0x0
	// in doze mode
	IOMUXC_GPR_GPR8_LPUART7_IPG_DOZE_LPUART7_IPG_DOZE_1 = 0x1
	// Position of LPUART8_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPUART8_IPG_STOP_MODE_Pos = 0x1e
	// Bit mask of LPUART8_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPUART8_IPG_STOP_MODE_Msk = 0x40000000
	// Bit LPUART8_IPG_STOP_MODE.
	IOMUXC_GPR_GPR8_LPUART8_IPG_STOP_MODE = 0x40000000
	// the module is functional in Stop mode
	IOMUXC_GPR_GPR8_LPUART8_IPG_STOP_MODE_LPUART8_IPG_STOP_MODE_0 = 0x0
	// the module is NOT functional in Stop mode, when this bit is equal to 1 and ipg_stop is asserted
	IOMUXC_GPR_GPR8_LPUART8_IPG_STOP_MODE_LPUART8_IPG_STOP_MODE_1 = 0x1
	// Position of LPUART8_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPUART8_IPG_DOZE_Pos = 0x1f
	// Bit mask of LPUART8_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPUART8_IPG_DOZE_Msk = 0x80000000
	// Bit LPUART8_IPG_DOZE.
	IOMUXC_GPR_GPR8_LPUART8_IPG_DOZE = 0x80000000
	// not in doze mode
	IOMUXC_GPR_GPR8_LPUART8_IPG_DOZE_LPUART8_IPG_DOZE_0 = 0x0
	// in doze mode
	IOMUXC_GPR_GPR8_LPUART8_IPG_DOZE_LPUART8_IPG_DOZE_1 = 0x1

	// GPR10: GPR10 General Purpose Register
	// Position of NIDEN field.
	IOMUXC_GPR_GPR10_NIDEN_Pos = 0x0
	// Bit mask of NIDEN field.
	IOMUXC_GPR_GPR10_NIDEN_Msk = 0x1
	// Bit NIDEN.
	IOMUXC_GPR_GPR10_NIDEN = 0x1
	// Debug turned off.
	IOMUXC_GPR_GPR10_NIDEN_NIDEN_0 = 0x0
	// Debug enabled (default).
	IOMUXC_GPR_GPR10_NIDEN_NIDEN_1 = 0x1
	// Position of DBG_EN field.
	IOMUXC_GPR_GPR10_DBG_EN_Pos = 0x1
	// Bit mask of DBG_EN field.
	IOMUXC_GPR_GPR10_DBG_EN_Msk = 0x2
	// Bit DBG_EN.
	IOMUXC_GPR_GPR10_DBG_EN = 0x2
	// Debug turned off.
	IOMUXC_GPR_GPR10_DBG_EN_DBG_EN_0 = 0x0
	// Debug enabled (default).
	IOMUXC_GPR_GPR10_DBG_EN_DBG_EN_1 = 0x1
	// Position of SEC_ERR_RESP field.
	IOMUXC_GPR_GPR10_SEC_ERR_RESP_Pos = 0x2
	// Bit mask of SEC_ERR_RESP field.
	IOMUXC_GPR_GPR10_SEC_ERR_RESP_Msk = 0x4
	// Bit SEC_ERR_RESP.
	IOMUXC_GPR_GPR10_SEC_ERR_RESP = 0x4
	// OKEY response
	IOMUXC_GPR_GPR10_SEC_ERR_RESP_SEC_ERR_RESP_0 = 0x0
	// SLVError (default)
	IOMUXC_GPR_GPR10_SEC_ERR_RESP_SEC_ERR_RESP_1 = 0x1
	// Position of DCPKEY_OCOTP_OR_KEYMUX field.
	IOMUXC_GPR_GPR10_DCPKEY_OCOTP_OR_KEYMUX_Pos = 0x4
	// Bit mask of DCPKEY_OCOTP_OR_KEYMUX field.
	IOMUXC_GPR_GPR10_DCPKEY_OCOTP_OR_KEYMUX_Msk = 0x10
	// Bit DCPKEY_OCOTP_OR_KEYMUX.
	IOMUXC_GPR_GPR10_DCPKEY_OCOTP_OR_KEYMUX = 0x10
	// Select key from Key MUX (SNVS/OTPMK).
	IOMUXC_GPR_GPR10_DCPKEY_OCOTP_OR_KEYMUX_DCPKEY_OCOTP_OR_KEYMUX_0 = 0x0
	// Select key from OCOTP (SW_GP2).
	IOMUXC_GPR_GPR10_DCPKEY_OCOTP_OR_KEYMUX_DCPKEY_OCOTP_OR_KEYMUX_1 = 0x1
	// Position of OCRAM_TZ_EN field.
	IOMUXC_GPR_GPR10_OCRAM_TZ_EN_Pos = 0x8
	// Bit mask of OCRAM_TZ_EN field.
	IOMUXC_GPR_GPR10_OCRAM_TZ_EN_Msk = 0x100
	// Bit OCRAM_TZ_EN.
	IOMUXC_GPR_GPR10_OCRAM_TZ_EN = 0x100
	// The TrustZone feature is disabled. Entire OCRAM space is available for all access types (secure/non-secure/user/supervisor).
	IOMUXC_GPR_GPR10_OCRAM_TZ_EN_OCRAM_TZ_EN_0 = 0x0
	// The TrustZone feature is enabled. Access to address in the range specified by [ENDADDR:STARTADDR] follows the execution mode access policy described in CSU chapter.
	IOMUXC_GPR_GPR10_OCRAM_TZ_EN_OCRAM_TZ_EN_1 = 0x1
	// Position of OCRAM_TZ_ADDR field.
	IOMUXC_GPR_GPR10_OCRAM_TZ_ADDR_Pos = 0x9
	// Bit mask of OCRAM_TZ_ADDR field.
	IOMUXC_GPR_GPR10_OCRAM_TZ_ADDR_Msk = 0xfe00
	// Position of LOCK_NIDEN field.
	IOMUXC_GPR_GPR10_LOCK_NIDEN_Pos = 0x10
	// Bit mask of LOCK_NIDEN field.
	IOMUXC_GPR_GPR10_LOCK_NIDEN_Msk = 0x10000
	// Bit LOCK_NIDEN.
	IOMUXC_GPR_GPR10_LOCK_NIDEN = 0x10000
	// Field is not locked
	IOMUXC_GPR_GPR10_LOCK_NIDEN_LOCK_NIDEN_0 = 0x0
	// Field is locked (read access only)
	IOMUXC_GPR_GPR10_LOCK_NIDEN_LOCK_NIDEN_1 = 0x1
	// Position of LOCK_DBG_EN field.
	IOMUXC_GPR_GPR10_LOCK_DBG_EN_Pos = 0x11
	// Bit mask of LOCK_DBG_EN field.
	IOMUXC_GPR_GPR10_LOCK_DBG_EN_Msk = 0x20000
	// Bit LOCK_DBG_EN.
	IOMUXC_GPR_GPR10_LOCK_DBG_EN = 0x20000
	// Field is not locked
	IOMUXC_GPR_GPR10_LOCK_DBG_EN_LOCK_DBG_EN_0 = 0x0
	// Field is locked (read access only)
	IOMUXC_GPR_GPR10_LOCK_DBG_EN_LOCK_DBG_EN_1 = 0x1
	// Position of LOCK_SEC_ERR_RESP field.
	IOMUXC_GPR_GPR10_LOCK_SEC_ERR_RESP_Pos = 0x12
	// Bit mask of LOCK_SEC_ERR_RESP field.
	IOMUXC_GPR_GPR10_LOCK_SEC_ERR_RESP_Msk = 0x40000
	// Bit LOCK_SEC_ERR_RESP.
	IOMUXC_GPR_GPR10_LOCK_SEC_ERR_RESP = 0x40000
	// Field is not locked
	IOMUXC_GPR_GPR10_LOCK_SEC_ERR_RESP_LOCK_SEC_ERR_RESP_0 = 0x0
	// Field is locked (read access only)
	IOMUXC_GPR_GPR10_LOCK_SEC_ERR_RESP_LOCK_SEC_ERR_RESP_1 = 0x1
	// Position of LOCK_DCPKEY_OCOTP_OR_KEYMUX field.
	IOMUXC_GPR_GPR10_LOCK_DCPKEY_OCOTP_OR_KEYMUX_Pos = 0x14
	// Bit mask of LOCK_DCPKEY_OCOTP_OR_KEYMUX field.
	IOMUXC_GPR_GPR10_LOCK_DCPKEY_OCOTP_OR_KEYMUX_Msk = 0x100000
	// Bit LOCK_DCPKEY_OCOTP_OR_KEYMUX.
	IOMUXC_GPR_GPR10_LOCK_DCPKEY_OCOTP_OR_KEYMUX = 0x100000
	// Field is not locked
	IOMUXC_GPR_GPR10_LOCK_DCPKEY_OCOTP_OR_KEYMUX_LOCK_DCPKEY_OCOTP_OR_KEYMUX_0 = 0x0
	// Field is locked (read access only)
	IOMUXC_GPR_GPR10_LOCK_DCPKEY_OCOTP_OR_KEYMUX_LOCK_DCPKEY_OCOTP_OR_KEYMUX_1 = 0x1
	// Position of LOCK_OCRAM_TZ_EN field.
	IOMUXC_GPR_GPR10_LOCK_OCRAM_TZ_EN_Pos = 0x18
	// Bit mask of LOCK_OCRAM_TZ_EN field.
	IOMUXC_GPR_GPR10_LOCK_OCRAM_TZ_EN_Msk = 0x1000000
	// Bit LOCK_OCRAM_TZ_EN.
	IOMUXC_GPR_GPR10_LOCK_OCRAM_TZ_EN = 0x1000000
	// Field is not locked
	IOMUXC_GPR_GPR10_LOCK_OCRAM_TZ_EN_LOCK_OCRAM_TZ_EN_0 = 0x0
	// Field is locked (read access only)
	IOMUXC_GPR_GPR10_LOCK_OCRAM_TZ_EN_LOCK_OCRAM_TZ_EN_1 = 0x1
	// Position of LOCK_OCRAM_TZ_ADDR field.
	IOMUXC_GPR_GPR10_LOCK_OCRAM_TZ_ADDR_Pos = 0x19
	// Bit mask of LOCK_OCRAM_TZ_ADDR field.
	IOMUXC_GPR_GPR10_LOCK_OCRAM_TZ_ADDR_Msk = 0xfe000000
	// Field is not locked
	IOMUXC_GPR_GPR10_LOCK_OCRAM_TZ_ADDR_LOCK_OCRAM_TZ_ADDR_0 = 0x0
	// Field is locked (read access only)
	IOMUXC_GPR_GPR10_LOCK_OCRAM_TZ_ADDR_LOCK_OCRAM_TZ_ADDR_1 = 0x1

	// GPR11: GPR11 General Purpose Register
	// Position of M7_APC_AC_R0_CTRL field.
	IOMUXC_GPR_GPR11_M7_APC_AC_R0_CTRL_Pos = 0x0
	// Bit mask of M7_APC_AC_R0_CTRL field.
	IOMUXC_GPR_GPR11_M7_APC_AC_R0_CTRL_Msk = 0x3
	// No access protection
	IOMUXC_GPR_GPR11_M7_APC_AC_R0_CTRL_M7_APC_AC_R0_CTRL_0 = 0x0
	// M7 debug protection enabled
	IOMUXC_GPR_GPR11_M7_APC_AC_R0_CTRL_M7_APC_AC_R0_CTRL_1 = 0x1
	// FlexSPI access protection
	IOMUXC_GPR_GPR11_M7_APC_AC_R0_CTRL_M7_APC_AC_R0_CTRL_2 = 0x2
	// Both M7 debug and FlexSPI access are protected
	IOMUXC_GPR_GPR11_M7_APC_AC_R0_CTRL_M7_APC_AC_R0_CTRL_3 = 0x3
	// Position of M7_APC_AC_R1_CTRL field.
	IOMUXC_GPR_GPR11_M7_APC_AC_R1_CTRL_Pos = 0x2
	// Bit mask of M7_APC_AC_R1_CTRL field.
	IOMUXC_GPR_GPR11_M7_APC_AC_R1_CTRL_Msk = 0xc
	// No access protection
	IOMUXC_GPR_GPR11_M7_APC_AC_R1_CTRL_M7_APC_AC_R1_CTRL_0 = 0x0
	// M7 debug protection enabled
	IOMUXC_GPR_GPR11_M7_APC_AC_R1_CTRL_M7_APC_AC_R1_CTRL_1 = 0x1
	// FlexSPI access protection
	IOMUXC_GPR_GPR11_M7_APC_AC_R1_CTRL_M7_APC_AC_R1_CTRL_2 = 0x2
	// Both M7 debug and FlexSPI access are protected
	IOMUXC_GPR_GPR11_M7_APC_AC_R1_CTRL_M7_APC_AC_R1_CTRL_3 = 0x3
	// Position of M7_APC_AC_R2_CTRL field.
	IOMUXC_GPR_GPR11_M7_APC_AC_R2_CTRL_Pos = 0x4
	// Bit mask of M7_APC_AC_R2_CTRL field.
	IOMUXC_GPR_GPR11_M7_APC_AC_R2_CTRL_Msk = 0x30
	// No access protection
	IOMUXC_GPR_GPR11_M7_APC_AC_R2_CTRL_M7_APC_AC_R2_CTRL_0 = 0x0
	// M7 debug protection enabled
	IOMUXC_GPR_GPR11_M7_APC_AC_R2_CTRL_M7_APC_AC_R2_CTRL_1 = 0x1
	// FlexSPI access protection
	IOMUXC_GPR_GPR11_M7_APC_AC_R2_CTRL_M7_APC_AC_R2_CTRL_2 = 0x2
	// Both M7 debug and FlexSPI access are protected
	IOMUXC_GPR_GPR11_M7_APC_AC_R2_CTRL_M7_APC_AC_R2_CTRL_3 = 0x3
	// Position of M7_APC_AC_R3_CTRL field.
	IOMUXC_GPR_GPR11_M7_APC_AC_R3_CTRL_Pos = 0x6
	// Bit mask of M7_APC_AC_R3_CTRL field.
	IOMUXC_GPR_GPR11_M7_APC_AC_R3_CTRL_Msk = 0xc0
	// No access protection
	IOMUXC_GPR_GPR11_M7_APC_AC_R3_CTRL_M7_APC_AC_R3_CTRL_0 = 0x0
	// M7 debug protection enabled
	IOMUXC_GPR_GPR11_M7_APC_AC_R3_CTRL_M7_APC_AC_R3_CTRL_1 = 0x1
	// FlexSPI access protection
	IOMUXC_GPR_GPR11_M7_APC_AC_R3_CTRL_M7_APC_AC_R3_CTRL_2 = 0x2
	// Both M7 debug and FlexSPI access are protected
	IOMUXC_GPR_GPR11_M7_APC_AC_R3_CTRL_M7_APC_AC_R3_CTRL_3 = 0x3
	// Position of BEE_DE_RX_EN field.
	IOMUXC_GPR_GPR11_BEE_DE_RX_EN_Pos = 0x8
	// Bit mask of BEE_DE_RX_EN field.
	IOMUXC_GPR_GPR11_BEE_DE_RX_EN_Msk = 0xf00

	// GPR12: GPR12 General Purpose Register
	// Position of FLEXIO1_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR12_FLEXIO1_IPG_STOP_MODE_Pos = 0x0
	// Bit mask of FLEXIO1_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR12_FLEXIO1_IPG_STOP_MODE_Msk = 0x1
	// Bit FLEXIO1_IPG_STOP_MODE.
	IOMUXC_GPR_GPR12_FLEXIO1_IPG_STOP_MODE = 0x1
	// FlexIO1 is functional in Stop mode.
	IOMUXC_GPR_GPR12_FLEXIO1_IPG_STOP_MODE_FLEXIO1_IPG_STOP_MODE_0 = 0x0
	// When this bit is equal to 1'b1 and ipg_stop is asserted, FlexIO1 is not functional in Stop mode.
	IOMUXC_GPR_GPR12_FLEXIO1_IPG_STOP_MODE_FLEXIO1_IPG_STOP_MODE_1 = 0x1
	// Position of FLEXIO1_IPG_DOZE field.
	IOMUXC_GPR_GPR12_FLEXIO1_IPG_DOZE_Pos = 0x1
	// Bit mask of FLEXIO1_IPG_DOZE field.
	IOMUXC_GPR_GPR12_FLEXIO1_IPG_DOZE_Msk = 0x2
	// Bit FLEXIO1_IPG_DOZE.
	IOMUXC_GPR_GPR12_FLEXIO1_IPG_DOZE = 0x2
	// FLEXIO1 is not in doze mode
	IOMUXC_GPR_GPR12_FLEXIO1_IPG_DOZE_FLEXIO1_IPG_DOZE_0 = 0x0
	// FLEXIO1 is in doze mode
	IOMUXC_GPR_GPR12_FLEXIO1_IPG_DOZE_FLEXIO1_IPG_DOZE_1 = 0x1
	// Position of FLEXIO2_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR12_FLEXIO2_IPG_STOP_MODE_Pos = 0x2
	// Bit mask of FLEXIO2_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR12_FLEXIO2_IPG_STOP_MODE_Msk = 0x4
	// Bit FLEXIO2_IPG_STOP_MODE.
	IOMUXC_GPR_GPR12_FLEXIO2_IPG_STOP_MODE = 0x4
	// FlexIO2 is functional in Stop mode.
	IOMUXC_GPR_GPR12_FLEXIO2_IPG_STOP_MODE_FLEXIO2_IPG_STOP_MODE_0 = 0x0
	// When this bit is equal to 1'b1 and ipg_stop is asserted, FlexIO2 is not functional in Stop mode.
	IOMUXC_GPR_GPR12_FLEXIO2_IPG_STOP_MODE_FLEXIO2_IPG_STOP_MODE_1 = 0x1
	// Position of FLEXIO2_IPG_DOZE field.
	IOMUXC_GPR_GPR12_FLEXIO2_IPG_DOZE_Pos = 0x3
	// Bit mask of FLEXIO2_IPG_DOZE field.
	IOMUXC_GPR_GPR12_FLEXIO2_IPG_DOZE_Msk = 0x8
	// Bit FLEXIO2_IPG_DOZE.
	IOMUXC_GPR_GPR12_FLEXIO2_IPG_DOZE = 0x8
	// FLEXIO2 is not in doze mode
	IOMUXC_GPR_GPR12_FLEXIO2_IPG_DOZE_FLEXIO2_IPG_DOZE_0 = 0x0
	// FLEXIO2 is in doze mode
	IOMUXC_GPR_GPR12_FLEXIO2_IPG_DOZE_FLEXIO2_IPG_DOZE_1 = 0x1
	// Position of ACMP_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR12_ACMP_IPG_STOP_MODE_Pos = 0x4
	// Bit mask of ACMP_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR12_ACMP_IPG_STOP_MODE_Msk = 0x10
	// Bit ACMP_IPG_STOP_MODE.
	IOMUXC_GPR_GPR12_ACMP_IPG_STOP_MODE = 0x10
	// ACMP is functional in Stop mode.
	IOMUXC_GPR_GPR12_ACMP_IPG_STOP_MODE_ACMP_IPG_STOP_MODE_0 = 0x0
	// When this bit is equal to 1'b1 and ipg_stop is asserted, ACMP is not functional in Stop mode.
	IOMUXC_GPR_GPR12_ACMP_IPG_STOP_MODE_ACMP_IPG_STOP_MODE_1 = 0x1
	// Position of FLEXIO3_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR12_FLEXIO3_IPG_STOP_MODE_Pos = 0x5
	// Bit mask of FLEXIO3_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR12_FLEXIO3_IPG_STOP_MODE_Msk = 0x20
	// Bit FLEXIO3_IPG_STOP_MODE.
	IOMUXC_GPR_GPR12_FLEXIO3_IPG_STOP_MODE = 0x20
	// FlexIO3 is functional in Stop mode.
	IOMUXC_GPR_GPR12_FLEXIO3_IPG_STOP_MODE_FLEXIO3_IPG_STOP_MODE_0 = 0x0
	// When this bit is equal to 1'b1 and ipg_stop is asserted, FlexIO3 is not functional in Stop mode.
	IOMUXC_GPR_GPR12_FLEXIO3_IPG_STOP_MODE_FLEXIO3_IPG_STOP_MODE_1 = 0x1
	// Position of FLEXIO3_IPG_DOZE field.
	IOMUXC_GPR_GPR12_FLEXIO3_IPG_DOZE_Pos = 0x6
	// Bit mask of FLEXIO3_IPG_DOZE field.
	IOMUXC_GPR_GPR12_FLEXIO3_IPG_DOZE_Msk = 0x40
	// Bit FLEXIO3_IPG_DOZE.
	IOMUXC_GPR_GPR12_FLEXIO3_IPG_DOZE = 0x40
	// FLEXIO3 is not in doze mode
	IOMUXC_GPR_GPR12_FLEXIO3_IPG_DOZE_FLEXIO3_IPG_DOZE_0 = 0x0
	// FLEXIO3 is in doze mode
	IOMUXC_GPR_GPR12_FLEXIO3_IPG_DOZE_FLEXIO3_IPG_DOZE_1 = 0x1

	// GPR13: GPR13 General Purpose Register
	// Position of ARCACHE_USDHC field.
	IOMUXC_GPR_GPR13_ARCACHE_USDHC_Pos = 0x0
	// Bit mask of ARCACHE_USDHC field.
	IOMUXC_GPR_GPR13_ARCACHE_USDHC_Msk = 0x1
	// Bit ARCACHE_USDHC.
	IOMUXC_GPR_GPR13_ARCACHE_USDHC = 0x1
	// Cacheable attribute is off for read transactions.
	IOMUXC_GPR_GPR13_ARCACHE_USDHC_ARCACHE_USDHC_0 = 0x0
	// Cacheable attribute is on for read transactions.
	IOMUXC_GPR_GPR13_ARCACHE_USDHC_ARCACHE_USDHC_1 = 0x1
	// Position of AWCACHE_USDHC field.
	IOMUXC_GPR_GPR13_AWCACHE_USDHC_Pos = 0x1
	// Bit mask of AWCACHE_USDHC field.
	IOMUXC_GPR_GPR13_AWCACHE_USDHC_Msk = 0x2
	// Bit AWCACHE_USDHC.
	IOMUXC_GPR_GPR13_AWCACHE_USDHC = 0x2
	// Cacheable attribute is off for write transactions.
	IOMUXC_GPR_GPR13_AWCACHE_USDHC_AWCACHE_USDHC_0 = 0x0
	// Cacheable attribute is on for write transactions.
	IOMUXC_GPR_GPR13_AWCACHE_USDHC_AWCACHE_USDHC_1 = 0x1
	// Position of CANFD_STOP_REQ field.
	IOMUXC_GPR_GPR13_CANFD_STOP_REQ_Pos = 0x4
	// Bit mask of CANFD_STOP_REQ field.
	IOMUXC_GPR_GPR13_CANFD_STOP_REQ_Msk = 0x10
	// Bit CANFD_STOP_REQ.
	IOMUXC_GPR_GPR13_CANFD_STOP_REQ = 0x10
	// stop request off
	IOMUXC_GPR_GPR13_CANFD_STOP_REQ_CANFD_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR13_CANFD_STOP_REQ_CANFD_STOP_REQ_1 = 0x1
	// Position of CACHE_ENET field.
	IOMUXC_GPR_GPR13_CACHE_ENET_Pos = 0x7
	// Bit mask of CACHE_ENET field.
	IOMUXC_GPR_GPR13_CACHE_ENET_Msk = 0x80
	// Bit CACHE_ENET.
	IOMUXC_GPR_GPR13_CACHE_ENET = 0x80
	// Cacheable attribute is off for read/write transactions.
	IOMUXC_GPR_GPR13_CACHE_ENET_CACHE_ENET_0 = 0x0
	// Cacheable attribute is on for read/write transactions.
	IOMUXC_GPR_GPR13_CACHE_ENET_CACHE_ENET_1 = 0x1
	// Position of CACHE_USB field.
	IOMUXC_GPR_GPR13_CACHE_USB_Pos = 0xd
	// Bit mask of CACHE_USB field.
	IOMUXC_GPR_GPR13_CACHE_USB_Msk = 0x2000
	// Bit CACHE_USB.
	IOMUXC_GPR_GPR13_CACHE_USB = 0x2000
	// Cacheable attribute is off for read/write transactions.
	IOMUXC_GPR_GPR13_CACHE_USB_CACHE_USB_0 = 0x0
	// Cacheable attribute is on for read/write transactions.
	IOMUXC_GPR_GPR13_CACHE_USB_CACHE_USB_1 = 0x1
	// Position of CANFD_STOP_ACK field.
	IOMUXC_GPR_GPR13_CANFD_STOP_ACK_Pos = 0x14
	// Bit mask of CANFD_STOP_ACK field.
	IOMUXC_GPR_GPR13_CANFD_STOP_ACK_Msk = 0x100000
	// Bit CANFD_STOP_ACK.
	IOMUXC_GPR_GPR13_CANFD_STOP_ACK = 0x100000
	// CANFD stop acknowledge is not asserted
	IOMUXC_GPR_GPR13_CANFD_STOP_ACK_CANFD_STOP_ACK_0 = 0x0
	// CANFD stop acknowledge is asserted
	IOMUXC_GPR_GPR13_CANFD_STOP_ACK_CANFD_STOP_ACK_1 = 0x1

	// GPR14: GPR14 General Purpose Register
	// Position of ACMP1_CMP_IGEN_TRIM_DN field.
	IOMUXC_GPR_GPR14_ACMP1_CMP_IGEN_TRIM_DN_Pos = 0x0
	// Bit mask of ACMP1_CMP_IGEN_TRIM_DN field.
	IOMUXC_GPR_GPR14_ACMP1_CMP_IGEN_TRIM_DN_Msk = 0x1
	// Bit ACMP1_CMP_IGEN_TRIM_DN.
	IOMUXC_GPR_GPR14_ACMP1_CMP_IGEN_TRIM_DN = 0x1
	// no reduce
	IOMUXC_GPR_GPR14_ACMP1_CMP_IGEN_TRIM_DN_ACMP1_CMP_IGEN_TRIM_DN_0 = 0x0
	// reduces
	IOMUXC_GPR_GPR14_ACMP1_CMP_IGEN_TRIM_DN_ACMP1_CMP_IGEN_TRIM_DN_1 = 0x1
	// Position of ACMP2_CMP_IGEN_TRIM_DN field.
	IOMUXC_GPR_GPR14_ACMP2_CMP_IGEN_TRIM_DN_Pos = 0x1
	// Bit mask of ACMP2_CMP_IGEN_TRIM_DN field.
	IOMUXC_GPR_GPR14_ACMP2_CMP_IGEN_TRIM_DN_Msk = 0x2
	// Bit ACMP2_CMP_IGEN_TRIM_DN.
	IOMUXC_GPR_GPR14_ACMP2_CMP_IGEN_TRIM_DN = 0x2
	// no reduce
	IOMUXC_GPR_GPR14_ACMP2_CMP_IGEN_TRIM_DN_ACMP2_CMP_IGEN_TRIM_DN_0 = 0x0
	// reduces
	IOMUXC_GPR_GPR14_ACMP2_CMP_IGEN_TRIM_DN_ACMP2_CMP_IGEN_TRIM_DN_1 = 0x1
	// Position of ACMP3_CMP_IGEN_TRIM_DN field.
	IOMUXC_GPR_GPR14_ACMP3_CMP_IGEN_TRIM_DN_Pos = 0x2
	// Bit mask of ACMP3_CMP_IGEN_TRIM_DN field.
	IOMUXC_GPR_GPR14_ACMP3_CMP_IGEN_TRIM_DN_Msk = 0x4
	// Bit ACMP3_CMP_IGEN_TRIM_DN.
	IOMUXC_GPR_GPR14_ACMP3_CMP_IGEN_TRIM_DN = 0x4
	// no reduce
	IOMUXC_GPR_GPR14_ACMP3_CMP_IGEN_TRIM_DN_ACMP3_CMP_IGEN_TRIM_DN_0 = 0x0
	// reduces
	IOMUXC_GPR_GPR14_ACMP3_CMP_IGEN_TRIM_DN_ACMP3_CMP_IGEN_TRIM_DN_1 = 0x1
	// Position of ACMP4_CMP_IGEN_TRIM_DN field.
	IOMUXC_GPR_GPR14_ACMP4_CMP_IGEN_TRIM_DN_Pos = 0x3
	// Bit mask of ACMP4_CMP_IGEN_TRIM_DN field.
	IOMUXC_GPR_GPR14_ACMP4_CMP_IGEN_TRIM_DN_Msk = 0x8
	// Bit ACMP4_CMP_IGEN_TRIM_DN.
	IOMUXC_GPR_GPR14_ACMP4_CMP_IGEN_TRIM_DN = 0x8
	// no reduce
	IOMUXC_GPR_GPR14_ACMP4_CMP_IGEN_TRIM_DN_ACMP4_CMP_IGEN_TRIM_DN_0 = 0x0
	// reduces
	IOMUXC_GPR_GPR14_ACMP4_CMP_IGEN_TRIM_DN_ACMP4_CMP_IGEN_TRIM_DN_1 = 0x1
	// Position of ACMP1_CMP_IGEN_TRIM_UP field.
	IOMUXC_GPR_GPR14_ACMP1_CMP_IGEN_TRIM_UP_Pos = 0x4
	// Bit mask of ACMP1_CMP_IGEN_TRIM_UP field.
	IOMUXC_GPR_GPR14_ACMP1_CMP_IGEN_TRIM_UP_Msk = 0x10
	// Bit ACMP1_CMP_IGEN_TRIM_UP.
	IOMUXC_GPR_GPR14_ACMP1_CMP_IGEN_TRIM_UP = 0x10
	// no increase
	IOMUXC_GPR_GPR14_ACMP1_CMP_IGEN_TRIM_UP_ACMP1_CMP_IGEN_TRIM_UP_0 = 0x0
	// increases
	IOMUXC_GPR_GPR14_ACMP1_CMP_IGEN_TRIM_UP_ACMP1_CMP_IGEN_TRIM_UP_1 = 0x1
	// Position of ACMP2_CMP_IGEN_TRIM_UP field.
	IOMUXC_GPR_GPR14_ACMP2_CMP_IGEN_TRIM_UP_Pos = 0x5
	// Bit mask of ACMP2_CMP_IGEN_TRIM_UP field.
	IOMUXC_GPR_GPR14_ACMP2_CMP_IGEN_TRIM_UP_Msk = 0x20
	// Bit ACMP2_CMP_IGEN_TRIM_UP.
	IOMUXC_GPR_GPR14_ACMP2_CMP_IGEN_TRIM_UP = 0x20
	// no increase
	IOMUXC_GPR_GPR14_ACMP2_CMP_IGEN_TRIM_UP_ACMP2_CMP_IGEN_TRIM_UP_0 = 0x0
	// increases
	IOMUXC_GPR_GPR14_ACMP2_CMP_IGEN_TRIM_UP_ACMP2_CMP_IGEN_TRIM_UP_1 = 0x1
	// Position of ACMP3_CMP_IGEN_TRIM_UP field.
	IOMUXC_GPR_GPR14_ACMP3_CMP_IGEN_TRIM_UP_Pos = 0x6
	// Bit mask of ACMP3_CMP_IGEN_TRIM_UP field.
	IOMUXC_GPR_GPR14_ACMP3_CMP_IGEN_TRIM_UP_Msk = 0x40
	// Bit ACMP3_CMP_IGEN_TRIM_UP.
	IOMUXC_GPR_GPR14_ACMP3_CMP_IGEN_TRIM_UP = 0x40
	// no increase
	IOMUXC_GPR_GPR14_ACMP3_CMP_IGEN_TRIM_UP_ACMP3_CMP_IGEN_TRIM_UP_0 = 0x0
	// increases
	IOMUXC_GPR_GPR14_ACMP3_CMP_IGEN_TRIM_UP_ACMP3_CMP_IGEN_TRIM_UP_1 = 0x1
	// Position of ACMP4_CMP_IGEN_TRIM_UP field.
	IOMUXC_GPR_GPR14_ACMP4_CMP_IGEN_TRIM_UP_Pos = 0x7
	// Bit mask of ACMP4_CMP_IGEN_TRIM_UP field.
	IOMUXC_GPR_GPR14_ACMP4_CMP_IGEN_TRIM_UP_Msk = 0x80
	// Bit ACMP4_CMP_IGEN_TRIM_UP.
	IOMUXC_GPR_GPR14_ACMP4_CMP_IGEN_TRIM_UP = 0x80
	// no increase
	IOMUXC_GPR_GPR14_ACMP4_CMP_IGEN_TRIM_UP_ACMP4_CMP_IGEN_TRIM_UP_0 = 0x0
	// increases
	IOMUXC_GPR_GPR14_ACMP4_CMP_IGEN_TRIM_UP_ACMP4_CMP_IGEN_TRIM_UP_1 = 0x1
	// Position of ACMP1_SAMPLE_SYNC_EN field.
	IOMUXC_GPR_GPR14_ACMP1_SAMPLE_SYNC_EN_Pos = 0x8
	// Bit mask of ACMP1_SAMPLE_SYNC_EN field.
	IOMUXC_GPR_GPR14_ACMP1_SAMPLE_SYNC_EN_Msk = 0x100
	// Bit ACMP1_SAMPLE_SYNC_EN.
	IOMUXC_GPR_GPR14_ACMP1_SAMPLE_SYNC_EN = 0x100
	// select XBAR output
	IOMUXC_GPR_GPR14_ACMP1_SAMPLE_SYNC_EN_ACMP1_SAMPLE_SYNC_EN_0 = 0x0
	// select synced sample_lv
	IOMUXC_GPR_GPR14_ACMP1_SAMPLE_SYNC_EN_ACMP1_SAMPLE_SYNC_EN_1 = 0x1
	// Position of ACMP2_SAMPLE_SYNC_EN field.
	IOMUXC_GPR_GPR14_ACMP2_SAMPLE_SYNC_EN_Pos = 0x9
	// Bit mask of ACMP2_SAMPLE_SYNC_EN field.
	IOMUXC_GPR_GPR14_ACMP2_SAMPLE_SYNC_EN_Msk = 0x200
	// Bit ACMP2_SAMPLE_SYNC_EN.
	IOMUXC_GPR_GPR14_ACMP2_SAMPLE_SYNC_EN = 0x200
	// select XBAR output
	IOMUXC_GPR_GPR14_ACMP2_SAMPLE_SYNC_EN_ACMP2_SAMPLE_SYNC_EN_0 = 0x0
	// select synced sample_lv
	IOMUXC_GPR_GPR14_ACMP2_SAMPLE_SYNC_EN_ACMP2_SAMPLE_SYNC_EN_1 = 0x1
	// Position of ACMP3_SAMPLE_SYNC_EN field.
	IOMUXC_GPR_GPR14_ACMP3_SAMPLE_SYNC_EN_Pos = 0xa
	// Bit mask of ACMP3_SAMPLE_SYNC_EN field.
	IOMUXC_GPR_GPR14_ACMP3_SAMPLE_SYNC_EN_Msk = 0x400
	// Bit ACMP3_SAMPLE_SYNC_EN.
	IOMUXC_GPR_GPR14_ACMP3_SAMPLE_SYNC_EN = 0x400
	// select XBAR output
	IOMUXC_GPR_GPR14_ACMP3_SAMPLE_SYNC_EN_ACMP3_SAMPLE_SYNC_EN_0 = 0x0
	// select synced sample_lv
	IOMUXC_GPR_GPR14_ACMP3_SAMPLE_SYNC_EN_ACMP3_SAMPLE_SYNC_EN_1 = 0x1
	// Position of ACMP4_SAMPLE_SYNC_EN field.
	IOMUXC_GPR_GPR14_ACMP4_SAMPLE_SYNC_EN_Pos = 0xb
	// Bit mask of ACMP4_SAMPLE_SYNC_EN field.
	IOMUXC_GPR_GPR14_ACMP4_SAMPLE_SYNC_EN_Msk = 0x800
	// Bit ACMP4_SAMPLE_SYNC_EN.
	IOMUXC_GPR_GPR14_ACMP4_SAMPLE_SYNC_EN = 0x800
	// select XBAR output
	IOMUXC_GPR_GPR14_ACMP4_SAMPLE_SYNC_EN_ACMP4_SAMPLE_SYNC_EN_0 = 0x0
	// select synced sample_lv
	IOMUXC_GPR_GPR14_ACMP4_SAMPLE_SYNC_EN_ACMP4_SAMPLE_SYNC_EN_1 = 0x1
	// Position of CM7_CFGITCMSZ field.
	IOMUXC_GPR_GPR14_CM7_CFGITCMSZ_Pos = 0x10
	// Bit mask of CM7_CFGITCMSZ field.
	IOMUXC_GPR_GPR14_CM7_CFGITCMSZ_Msk = 0xf0000
	// 0 KB (No ITCM)
	IOMUXC_GPR_GPR14_CM7_CFGITCMSZ_CM7_CFGITCMSZ_0 = 0x0
	// 4 KB
	IOMUXC_GPR_GPR14_CM7_CFGITCMSZ_CM7_CFGITCMSZ_3 = 0x3
	// 8 KB
	IOMUXC_GPR_GPR14_CM7_CFGITCMSZ_CM7_CFGITCMSZ_4 = 0x4
	// 16 KB
	IOMUXC_GPR_GPR14_CM7_CFGITCMSZ_CM7_CFGITCMSZ_5 = 0x5
	// 32 KB
	IOMUXC_GPR_GPR14_CM7_CFGITCMSZ_CM7_CFGITCMSZ_6 = 0x6
	// 64 KB
	IOMUXC_GPR_GPR14_CM7_CFGITCMSZ_CM7_CFGITCMSZ_7 = 0x7
	// 128 KB
	IOMUXC_GPR_GPR14_CM7_CFGITCMSZ_CM7_CFGITCMSZ_8 = 0x8
	// 256 KB
	IOMUXC_GPR_GPR14_CM7_CFGITCMSZ_CM7_CFGITCMSZ_9 = 0x9
	// 512 KB
	IOMUXC_GPR_GPR14_CM7_CFGITCMSZ_CM7_CFGITCMSZ_10 = 0xa
	// Position of CM7_CFGDTCMSZ field.
	IOMUXC_GPR_GPR14_CM7_CFGDTCMSZ_Pos = 0x14
	// Bit mask of CM7_CFGDTCMSZ field.
	IOMUXC_GPR_GPR14_CM7_CFGDTCMSZ_Msk = 0xf00000
	// 0 KB (No DTCM)
	IOMUXC_GPR_GPR14_CM7_CFGDTCMSZ_CM7_CFGDTCMSZ_0 = 0x0
	// 4 KB
	IOMUXC_GPR_GPR14_CM7_CFGDTCMSZ_CM7_CFGDTCMSZ_3 = 0x3
	// 8 KB
	IOMUXC_GPR_GPR14_CM7_CFGDTCMSZ_CM7_CFGDTCMSZ_4 = 0x4
	// 16 KB
	IOMUXC_GPR_GPR14_CM7_CFGDTCMSZ_CM7_CFGDTCMSZ_5 = 0x5
	// 32 KB
	IOMUXC_GPR_GPR14_CM7_CFGDTCMSZ_CM7_CFGDTCMSZ_6 = 0x6
	// 64 KB
	IOMUXC_GPR_GPR14_CM7_CFGDTCMSZ_CM7_CFGDTCMSZ_7 = 0x7
	// 128 KB
	IOMUXC_GPR_GPR14_CM7_CFGDTCMSZ_CM7_CFGDTCMSZ_8 = 0x8
	// 256 KB
	IOMUXC_GPR_GPR14_CM7_CFGDTCMSZ_CM7_CFGDTCMSZ_9 = 0x9
	// 512 KB
	IOMUXC_GPR_GPR14_CM7_CFGDTCMSZ_CM7_CFGDTCMSZ_10 = 0xa

	// GPR16: GPR16 General Purpose Register
	// Position of INIT_ITCM_EN field.
	IOMUXC_GPR_GPR16_INIT_ITCM_EN_Pos = 0x0
	// Bit mask of INIT_ITCM_EN field.
	IOMUXC_GPR_GPR16_INIT_ITCM_EN_Msk = 0x1
	// Bit INIT_ITCM_EN.
	IOMUXC_GPR_GPR16_INIT_ITCM_EN = 0x1
	// ITCM is disabled
	IOMUXC_GPR_GPR16_INIT_ITCM_EN_INIT_ITCM_EN_0 = 0x0
	// ITCM is enabled
	IOMUXC_GPR_GPR16_INIT_ITCM_EN_INIT_ITCM_EN_1 = 0x1
	// Position of INIT_DTCM_EN field.
	IOMUXC_GPR_GPR16_INIT_DTCM_EN_Pos = 0x1
	// Bit mask of INIT_DTCM_EN field.
	IOMUXC_GPR_GPR16_INIT_DTCM_EN_Msk = 0x2
	// Bit INIT_DTCM_EN.
	IOMUXC_GPR_GPR16_INIT_DTCM_EN = 0x2
	// DTCM is disabled
	IOMUXC_GPR_GPR16_INIT_DTCM_EN_INIT_DTCM_EN_0 = 0x0
	// DTCM is enabled
	IOMUXC_GPR_GPR16_INIT_DTCM_EN_INIT_DTCM_EN_1 = 0x1
	// Position of FLEXRAM_BANK_CFG_SEL field.
	IOMUXC_GPR_GPR16_FLEXRAM_BANK_CFG_SEL_Pos = 0x2
	// Bit mask of FLEXRAM_BANK_CFG_SEL field.
	IOMUXC_GPR_GPR16_FLEXRAM_BANK_CFG_SEL_Msk = 0x4
	// Bit FLEXRAM_BANK_CFG_SEL.
	IOMUXC_GPR_GPR16_FLEXRAM_BANK_CFG_SEL = 0x4
	// use fuse value to config
	IOMUXC_GPR_GPR16_FLEXRAM_BANK_CFG_SEL_FLEXRAM_BANK_CFG_SEL_0 = 0x0
	// use FLEXRAM_BANK_CFG to config
	IOMUXC_GPR_GPR16_FLEXRAM_BANK_CFG_SEL_FLEXRAM_BANK_CFG_SEL_1 = 0x1

	// GPR17: GPR17 General Purpose Register
	// Position of FLEXRAM_BANK_CFG field.
	IOMUXC_GPR_GPR17_FLEXRAM_BANK_CFG_Pos = 0x0
	// Bit mask of FLEXRAM_BANK_CFG field.
	IOMUXC_GPR_GPR17_FLEXRAM_BANK_CFG_Msk = 0xffffffff

	// GPR18: GPR18 General Purpose Register
	// Position of LOCK_M7_APC_AC_R0_BOT field.
	IOMUXC_GPR_GPR18_LOCK_M7_APC_AC_R0_BOT_Pos = 0x0
	// Bit mask of LOCK_M7_APC_AC_R0_BOT field.
	IOMUXC_GPR_GPR18_LOCK_M7_APC_AC_R0_BOT_Msk = 0x1
	// Bit LOCK_M7_APC_AC_R0_BOT.
	IOMUXC_GPR_GPR18_LOCK_M7_APC_AC_R0_BOT = 0x1
	// Register field [31:1] is not locked
	IOMUXC_GPR_GPR18_LOCK_M7_APC_AC_R0_BOT_LOCK_M7_APC_AC_R0_BOT_0 = 0x0
	// Register field [31:1] is locked (read access only)
	IOMUXC_GPR_GPR18_LOCK_M7_APC_AC_R0_BOT_LOCK_M7_APC_AC_R0_BOT_1 = 0x1
	// Position of M7_APC_AC_R0_BOT field.
	IOMUXC_GPR_GPR18_M7_APC_AC_R0_BOT_Pos = 0x3
	// Bit mask of M7_APC_AC_R0_BOT field.
	IOMUXC_GPR_GPR18_M7_APC_AC_R0_BOT_Msk = 0xfffffff8

	// GPR19: GPR19 General Purpose Register
	// Position of LOCK_M7_APC_AC_R0_TOP field.
	IOMUXC_GPR_GPR19_LOCK_M7_APC_AC_R0_TOP_Pos = 0x0
	// Bit mask of LOCK_M7_APC_AC_R0_TOP field.
	IOMUXC_GPR_GPR19_LOCK_M7_APC_AC_R0_TOP_Msk = 0x1
	// Bit LOCK_M7_APC_AC_R0_TOP.
	IOMUXC_GPR_GPR19_LOCK_M7_APC_AC_R0_TOP = 0x1
	// Register field [31:1] is not locked
	IOMUXC_GPR_GPR19_LOCK_M7_APC_AC_R0_TOP_LOCK_M7_APC_AC_R0_TOP_0 = 0x0
	// Register field [31:1] is locked (read access only)
	IOMUXC_GPR_GPR19_LOCK_M7_APC_AC_R0_TOP_LOCK_M7_APC_AC_R0_TOP_1 = 0x1
	// Position of M7_APC_AC_R0_TOP field.
	IOMUXC_GPR_GPR19_M7_APC_AC_R0_TOP_Pos = 0x3
	// Bit mask of M7_APC_AC_R0_TOP field.
	IOMUXC_GPR_GPR19_M7_APC_AC_R0_TOP_Msk = 0xfffffff8

	// GPR20: GPR20 General Purpose Register
	// Position of LOCK_M7_APC_AC_R1_BOT field.
	IOMUXC_GPR_GPR20_LOCK_M7_APC_AC_R1_BOT_Pos = 0x0
	// Bit mask of LOCK_M7_APC_AC_R1_BOT field.
	IOMUXC_GPR_GPR20_LOCK_M7_APC_AC_R1_BOT_Msk = 0x1
	// Bit LOCK_M7_APC_AC_R1_BOT.
	IOMUXC_GPR_GPR20_LOCK_M7_APC_AC_R1_BOT = 0x1
	// Register field [31:1] is not locked
	IOMUXC_GPR_GPR20_LOCK_M7_APC_AC_R1_BOT_LOCK_M7_APC_AC_R1_BOT_0 = 0x0
	// Register field [31:1] is locked (read access only)
	IOMUXC_GPR_GPR20_LOCK_M7_APC_AC_R1_BOT_LOCK_M7_APC_AC_R1_BOT_1 = 0x1
	// Position of M7_APC_AC_R1_BOT field.
	IOMUXC_GPR_GPR20_M7_APC_AC_R1_BOT_Pos = 0x3
	// Bit mask of M7_APC_AC_R1_BOT field.
	IOMUXC_GPR_GPR20_M7_APC_AC_R1_BOT_Msk = 0xfffffff8

	// GPR21: GPR21 General Purpose Register
	// Position of LOCK_M7_APC_AC_R1_TOP field.
	IOMUXC_GPR_GPR21_LOCK_M7_APC_AC_R1_TOP_Pos = 0x0
	// Bit mask of LOCK_M7_APC_AC_R1_TOP field.
	IOMUXC_GPR_GPR21_LOCK_M7_APC_AC_R1_TOP_Msk = 0x1
	// Bit LOCK_M7_APC_AC_R1_TOP.
	IOMUXC_GPR_GPR21_LOCK_M7_APC_AC_R1_TOP = 0x1
	// Register field [31:1] is not locked
	IOMUXC_GPR_GPR21_LOCK_M7_APC_AC_R1_TOP_LOCK_M7_APC_AC_R1_TOP_0 = 0x0
	// Register field [31:1] is locked (read access only)
	IOMUXC_GPR_GPR21_LOCK_M7_APC_AC_R1_TOP_LOCK_M7_APC_AC_R1_TOP_1 = 0x1
	// Position of M7_APC_AC_R1_TOP field.
	IOMUXC_GPR_GPR21_M7_APC_AC_R1_TOP_Pos = 0x3
	// Bit mask of M7_APC_AC_R1_TOP field.
	IOMUXC_GPR_GPR21_M7_APC_AC_R1_TOP_Msk = 0xfffffff8

	// GPR22: GPR22 General Purpose Register
	// Position of LOCK_M7_APC_AC_R2_BOT field.
	IOMUXC_GPR_GPR22_LOCK_M7_APC_AC_R2_BOT_Pos = 0x0
	// Bit mask of LOCK_M7_APC_AC_R2_BOT field.
	IOMUXC_GPR_GPR22_LOCK_M7_APC_AC_R2_BOT_Msk = 0x1
	// Bit LOCK_M7_APC_AC_R2_BOT.
	IOMUXC_GPR_GPR22_LOCK_M7_APC_AC_R2_BOT = 0x1
	// Register field [31:1] is not locked
	IOMUXC_GPR_GPR22_LOCK_M7_APC_AC_R2_BOT_LOCK_M7_APC_AC_R2_BOT_0 = 0x0
	// Register field [31:1] is locked (read access only)
	IOMUXC_GPR_GPR22_LOCK_M7_APC_AC_R2_BOT_LOCK_M7_APC_AC_R2_BOT_1 = 0x1
	// Position of M7_APC_AC_R2_BOT field.
	IOMUXC_GPR_GPR22_M7_APC_AC_R2_BOT_Pos = 0x3
	// Bit mask of M7_APC_AC_R2_BOT field.
	IOMUXC_GPR_GPR22_M7_APC_AC_R2_BOT_Msk = 0xfffffff8

	// GPR23: GPR23 General Purpose Register
	// Position of LOCK_M7_APC_AC_R2_TOP field.
	IOMUXC_GPR_GPR23_LOCK_M7_APC_AC_R2_TOP_Pos = 0x0
	// Bit mask of LOCK_M7_APC_AC_R2_TOP field.
	IOMUXC_GPR_GPR23_LOCK_M7_APC_AC_R2_TOP_Msk = 0x1
	// Bit LOCK_M7_APC_AC_R2_TOP.
	IOMUXC_GPR_GPR23_LOCK_M7_APC_AC_R2_TOP = 0x1
	// Register field [31:1] is not locked
	IOMUXC_GPR_GPR23_LOCK_M7_APC_AC_R2_TOP_LOCK_M7_APC_AC_R2_TOP_0 = 0x0
	// Register field [31:1] is locked (read access only)
	IOMUXC_GPR_GPR23_LOCK_M7_APC_AC_R2_TOP_LOCK_M7_APC_AC_R2_TOP_1 = 0x1
	// Position of M7_APC_AC_R2_TOP field.
	IOMUXC_GPR_GPR23_M7_APC_AC_R2_TOP_Pos = 0x3
	// Bit mask of M7_APC_AC_R2_TOP field.
	IOMUXC_GPR_GPR23_M7_APC_AC_R2_TOP_Msk = 0xfffffff8

	// GPR24: GPR24 General Purpose Register
	// Position of LOCK_M7_APC_AC_R3_BOT field.
	IOMUXC_GPR_GPR24_LOCK_M7_APC_AC_R3_BOT_Pos = 0x0
	// Bit mask of LOCK_M7_APC_AC_R3_BOT field.
	IOMUXC_GPR_GPR24_LOCK_M7_APC_AC_R3_BOT_Msk = 0x1
	// Bit LOCK_M7_APC_AC_R3_BOT.
	IOMUXC_GPR_GPR24_LOCK_M7_APC_AC_R3_BOT = 0x1
	// Register field [31:1] is not locked
	IOMUXC_GPR_GPR24_LOCK_M7_APC_AC_R3_BOT_LOCK_M7_APC_AC_R3_BOT_0 = 0x0
	// Register field [31:1] is locked (read access only)
	IOMUXC_GPR_GPR24_LOCK_M7_APC_AC_R3_BOT_LOCK_M7_APC_AC_R3_BOT_1 = 0x1
	// Position of M7_APC_AC_R3_BOT field.
	IOMUXC_GPR_GPR24_M7_APC_AC_R3_BOT_Pos = 0x3
	// Bit mask of M7_APC_AC_R3_BOT field.
	IOMUXC_GPR_GPR24_M7_APC_AC_R3_BOT_Msk = 0xfffffff8

	// GPR25: GPR25 General Purpose Register
	// Position of LOCK_M7_APC_AC_R3_TOP field.
	IOMUXC_GPR_GPR25_LOCK_M7_APC_AC_R3_TOP_Pos = 0x0
	// Bit mask of LOCK_M7_APC_AC_R3_TOP field.
	IOMUXC_GPR_GPR25_LOCK_M7_APC_AC_R3_TOP_Msk = 0x1
	// Bit LOCK_M7_APC_AC_R3_TOP.
	IOMUXC_GPR_GPR25_LOCK_M7_APC_AC_R3_TOP = 0x1
	// Register field [31:1] is not locked
	IOMUXC_GPR_GPR25_LOCK_M7_APC_AC_R3_TOP_LOCK_M7_APC_AC_R3_TOP_0 = 0x0
	// Register field [31:1] is locked (read access only)
	IOMUXC_GPR_GPR25_LOCK_M7_APC_AC_R3_TOP_LOCK_M7_APC_AC_R3_TOP_1 = 0x1
	// Position of M7_APC_AC_R3_TOP field.
	IOMUXC_GPR_GPR25_M7_APC_AC_R3_TOP_Pos = 0x3
	// Bit mask of M7_APC_AC_R3_TOP field.
	IOMUXC_GPR_GPR25_M7_APC_AC_R3_TOP_Msk = 0xfffffff8

	// GPR26: GPR26 General Purpose Register
	// Position of GPIO_MUX1_GPIO_SEL field.
	IOMUXC_GPR_GPR26_GPIO_MUX1_GPIO_SEL_Pos = 0x0
	// Bit mask of GPIO_MUX1_GPIO_SEL field.
	IOMUXC_GPR_GPR26_GPIO_MUX1_GPIO_SEL_Msk = 0xffffffff

	// GPR27: GPR27 General Purpose Register
	// Position of GPIO_MUX2_GPIO_SEL field.
	IOMUXC_GPR_GPR27_GPIO_MUX2_GPIO_SEL_Pos = 0x0
	// Bit mask of GPIO_MUX2_GPIO_SEL field.
	IOMUXC_GPR_GPR27_GPIO_MUX2_GPIO_SEL_Msk = 0xffffffff

	// GPR28: GPR28 General Purpose Register
	// Position of GPIO_MUX3_GPIO_SEL field.
	IOMUXC_GPR_GPR28_GPIO_MUX3_GPIO_SEL_Pos = 0x0
	// Bit mask of GPIO_MUX3_GPIO_SEL field.
	IOMUXC_GPR_GPR28_GPIO_MUX3_GPIO_SEL_Msk = 0xffffffff

	// GPR29: GPR29 General Purpose Register
	// Position of GPIO_MUX4_GPIO_SEL field.
	IOMUXC_GPR_GPR29_GPIO_MUX4_GPIO_SEL_Pos = 0x0
	// Bit mask of GPIO_MUX4_GPIO_SEL field.
	IOMUXC_GPR_GPR29_GPIO_MUX4_GPIO_SEL_Msk = 0xffffffff

	// GPR30: GPR30 General Purpose Register
	// Position of FLEXSPI_REMAP_ADDR_START field.
	IOMUXC_GPR_GPR30_FLEXSPI_REMAP_ADDR_START_Pos = 0xc
	// Bit mask of FLEXSPI_REMAP_ADDR_START field.
	IOMUXC_GPR_GPR30_FLEXSPI_REMAP_ADDR_START_Msk = 0xfffff000

	// GPR31: GPR31 General Purpose Register
	// Position of FLEXSPI_REMAP_ADDR_END field.
	IOMUXC_GPR_GPR31_FLEXSPI_REMAP_ADDR_END_Pos = 0xc
	// Bit mask of FLEXSPI_REMAP_ADDR_END field.
	IOMUXC_GPR_GPR31_FLEXSPI_REMAP_ADDR_END_Msk = 0xfffff000

	// GPR32: GPR32 General Purpose Register
	// Position of FLEXSPI_REMAP_ADDR_OFFSET field.
	IOMUXC_GPR_GPR32_FLEXSPI_REMAP_ADDR_OFFSET_Pos = 0xc
	// Bit mask of FLEXSPI_REMAP_ADDR_OFFSET field.
	IOMUXC_GPR_GPR32_FLEXSPI_REMAP_ADDR_OFFSET_Msk = 0xfffff000

	// GPR33: GPR33 General Purpose Register
	// Position of OCRAM2_TZ_EN field.
	IOMUXC_GPR_GPR33_OCRAM2_TZ_EN_Pos = 0x0
	// Bit mask of OCRAM2_TZ_EN field.
	IOMUXC_GPR_GPR33_OCRAM2_TZ_EN_Msk = 0x1
	// Bit OCRAM2_TZ_EN.
	IOMUXC_GPR_GPR33_OCRAM2_TZ_EN = 0x1
	// The TrustZone feature is disabled. Entire OCRAM2 space is available for all access types (secure/non-secure/user/supervisor).
	IOMUXC_GPR_GPR33_OCRAM2_TZ_EN_OCRAM2_TZ_EN_0 = 0x0
	// The TrustZone feature is enabled. Access to address in the range specified by [ENDADDR:STARTADDR] follows the execution mode access policy described in CSU chapter.
	IOMUXC_GPR_GPR33_OCRAM2_TZ_EN_OCRAM2_TZ_EN_1 = 0x1
	// Position of OCRAM2_TZ_ADDR field.
	IOMUXC_GPR_GPR33_OCRAM2_TZ_ADDR_Pos = 0x1
	// Bit mask of OCRAM2_TZ_ADDR field.
	IOMUXC_GPR_GPR33_OCRAM2_TZ_ADDR_Msk = 0xfe
	// Position of LOCK_OCRAM2_TZ_EN field.
	IOMUXC_GPR_GPR33_LOCK_OCRAM2_TZ_EN_Pos = 0x10
	// Bit mask of LOCK_OCRAM2_TZ_EN field.
	IOMUXC_GPR_GPR33_LOCK_OCRAM2_TZ_EN_Msk = 0x10000
	// Bit LOCK_OCRAM2_TZ_EN.
	IOMUXC_GPR_GPR33_LOCK_OCRAM2_TZ_EN = 0x10000
	// Field is not locked
	IOMUXC_GPR_GPR33_LOCK_OCRAM2_TZ_EN_LOCK_OCRAM2_TZ_EN_0 = 0x0
	// Field is locked (read access only)
	IOMUXC_GPR_GPR33_LOCK_OCRAM2_TZ_EN_LOCK_OCRAM2_TZ_EN_1 = 0x1
	// Position of LOCK_OCRAM2_TZ_ADDR field.
	IOMUXC_GPR_GPR33_LOCK_OCRAM2_TZ_ADDR_Pos = 0x11
	// Bit mask of LOCK_OCRAM2_TZ_ADDR field.
	IOMUXC_GPR_GPR33_LOCK_OCRAM2_TZ_ADDR_Msk = 0xfe0000
	// Field is not locked
	IOMUXC_GPR_GPR33_LOCK_OCRAM2_TZ_ADDR_LOCK_OCRAM2_TZ_ADDR_0 = 0x0
	// Field is locked (read access only)
	IOMUXC_GPR_GPR33_LOCK_OCRAM2_TZ_ADDR_LOCK_OCRAM2_TZ_ADDR_1 = 0x1

	// GPR34: GPR34 General Purpose Register
	// Position of SIP_TEST_MUX_BOOT_PIN_SEL field.
	IOMUXC_GPR_GPR34_SIP_TEST_MUX_BOOT_PIN_SEL_Pos = 0x0
	// Bit mask of SIP_TEST_MUX_BOOT_PIN_SEL field.
	IOMUXC_GPR_GPR34_SIP_TEST_MUX_BOOT_PIN_SEL_Msk = 0xff
	// Position of SIP_TEST_MUX_QSPI_SIP_EN field.
	IOMUXC_GPR_GPR34_SIP_TEST_MUX_QSPI_SIP_EN_Pos = 0x8
	// Bit mask of SIP_TEST_MUX_QSPI_SIP_EN field.
	IOMUXC_GPR_GPR34_SIP_TEST_MUX_QSPI_SIP_EN_Msk = 0x100
	// Bit SIP_TEST_MUX_QSPI_SIP_EN.
	IOMUXC_GPR_GPR34_SIP_TEST_MUX_QSPI_SIP_EN = 0x100
	// SIP_TEST_MUX is disabled
	IOMUXC_GPR_GPR34_SIP_TEST_MUX_QSPI_SIP_EN_SIP_TEST_MUX_QSPI_SIP_EN_0 = 0x0
	// SIP_TEST_MUX is enabled
	IOMUXC_GPR_GPR34_SIP_TEST_MUX_QSPI_SIP_EN_SIP_TEST_MUX_QSPI_SIP_EN_1 = 0x1
)

// Bitfields for FLEXRAM: FLEXRAM
const (
	// TCM_CTRL: TCM CRTL Register
	// Position of TCM_WWAIT_EN field.
	FLEXRAM_TCM_CTRL_TCM_WWAIT_EN_Pos = 0x0
	// Bit mask of TCM_WWAIT_EN field.
	FLEXRAM_TCM_CTRL_TCM_WWAIT_EN_Msk = 0x1
	// Bit TCM_WWAIT_EN.
	FLEXRAM_TCM_CTRL_TCM_WWAIT_EN = 0x1
	// TCM write fast mode: Write RAM accesses are expected to be finished in 1-cycle.
	FLEXRAM_TCM_CTRL_TCM_WWAIT_EN_TCM_WWAIT_EN_0 = 0x0
	// TCM write wait mode: Write RAM accesses are expected to be finished in 2-cycles.
	FLEXRAM_TCM_CTRL_TCM_WWAIT_EN_TCM_WWAIT_EN_1 = 0x1
	// Position of TCM_RWAIT_EN field.
	FLEXRAM_TCM_CTRL_TCM_RWAIT_EN_Pos = 0x1
	// Bit mask of TCM_RWAIT_EN field.
	FLEXRAM_TCM_CTRL_TCM_RWAIT_EN_Msk = 0x2
	// Bit TCM_RWAIT_EN.
	FLEXRAM_TCM_CTRL_TCM_RWAIT_EN = 0x2
	// TCM read fast mode: Read RAM accesses are expected to be finished in 1-cycle.
	FLEXRAM_TCM_CTRL_TCM_RWAIT_EN_TCM_RWAIT_EN_0 = 0x0
	// TCM read wait mode: Read RAM accesses are expected to be finished in 2-cycles.
	FLEXRAM_TCM_CTRL_TCM_RWAIT_EN_TCM_RWAIT_EN_1 = 0x1
	// Position of FORCE_CLK_ON field.
	FLEXRAM_TCM_CTRL_FORCE_CLK_ON_Pos = 0x2
	// Bit mask of FORCE_CLK_ON field.
	FLEXRAM_TCM_CTRL_FORCE_CLK_ON_Msk = 0x4
	// Bit FORCE_CLK_ON.
	FLEXRAM_TCM_CTRL_FORCE_CLK_ON = 0x4

	// INT_STATUS: Interrupt Status Register
	// Position of ITCM_ERR_STATUS field.
	FLEXRAM_INT_STATUS_ITCM_ERR_STATUS_Pos = 0x3
	// Bit mask of ITCM_ERR_STATUS field.
	FLEXRAM_INT_STATUS_ITCM_ERR_STATUS_Msk = 0x8
	// Bit ITCM_ERR_STATUS.
	FLEXRAM_INT_STATUS_ITCM_ERR_STATUS = 0x8
	// ITCM access error does not happen
	FLEXRAM_INT_STATUS_ITCM_ERR_STATUS_ITCM_ERR_STATUS_0 = 0x0
	// ITCM access error happens.
	FLEXRAM_INT_STATUS_ITCM_ERR_STATUS_ITCM_ERR_STATUS_1 = 0x1
	// Position of DTCM_ERR_STATUS field.
	FLEXRAM_INT_STATUS_DTCM_ERR_STATUS_Pos = 0x4
	// Bit mask of DTCM_ERR_STATUS field.
	FLEXRAM_INT_STATUS_DTCM_ERR_STATUS_Msk = 0x10
	// Bit DTCM_ERR_STATUS.
	FLEXRAM_INT_STATUS_DTCM_ERR_STATUS = 0x10
	// DTCM access error does not happen
	FLEXRAM_INT_STATUS_DTCM_ERR_STATUS_DTCM_ERR_STATUS_0 = 0x0
	// DTCM access error happens.
	FLEXRAM_INT_STATUS_DTCM_ERR_STATUS_DTCM_ERR_STATUS_1 = 0x1
	// Position of OCRAM_ERR_STATUS field.
	FLEXRAM_INT_STATUS_OCRAM_ERR_STATUS_Pos = 0x5
	// Bit mask of OCRAM_ERR_STATUS field.
	FLEXRAM_INT_STATUS_OCRAM_ERR_STATUS_Msk = 0x20
	// Bit OCRAM_ERR_STATUS.
	FLEXRAM_INT_STATUS_OCRAM_ERR_STATUS = 0x20
	// OCRAM access error does not happen
	FLEXRAM_INT_STATUS_OCRAM_ERR_STATUS_OCRAM_ERR_STATUS_0 = 0x0
	// OCRAM access error happens.
	FLEXRAM_INT_STATUS_OCRAM_ERR_STATUS_OCRAM_ERR_STATUS_1 = 0x1

	// INT_STAT_EN: Interrupt Status Enable Register
	// Position of ITCM_ERR_STAT_EN field.
	FLEXRAM_INT_STAT_EN_ITCM_ERR_STAT_EN_Pos = 0x3
	// Bit mask of ITCM_ERR_STAT_EN field.
	FLEXRAM_INT_STAT_EN_ITCM_ERR_STAT_EN_Msk = 0x8
	// Bit ITCM_ERR_STAT_EN.
	FLEXRAM_INT_STAT_EN_ITCM_ERR_STAT_EN = 0x8
	// Masked
	FLEXRAM_INT_STAT_EN_ITCM_ERR_STAT_EN_ITCM_ERR_STAT_EN_0 = 0x0
	// Enabled
	FLEXRAM_INT_STAT_EN_ITCM_ERR_STAT_EN_ITCM_ERR_STAT_EN_1 = 0x1
	// Position of DTCM_ERR_STAT_EN field.
	FLEXRAM_INT_STAT_EN_DTCM_ERR_STAT_EN_Pos = 0x4
	// Bit mask of DTCM_ERR_STAT_EN field.
	FLEXRAM_INT_STAT_EN_DTCM_ERR_STAT_EN_Msk = 0x10
	// Bit DTCM_ERR_STAT_EN.
	FLEXRAM_INT_STAT_EN_DTCM_ERR_STAT_EN = 0x10
	// Masked
	FLEXRAM_INT_STAT_EN_DTCM_ERR_STAT_EN_DTCM_ERR_STAT_EN_0 = 0x0
	// Enabled
	FLEXRAM_INT_STAT_EN_DTCM_ERR_STAT_EN_DTCM_ERR_STAT_EN_1 = 0x1
	// Position of OCRAM_ERR_STAT_EN field.
	FLEXRAM_INT_STAT_EN_OCRAM_ERR_STAT_EN_Pos = 0x5
	// Bit mask of OCRAM_ERR_STAT_EN field.
	FLEXRAM_INT_STAT_EN_OCRAM_ERR_STAT_EN_Msk = 0x20
	// Bit OCRAM_ERR_STAT_EN.
	FLEXRAM_INT_STAT_EN_OCRAM_ERR_STAT_EN = 0x20
	// Masked
	FLEXRAM_INT_STAT_EN_OCRAM_ERR_STAT_EN_OCRAM_ERR_STAT_EN_0 = 0x0
	// Enabled
	FLEXRAM_INT_STAT_EN_OCRAM_ERR_STAT_EN_OCRAM_ERR_STAT_EN_1 = 0x1

	// INT_SIG_EN: Interrupt Enable Register
	// Position of ITCM_ERR_SIG_EN field.
	FLEXRAM_INT_SIG_EN_ITCM_ERR_SIG_EN_Pos = 0x3
	// Bit mask of ITCM_ERR_SIG_EN field.
	FLEXRAM_INT_SIG_EN_ITCM_ERR_SIG_EN_Msk = 0x8
	// Bit ITCM_ERR_SIG_EN.
	FLEXRAM_INT_SIG_EN_ITCM_ERR_SIG_EN = 0x8
	// Masked
	FLEXRAM_INT_SIG_EN_ITCM_ERR_SIG_EN_ITCM_ERR_SIG_EN_0 = 0x0
	// Enabled
	FLEXRAM_INT_SIG_EN_ITCM_ERR_SIG_EN_ITCM_ERR_SIG_EN_1 = 0x1
	// Position of DTCM_ERR_SIG_EN field.
	FLEXRAM_INT_SIG_EN_DTCM_ERR_SIG_EN_Pos = 0x4
	// Bit mask of DTCM_ERR_SIG_EN field.
	FLEXRAM_INT_SIG_EN_DTCM_ERR_SIG_EN_Msk = 0x10
	// Bit DTCM_ERR_SIG_EN.
	FLEXRAM_INT_SIG_EN_DTCM_ERR_SIG_EN = 0x10
	// Masked
	FLEXRAM_INT_SIG_EN_DTCM_ERR_SIG_EN_DTCM_ERR_SIG_EN_0 = 0x0
	// Enabled
	FLEXRAM_INT_SIG_EN_DTCM_ERR_SIG_EN_DTCM_ERR_SIG_EN_1 = 0x1
	// Position of OCRAM_ERR_SIG_EN field.
	FLEXRAM_INT_SIG_EN_OCRAM_ERR_SIG_EN_Pos = 0x5
	// Bit mask of OCRAM_ERR_SIG_EN field.
	FLEXRAM_INT_SIG_EN_OCRAM_ERR_SIG_EN_Msk = 0x20
	// Bit OCRAM_ERR_SIG_EN.
	FLEXRAM_INT_SIG_EN_OCRAM_ERR_SIG_EN = 0x20
	// Masked
	FLEXRAM_INT_SIG_EN_OCRAM_ERR_SIG_EN_OCRAM_ERR_SIG_EN_0 = 0x0
	// Enabled
	FLEXRAM_INT_SIG_EN_OCRAM_ERR_SIG_EN_OCRAM_ERR_SIG_EN_1 = 0x1
)

// Bitfields for EWM: EWM
const (
	// CTRL: Control Register
	// Position of EWMEN field.
	EWM_CTRL_EWMEN_Pos = 0x0
	// Bit mask of EWMEN field.
	EWM_CTRL_EWMEN_Msk = 0x1
	// Bit EWMEN.
	EWM_CTRL_EWMEN = 0x1
	// Position of ASSIN field.
	EWM_CTRL_ASSIN_Pos = 0x1
	// Bit mask of ASSIN field.
	EWM_CTRL_ASSIN_Msk = 0x2
	// Bit ASSIN.
	EWM_CTRL_ASSIN = 0x2
	// Position of INEN field.
	EWM_CTRL_INEN_Pos = 0x2
	// Bit mask of INEN field.
	EWM_CTRL_INEN_Msk = 0x4
	// Bit INEN.
	EWM_CTRL_INEN = 0x4
	// Position of INTEN field.
	EWM_CTRL_INTEN_Pos = 0x3
	// Bit mask of INTEN field.
	EWM_CTRL_INTEN_Msk = 0x8
	// Bit INTEN.
	EWM_CTRL_INTEN = 0x8

	// SERV: Service Register
	// Position of SERVICE field.
	EWM_SERV_SERVICE_Pos = 0x0
	// Bit mask of SERVICE field.
	EWM_SERV_SERVICE_Msk = 0xff

	// CMPL: Compare Low Register
	// Position of COMPAREL field.
	EWM_CMPL_COMPAREL_Pos = 0x0
	// Bit mask of COMPAREL field.
	EWM_CMPL_COMPAREL_Msk = 0xff

	// CMPH: Compare High Register
	// Position of COMPAREH field.
	EWM_CMPH_COMPAREH_Pos = 0x0
	// Bit mask of COMPAREH field.
	EWM_CMPH_COMPAREH_Msk = 0xff

	// CLKCTRL: Clock Control Register
	// Position of CLKSEL field.
	EWM_CLKCTRL_CLKSEL_Pos = 0x0
	// Bit mask of CLKSEL field.
	EWM_CLKCTRL_CLKSEL_Msk = 0x3

	// CLKPRESCALER: Clock Prescaler Register
	// Position of CLK_DIV field.
	EWM_CLKPRESCALER_CLK_DIV_Pos = 0x0
	// Bit mask of CLK_DIV field.
	EWM_CLKPRESCALER_CLK_DIV_Msk = 0xff
)

// Bitfields for WDOG1: WDOG
const (
	// WCR: Watchdog Control Register
	// Position of WDZST field.
	WDOG_WCR_WDZST_Pos = 0x0
	// Bit mask of WDZST field.
	WDOG_WCR_WDZST_Msk = 0x1
	// Bit WDZST.
	WDOG_WCR_WDZST = 0x1
	// Continue timer operation (Default).
	WDOG_WCR_WDZST_WDZST_0 = 0x0
	// Suspend the watchdog timer.
	WDOG_WCR_WDZST_WDZST_1 = 0x1
	// Position of WDBG field.
	WDOG_WCR_WDBG_Pos = 0x1
	// Bit mask of WDBG field.
	WDOG_WCR_WDBG_Msk = 0x2
	// Bit WDBG.
	WDOG_WCR_WDBG = 0x2
	// Continue WDOG timer operation (Default).
	WDOG_WCR_WDBG_WDBG_0 = 0x0
	// Suspend the watchdog timer.
	WDOG_WCR_WDBG_WDBG_1 = 0x1
	// Position of WDE field.
	WDOG_WCR_WDE_Pos = 0x2
	// Bit mask of WDE field.
	WDOG_WCR_WDE_Msk = 0x4
	// Bit WDE.
	WDOG_WCR_WDE = 0x4
	// Disable the Watchdog (Default).
	WDOG_WCR_WDE_WDE_0 = 0x0
	// Enable the Watchdog.
	WDOG_WCR_WDE_WDE_1 = 0x1
	// Position of WDT field.
	WDOG_WCR_WDT_Pos = 0x3
	// Bit mask of WDT field.
	WDOG_WCR_WDT_Msk = 0x8
	// Bit WDT.
	WDOG_WCR_WDT = 0x8
	// No effect on WDOG_B (Default).
	WDOG_WCR_WDT_WDT_0 = 0x0
	// Assert WDOG_B upon a Watchdog Time-out event.
	WDOG_WCR_WDT_WDT_1 = 0x1
	// Position of SRS field.
	WDOG_WCR_SRS_Pos = 0x4
	// Bit mask of SRS field.
	WDOG_WCR_SRS_Msk = 0x10
	// Bit SRS.
	WDOG_WCR_SRS = 0x10
	// Assert system reset signal.
	WDOG_WCR_SRS_SRS_0 = 0x0
	// No effect on the system (Default).
	WDOG_WCR_SRS_SRS_1 = 0x1
	// Position of WDA field.
	WDOG_WCR_WDA_Pos = 0x5
	// Bit mask of WDA field.
	WDOG_WCR_WDA_Msk = 0x20
	// Bit WDA.
	WDOG_WCR_WDA = 0x20
	// Assert WDOG_B output.
	WDOG_WCR_WDA_WDA_0 = 0x0
	// No effect on system (Default).
	WDOG_WCR_WDA_WDA_1 = 0x1
	// Position of SRE field.
	WDOG_WCR_SRE_Pos = 0x6
	// Bit mask of SRE field.
	WDOG_WCR_SRE_Msk = 0x40
	// Bit SRE.
	WDOG_WCR_SRE = 0x40
	// using original way to generate software reset (default)
	WDOG_WCR_SRE_SRE_0 = 0x0
	// using new way to generate software reset.
	WDOG_WCR_SRE_SRE_1 = 0x1
	// Position of WDW field.
	WDOG_WCR_WDW_Pos = 0x7
	// Bit mask of WDW field.
	WDOG_WCR_WDW_Msk = 0x80
	// Bit WDW.
	WDOG_WCR_WDW = 0x80
	// Continue WDOG timer operation (Default).
	WDOG_WCR_WDW_WDW_0 = 0x0
	// Suspend WDOG timer operation.
	WDOG_WCR_WDW_WDW_1 = 0x1
	// Position of WT field.
	WDOG_WCR_WT_Pos = 0x8
	// Bit mask of WT field.
	WDOG_WCR_WT_Msk = 0xff00
	// - 0.5 Seconds (Default).
	WDOG_WCR_WT_WT_0 = 0x0
	// - 1.0 Seconds.
	WDOG_WCR_WT_WT_1 = 0x1
	// - 1.5 Seconds.
	WDOG_WCR_WT_WT_2 = 0x2
	// - 2.0 Seconds.
	WDOG_WCR_WT_WT_3 = 0x3
	// - 128 Seconds.
	WDOG_WCR_WT_WT_255 = 0xff

	// WSR: Watchdog Service Register
	// Position of WSR field.
	WDOG_WSR_WSR_Pos = 0x0
	// Bit mask of WSR field.
	WDOG_WSR_WSR_Msk = 0xffff
	// Write to the Watchdog Service Register (WDOG_WSR).
	WDOG_WSR_WSR_WSR_21845 = 0x5555
	// Write to the Watchdog Service Register (WDOG_WSR).
	WDOG_WSR_WSR_WSR_43690 = 0xaaaa

	// WRSR: Watchdog Reset Status Register
	// Position of SFTW field.
	WDOG_WRSR_SFTW_Pos = 0x0
	// Bit mask of SFTW field.
	WDOG_WRSR_SFTW_Msk = 0x1
	// Bit SFTW.
	WDOG_WRSR_SFTW = 0x1
	// Reset is not the result of a software reset.
	WDOG_WRSR_SFTW_SFTW_0 = 0x0
	// Reset is the result of a software reset.
	WDOG_WRSR_SFTW_SFTW_1 = 0x1
	// Position of TOUT field.
	WDOG_WRSR_TOUT_Pos = 0x1
	// Bit mask of TOUT field.
	WDOG_WRSR_TOUT_Msk = 0x2
	// Bit TOUT.
	WDOG_WRSR_TOUT = 0x2
	// Reset is not the result of a WDOG timeout.
	WDOG_WRSR_TOUT_TOUT_0 = 0x0
	// Reset is the result of a WDOG timeout.
	WDOG_WRSR_TOUT_TOUT_1 = 0x1
	// Position of POR field.
	WDOG_WRSR_POR_Pos = 0x4
	// Bit mask of POR field.
	WDOG_WRSR_POR_Msk = 0x10
	// Bit POR.
	WDOG_WRSR_POR = 0x10
	// Reset is not the result of a power on reset.
	WDOG_WRSR_POR_POR_0 = 0x0
	// Reset is the result of a power on reset.
	WDOG_WRSR_POR_POR_1 = 0x1

	// WICR: Watchdog Interrupt Control Register
	// Position of WICT field.
	WDOG_WICR_WICT_Pos = 0x0
	// Bit mask of WICT field.
	WDOG_WICR_WICT_Msk = 0xff
	// WICT[7:0] = Time duration between interrupt and time-out is 0 seconds.
	WDOG_WICR_WICT_WICT_0 = 0x0
	// WICT[7:0] = Time duration between interrupt and time-out is 0.5 seconds.
	WDOG_WICR_WICT_WICT_1 = 0x1
	// WICT[7:0] = Time duration between interrupt and time-out is 2 seconds (Default).
	WDOG_WICR_WICT_WICT_4 = 0x4
	// WICT[7:0] = Time duration between interrupt and time-out is 127.5 seconds.
	WDOG_WICR_WICT_WICT_255 = 0xff
	// Position of WTIS field.
	WDOG_WICR_WTIS_Pos = 0xe
	// Bit mask of WTIS field.
	WDOG_WICR_WTIS_Msk = 0x4000
	// Bit WTIS.
	WDOG_WICR_WTIS = 0x4000
	// No interrupt has occurred (Default).
	WDOG_WICR_WTIS_WTIS_0 = 0x0
	// Interrupt has occurred
	WDOG_WICR_WTIS_WTIS_1 = 0x1
	// Position of WIE field.
	WDOG_WICR_WIE_Pos = 0xf
	// Bit mask of WIE field.
	WDOG_WICR_WIE_Msk = 0x8000
	// Bit WIE.
	WDOG_WICR_WIE = 0x8000
	// Disable Interrupt (Default).
	WDOG_WICR_WIE_WIE_0 = 0x0
	// Enable Interrupt.
	WDOG_WICR_WIE_WIE_1 = 0x1

	// WMCR: Watchdog Miscellaneous Control Register
	// Position of PDE field.
	WDOG_WMCR_PDE_Pos = 0x0
	// Bit mask of PDE field.
	WDOG_WMCR_PDE_Msk = 0x1
	// Bit PDE.
	WDOG_WMCR_PDE = 0x1
	// Power Down Counter of WDOG is disabled.
	WDOG_WMCR_PDE_PDE_0 = 0x0
	// Power Down Counter of WDOG is enabled (Default).
	WDOG_WMCR_PDE_PDE_1 = 0x1
)

// Bitfields for RTWDOG: WDOG
const (
	// CS: Watchdog Control and Status Register
	// Position of STOP field.
	RTWDOG_CS_STOP_Pos = 0x0
	// Bit mask of STOP field.
	RTWDOG_CS_STOP_Msk = 0x1
	// Bit STOP.
	RTWDOG_CS_STOP = 0x1
	// Watchdog disabled in chip stop mode.
	RTWDOG_CS_STOP_STOP_0 = 0x0
	// Watchdog enabled in chip stop mode.
	RTWDOG_CS_STOP_STOP_1 = 0x1
	// Position of WAIT field.
	RTWDOG_CS_WAIT_Pos = 0x1
	// Bit mask of WAIT field.
	RTWDOG_CS_WAIT_Msk = 0x2
	// Bit WAIT.
	RTWDOG_CS_WAIT = 0x2
	// Watchdog disabled in chip wait mode.
	RTWDOG_CS_WAIT_WAIT_0 = 0x0
	// Watchdog enabled in chip wait mode.
	RTWDOG_CS_WAIT_WAIT_1 = 0x1
	// Position of DBG field.
	RTWDOG_CS_DBG_Pos = 0x2
	// Bit mask of DBG field.
	RTWDOG_CS_DBG_Msk = 0x4
	// Bit DBG.
	RTWDOG_CS_DBG = 0x4
	// Watchdog disabled in chip debug mode.
	RTWDOG_CS_DBG_DBG_0 = 0x0
	// Watchdog enabled in chip debug mode.
	RTWDOG_CS_DBG_DBG_1 = 0x1
	// Position of TST field.
	RTWDOG_CS_TST_Pos = 0x3
	// Bit mask of TST field.
	RTWDOG_CS_TST_Msk = 0x18
	// Watchdog test mode disabled.
	RTWDOG_CS_TST_TST_0 = 0x0
	// Watchdog user mode enabled. (Watchdog test mode disabled.) After testing the watchdog, software should use this setting to indicate that the watchdog is functioning normally in user mode.
	RTWDOG_CS_TST_TST_1 = 0x1
	// Watchdog test mode enabled, only the low byte is used. CNT[CNTLOW] is compared with TOVAL[TOVALLOW].
	RTWDOG_CS_TST_TST_2 = 0x2
	// Watchdog test mode enabled, only the high byte is used. CNT[CNTHIGH] is compared with TOVAL[TOVALHIGH].
	RTWDOG_CS_TST_TST_3 = 0x3
	// Position of UPDATE field.
	RTWDOG_CS_UPDATE_Pos = 0x5
	// Bit mask of UPDATE field.
	RTWDOG_CS_UPDATE_Msk = 0x20
	// Bit UPDATE.
	RTWDOG_CS_UPDATE = 0x20
	// Updates not allowed. After the initial configuration, the watchdog cannot be later modified without forcing a reset.
	RTWDOG_CS_UPDATE_UPDATE_0 = 0x0
	// Updates allowed. Software can modify the watchdog configuration registers within 128 bus clocks after performing the unlock write sequence.
	RTWDOG_CS_UPDATE_UPDATE_1 = 0x1
	// Position of INT field.
	RTWDOG_CS_INT_Pos = 0x6
	// Bit mask of INT field.
	RTWDOG_CS_INT_Msk = 0x40
	// Bit INT.
	RTWDOG_CS_INT = 0x40
	// Watchdog interrupts are disabled. Watchdog resets are not delayed.
	RTWDOG_CS_INT_INT_0 = 0x0
	// Watchdog interrupts are enabled. Watchdog resets are delayed by 128 bus clocks from the interrupt vector fetch.
	RTWDOG_CS_INT_INT_1 = 0x1
	// Position of EN field.
	RTWDOG_CS_EN_Pos = 0x7
	// Bit mask of EN field.
	RTWDOG_CS_EN_Msk = 0x80
	// Bit EN.
	RTWDOG_CS_EN = 0x80
	// Watchdog disabled.
	RTWDOG_CS_EN_EN_0 = 0x0
	// Watchdog enabled.
	RTWDOG_CS_EN_EN_1 = 0x1
	// Position of CLK field.
	RTWDOG_CS_CLK_Pos = 0x8
	// Bit mask of CLK field.
	RTWDOG_CS_CLK_Msk = 0x300
	// Bus clock
	RTWDOG_CS_CLK_CLK_0 = 0x0
	// LPO clock
	RTWDOG_CS_CLK_CLK_1 = 0x1
	// INTCLK (internal clock)
	RTWDOG_CS_CLK_CLK_2 = 0x2
	// ERCLK (external reference clock)
	RTWDOG_CS_CLK_CLK_3 = 0x3
	// Position of RCS field.
	RTWDOG_CS_RCS_Pos = 0xa
	// Bit mask of RCS field.
	RTWDOG_CS_RCS_Msk = 0x400
	// Bit RCS.
	RTWDOG_CS_RCS = 0x400
	// Reconfiguring WDOG.
	RTWDOG_CS_RCS_RCS_0 = 0x0
	// Reconfiguration is successful.
	RTWDOG_CS_RCS_RCS_1 = 0x1
	// Position of ULK field.
	RTWDOG_CS_ULK_Pos = 0xb
	// Bit mask of ULK field.
	RTWDOG_CS_ULK_Msk = 0x800
	// Bit ULK.
	RTWDOG_CS_ULK = 0x800
	// WDOG is locked.
	RTWDOG_CS_ULK_ULK_0 = 0x0
	// WDOG is unlocked.
	RTWDOG_CS_ULK_ULK_1 = 0x1
	// Position of PRES field.
	RTWDOG_CS_PRES_Pos = 0xc
	// Bit mask of PRES field.
	RTWDOG_CS_PRES_Msk = 0x1000
	// Bit PRES.
	RTWDOG_CS_PRES = 0x1000
	// 256 prescaler disabled.
	RTWDOG_CS_PRES_PRES_0 = 0x0
	// 256 prescaler enabled.
	RTWDOG_CS_PRES_PRES_1 = 0x1
	// Position of CMD32EN field.
	RTWDOG_CS_CMD32EN_Pos = 0xd
	// Bit mask of CMD32EN field.
	RTWDOG_CS_CMD32EN_Msk = 0x2000
	// Bit CMD32EN.
	RTWDOG_CS_CMD32EN = 0x2000
	// Disables support for 32-bit refresh/unlock command write words. Only 16-bit or 8-bit is supported.
	RTWDOG_CS_CMD32EN_CMD32EN_0 = 0x0
	// Enables support for 32-bit refresh/unlock command write words. 16-bit or 8-bit is NOT supported.
	RTWDOG_CS_CMD32EN_CMD32EN_1 = 0x1
	// Position of FLG field.
	RTWDOG_CS_FLG_Pos = 0xe
	// Bit mask of FLG field.
	RTWDOG_CS_FLG_Msk = 0x4000
	// Bit FLG.
	RTWDOG_CS_FLG = 0x4000
	// No interrupt occurred.
	RTWDOG_CS_FLG_FLG_0 = 0x0
	// An interrupt occurred.
	RTWDOG_CS_FLG_FLG_1 = 0x1
	// Position of WIN field.
	RTWDOG_CS_WIN_Pos = 0xf
	// Bit mask of WIN field.
	RTWDOG_CS_WIN_Msk = 0x8000
	// Bit WIN.
	RTWDOG_CS_WIN = 0x8000
	// Window mode disabled.
	RTWDOG_CS_WIN_WIN_0 = 0x0
	// Window mode enabled.
	RTWDOG_CS_WIN_WIN_1 = 0x1

	// CNT: Watchdog Counter Register
	// Position of CNTLOW field.
	RTWDOG_CNT_CNTLOW_Pos = 0x0
	// Bit mask of CNTLOW field.
	RTWDOG_CNT_CNTLOW_Msk = 0xff
	// Position of CNTHIGH field.
	RTWDOG_CNT_CNTHIGH_Pos = 0x8
	// Bit mask of CNTHIGH field.
	RTWDOG_CNT_CNTHIGH_Msk = 0xff00

	// TOVAL: Watchdog Timeout Value Register
	// Position of TOVALLOW field.
	RTWDOG_TOVAL_TOVALLOW_Pos = 0x0
	// Bit mask of TOVALLOW field.
	RTWDOG_TOVAL_TOVALLOW_Msk = 0xff
	// Position of TOVALHIGH field.
	RTWDOG_TOVAL_TOVALHIGH_Pos = 0x8
	// Bit mask of TOVALHIGH field.
	RTWDOG_TOVAL_TOVALHIGH_Msk = 0xff00

	// WIN: Watchdog Window Register
	// Position of WINLOW field.
	RTWDOG_WIN_WINLOW_Pos = 0x0
	// Bit mask of WINLOW field.
	RTWDOG_WIN_WINLOW_Msk = 0xff
	// Position of WINHIGH field.
	RTWDOG_WIN_WINHIGH_Pos = 0x8
	// Bit mask of WINHIGH field.
	RTWDOG_WIN_WINHIGH_Msk = 0xff00
)

// Bitfields for ADC1: Analog-to-Digital Converter
const (
	// HC0: Control register for hardware triggers
	// Position of ADCH field.
	ADC_HC0_ADCH_Pos = 0x0
	// Bit mask of ADCH field.
	ADC_HC0_ADCH_Msk = 0x1f
	// External channel selection from ADC_ETC
	ADC_HC0_ADCH_ADCH_16 = 0x10
	// VREFSH = internal channel, for ADC self-test, hard connected to VRH internally
	ADC_HC0_ADCH_ADCH_25 = 0x19
	// Conversion Disabled. Hardware Triggers will not initiate any conversion.
	ADC_HC0_ADCH_ADCH_31 = 0x1f
	// Position of AIEN field.
	ADC_HC0_AIEN_Pos = 0x7
	// Bit mask of AIEN field.
	ADC_HC0_AIEN_Msk = 0x80
	// Bit AIEN.
	ADC_HC0_AIEN = 0x80
	// Conversion complete interrupt disabled
	ADC_HC0_AIEN_AIEN_0 = 0x0
	// Conversion complete interrupt enabled
	ADC_HC0_AIEN_AIEN_1 = 0x1

	// HC1: Control register for hardware triggers
	// Position of ADCH field.
	ADC_HC_ADCH_Pos = 0x0
	// Bit mask of ADCH field.
	ADC_HC_ADCH_Msk = 0x1f
	// External channel selection from ADC_ETC
	ADC_HC_ADCH_ADCH_16 = 0x10
	// VREFSH = internal channel, for ADC self-test, hard connected to VRH internally
	ADC_HC_ADCH_ADCH_25 = 0x19
	// Conversion Disabled. Hardware Triggers will not initiate any conversion.
	ADC_HC_ADCH_ADCH_31 = 0x1f
	// Position of AIEN field.
	ADC_HC_AIEN_Pos = 0x7
	// Bit mask of AIEN field.
	ADC_HC_AIEN_Msk = 0x80
	// Bit AIEN.
	ADC_HC_AIEN = 0x80
	// Conversion complete interrupt disabled
	ADC_HC_AIEN_AIEN_0 = 0x0
	// Conversion complete interrupt enabled
	ADC_HC_AIEN_AIEN_1 = 0x1

	// HS: Status register for HW triggers
	// Position of COCO0 field.
	ADC_HS_COCO0_Pos = 0x0
	// Bit mask of COCO0 field.
	ADC_HS_COCO0_Msk = 0x1
	// Bit COCO0.
	ADC_HS_COCO0 = 0x1

	// R0: Data result register for HW triggers
	// Position of CDATA field.
	ADC_R0_CDATA_Pos = 0x0
	// Bit mask of CDATA field.
	ADC_R0_CDATA_Msk = 0xfff

	// R1: Data result register for HW triggers
	// Position of CDATA field.
	ADC_R_CDATA_Pos = 0x0
	// Bit mask of CDATA field.
	ADC_R_CDATA_Msk = 0xfff

	// CFG: Configuration register
	// Position of ADICLK field.
	ADC_CFG_ADICLK_Pos = 0x0
	// Bit mask of ADICLK field.
	ADC_CFG_ADICLK_Msk = 0x3
	// IPG clock
	ADC_CFG_ADICLK_ADICLK_0 = 0x0
	// IPG clock divided by 2
	ADC_CFG_ADICLK_ADICLK_1 = 0x1
	// Asynchronous clock (ADACK)
	ADC_CFG_ADICLK_ADICLK_3 = 0x3
	// Position of MODE field.
	ADC_CFG_MODE_Pos = 0x2
	// Bit mask of MODE field.
	ADC_CFG_MODE_Msk = 0xc
	// 8-bit conversion
	ADC_CFG_MODE_MODE_0 = 0x0
	// 10-bit conversion
	ADC_CFG_MODE_MODE_1 = 0x1
	// 12-bit conversion
	ADC_CFG_MODE_MODE_2 = 0x2
	// Position of ADLSMP field.
	ADC_CFG_ADLSMP_Pos = 0x4
	// Bit mask of ADLSMP field.
	ADC_CFG_ADLSMP_Msk = 0x10
	// Bit ADLSMP.
	ADC_CFG_ADLSMP = 0x10
	// Short sample mode.
	ADC_CFG_ADLSMP_ADLSMP_0 = 0x0
	// Long sample mode.
	ADC_CFG_ADLSMP_ADLSMP_1 = 0x1
	// Position of ADIV field.
	ADC_CFG_ADIV_Pos = 0x5
	// Bit mask of ADIV field.
	ADC_CFG_ADIV_Msk = 0x60
	// Input clock
	ADC_CFG_ADIV_ADIV_0 = 0x0
	// Input clock / 2
	ADC_CFG_ADIV_ADIV_1 = 0x1
	// Input clock / 4
	ADC_CFG_ADIV_ADIV_2 = 0x2
	// Input clock / 8
	ADC_CFG_ADIV_ADIV_3 = 0x3
	// Position of ADLPC field.
	ADC_CFG_ADLPC_Pos = 0x7
	// Bit mask of ADLPC field.
	ADC_CFG_ADLPC_Msk = 0x80
	// Bit ADLPC.
	ADC_CFG_ADLPC = 0x80
	// ADC hard block not in low power mode.
	ADC_CFG_ADLPC_ADLPC_0 = 0x0
	// ADC hard block in low power mode.
	ADC_CFG_ADLPC_ADLPC_1 = 0x1
	// Position of ADSTS field.
	ADC_CFG_ADSTS_Pos = 0x8
	// Bit mask of ADSTS field.
	ADC_CFG_ADSTS_Msk = 0x300
	// Sample period (ADC clocks) = 2 if ADLSMP=0b Sample period (ADC clocks) = 12 if ADLSMP=1b
	ADC_CFG_ADSTS_ADSTS_0 = 0x0
	// Sample period (ADC clocks) = 4 if ADLSMP=0b Sample period (ADC clocks) = 16 if ADLSMP=1b
	ADC_CFG_ADSTS_ADSTS_1 = 0x1
	// Sample period (ADC clocks) = 6 if ADLSMP=0b Sample period (ADC clocks) = 20 if ADLSMP=1b
	ADC_CFG_ADSTS_ADSTS_2 = 0x2
	// Sample period (ADC clocks) = 8 if ADLSMP=0b Sample period (ADC clocks) = 24 if ADLSMP=1b
	ADC_CFG_ADSTS_ADSTS_3 = 0x3
	// Position of ADHSC field.
	ADC_CFG_ADHSC_Pos = 0xa
	// Bit mask of ADHSC field.
	ADC_CFG_ADHSC_Msk = 0x400
	// Bit ADHSC.
	ADC_CFG_ADHSC = 0x400
	// Normal conversion selected.
	ADC_CFG_ADHSC_ADHSC_0 = 0x0
	// High speed conversion selected.
	ADC_CFG_ADHSC_ADHSC_1 = 0x1
	// Position of REFSEL field.
	ADC_CFG_REFSEL_Pos = 0xb
	// Bit mask of REFSEL field.
	ADC_CFG_REFSEL_Msk = 0x1800
	// Selects VREFH/VREFL as reference voltage.
	ADC_CFG_REFSEL_REFSEL_0 = 0x0
	// Position of ADTRG field.
	ADC_CFG_ADTRG_Pos = 0xd
	// Bit mask of ADTRG field.
	ADC_CFG_ADTRG_Msk = 0x2000
	// Bit ADTRG.
	ADC_CFG_ADTRG = 0x2000
	// Software trigger selected
	ADC_CFG_ADTRG_ADTRG_0 = 0x0
	// Hardware trigger selected
	ADC_CFG_ADTRG_ADTRG_1 = 0x1
	// Position of AVGS field.
	ADC_CFG_AVGS_Pos = 0xe
	// Bit mask of AVGS field.
	ADC_CFG_AVGS_Msk = 0xc000
	// 4 samples averaged
	ADC_CFG_AVGS_AVGS_0 = 0x0
	// 8 samples averaged
	ADC_CFG_AVGS_AVGS_1 = 0x1
	// 16 samples averaged
	ADC_CFG_AVGS_AVGS_2 = 0x2
	// 32 samples averaged
	ADC_CFG_AVGS_AVGS_3 = 0x3
	// Position of OVWREN field.
	ADC_CFG_OVWREN_Pos = 0x10
	// Bit mask of OVWREN field.
	ADC_CFG_OVWREN_Msk = 0x10000
	// Bit OVWREN.
	ADC_CFG_OVWREN = 0x10000
	// Disable the overwriting. Existing Data in Data result register will not be overwritten by subsequent converted data.
	ADC_CFG_OVWREN_OVWREN_0 = 0x0
	// Enable the overwriting.
	ADC_CFG_OVWREN_OVWREN_1 = 0x1

	// GC: General control register
	// Position of ADACKEN field.
	ADC_GC_ADACKEN_Pos = 0x0
	// Bit mask of ADACKEN field.
	ADC_GC_ADACKEN_Msk = 0x1
	// Bit ADACKEN.
	ADC_GC_ADACKEN = 0x1
	// Asynchronous clock output disabled; Asynchronous clock only enabled if selected by ADICLK and a conversion is active.
	ADC_GC_ADACKEN_ADACKEN_0 = 0x0
	// Asynchronous clock and clock output enabled regardless of the state of the ADC
	ADC_GC_ADACKEN_ADACKEN_1 = 0x1
	// Position of DMAEN field.
	ADC_GC_DMAEN_Pos = 0x1
	// Bit mask of DMAEN field.
	ADC_GC_DMAEN_Msk = 0x2
	// Bit DMAEN.
	ADC_GC_DMAEN = 0x2
	// DMA disabled (default)
	ADC_GC_DMAEN_DMAEN_0 = 0x0
	// DMA enabled
	ADC_GC_DMAEN_DMAEN_1 = 0x1
	// Position of ACREN field.
	ADC_GC_ACREN_Pos = 0x2
	// Bit mask of ACREN field.
	ADC_GC_ACREN_Msk = 0x4
	// Bit ACREN.
	ADC_GC_ACREN = 0x4
	// Range function disabled. Only the compare value 1 of ADC_CV register (CV1) is compared.
	ADC_GC_ACREN_ACREN_0 = 0x0
	// Range function enabled. Both compare values of ADC_CV registers (CV1 and CV2) are compared.
	ADC_GC_ACREN_ACREN_1 = 0x1
	// Position of ACFGT field.
	ADC_GC_ACFGT_Pos = 0x3
	// Bit mask of ACFGT field.
	ADC_GC_ACFGT_Msk = 0x8
	// Bit ACFGT.
	ADC_GC_ACFGT = 0x8
	// Configures "Less Than Threshold, Outside Range Not Inclusive and Inside Range Not Inclusive" functionality based on the values placed in the ADC_CV register.
	ADC_GC_ACFGT_ACFGT_0 = 0x0
	// Configures "Greater Than Or Equal To Threshold, Outside Range Inclusive and Inside Range Inclusive" functionality based on the values placed in the ADC_CV registers.
	ADC_GC_ACFGT_ACFGT_1 = 0x1
	// Position of ACFE field.
	ADC_GC_ACFE_Pos = 0x4
	// Bit mask of ACFE field.
	ADC_GC_ACFE_Msk = 0x10
	// Bit ACFE.
	ADC_GC_ACFE = 0x10
	// Compare function disabled
	ADC_GC_ACFE_ACFE_0 = 0x0
	// Compare function enabled
	ADC_GC_ACFE_ACFE_1 = 0x1
	// Position of AVGE field.
	ADC_GC_AVGE_Pos = 0x5
	// Bit mask of AVGE field.
	ADC_GC_AVGE_Msk = 0x20
	// Bit AVGE.
	ADC_GC_AVGE = 0x20
	// Hardware average function disabled
	ADC_GC_AVGE_AVGE_0 = 0x0
	// Hardware average function enabled
	ADC_GC_AVGE_AVGE_1 = 0x1
	// Position of ADCO field.
	ADC_GC_ADCO_Pos = 0x6
	// Bit mask of ADCO field.
	ADC_GC_ADCO_Msk = 0x40
	// Bit ADCO.
	ADC_GC_ADCO = 0x40
	// One conversion or one set of conversions if the hardware average function is enabled (AVGE=1) after initiating a conversion.
	ADC_GC_ADCO_ADCO_0 = 0x0
	// Continuous conversions or sets of conversions if the hardware average function is enabled (AVGE=1) after initiating a conversion.
	ADC_GC_ADCO_ADCO_1 = 0x1
	// Position of CAL field.
	ADC_GC_CAL_Pos = 0x7
	// Bit mask of CAL field.
	ADC_GC_CAL_Msk = 0x80
	// Bit CAL.
	ADC_GC_CAL = 0x80

	// GS: General status register
	// Position of ADACT field.
	ADC_GS_ADACT_Pos = 0x0
	// Bit mask of ADACT field.
	ADC_GS_ADACT_Msk = 0x1
	// Bit ADACT.
	ADC_GS_ADACT = 0x1
	// Conversion not in progress.
	ADC_GS_ADACT_ADACT_0 = 0x0
	// Conversion in progress.
	ADC_GS_ADACT_ADACT_1 = 0x1
	// Position of CALF field.
	ADC_GS_CALF_Pos = 0x1
	// Bit mask of CALF field.
	ADC_GS_CALF_Msk = 0x2
	// Bit CALF.
	ADC_GS_CALF = 0x2
	// Calibration completed normally.
	ADC_GS_CALF_CALF_0 = 0x0
	// Calibration failed. ADC accuracy specifications are not guaranteed.
	ADC_GS_CALF_CALF_1 = 0x1
	// Position of AWKST field.
	ADC_GS_AWKST_Pos = 0x2
	// Bit mask of AWKST field.
	ADC_GS_AWKST_Msk = 0x4
	// Bit AWKST.
	ADC_GS_AWKST = 0x4
	// No asynchronous interrupt.
	ADC_GS_AWKST_AWKST_0 = 0x0
	// Asynchronous wake up interrupt occurred in stop mode.
	ADC_GS_AWKST_AWKST_1 = 0x1

	// CV: Compare value register
	// Position of CV1 field.
	ADC_CV_CV1_Pos = 0x0
	// Bit mask of CV1 field.
	ADC_CV_CV1_Msk = 0xfff
	// Position of CV2 field.
	ADC_CV_CV2_Pos = 0x10
	// Bit mask of CV2 field.
	ADC_CV_CV2_Msk = 0xfff0000

	// OFS: Offset correction value register
	// Position of OFS field.
	ADC_OFS_OFS_Pos = 0x0
	// Bit mask of OFS field.
	ADC_OFS_OFS_Msk = 0xfff
	// Position of SIGN field.
	ADC_OFS_SIGN_Pos = 0xc
	// Bit mask of SIGN field.
	ADC_OFS_SIGN_Msk = 0x1000
	// Bit SIGN.
	ADC_OFS_SIGN = 0x1000
	// The offset value is added with the raw result
	ADC_OFS_SIGN_SIGN_0 = 0x0
	// The offset value is subtracted from the raw converted value
	ADC_OFS_SIGN_SIGN_1 = 0x1

	// CAL: Calibration value register
	// Position of CAL_CODE field.
	ADC_CAL_CAL_CODE_Pos = 0x0
	// Bit mask of CAL_CODE field.
	ADC_CAL_CAL_CODE_Msk = 0xf
)

// Bitfields for TRNG: TRNG
const (
	// MCTL: Miscellaneous Control Register
	// Position of SAMP_MODE field.
	TRNG_MCTL_SAMP_MODE_Pos = 0x0
	// Bit mask of SAMP_MODE field.
	TRNG_MCTL_SAMP_MODE_Msk = 0x3
	// use Von Neumann data into both Entropy shifter and Statistical Checker
	TRNG_MCTL_SAMP_MODE_SAMP_MODE_0 = 0x0
	// use raw data into both Entropy shifter and Statistical Checker
	TRNG_MCTL_SAMP_MODE_SAMP_MODE_1 = 0x1
	// use Von Neumann data into Entropy shifter. Use raw data into Statistical Checker
	TRNG_MCTL_SAMP_MODE_SAMP_MODE_2 = 0x2
	// undefined/reserved.
	TRNG_MCTL_SAMP_MODE_SAMP_MODE_3 = 0x3
	// Position of OSC_DIV field.
	TRNG_MCTL_OSC_DIV_Pos = 0x2
	// Bit mask of OSC_DIV field.
	TRNG_MCTL_OSC_DIV_Msk = 0xc
	// use ring oscillator with no divide
	TRNG_MCTL_OSC_DIV_OSC_DIV_0 = 0x0
	// use ring oscillator divided-by-2
	TRNG_MCTL_OSC_DIV_OSC_DIV_1 = 0x1
	// use ring oscillator divided-by-4
	TRNG_MCTL_OSC_DIV_OSC_DIV_2 = 0x2
	// use ring oscillator divided-by-8
	TRNG_MCTL_OSC_DIV_OSC_DIV_3 = 0x3
	// Position of UNUSED4 field.
	TRNG_MCTL_UNUSED4_Pos = 0x4
	// Bit mask of UNUSED4 field.
	TRNG_MCTL_UNUSED4_Msk = 0x10
	// Bit UNUSED4.
	TRNG_MCTL_UNUSED4 = 0x10
	// Position of UNUSED5 field.
	TRNG_MCTL_UNUSED5_Pos = 0x5
	// Bit mask of UNUSED5 field.
	TRNG_MCTL_UNUSED5_Msk = 0x20
	// Bit UNUSED5.
	TRNG_MCTL_UNUSED5 = 0x20
	// Position of RST_DEF field.
	TRNG_MCTL_RST_DEF_Pos = 0x6
	// Bit mask of RST_DEF field.
	TRNG_MCTL_RST_DEF_Msk = 0x40
	// Bit RST_DEF.
	TRNG_MCTL_RST_DEF = 0x40
	// Position of FOR_SCLK field.
	TRNG_MCTL_FOR_SCLK_Pos = 0x7
	// Bit mask of FOR_SCLK field.
	TRNG_MCTL_FOR_SCLK_Msk = 0x80
	// Bit FOR_SCLK.
	TRNG_MCTL_FOR_SCLK = 0x80
	// Position of FCT_FAIL field.
	TRNG_MCTL_FCT_FAIL_Pos = 0x8
	// Bit mask of FCT_FAIL field.
	TRNG_MCTL_FCT_FAIL_Msk = 0x100
	// Bit FCT_FAIL.
	TRNG_MCTL_FCT_FAIL = 0x100
	// Position of FCT_VAL field.
	TRNG_MCTL_FCT_VAL_Pos = 0x9
	// Bit mask of FCT_VAL field.
	TRNG_MCTL_FCT_VAL_Msk = 0x200
	// Bit FCT_VAL.
	TRNG_MCTL_FCT_VAL = 0x200
	// Position of ENT_VAL field.
	TRNG_MCTL_ENT_VAL_Pos = 0xa
	// Bit mask of ENT_VAL field.
	TRNG_MCTL_ENT_VAL_Msk = 0x400
	// Bit ENT_VAL.
	TRNG_MCTL_ENT_VAL = 0x400
	// Position of TST_OUT field.
	TRNG_MCTL_TST_OUT_Pos = 0xb
	// Bit mask of TST_OUT field.
	TRNG_MCTL_TST_OUT_Msk = 0x800
	// Bit TST_OUT.
	TRNG_MCTL_TST_OUT = 0x800
	// Position of ERR field.
	TRNG_MCTL_ERR_Pos = 0xc
	// Bit mask of ERR field.
	TRNG_MCTL_ERR_Msk = 0x1000
	// Bit ERR.
	TRNG_MCTL_ERR = 0x1000
	// Position of TSTOP_OK field.
	TRNG_MCTL_TSTOP_OK_Pos = 0xd
	// Bit mask of TSTOP_OK field.
	TRNG_MCTL_TSTOP_OK_Msk = 0x2000
	// Bit TSTOP_OK.
	TRNG_MCTL_TSTOP_OK = 0x2000
	// Position of LRUN_CONT field.
	TRNG_MCTL_LRUN_CONT_Pos = 0xe
	// Bit mask of LRUN_CONT field.
	TRNG_MCTL_LRUN_CONT_Msk = 0x4000
	// Bit LRUN_CONT.
	TRNG_MCTL_LRUN_CONT = 0x4000
	// Position of PRGM field.
	TRNG_MCTL_PRGM_Pos = 0x10
	// Bit mask of PRGM field.
	TRNG_MCTL_PRGM_Msk = 0x10000
	// Bit PRGM.
	TRNG_MCTL_PRGM = 0x10000

	// SCMISC: Statistical Check Miscellaneous Register
	// Position of LRUN_MAX field.
	TRNG_SCMISC_LRUN_MAX_Pos = 0x0
	// Bit mask of LRUN_MAX field.
	TRNG_SCMISC_LRUN_MAX_Msk = 0xff
	// Position of RTY_CT field.
	TRNG_SCMISC_RTY_CT_Pos = 0x10
	// Bit mask of RTY_CT field.
	TRNG_SCMISC_RTY_CT_Msk = 0xf0000

	// PKRRNG: Poker Range Register
	// Position of PKR_RNG field.
	TRNG_PKRRNG_PKR_RNG_Pos = 0x0
	// Bit mask of PKR_RNG field.
	TRNG_PKRRNG_PKR_RNG_Msk = 0xffff

	// PKRMAX: Poker Maximum Limit Register
	// Position of PKR_MAX field.
	TRNG_PKRMAX_PKR_MAX_Pos = 0x0
	// Bit mask of PKR_MAX field.
	TRNG_PKRMAX_PKR_MAX_Msk = 0xffffff

	// PKRSQ: Poker Square Calculation Result Register
	// Position of PKR_SQ field.
	TRNG_PKRSQ_PKR_SQ_Pos = 0x0
	// Bit mask of PKR_SQ field.
	TRNG_PKRSQ_PKR_SQ_Msk = 0xffffff

	// SDCTL: Seed Control Register
	// Position of SAMP_SIZE field.
	TRNG_SDCTL_SAMP_SIZE_Pos = 0x0
	// Bit mask of SAMP_SIZE field.
	TRNG_SDCTL_SAMP_SIZE_Msk = 0xffff
	// Position of ENT_DLY field.
	TRNG_SDCTL_ENT_DLY_Pos = 0x10
	// Bit mask of ENT_DLY field.
	TRNG_SDCTL_ENT_DLY_Msk = 0xffff0000

	// SBLIM: Sparse Bit Limit Register
	// Position of SB_LIM field.
	TRNG_SBLIM_SB_LIM_Pos = 0x0
	// Bit mask of SB_LIM field.
	TRNG_SBLIM_SB_LIM_Msk = 0x3ff

	// TOTSAM: Total Samples Register
	// Position of TOT_SAM field.
	TRNG_TOTSAM_TOT_SAM_Pos = 0x0
	// Bit mask of TOT_SAM field.
	TRNG_TOTSAM_TOT_SAM_Msk = 0xfffff

	// FRQMIN: Frequency Count Minimum Limit Register
	// Position of FRQ_MIN field.
	TRNG_FRQMIN_FRQ_MIN_Pos = 0x0
	// Bit mask of FRQ_MIN field.
	TRNG_FRQMIN_FRQ_MIN_Msk = 0x3fffff

	// FRQCNT: Frequency Count Register
	// Position of FRQ_CT field.
	TRNG_FRQCNT_FRQ_CT_Pos = 0x0
	// Bit mask of FRQ_CT field.
	TRNG_FRQCNT_FRQ_CT_Msk = 0x3fffff

	// FRQMAX: Frequency Count Maximum Limit Register
	// Position of FRQ_MAX field.
	TRNG_FRQMAX_FRQ_MAX_Pos = 0x0
	// Bit mask of FRQ_MAX field.
	TRNG_FRQMAX_FRQ_MAX_Msk = 0x3fffff

	// SCMC: Statistical Check Monobit Count Register
	// Position of MONO_CT field.
	TRNG_SCMC_MONO_CT_Pos = 0x0
	// Bit mask of MONO_CT field.
	TRNG_SCMC_MONO_CT_Msk = 0xffff

	// SCML: Statistical Check Monobit Limit Register
	// Position of MONO_MAX field.
	TRNG_SCML_MONO_MAX_Pos = 0x0
	// Bit mask of MONO_MAX field.
	TRNG_SCML_MONO_MAX_Msk = 0xffff
	// Position of MONO_RNG field.
	TRNG_SCML_MONO_RNG_Pos = 0x10
	// Bit mask of MONO_RNG field.
	TRNG_SCML_MONO_RNG_Msk = 0xffff0000

	// SCR1C: Statistical Check Run Length 1 Count Register
	// Position of R1_0_CT field.
	TRNG_SCR1C_R1_0_CT_Pos = 0x0
	// Bit mask of R1_0_CT field.
	TRNG_SCR1C_R1_0_CT_Msk = 0x7fff
	// Position of R1_1_CT field.
	TRNG_SCR1C_R1_1_CT_Pos = 0x10
	// Bit mask of R1_1_CT field.
	TRNG_SCR1C_R1_1_CT_Msk = 0x7fff0000

	// SCR1L: Statistical Check Run Length 1 Limit Register
	// Position of RUN1_MAX field.
	TRNG_SCR1L_RUN1_MAX_Pos = 0x0
	// Bit mask of RUN1_MAX field.
	TRNG_SCR1L_RUN1_MAX_Msk = 0x7fff
	// Position of RUN1_RNG field.
	TRNG_SCR1L_RUN1_RNG_Pos = 0x10
	// Bit mask of RUN1_RNG field.
	TRNG_SCR1L_RUN1_RNG_Msk = 0x7fff0000

	// SCR2C: Statistical Check Run Length 2 Count Register
	// Position of R2_0_CT field.
	TRNG_SCR2C_R2_0_CT_Pos = 0x0
	// Bit mask of R2_0_CT field.
	TRNG_SCR2C_R2_0_CT_Msk = 0x3fff
	// Position of R2_1_CT field.
	TRNG_SCR2C_R2_1_CT_Pos = 0x10
	// Bit mask of R2_1_CT field.
	TRNG_SCR2C_R2_1_CT_Msk = 0x3fff0000

	// SCR2L: Statistical Check Run Length 2 Limit Register
	// Position of RUN2_MAX field.
	TRNG_SCR2L_RUN2_MAX_Pos = 0x0
	// Bit mask of RUN2_MAX field.
	TRNG_SCR2L_RUN2_MAX_Msk = 0x3fff
	// Position of RUN2_RNG field.
	TRNG_SCR2L_RUN2_RNG_Pos = 0x10
	// Bit mask of RUN2_RNG field.
	TRNG_SCR2L_RUN2_RNG_Msk = 0x3fff0000

	// SCR3C: Statistical Check Run Length 3 Count Register
	// Position of R3_0_CT field.
	TRNG_SCR3C_R3_0_CT_Pos = 0x0
	// Bit mask of R3_0_CT field.
	TRNG_SCR3C_R3_0_CT_Msk = 0x1fff
	// Position of R3_1_CT field.
	TRNG_SCR3C_R3_1_CT_Pos = 0x10
	// Bit mask of R3_1_CT field.
	TRNG_SCR3C_R3_1_CT_Msk = 0x1fff0000

	// SCR3L: Statistical Check Run Length 3 Limit Register
	// Position of RUN3_MAX field.
	TRNG_SCR3L_RUN3_MAX_Pos = 0x0
	// Bit mask of RUN3_MAX field.
	TRNG_SCR3L_RUN3_MAX_Msk = 0x1fff
	// Position of RUN3_RNG field.
	TRNG_SCR3L_RUN3_RNG_Pos = 0x10
	// Bit mask of RUN3_RNG field.
	TRNG_SCR3L_RUN3_RNG_Msk = 0x1fff0000

	// SCR4C: Statistical Check Run Length 4 Count Register
	// Position of R4_0_CT field.
	TRNG_SCR4C_R4_0_CT_Pos = 0x0
	// Bit mask of R4_0_CT field.
	TRNG_SCR4C_R4_0_CT_Msk = 0xfff
	// Position of R4_1_CT field.
	TRNG_SCR4C_R4_1_CT_Pos = 0x10
	// Bit mask of R4_1_CT field.
	TRNG_SCR4C_R4_1_CT_Msk = 0xfff0000

	// SCR4L: Statistical Check Run Length 4 Limit Register
	// Position of RUN4_MAX field.
	TRNG_SCR4L_RUN4_MAX_Pos = 0x0
	// Bit mask of RUN4_MAX field.
	TRNG_SCR4L_RUN4_MAX_Msk = 0xfff
	// Position of RUN4_RNG field.
	TRNG_SCR4L_RUN4_RNG_Pos = 0x10
	// Bit mask of RUN4_RNG field.
	TRNG_SCR4L_RUN4_RNG_Msk = 0xfff0000

	// SCR5C: Statistical Check Run Length 5 Count Register
	// Position of R5_0_CT field.
	TRNG_SCR5C_R5_0_CT_Pos = 0x0
	// Bit mask of R5_0_CT field.
	TRNG_SCR5C_R5_0_CT_Msk = 0x7ff
	// Position of R5_1_CT field.
	TRNG_SCR5C_R5_1_CT_Pos = 0x10
	// Bit mask of R5_1_CT field.
	TRNG_SCR5C_R5_1_CT_Msk = 0x7ff0000

	// SCR5L: Statistical Check Run Length 5 Limit Register
	// Position of RUN5_MAX field.
	TRNG_SCR5L_RUN5_MAX_Pos = 0x0
	// Bit mask of RUN5_MAX field.
	TRNG_SCR5L_RUN5_MAX_Msk = 0x7ff
	// Position of RUN5_RNG field.
	TRNG_SCR5L_RUN5_RNG_Pos = 0x10
	// Bit mask of RUN5_RNG field.
	TRNG_SCR5L_RUN5_RNG_Msk = 0x7ff0000

	// SCR6PC: Statistical Check Run Length 6+ Count Register
	// Position of R6P_0_CT field.
	TRNG_SCR6PC_R6P_0_CT_Pos = 0x0
	// Bit mask of R6P_0_CT field.
	TRNG_SCR6PC_R6P_0_CT_Msk = 0x7ff
	// Position of R6P_1_CT field.
	TRNG_SCR6PC_R6P_1_CT_Pos = 0x10
	// Bit mask of R6P_1_CT field.
	TRNG_SCR6PC_R6P_1_CT_Msk = 0x7ff0000

	// SCR6PL: Statistical Check Run Length 6+ Limit Register
	// Position of RUN6P_MAX field.
	TRNG_SCR6PL_RUN6P_MAX_Pos = 0x0
	// Bit mask of RUN6P_MAX field.
	TRNG_SCR6PL_RUN6P_MAX_Msk = 0x7ff
	// Position of RUN6P_RNG field.
	TRNG_SCR6PL_RUN6P_RNG_Pos = 0x10
	// Bit mask of RUN6P_RNG field.
	TRNG_SCR6PL_RUN6P_RNG_Msk = 0x7ff0000

	// STATUS: Status Register
	// Position of TF1BR0 field.
	TRNG_STATUS_TF1BR0_Pos = 0x0
	// Bit mask of TF1BR0 field.
	TRNG_STATUS_TF1BR0_Msk = 0x1
	// Bit TF1BR0.
	TRNG_STATUS_TF1BR0 = 0x1
	// Position of TF1BR1 field.
	TRNG_STATUS_TF1BR1_Pos = 0x1
	// Bit mask of TF1BR1 field.
	TRNG_STATUS_TF1BR1_Msk = 0x2
	// Bit TF1BR1.
	TRNG_STATUS_TF1BR1 = 0x2
	// Position of TF2BR0 field.
	TRNG_STATUS_TF2BR0_Pos = 0x2
	// Bit mask of TF2BR0 field.
	TRNG_STATUS_TF2BR0_Msk = 0x4
	// Bit TF2BR0.
	TRNG_STATUS_TF2BR0 = 0x4
	// Position of TF2BR1 field.
	TRNG_STATUS_TF2BR1_Pos = 0x3
	// Bit mask of TF2BR1 field.
	TRNG_STATUS_TF2BR1_Msk = 0x8
	// Bit TF2BR1.
	TRNG_STATUS_TF2BR1 = 0x8
	// Position of TF3BR0 field.
	TRNG_STATUS_TF3BR0_Pos = 0x4
	// Bit mask of TF3BR0 field.
	TRNG_STATUS_TF3BR0_Msk = 0x10
	// Bit TF3BR0.
	TRNG_STATUS_TF3BR0 = 0x10
	// Position of TF3BR1 field.
	TRNG_STATUS_TF3BR1_Pos = 0x5
	// Bit mask of TF3BR1 field.
	TRNG_STATUS_TF3BR1_Msk = 0x20
	// Bit TF3BR1.
	TRNG_STATUS_TF3BR1 = 0x20
	// Position of TF4BR0 field.
	TRNG_STATUS_TF4BR0_Pos = 0x6
	// Bit mask of TF4BR0 field.
	TRNG_STATUS_TF4BR0_Msk = 0x40
	// Bit TF4BR0.
	TRNG_STATUS_TF4BR0 = 0x40
	// Position of TF4BR1 field.
	TRNG_STATUS_TF4BR1_Pos = 0x7
	// Bit mask of TF4BR1 field.
	TRNG_STATUS_TF4BR1_Msk = 0x80
	// Bit TF4BR1.
	TRNG_STATUS_TF4BR1 = 0x80
	// Position of TF5BR0 field.
	TRNG_STATUS_TF5BR0_Pos = 0x8
	// Bit mask of TF5BR0 field.
	TRNG_STATUS_TF5BR0_Msk = 0x100
	// Bit TF5BR0.
	TRNG_STATUS_TF5BR0 = 0x100
	// Position of TF5BR1 field.
	TRNG_STATUS_TF5BR1_Pos = 0x9
	// Bit mask of TF5BR1 field.
	TRNG_STATUS_TF5BR1_Msk = 0x200
	// Bit TF5BR1.
	TRNG_STATUS_TF5BR1 = 0x200
	// Position of TF6PBR0 field.
	TRNG_STATUS_TF6PBR0_Pos = 0xa
	// Bit mask of TF6PBR0 field.
	TRNG_STATUS_TF6PBR0_Msk = 0x400
	// Bit TF6PBR0.
	TRNG_STATUS_TF6PBR0 = 0x400
	// Position of TF6PBR1 field.
	TRNG_STATUS_TF6PBR1_Pos = 0xb
	// Bit mask of TF6PBR1 field.
	TRNG_STATUS_TF6PBR1_Msk = 0x800
	// Bit TF6PBR1.
	TRNG_STATUS_TF6PBR1 = 0x800
	// Position of TFSB field.
	TRNG_STATUS_TFSB_Pos = 0xc
	// Bit mask of TFSB field.
	TRNG_STATUS_TFSB_Msk = 0x1000
	// Bit TFSB.
	TRNG_STATUS_TFSB = 0x1000
	// Position of TFLR field.
	TRNG_STATUS_TFLR_Pos = 0xd
	// Bit mask of TFLR field.
	TRNG_STATUS_TFLR_Msk = 0x2000
	// Bit TFLR.
	TRNG_STATUS_TFLR = 0x2000
	// Position of TFP field.
	TRNG_STATUS_TFP_Pos = 0xe
	// Bit mask of TFP field.
	TRNG_STATUS_TFP_Msk = 0x4000
	// Bit TFP.
	TRNG_STATUS_TFP = 0x4000
	// Position of TFMB field.
	TRNG_STATUS_TFMB_Pos = 0xf
	// Bit mask of TFMB field.
	TRNG_STATUS_TFMB_Msk = 0x8000
	// Bit TFMB.
	TRNG_STATUS_TFMB = 0x8000
	// Position of RETRY_CT field.
	TRNG_STATUS_RETRY_CT_Pos = 0x10
	// Bit mask of RETRY_CT field.
	TRNG_STATUS_RETRY_CT_Msk = 0xf0000

	// ENT: Entropy Read Register
	// Position of ENT field.
	TRNG_ENT_ENT_Pos = 0x0
	// Bit mask of ENT field.
	TRNG_ENT_ENT_Msk = 0xffffffff

	// PKRCNT10: Statistical Check Poker Count 1 and 0 Register
	// Position of PKR_0_CT field.
	TRNG_PKRCNT10_PKR_0_CT_Pos = 0x0
	// Bit mask of PKR_0_CT field.
	TRNG_PKRCNT10_PKR_0_CT_Msk = 0xffff
	// Position of PKR_1_CT field.
	TRNG_PKRCNT10_PKR_1_CT_Pos = 0x10
	// Bit mask of PKR_1_CT field.
	TRNG_PKRCNT10_PKR_1_CT_Msk = 0xffff0000

	// PKRCNT32: Statistical Check Poker Count 3 and 2 Register
	// Position of PKR_2_CT field.
	TRNG_PKRCNT32_PKR_2_CT_Pos = 0x0
	// Bit mask of PKR_2_CT field.
	TRNG_PKRCNT32_PKR_2_CT_Msk = 0xffff
	// Position of PKR_3_CT field.
	TRNG_PKRCNT32_PKR_3_CT_Pos = 0x10
	// Bit mask of PKR_3_CT field.
	TRNG_PKRCNT32_PKR_3_CT_Msk = 0xffff0000

	// PKRCNT54: Statistical Check Poker Count 5 and 4 Register
	// Position of PKR_4_CT field.
	TRNG_PKRCNT54_PKR_4_CT_Pos = 0x0
	// Bit mask of PKR_4_CT field.
	TRNG_PKRCNT54_PKR_4_CT_Msk = 0xffff
	// Position of PKR_5_CT field.
	TRNG_PKRCNT54_PKR_5_CT_Pos = 0x10
	// Bit mask of PKR_5_CT field.
	TRNG_PKRCNT54_PKR_5_CT_Msk = 0xffff0000

	// PKRCNT76: Statistical Check Poker Count 7 and 6 Register
	// Position of PKR_6_CT field.
	TRNG_PKRCNT76_PKR_6_CT_Pos = 0x0
	// Bit mask of PKR_6_CT field.
	TRNG_PKRCNT76_PKR_6_CT_Msk = 0xffff
	// Position of PKR_7_CT field.
	TRNG_PKRCNT76_PKR_7_CT_Pos = 0x10
	// Bit mask of PKR_7_CT field.
	TRNG_PKRCNT76_PKR_7_CT_Msk = 0xffff0000

	// PKRCNT98: Statistical Check Poker Count 9 and 8 Register
	// Position of PKR_8_CT field.
	TRNG_PKRCNT98_PKR_8_CT_Pos = 0x0
	// Bit mask of PKR_8_CT field.
	TRNG_PKRCNT98_PKR_8_CT_Msk = 0xffff
	// Position of PKR_9_CT field.
	TRNG_PKRCNT98_PKR_9_CT_Pos = 0x10
	// Bit mask of PKR_9_CT field.
	TRNG_PKRCNT98_PKR_9_CT_Msk = 0xffff0000

	// PKRCNTBA: Statistical Check Poker Count B and A Register
	// Position of PKR_A_CT field.
	TRNG_PKRCNTBA_PKR_A_CT_Pos = 0x0
	// Bit mask of PKR_A_CT field.
	TRNG_PKRCNTBA_PKR_A_CT_Msk = 0xffff
	// Position of PKR_B_CT field.
	TRNG_PKRCNTBA_PKR_B_CT_Pos = 0x10
	// Bit mask of PKR_B_CT field.
	TRNG_PKRCNTBA_PKR_B_CT_Msk = 0xffff0000

	// PKRCNTDC: Statistical Check Poker Count D and C Register
	// Position of PKR_C_CT field.
	TRNG_PKRCNTDC_PKR_C_CT_Pos = 0x0
	// Bit mask of PKR_C_CT field.
	TRNG_PKRCNTDC_PKR_C_CT_Msk = 0xffff
	// Position of PKR_D_CT field.
	TRNG_PKRCNTDC_PKR_D_CT_Pos = 0x10
	// Bit mask of PKR_D_CT field.
	TRNG_PKRCNTDC_PKR_D_CT_Msk = 0xffff0000

	// PKRCNTFE: Statistical Check Poker Count F and E Register
	// Position of PKR_E_CT field.
	TRNG_PKRCNTFE_PKR_E_CT_Pos = 0x0
	// Bit mask of PKR_E_CT field.
	TRNG_PKRCNTFE_PKR_E_CT_Msk = 0xffff
	// Position of PKR_F_CT field.
	TRNG_PKRCNTFE_PKR_F_CT_Pos = 0x10
	// Bit mask of PKR_F_CT field.
	TRNG_PKRCNTFE_PKR_F_CT_Msk = 0xffff0000

	// SEC_CFG: Security Configuration Register
	// Position of UNUSED0 field.
	TRNG_SEC_CFG_UNUSED0_Pos = 0x0
	// Bit mask of UNUSED0 field.
	TRNG_SEC_CFG_UNUSED0_Msk = 0x1
	// Bit UNUSED0.
	TRNG_SEC_CFG_UNUSED0 = 0x1
	// Position of NO_PRGM field.
	TRNG_SEC_CFG_NO_PRGM_Pos = 0x1
	// Bit mask of NO_PRGM field.
	TRNG_SEC_CFG_NO_PRGM_Msk = 0x2
	// Bit NO_PRGM.
	TRNG_SEC_CFG_NO_PRGM = 0x2
	// Programability of registers controlled only by the Miscellaneous Control Register's access mode bit.
	TRNG_SEC_CFG_NO_PRGM_NO_PRGM_0 = 0x0
	// Overides Miscellaneous Control Register access mode and prevents TRNG register programming.
	TRNG_SEC_CFG_NO_PRGM_NO_PRGM_1 = 0x1
	// Position of UNUSED2 field.
	TRNG_SEC_CFG_UNUSED2_Pos = 0x2
	// Bit mask of UNUSED2 field.
	TRNG_SEC_CFG_UNUSED2_Msk = 0x4
	// Bit UNUSED2.
	TRNG_SEC_CFG_UNUSED2 = 0x4

	// INT_CTRL: Interrupt Control Register
	// Position of HW_ERR field.
	TRNG_INT_CTRL_HW_ERR_Pos = 0x0
	// Bit mask of HW_ERR field.
	TRNG_INT_CTRL_HW_ERR_Msk = 0x1
	// Bit HW_ERR.
	TRNG_INT_CTRL_HW_ERR = 0x1
	// Corresponding bit of INT_STATUS register cleared.
	TRNG_INT_CTRL_HW_ERR_HW_ERR_0 = 0x0
	// Corresponding bit of INT_STATUS register active.
	TRNG_INT_CTRL_HW_ERR_HW_ERR_1 = 0x1
	// Position of ENT_VAL field.
	TRNG_INT_CTRL_ENT_VAL_Pos = 0x1
	// Bit mask of ENT_VAL field.
	TRNG_INT_CTRL_ENT_VAL_Msk = 0x2
	// Bit ENT_VAL.
	TRNG_INT_CTRL_ENT_VAL = 0x2
	// Same behavior as bit 0 of this register.
	TRNG_INT_CTRL_ENT_VAL_ENT_VAL_0 = 0x0
	// Same behavior as bit 0 of this register.
	TRNG_INT_CTRL_ENT_VAL_ENT_VAL_1 = 0x1
	// Position of FRQ_CT_FAIL field.
	TRNG_INT_CTRL_FRQ_CT_FAIL_Pos = 0x2
	// Bit mask of FRQ_CT_FAIL field.
	TRNG_INT_CTRL_FRQ_CT_FAIL_Msk = 0x4
	// Bit FRQ_CT_FAIL.
	TRNG_INT_CTRL_FRQ_CT_FAIL = 0x4
	// Same behavior as bit 0 of this register.
	TRNG_INT_CTRL_FRQ_CT_FAIL_FRQ_CT_FAIL_0 = 0x0
	// Same behavior as bit 0 of this register.
	TRNG_INT_CTRL_FRQ_CT_FAIL_FRQ_CT_FAIL_1 = 0x1

	// INT_MASK: Mask Register
	// Position of HW_ERR field.
	TRNG_INT_MASK_HW_ERR_Pos = 0x0
	// Bit mask of HW_ERR field.
	TRNG_INT_MASK_HW_ERR_Msk = 0x1
	// Bit HW_ERR.
	TRNG_INT_MASK_HW_ERR = 0x1
	// Corresponding interrupt of INT_STATUS is masked.
	TRNG_INT_MASK_HW_ERR_HW_ERR_0 = 0x0
	// Corresponding bit of INT_STATUS is active.
	TRNG_INT_MASK_HW_ERR_HW_ERR_1 = 0x1
	// Position of ENT_VAL field.
	TRNG_INT_MASK_ENT_VAL_Pos = 0x1
	// Bit mask of ENT_VAL field.
	TRNG_INT_MASK_ENT_VAL_Msk = 0x2
	// Bit ENT_VAL.
	TRNG_INT_MASK_ENT_VAL = 0x2
	// Same behavior as bit 0 of this register.
	TRNG_INT_MASK_ENT_VAL_ENT_VAL_0 = 0x0
	// Same behavior as bit 0 of this register.
	TRNG_INT_MASK_ENT_VAL_ENT_VAL_1 = 0x1
	// Position of FRQ_CT_FAIL field.
	TRNG_INT_MASK_FRQ_CT_FAIL_Pos = 0x2
	// Bit mask of FRQ_CT_FAIL field.
	TRNG_INT_MASK_FRQ_CT_FAIL_Msk = 0x4
	// Bit FRQ_CT_FAIL.
	TRNG_INT_MASK_FRQ_CT_FAIL = 0x4
	// Same behavior as bit 0 of this register.
	TRNG_INT_MASK_FRQ_CT_FAIL_FRQ_CT_FAIL_0 = 0x0
	// Same behavior as bit 0 of this register.
	TRNG_INT_MASK_FRQ_CT_FAIL_FRQ_CT_FAIL_1 = 0x1

	// INT_STATUS: Interrupt Status Register
	// Position of HW_ERR field.
	TRNG_INT_STATUS_HW_ERR_Pos = 0x0
	// Bit mask of HW_ERR field.
	TRNG_INT_STATUS_HW_ERR_Msk = 0x1
	// Bit HW_ERR.
	TRNG_INT_STATUS_HW_ERR = 0x1
	// no error
	TRNG_INT_STATUS_HW_ERR_HW_ERR_0 = 0x0
	// error detected.
	TRNG_INT_STATUS_HW_ERR_HW_ERR_1 = 0x1
	// Position of ENT_VAL field.
	TRNG_INT_STATUS_ENT_VAL_Pos = 0x1
	// Bit mask of ENT_VAL field.
	TRNG_INT_STATUS_ENT_VAL_Msk = 0x2
	// Bit ENT_VAL.
	TRNG_INT_STATUS_ENT_VAL = 0x2
	// Busy generation entropy. Any value read is invalid.
	TRNG_INT_STATUS_ENT_VAL_ENT_VAL_0 = 0x0
	// TRNG can be stopped and entropy is valid if read.
	TRNG_INT_STATUS_ENT_VAL_ENT_VAL_1 = 0x1
	// Position of FRQ_CT_FAIL field.
	TRNG_INT_STATUS_FRQ_CT_FAIL_Pos = 0x2
	// Bit mask of FRQ_CT_FAIL field.
	TRNG_INT_STATUS_FRQ_CT_FAIL_Msk = 0x4
	// Bit FRQ_CT_FAIL.
	TRNG_INT_STATUS_FRQ_CT_FAIL = 0x4
	// No hardware nor self test frequency errors.
	TRNG_INT_STATUS_FRQ_CT_FAIL_FRQ_CT_FAIL_0 = 0x0
	// The frequency counter has detected a failure.
	TRNG_INT_STATUS_FRQ_CT_FAIL_FRQ_CT_FAIL_1 = 0x1

	// VID1: Version ID Register (MS)
	// Position of MIN_REV field.
	TRNG_VID1_MIN_REV_Pos = 0x0
	// Bit mask of MIN_REV field.
	TRNG_VID1_MIN_REV_Msk = 0xff
	// Minor revision number for TRNG.
	TRNG_VID1_MIN_REV_MIN_REV_0 = 0x0
	// Position of MAJ_REV field.
	TRNG_VID1_MAJ_REV_Pos = 0x8
	// Bit mask of MAJ_REV field.
	TRNG_VID1_MAJ_REV_Msk = 0xff00
	// Major revision number for TRNG.
	TRNG_VID1_MAJ_REV_MAJ_REV_1 = 0x1
	// Position of IP_ID field.
	TRNG_VID1_IP_ID_Pos = 0x10
	// Bit mask of IP_ID field.
	TRNG_VID1_IP_ID_Msk = 0xffff0000
	// ID for TRNG.
	TRNG_VID1_IP_ID_IP_ID_48 = 0x30

	// VID2: Version ID Register (LS)
	// Position of CONFIG_OPT field.
	TRNG_VID2_CONFIG_OPT_Pos = 0x0
	// Bit mask of CONFIG_OPT field.
	TRNG_VID2_CONFIG_OPT_Msk = 0xff
	// TRNG_CONFIG_OPT for TRNG.
	TRNG_VID2_CONFIG_OPT_CONFIG_OPT_0 = 0x0
	// Position of ECO_REV field.
	TRNG_VID2_ECO_REV_Pos = 0x8
	// Bit mask of ECO_REV field.
	TRNG_VID2_ECO_REV_Msk = 0xff00
	// TRNG_ECO_REV for TRNG.
	TRNG_VID2_ECO_REV_ECO_REV_0 = 0x0
	// Position of INTG_OPT field.
	TRNG_VID2_INTG_OPT_Pos = 0x10
	// Bit mask of INTG_OPT field.
	TRNG_VID2_INTG_OPT_Msk = 0xff0000
	// INTG_OPT for TRNG.
	TRNG_VID2_INTG_OPT_INTG_OPT_0 = 0x0
	// Position of ERA field.
	TRNG_VID2_ERA_Pos = 0x18
	// Bit mask of ERA field.
	TRNG_VID2_ERA_Msk = 0xff000000
	// COMPILE_OPT for TRNG.
	TRNG_VID2_ERA_ERA_0 = 0x0
)

// Bitfields for SNVS: SNVS
const (
	// HPLR: SNVS_HP Lock Register
	// Position of ZMK_WSL field.
	SNVS_HPLR_ZMK_WSL_Pos = 0x0
	// Bit mask of ZMK_WSL field.
	SNVS_HPLR_ZMK_WSL_Msk = 0x1
	// Bit ZMK_WSL.
	SNVS_HPLR_ZMK_WSL = 0x1
	// Write access is allowed
	SNVS_HPLR_ZMK_WSL_ZMK_WSL_0 = 0x0
	// Write access is not allowed
	SNVS_HPLR_ZMK_WSL_ZMK_WSL_1 = 0x1
	// Position of ZMK_RSL field.
	SNVS_HPLR_ZMK_RSL_Pos = 0x1
	// Bit mask of ZMK_RSL field.
	SNVS_HPLR_ZMK_RSL_Msk = 0x2
	// Bit ZMK_RSL.
	SNVS_HPLR_ZMK_RSL = 0x2
	// Read access is allowed (only in software Programming mode)
	SNVS_HPLR_ZMK_RSL_ZMK_RSL_0 = 0x0
	// Read access is not allowed
	SNVS_HPLR_ZMK_RSL_ZMK_RSL_1 = 0x1
	// Position of SRTC_SL field.
	SNVS_HPLR_SRTC_SL_Pos = 0x2
	// Bit mask of SRTC_SL field.
	SNVS_HPLR_SRTC_SL_Msk = 0x4
	// Bit SRTC_SL.
	SNVS_HPLR_SRTC_SL = 0x4
	// Write access is allowed
	SNVS_HPLR_SRTC_SL_SRTC_SL_0 = 0x0
	// Write access is not allowed
	SNVS_HPLR_SRTC_SL_SRTC_SL_1 = 0x1
	// Position of LPCALB_SL field.
	SNVS_HPLR_LPCALB_SL_Pos = 0x3
	// Bit mask of LPCALB_SL field.
	SNVS_HPLR_LPCALB_SL_Msk = 0x8
	// Bit LPCALB_SL.
	SNVS_HPLR_LPCALB_SL = 0x8
	// Write access is allowed
	SNVS_HPLR_LPCALB_SL_LPCALB_SL_0 = 0x0
	// Write access is not allowed
	SNVS_HPLR_LPCALB_SL_LPCALB_SL_1 = 0x1
	// Position of MC_SL field.
	SNVS_HPLR_MC_SL_Pos = 0x4
	// Bit mask of MC_SL field.
	SNVS_HPLR_MC_SL_Msk = 0x10
	// Bit MC_SL.
	SNVS_HPLR_MC_SL = 0x10
	// Write access (increment) is allowed
	SNVS_HPLR_MC_SL_MC_SL_0 = 0x0
	// Write access (increment) is not allowed
	SNVS_HPLR_MC_SL_MC_SL_1 = 0x1
	// Position of GPR_SL field.
	SNVS_HPLR_GPR_SL_Pos = 0x5
	// Bit mask of GPR_SL field.
	SNVS_HPLR_GPR_SL_Msk = 0x20
	// Bit GPR_SL.
	SNVS_HPLR_GPR_SL = 0x20
	// Write access is allowed
	SNVS_HPLR_GPR_SL_GPR_SL_0 = 0x0
	// Write access is not allowed
	SNVS_HPLR_GPR_SL_GPR_SL_1 = 0x1
	// Position of LPSVCR_SL field.
	SNVS_HPLR_LPSVCR_SL_Pos = 0x6
	// Bit mask of LPSVCR_SL field.
	SNVS_HPLR_LPSVCR_SL_Msk = 0x40
	// Bit LPSVCR_SL.
	SNVS_HPLR_LPSVCR_SL = 0x40
	// Write access is allowed
	SNVS_HPLR_LPSVCR_SL_LPSVCR_SL_0 = 0x0
	// Write access is not allowed
	SNVS_HPLR_LPSVCR_SL_LPSVCR_SL_1 = 0x1
	// Position of LPTDCR_SL field.
	SNVS_HPLR_LPTDCR_SL_Pos = 0x8
	// Bit mask of LPTDCR_SL field.
	SNVS_HPLR_LPTDCR_SL_Msk = 0x100
	// Bit LPTDCR_SL.
	SNVS_HPLR_LPTDCR_SL = 0x100
	// Write access is allowed
	SNVS_HPLR_LPTDCR_SL_LPTDCR_SL_0 = 0x0
	// Write access is not allowed
	SNVS_HPLR_LPTDCR_SL_LPTDCR_SL_1 = 0x1
	// Position of MKS_SL field.
	SNVS_HPLR_MKS_SL_Pos = 0x9
	// Bit mask of MKS_SL field.
	SNVS_HPLR_MKS_SL_Msk = 0x200
	// Bit MKS_SL.
	SNVS_HPLR_MKS_SL = 0x200
	// Write access is allowed
	SNVS_HPLR_MKS_SL_MKS_SL_0 = 0x0
	// Write access is not allowed
	SNVS_HPLR_MKS_SL_MKS_SL_1 = 0x1
	// Position of HPSVCR_L field.
	SNVS_HPLR_HPSVCR_L_Pos = 0x10
	// Bit mask of HPSVCR_L field.
	SNVS_HPLR_HPSVCR_L_Msk = 0x10000
	// Bit HPSVCR_L.
	SNVS_HPLR_HPSVCR_L = 0x10000
	// Write access is allowed
	SNVS_HPLR_HPSVCR_L_HPSVCR_L_0 = 0x0
	// Write access is not allowed
	SNVS_HPLR_HPSVCR_L_HPSVCR_L_1 = 0x1
	// Position of HPSICR_L field.
	SNVS_HPLR_HPSICR_L_Pos = 0x11
	// Bit mask of HPSICR_L field.
	SNVS_HPLR_HPSICR_L_Msk = 0x20000
	// Bit HPSICR_L.
	SNVS_HPLR_HPSICR_L = 0x20000
	// Write access is allowed
	SNVS_HPLR_HPSICR_L_HPSICR_L_0 = 0x0
	// Write access is not allowed
	SNVS_HPLR_HPSICR_L_HPSICR_L_1 = 0x1
	// Position of HAC_L field.
	SNVS_HPLR_HAC_L_Pos = 0x12
	// Bit mask of HAC_L field.
	SNVS_HPLR_HAC_L_Msk = 0x40000
	// Bit HAC_L.
	SNVS_HPLR_HAC_L = 0x40000
	// Write access is allowed
	SNVS_HPLR_HAC_L_HAC_L_0 = 0x0
	// Write access is not allowed
	SNVS_HPLR_HAC_L_HAC_L_1 = 0x1

	// HPCOMR: SNVS_HP Command Register
	// Position of SSM_ST field.
	SNVS_HPCOMR_SSM_ST_Pos = 0x0
	// Bit mask of SSM_ST field.
	SNVS_HPCOMR_SSM_ST_Msk = 0x1
	// Bit SSM_ST.
	SNVS_HPCOMR_SSM_ST = 0x1
	// Position of SSM_ST_DIS field.
	SNVS_HPCOMR_SSM_ST_DIS_Pos = 0x1
	// Bit mask of SSM_ST_DIS field.
	SNVS_HPCOMR_SSM_ST_DIS_Msk = 0x2
	// Bit SSM_ST_DIS.
	SNVS_HPCOMR_SSM_ST_DIS = 0x2
	// Secure to Trusted State transition is enabled
	SNVS_HPCOMR_SSM_ST_DIS_SSM_ST_DIS_0 = 0x0
	// Secure to Trusted State transition is disabled
	SNVS_HPCOMR_SSM_ST_DIS_SSM_ST_DIS_1 = 0x1
	// Position of SSM_SFNS_DIS field.
	SNVS_HPCOMR_SSM_SFNS_DIS_Pos = 0x2
	// Bit mask of SSM_SFNS_DIS field.
	SNVS_HPCOMR_SSM_SFNS_DIS_Msk = 0x4
	// Bit SSM_SFNS_DIS.
	SNVS_HPCOMR_SSM_SFNS_DIS = 0x4
	// Soft Fail to Non-Secure State transition is enabled
	SNVS_HPCOMR_SSM_SFNS_DIS_SSM_SFNS_DIS_0 = 0x0
	// Soft Fail to Non-Secure State transition is disabled
	SNVS_HPCOMR_SSM_SFNS_DIS_SSM_SFNS_DIS_1 = 0x1
	// Position of LP_SWR field.
	SNVS_HPCOMR_LP_SWR_Pos = 0x4
	// Bit mask of LP_SWR field.
	SNVS_HPCOMR_LP_SWR_Msk = 0x10
	// Bit LP_SWR.
	SNVS_HPCOMR_LP_SWR = 0x10
	// No Action
	SNVS_HPCOMR_LP_SWR_LP_SWR_0 = 0x0
	// Reset LP section
	SNVS_HPCOMR_LP_SWR_LP_SWR_1 = 0x1
	// Position of LP_SWR_DIS field.
	SNVS_HPCOMR_LP_SWR_DIS_Pos = 0x5
	// Bit mask of LP_SWR_DIS field.
	SNVS_HPCOMR_LP_SWR_DIS_Msk = 0x20
	// Bit LP_SWR_DIS.
	SNVS_HPCOMR_LP_SWR_DIS = 0x20
	// LP software reset is enabled
	SNVS_HPCOMR_LP_SWR_DIS_LP_SWR_DIS_0 = 0x0
	// LP software reset is disabled
	SNVS_HPCOMR_LP_SWR_DIS_LP_SWR_DIS_1 = 0x1
	// Position of SW_SV field.
	SNVS_HPCOMR_SW_SV_Pos = 0x8
	// Bit mask of SW_SV field.
	SNVS_HPCOMR_SW_SV_Msk = 0x100
	// Bit SW_SV.
	SNVS_HPCOMR_SW_SV = 0x100
	// Position of SW_FSV field.
	SNVS_HPCOMR_SW_FSV_Pos = 0x9
	// Bit mask of SW_FSV field.
	SNVS_HPCOMR_SW_FSV_Msk = 0x200
	// Bit SW_FSV.
	SNVS_HPCOMR_SW_FSV = 0x200
	// Position of SW_LPSV field.
	SNVS_HPCOMR_SW_LPSV_Pos = 0xa
	// Bit mask of SW_LPSV field.
	SNVS_HPCOMR_SW_LPSV_Msk = 0x400
	// Bit SW_LPSV.
	SNVS_HPCOMR_SW_LPSV = 0x400
	// Position of PROG_ZMK field.
	SNVS_HPCOMR_PROG_ZMK_Pos = 0xc
	// Bit mask of PROG_ZMK field.
	SNVS_HPCOMR_PROG_ZMK_Msk = 0x1000
	// Bit PROG_ZMK.
	SNVS_HPCOMR_PROG_ZMK = 0x1000
	// No Action
	SNVS_HPCOMR_PROG_ZMK_PROG_ZMK_0 = 0x0
	// Activate hardware key programming mechanism
	SNVS_HPCOMR_PROG_ZMK_PROG_ZMK_1 = 0x1
	// Position of MKS_EN field.
	SNVS_HPCOMR_MKS_EN_Pos = 0xd
	// Bit mask of MKS_EN field.
	SNVS_HPCOMR_MKS_EN_Msk = 0x2000
	// Bit MKS_EN.
	SNVS_HPCOMR_MKS_EN = 0x2000
	// OTP master key is selected as an SNVS master key
	SNVS_HPCOMR_MKS_EN_MKS_EN_0 = 0x0
	// SNVS master key is selected according to the setting of the MASTER_KEY_SEL field of LPMKCR
	SNVS_HPCOMR_MKS_EN_MKS_EN_1 = 0x1
	// Position of HAC_EN field.
	SNVS_HPCOMR_HAC_EN_Pos = 0x10
	// Bit mask of HAC_EN field.
	SNVS_HPCOMR_HAC_EN_Msk = 0x10000
	// Bit HAC_EN.
	SNVS_HPCOMR_HAC_EN = 0x10000
	// High Assurance Counter is disabled
	SNVS_HPCOMR_HAC_EN_HAC_EN_0 = 0x0
	// High Assurance Counter is enabled
	SNVS_HPCOMR_HAC_EN_HAC_EN_1 = 0x1
	// Position of HAC_LOAD field.
	SNVS_HPCOMR_HAC_LOAD_Pos = 0x11
	// Bit mask of HAC_LOAD field.
	SNVS_HPCOMR_HAC_LOAD_Msk = 0x20000
	// Bit HAC_LOAD.
	SNVS_HPCOMR_HAC_LOAD = 0x20000
	// No Action
	SNVS_HPCOMR_HAC_LOAD_HAC_LOAD_0 = 0x0
	// Load the HAC
	SNVS_HPCOMR_HAC_LOAD_HAC_LOAD_1 = 0x1
	// Position of HAC_CLEAR field.
	SNVS_HPCOMR_HAC_CLEAR_Pos = 0x12
	// Bit mask of HAC_CLEAR field.
	SNVS_HPCOMR_HAC_CLEAR_Msk = 0x40000
	// Bit HAC_CLEAR.
	SNVS_HPCOMR_HAC_CLEAR = 0x40000
	// No Action
	SNVS_HPCOMR_HAC_CLEAR_HAC_CLEAR_0 = 0x0
	// Clear the HAC
	SNVS_HPCOMR_HAC_CLEAR_HAC_CLEAR_1 = 0x1
	// Position of HAC_STOP field.
	SNVS_HPCOMR_HAC_STOP_Pos = 0x13
	// Bit mask of HAC_STOP field.
	SNVS_HPCOMR_HAC_STOP_Msk = 0x80000
	// Bit HAC_STOP.
	SNVS_HPCOMR_HAC_STOP = 0x80000
	// Position of NPSWA_EN field.
	SNVS_HPCOMR_NPSWA_EN_Pos = 0x1f
	// Bit mask of NPSWA_EN field.
	SNVS_HPCOMR_NPSWA_EN_Msk = 0x80000000
	// Bit NPSWA_EN.
	SNVS_HPCOMR_NPSWA_EN = 0x80000000

	// HPCR: SNVS_HP Control Register
	// Position of RTC_EN field.
	SNVS_HPCR_RTC_EN_Pos = 0x0
	// Bit mask of RTC_EN field.
	SNVS_HPCR_RTC_EN_Msk = 0x1
	// Bit RTC_EN.
	SNVS_HPCR_RTC_EN = 0x1
	// RTC is disabled
	SNVS_HPCR_RTC_EN_RTC_EN_0 = 0x0
	// RTC is enabled
	SNVS_HPCR_RTC_EN_RTC_EN_1 = 0x1
	// Position of HPTA_EN field.
	SNVS_HPCR_HPTA_EN_Pos = 0x1
	// Bit mask of HPTA_EN field.
	SNVS_HPCR_HPTA_EN_Msk = 0x2
	// Bit HPTA_EN.
	SNVS_HPCR_HPTA_EN = 0x2
	// HP Time Alarm Interrupt is disabled
	SNVS_HPCR_HPTA_EN_HPTA_EN_0 = 0x0
	// HP Time Alarm Interrupt is enabled
	SNVS_HPCR_HPTA_EN_HPTA_EN_1 = 0x1
	// Position of DIS_PI field.
	SNVS_HPCR_DIS_PI_Pos = 0x2
	// Bit mask of DIS_PI field.
	SNVS_HPCR_DIS_PI_Msk = 0x4
	// Bit DIS_PI.
	SNVS_HPCR_DIS_PI = 0x4
	// Periodic interrupt will trigger a functional interrupt
	SNVS_HPCR_DIS_PI_DIS_PI_0 = 0x0
	// Disable periodic interrupt in the function interrupt
	SNVS_HPCR_DIS_PI_DIS_PI_1 = 0x1
	// Position of PI_EN field.
	SNVS_HPCR_PI_EN_Pos = 0x3
	// Bit mask of PI_EN field.
	SNVS_HPCR_PI_EN_Msk = 0x8
	// Bit PI_EN.
	SNVS_HPCR_PI_EN = 0x8
	// HP Periodic Interrupt is disabled
	SNVS_HPCR_PI_EN_PI_EN_0 = 0x0
	// HP Periodic Interrupt is enabled
	SNVS_HPCR_PI_EN_PI_EN_1 = 0x1
	// Position of PI_FREQ field.
	SNVS_HPCR_PI_FREQ_Pos = 0x4
	// Bit mask of PI_FREQ field.
	SNVS_HPCR_PI_FREQ_Msk = 0xf0
	// - bit 0 of the HPRTCLR is selected as a source of the periodic interrupt
	SNVS_HPCR_PI_FREQ_PI_FREQ_0 = 0x0
	// - bit 1 of the HPRTCLR is selected as a source of the periodic interrupt
	SNVS_HPCR_PI_FREQ_PI_FREQ_1 = 0x1
	// - bit 2 of the HPRTCLR is selected as a source of the periodic interrupt
	SNVS_HPCR_PI_FREQ_PI_FREQ_2 = 0x2
	// - bit 3 of the HPRTCLR is selected as a source of the periodic interrupt
	SNVS_HPCR_PI_FREQ_PI_FREQ_3 = 0x3
	// - bit 4 of the HPRTCLR is selected as a source of the periodic interrupt
	SNVS_HPCR_PI_FREQ_PI_FREQ_4 = 0x4
	// - bit 5 of the HPRTCLR is selected as a source of the periodic interrupt
	SNVS_HPCR_PI_FREQ_PI_FREQ_5 = 0x5
	// - bit 6 of the HPRTCLR is selected as a source of the periodic interrupt
	SNVS_HPCR_PI_FREQ_PI_FREQ_6 = 0x6
	// - bit 7 of the HPRTCLR is selected as a source of the periodic interrupt
	SNVS_HPCR_PI_FREQ_PI_FREQ_7 = 0x7
	// - bit 8 of the HPRTCLR is selected as a source of the periodic interrupt
	SNVS_HPCR_PI_FREQ_PI_FREQ_8 = 0x8
	// - bit 9 of the HPRTCLR is selected as a source of the periodic interrupt
	SNVS_HPCR_PI_FREQ_PI_FREQ_9 = 0x9
	// - bit 10 of the HPRTCLR is selected as a source of the periodic interrupt
	SNVS_HPCR_PI_FREQ_PI_FREQ_10 = 0xa
	// - bit 11 of the HPRTCLR is selected as a source of the periodic interrupt
	SNVS_HPCR_PI_FREQ_PI_FREQ_11 = 0xb
	// - bit 12 of the HPRTCLR is selected as a source of the periodic interrupt
	SNVS_HPCR_PI_FREQ_PI_FREQ_12 = 0xc
	// - bit 13 of the HPRTCLR is selected as a source of the periodic interrupt
	SNVS_HPCR_PI_FREQ_PI_FREQ_13 = 0xd
	// - bit 14 of the HPRTCLR is selected as a source of the periodic interrupt
	SNVS_HPCR_PI_FREQ_PI_FREQ_14 = 0xe
	// - bit 15 of the HPRTCLR is selected as a source of the periodic interrupt
	SNVS_HPCR_PI_FREQ_PI_FREQ_15 = 0xf
	// Position of HPCALB_EN field.
	SNVS_HPCR_HPCALB_EN_Pos = 0x8
	// Bit mask of HPCALB_EN field.
	SNVS_HPCR_HPCALB_EN_Msk = 0x100
	// Bit HPCALB_EN.
	SNVS_HPCR_HPCALB_EN = 0x100
	// HP Timer calibration disabled
	SNVS_HPCR_HPCALB_EN_HPCALB_EN_0 = 0x0
	// HP Timer calibration enabled
	SNVS_HPCR_HPCALB_EN_HPCALB_EN_1 = 0x1
	// Position of HPCALB_VAL field.
	SNVS_HPCR_HPCALB_VAL_Pos = 0xa
	// Bit mask of HPCALB_VAL field.
	SNVS_HPCR_HPCALB_VAL_Msk = 0x7c00
	// +0 counts per each 32768 ticks of the counter
	SNVS_HPCR_HPCALB_VAL_HPCALB_VAL_0 = 0x0
	// +1 counts per each 32768 ticks of the counter
	SNVS_HPCR_HPCALB_VAL_HPCALB_VAL_1 = 0x1
	// +2 counts per each 32768 ticks of the counter
	SNVS_HPCR_HPCALB_VAL_HPCALB_VAL_2 = 0x2
	// +15 counts per each 32768 ticks of the counter
	SNVS_HPCR_HPCALB_VAL_HPCALB_VAL_15 = 0xf
	// -16 counts per each 32768 ticks of the counter
	SNVS_HPCR_HPCALB_VAL_HPCALB_VAL_16 = 0x10
	// -15 counts per each 32768 ticks of the counter
	SNVS_HPCR_HPCALB_VAL_HPCALB_VAL_17 = 0x11
	// -2 counts per each 32768 ticks of the counter
	SNVS_HPCR_HPCALB_VAL_HPCALB_VAL_30 = 0x1e
	// -1 counts per each 32768 ticks of the counter
	SNVS_HPCR_HPCALB_VAL_HPCALB_VAL_31 = 0x1f
	// Position of HP_TS field.
	SNVS_HPCR_HP_TS_Pos = 0x10
	// Bit mask of HP_TS field.
	SNVS_HPCR_HP_TS_Msk = 0x10000
	// Bit HP_TS.
	SNVS_HPCR_HP_TS = 0x10000
	// No Action
	SNVS_HPCR_HP_TS_HP_TS_0 = 0x0
	// Synchronize the HP Time Counter to the LP Time Counter
	SNVS_HPCR_HP_TS_HP_TS_1 = 0x1
	// Position of BTN_CONFIG field.
	SNVS_HPCR_BTN_CONFIG_Pos = 0x18
	// Bit mask of BTN_CONFIG field.
	SNVS_HPCR_BTN_CONFIG_Msk = 0x7000000
	// Position of BTN_MASK field.
	SNVS_HPCR_BTN_MASK_Pos = 0x1b
	// Bit mask of BTN_MASK field.
	SNVS_HPCR_BTN_MASK_Msk = 0x8000000
	// Bit BTN_MASK.
	SNVS_HPCR_BTN_MASK = 0x8000000

	// HPSICR: SNVS_HP Security Interrupt Control Register
	// Position of SV0_EN field.
	SNVS_HPSICR_SV0_EN_Pos = 0x0
	// Bit mask of SV0_EN field.
	SNVS_HPSICR_SV0_EN_Msk = 0x1
	// Bit SV0_EN.
	SNVS_HPSICR_SV0_EN = 0x1
	// Security Violation 0 Interrupt is Disabled
	SNVS_HPSICR_SV0_EN_SV0_EN_0 = 0x0
	// Security Violation 0 Interrupt is Enabled
	SNVS_HPSICR_SV0_EN_SV0_EN_1 = 0x1
	// Position of SV1_EN field.
	SNVS_HPSICR_SV1_EN_Pos = 0x1
	// Bit mask of SV1_EN field.
	SNVS_HPSICR_SV1_EN_Msk = 0x2
	// Bit SV1_EN.
	SNVS_HPSICR_SV1_EN = 0x2
	// Security Violation 1 Interrupt is Disabled
	SNVS_HPSICR_SV1_EN_SV1_EN_0 = 0x0
	// Security Violation 1 Interrupt is Enabled
	SNVS_HPSICR_SV1_EN_SV1_EN_1 = 0x1
	// Position of SV2_EN field.
	SNVS_HPSICR_SV2_EN_Pos = 0x2
	// Bit mask of SV2_EN field.
	SNVS_HPSICR_SV2_EN_Msk = 0x4
	// Bit SV2_EN.
	SNVS_HPSICR_SV2_EN = 0x4
	// Security Violation 2 Interrupt is Disabled
	SNVS_HPSICR_SV2_EN_SV2_EN_0 = 0x0
	// Security Violation 2 Interrupt is Enabled
	SNVS_HPSICR_SV2_EN_SV2_EN_1 = 0x1
	// Position of SV3_EN field.
	SNVS_HPSICR_SV3_EN_Pos = 0x3
	// Bit mask of SV3_EN field.
	SNVS_HPSICR_SV3_EN_Msk = 0x8
	// Bit SV3_EN.
	SNVS_HPSICR_SV3_EN = 0x8
	// Security Violation 3 Interrupt is Disabled
	SNVS_HPSICR_SV3_EN_SV3_EN_0 = 0x0
	// Security Violation 3 Interrupt is Enabled
	SNVS_HPSICR_SV3_EN_SV3_EN_1 = 0x1
	// Position of SV4_EN field.
	SNVS_HPSICR_SV4_EN_Pos = 0x4
	// Bit mask of SV4_EN field.
	SNVS_HPSICR_SV4_EN_Msk = 0x10
	// Bit SV4_EN.
	SNVS_HPSICR_SV4_EN = 0x10
	// Security Violation 4 Interrupt is Disabled
	SNVS_HPSICR_SV4_EN_SV4_EN_0 = 0x0
	// Security Violation 4 Interrupt is Enabled
	SNVS_HPSICR_SV4_EN_SV4_EN_1 = 0x1
	// Position of SV5_EN field.
	SNVS_HPSICR_SV5_EN_Pos = 0x5
	// Bit mask of SV5_EN field.
	SNVS_HPSICR_SV5_EN_Msk = 0x20
	// Bit SV5_EN.
	SNVS_HPSICR_SV5_EN = 0x20
	// Security Violation 5 Interrupt is Disabled
	SNVS_HPSICR_SV5_EN_SV5_EN_0 = 0x0
	// Security Violation 5 Interrupt is Enabled
	SNVS_HPSICR_SV5_EN_SV5_EN_1 = 0x1
	// Position of LPSVI_EN field.
	SNVS_HPSICR_LPSVI_EN_Pos = 0x1f
	// Bit mask of LPSVI_EN field.
	SNVS_HPSICR_LPSVI_EN_Msk = 0x80000000
	// Bit LPSVI_EN.
	SNVS_HPSICR_LPSVI_EN = 0x80000000
	// LP Security Violation Interrupt is Disabled
	SNVS_HPSICR_LPSVI_EN_LPSVI_EN_0 = 0x0
	// LP Security Violation Interrupt is Enabled
	SNVS_HPSICR_LPSVI_EN_LPSVI_EN_1 = 0x1

	// HPSVCR: SNVS_HP Security Violation Control Register
	// Position of SV0_CFG field.
	SNVS_HPSVCR_SV0_CFG_Pos = 0x0
	// Bit mask of SV0_CFG field.
	SNVS_HPSVCR_SV0_CFG_Msk = 0x1
	// Bit SV0_CFG.
	SNVS_HPSVCR_SV0_CFG = 0x1
	// Security Violation 0 is a non-fatal violation
	SNVS_HPSVCR_SV0_CFG_SV0_CFG_0 = 0x0
	// Security Violation 0 is a fatal violation
	SNVS_HPSVCR_SV0_CFG_SV0_CFG_1 = 0x1
	// Position of SV1_CFG field.
	SNVS_HPSVCR_SV1_CFG_Pos = 0x1
	// Bit mask of SV1_CFG field.
	SNVS_HPSVCR_SV1_CFG_Msk = 0x2
	// Bit SV1_CFG.
	SNVS_HPSVCR_SV1_CFG = 0x2
	// Security Violation 1 is a non-fatal violation
	SNVS_HPSVCR_SV1_CFG_SV1_CFG_0 = 0x0
	// Security Violation 1 is a fatal violation
	SNVS_HPSVCR_SV1_CFG_SV1_CFG_1 = 0x1
	// Position of SV2_CFG field.
	SNVS_HPSVCR_SV2_CFG_Pos = 0x2
	// Bit mask of SV2_CFG field.
	SNVS_HPSVCR_SV2_CFG_Msk = 0x4
	// Bit SV2_CFG.
	SNVS_HPSVCR_SV2_CFG = 0x4
	// Security Violation 2 is a non-fatal violation
	SNVS_HPSVCR_SV2_CFG_SV2_CFG_0 = 0x0
	// Security Violation 2 is a fatal violation
	SNVS_HPSVCR_SV2_CFG_SV2_CFG_1 = 0x1
	// Position of SV3_CFG field.
	SNVS_HPSVCR_SV3_CFG_Pos = 0x3
	// Bit mask of SV3_CFG field.
	SNVS_HPSVCR_SV3_CFG_Msk = 0x8
	// Bit SV3_CFG.
	SNVS_HPSVCR_SV3_CFG = 0x8
	// Security Violation 3 is a non-fatal violation
	SNVS_HPSVCR_SV3_CFG_SV3_CFG_0 = 0x0
	// Security Violation 3 is a fatal violation
	SNVS_HPSVCR_SV3_CFG_SV3_CFG_1 = 0x1
	// Position of SV4_CFG field.
	SNVS_HPSVCR_SV4_CFG_Pos = 0x4
	// Bit mask of SV4_CFG field.
	SNVS_HPSVCR_SV4_CFG_Msk = 0x10
	// Bit SV4_CFG.
	SNVS_HPSVCR_SV4_CFG = 0x10
	// Security Violation 4 is a non-fatal violation
	SNVS_HPSVCR_SV4_CFG_SV4_CFG_0 = 0x0
	// Security Violation 4 is a fatal violation
	SNVS_HPSVCR_SV4_CFG_SV4_CFG_1 = 0x1
	// Position of SV5_CFG field.
	SNVS_HPSVCR_SV5_CFG_Pos = 0x5
	// Bit mask of SV5_CFG field.
	SNVS_HPSVCR_SV5_CFG_Msk = 0x60
	// Security Violation 5 is disabled
	SNVS_HPSVCR_SV5_CFG_SV5_CFG_0 = 0x0
	// Security Violation 5 is a non-fatal violation
	SNVS_HPSVCR_SV5_CFG_SV5_CFG_1 = 0x1
	// Security Violation 5 is a fatal violation
	SNVS_HPSVCR_SV5_CFG_SV5_CFG_2 = 0x2
	// Position of LPSV_CFG field.
	SNVS_HPSVCR_LPSV_CFG_Pos = 0x1e
	// Bit mask of LPSV_CFG field.
	SNVS_HPSVCR_LPSV_CFG_Msk = 0xc0000000
	// LP security violation is disabled
	SNVS_HPSVCR_LPSV_CFG_LPSV_CFG_0 = 0x0
	// LP security violation is a non-fatal violation
	SNVS_HPSVCR_LPSV_CFG_LPSV_CFG_1 = 0x1
	// LP security violation is a fatal violation
	SNVS_HPSVCR_LPSV_CFG_LPSV_CFG_2 = 0x2

	// HPSR: SNVS_HP Status Register
	// Position of HPTA field.
	SNVS_HPSR_HPTA_Pos = 0x0
	// Bit mask of HPTA field.
	SNVS_HPSR_HPTA_Msk = 0x1
	// Bit HPTA.
	SNVS_HPSR_HPTA = 0x1
	// No time alarm interrupt occurred.
	SNVS_HPSR_HPTA_HPTA_0 = 0x0
	// A time alarm interrupt occurred.
	SNVS_HPSR_HPTA_HPTA_1 = 0x1
	// Position of PI field.
	SNVS_HPSR_PI_Pos = 0x1
	// Bit mask of PI field.
	SNVS_HPSR_PI_Msk = 0x2
	// Bit PI.
	SNVS_HPSR_PI = 0x2
	// No periodic interrupt occurred.
	SNVS_HPSR_PI_PI_0 = 0x0
	// A periodic interrupt occurred.
	SNVS_HPSR_PI_PI_1 = 0x1
	// Position of LPDIS field.
	SNVS_HPSR_LPDIS_Pos = 0x4
	// Bit mask of LPDIS field.
	SNVS_HPSR_LPDIS_Msk = 0x10
	// Bit LPDIS.
	SNVS_HPSR_LPDIS = 0x10
	// Position of BTN field.
	SNVS_HPSR_BTN_Pos = 0x6
	// Bit mask of BTN field.
	SNVS_HPSR_BTN_Msk = 0x40
	// Bit BTN.
	SNVS_HPSR_BTN = 0x40
	// Position of BI field.
	SNVS_HPSR_BI_Pos = 0x7
	// Bit mask of BI field.
	SNVS_HPSR_BI_Msk = 0x80
	// Bit BI.
	SNVS_HPSR_BI = 0x80
	// Position of SSM_STATE field.
	SNVS_HPSR_SSM_STATE_Pos = 0x8
	// Bit mask of SSM_STATE field.
	SNVS_HPSR_SSM_STATE_Msk = 0xf00
	// Init
	SNVS_HPSR_SSM_STATE_SSM_STATE_0 = 0x0
	// Hard Fail
	SNVS_HPSR_SSM_STATE_SSM_STATE_1 = 0x1
	// Soft Fail
	SNVS_HPSR_SSM_STATE_SSM_STATE_3 = 0x3
	// Init Intermediate (transition state between Init and Check - SSM stays in this state only one clock cycle)
	SNVS_HPSR_SSM_STATE_SSM_STATE_8 = 0x8
	// Check
	SNVS_HPSR_SSM_STATE_SSM_STATE_9 = 0x9
	// Non-Secure
	SNVS_HPSR_SSM_STATE_SSM_STATE_11 = 0xb
	// Trusted
	SNVS_HPSR_SSM_STATE_SSM_STATE_13 = 0xd
	// Secure
	SNVS_HPSR_SSM_STATE_SSM_STATE_15 = 0xf
	// Position of SECURITY_CONFIG field.
	SNVS_HPSR_SECURITY_CONFIG_Pos = 0xc
	// Bit mask of SECURITY_CONFIG field.
	SNVS_HPSR_SECURITY_CONFIG_Msk = 0xf000
	// FIELD RETURN configuration
	SNVS_HPSR_SECURITY_CONFIG_FIELD_RETURN_CONFIG = 0x4
	// Position of OTPMK_SYNDROME field.
	SNVS_HPSR_OTPMK_SYNDROME_Pos = 0x10
	// Bit mask of OTPMK_SYNDROME field.
	SNVS_HPSR_OTPMK_SYNDROME_Msk = 0x1ff0000
	// Position of OTPMK_ZERO field.
	SNVS_HPSR_OTPMK_ZERO_Pos = 0x1b
	// Bit mask of OTPMK_ZERO field.
	SNVS_HPSR_OTPMK_ZERO_Msk = 0x8000000
	// Bit OTPMK_ZERO.
	SNVS_HPSR_OTPMK_ZERO = 0x8000000
	// The OTPMK is not zero.
	SNVS_HPSR_OTPMK_ZERO_OTPMK_ZERO_0 = 0x0
	// The OTPMK is zero.
	SNVS_HPSR_OTPMK_ZERO_OTPMK_ZERO_1 = 0x1
	// Position of ZMK_ZERO field.
	SNVS_HPSR_ZMK_ZERO_Pos = 0x1f
	// Bit mask of ZMK_ZERO field.
	SNVS_HPSR_ZMK_ZERO_Msk = 0x80000000
	// Bit ZMK_ZERO.
	SNVS_HPSR_ZMK_ZERO = 0x80000000
	// The ZMK is not zero.
	SNVS_HPSR_ZMK_ZERO_ZMK_ZERO_0 = 0x0
	// The ZMK is zero.
	SNVS_HPSR_ZMK_ZERO_ZMK_ZERO_1 = 0x1

	// HPSVSR: SNVS_HP Security Violation Status Register
	// Position of SV0 field.
	SNVS_HPSVSR_SV0_Pos = 0x0
	// Bit mask of SV0 field.
	SNVS_HPSVSR_SV0_Msk = 0x1
	// Bit SV0.
	SNVS_HPSVSR_SV0 = 0x1
	// No Security Violation 0 security violation was detected.
	SNVS_HPSVSR_SV0_SV0_0 = 0x0
	// Security Violation 0 security violation was detected.
	SNVS_HPSVSR_SV0_SV0_1 = 0x1
	// Position of SV1 field.
	SNVS_HPSVSR_SV1_Pos = 0x1
	// Bit mask of SV1 field.
	SNVS_HPSVSR_SV1_Msk = 0x2
	// Bit SV1.
	SNVS_HPSVSR_SV1 = 0x2
	// No Security Violation 1 security violation was detected.
	SNVS_HPSVSR_SV1_SV1_0 = 0x0
	// Security Violation 1 security violation was detected.
	SNVS_HPSVSR_SV1_SV1_1 = 0x1
	// Position of SV2 field.
	SNVS_HPSVSR_SV2_Pos = 0x2
	// Bit mask of SV2 field.
	SNVS_HPSVSR_SV2_Msk = 0x4
	// Bit SV2.
	SNVS_HPSVSR_SV2 = 0x4
	// No Security Violation 2 security violation was detected.
	SNVS_HPSVSR_SV2_SV2_0 = 0x0
	// Security Violation 2 security violation was detected.
	SNVS_HPSVSR_SV2_SV2_1 = 0x1
	// Position of SV3 field.
	SNVS_HPSVSR_SV3_Pos = 0x3
	// Bit mask of SV3 field.
	SNVS_HPSVSR_SV3_Msk = 0x8
	// Bit SV3.
	SNVS_HPSVSR_SV3 = 0x8
	// No Security Violation 3 security violation was detected.
	SNVS_HPSVSR_SV3_SV3_0 = 0x0
	// Security Violation 3 security violation was detected.
	SNVS_HPSVSR_SV3_SV3_1 = 0x1
	// Position of SV4 field.
	SNVS_HPSVSR_SV4_Pos = 0x4
	// Bit mask of SV4 field.
	SNVS_HPSVSR_SV4_Msk = 0x10
	// Bit SV4.
	SNVS_HPSVSR_SV4 = 0x10
	// No Security Violation 4 security violation was detected.
	SNVS_HPSVSR_SV4_SV4_0 = 0x0
	// Security Violation 4 security violation was detected.
	SNVS_HPSVSR_SV4_SV4_1 = 0x1
	// Position of SV5 field.
	SNVS_HPSVSR_SV5_Pos = 0x5
	// Bit mask of SV5 field.
	SNVS_HPSVSR_SV5_Msk = 0x20
	// Bit SV5.
	SNVS_HPSVSR_SV5 = 0x20
	// No Security Violation 5 security violation was detected.
	SNVS_HPSVSR_SV5_SV5_0 = 0x0
	// Security Violation 5 security violation was detected.
	SNVS_HPSVSR_SV5_SV5_1 = 0x1
	// Position of SW_SV field.
	SNVS_HPSVSR_SW_SV_Pos = 0xd
	// Bit mask of SW_SV field.
	SNVS_HPSVSR_SW_SV_Msk = 0x2000
	// Bit SW_SV.
	SNVS_HPSVSR_SW_SV = 0x2000
	// Position of SW_FSV field.
	SNVS_HPSVSR_SW_FSV_Pos = 0xe
	// Bit mask of SW_FSV field.
	SNVS_HPSVSR_SW_FSV_Msk = 0x4000
	// Bit SW_FSV.
	SNVS_HPSVSR_SW_FSV = 0x4000
	// Position of SW_LPSV field.
	SNVS_HPSVSR_SW_LPSV_Pos = 0xf
	// Bit mask of SW_LPSV field.
	SNVS_HPSVSR_SW_LPSV_Msk = 0x8000
	// Bit SW_LPSV.
	SNVS_HPSVSR_SW_LPSV = 0x8000
	// Position of ZMK_SYNDROME field.
	SNVS_HPSVSR_ZMK_SYNDROME_Pos = 0x10
	// Bit mask of ZMK_SYNDROME field.
	SNVS_HPSVSR_ZMK_SYNDROME_Msk = 0x1ff0000
	// Position of ZMK_ECC_FAIL field.
	SNVS_HPSVSR_ZMK_ECC_FAIL_Pos = 0x1b
	// Bit mask of ZMK_ECC_FAIL field.
	SNVS_HPSVSR_ZMK_ECC_FAIL_Msk = 0x8000000
	// Bit ZMK_ECC_FAIL.
	SNVS_HPSVSR_ZMK_ECC_FAIL = 0x8000000
	// ZMK ECC Failure was not detected.
	SNVS_HPSVSR_ZMK_ECC_FAIL_ZMK_ECC_FAIL_0 = 0x0
	// ZMK ECC Failure was detected.
	SNVS_HPSVSR_ZMK_ECC_FAIL_ZMK_ECC_FAIL_1 = 0x1
	// Position of LP_SEC_VIO field.
	SNVS_HPSVSR_LP_SEC_VIO_Pos = 0x1f
	// Bit mask of LP_SEC_VIO field.
	SNVS_HPSVSR_LP_SEC_VIO_Msk = 0x80000000
	// Bit LP_SEC_VIO.
	SNVS_HPSVSR_LP_SEC_VIO = 0x80000000

	// HPHACIVR: SNVS_HP High Assurance Counter IV Register
	// Position of HAC_COUNTER_IV field.
	SNVS_HPHACIVR_HAC_COUNTER_IV_Pos = 0x0
	// Bit mask of HAC_COUNTER_IV field.
	SNVS_HPHACIVR_HAC_COUNTER_IV_Msk = 0xffffffff

	// HPHACR: SNVS_HP High Assurance Counter Register
	// Position of HAC_COUNTER field.
	SNVS_HPHACR_HAC_COUNTER_Pos = 0x0
	// Bit mask of HAC_COUNTER field.
	SNVS_HPHACR_HAC_COUNTER_Msk = 0xffffffff

	// HPRTCMR: SNVS_HP Real Time Counter MSB Register
	// Position of RTC field.
	SNVS_HPRTCMR_RTC_Pos = 0x0
	// Bit mask of RTC field.
	SNVS_HPRTCMR_RTC_Msk = 0x7fff

	// HPRTCLR: SNVS_HP Real Time Counter LSB Register
	// Position of RTC field.
	SNVS_HPRTCLR_RTC_Pos = 0x0
	// Bit mask of RTC field.
	SNVS_HPRTCLR_RTC_Msk = 0xffffffff

	// HPTAMR: SNVS_HP Time Alarm MSB Register
	// Position of HPTA_MS field.
	SNVS_HPTAMR_HPTA_MS_Pos = 0x0
	// Bit mask of HPTA_MS field.
	SNVS_HPTAMR_HPTA_MS_Msk = 0x7fff

	// HPTALR: SNVS_HP Time Alarm LSB Register
	// Position of HPTA_LS field.
	SNVS_HPTALR_HPTA_LS_Pos = 0x0
	// Bit mask of HPTA_LS field.
	SNVS_HPTALR_HPTA_LS_Msk = 0xffffffff

	// LPLR: SNVS_LP Lock Register
	// Position of ZMK_WHL field.
	SNVS_LPLR_ZMK_WHL_Pos = 0x0
	// Bit mask of ZMK_WHL field.
	SNVS_LPLR_ZMK_WHL_Msk = 0x1
	// Bit ZMK_WHL.
	SNVS_LPLR_ZMK_WHL = 0x1
	// Write access is allowed.
	SNVS_LPLR_ZMK_WHL_ZMK_WHL_0 = 0x0
	// Write access is not allowed.
	SNVS_LPLR_ZMK_WHL_ZMK_WHL_1 = 0x1
	// Position of ZMK_RHL field.
	SNVS_LPLR_ZMK_RHL_Pos = 0x1
	// Bit mask of ZMK_RHL field.
	SNVS_LPLR_ZMK_RHL_Msk = 0x2
	// Bit ZMK_RHL.
	SNVS_LPLR_ZMK_RHL = 0x2
	// Read access is allowed (only in software programming mode).
	SNVS_LPLR_ZMK_RHL_ZMK_RHL_0 = 0x0
	// Read access is not allowed.
	SNVS_LPLR_ZMK_RHL_ZMK_RHL_1 = 0x1
	// Position of SRTC_HL field.
	SNVS_LPLR_SRTC_HL_Pos = 0x2
	// Bit mask of SRTC_HL field.
	SNVS_LPLR_SRTC_HL_Msk = 0x4
	// Bit SRTC_HL.
	SNVS_LPLR_SRTC_HL = 0x4
	// Write access is allowed.
	SNVS_LPLR_SRTC_HL_SRTC_HL_0 = 0x0
	// Write access is not allowed.
	SNVS_LPLR_SRTC_HL_SRTC_HL_1 = 0x1
	// Position of LPCALB_HL field.
	SNVS_LPLR_LPCALB_HL_Pos = 0x3
	// Bit mask of LPCALB_HL field.
	SNVS_LPLR_LPCALB_HL_Msk = 0x8
	// Bit LPCALB_HL.
	SNVS_LPLR_LPCALB_HL = 0x8
	// Write access is allowed.
	SNVS_LPLR_LPCALB_HL_LPCALB_HL_0 = 0x0
	// Write access is not allowed.
	SNVS_LPLR_LPCALB_HL_LPCALB_HL_1 = 0x1
	// Position of MC_HL field.
	SNVS_LPLR_MC_HL_Pos = 0x4
	// Bit mask of MC_HL field.
	SNVS_LPLR_MC_HL_Msk = 0x10
	// Bit MC_HL.
	SNVS_LPLR_MC_HL = 0x10
	// Write access (increment) is allowed.
	SNVS_LPLR_MC_HL_MC_HL_0 = 0x0
	// Write access (increment) is not allowed.
	SNVS_LPLR_MC_HL_MC_HL_1 = 0x1
	// Position of GPR_HL field.
	SNVS_LPLR_GPR_HL_Pos = 0x5
	// Bit mask of GPR_HL field.
	SNVS_LPLR_GPR_HL_Msk = 0x20
	// Bit GPR_HL.
	SNVS_LPLR_GPR_HL = 0x20
	// Write access is allowed.
	SNVS_LPLR_GPR_HL_GPR_HL_0 = 0x0
	// Write access is not allowed.
	SNVS_LPLR_GPR_HL_GPR_HL_1 = 0x1
	// Position of LPSVCR_HL field.
	SNVS_LPLR_LPSVCR_HL_Pos = 0x6
	// Bit mask of LPSVCR_HL field.
	SNVS_LPLR_LPSVCR_HL_Msk = 0x40
	// Bit LPSVCR_HL.
	SNVS_LPLR_LPSVCR_HL = 0x40
	// Write access is allowed.
	SNVS_LPLR_LPSVCR_HL_LPSVCR_HL_0 = 0x0
	// Write access is not allowed.
	SNVS_LPLR_LPSVCR_HL_LPSVCR_HL_1 = 0x1
	// Position of LPTDCR_HL field.
	SNVS_LPLR_LPTDCR_HL_Pos = 0x8
	// Bit mask of LPTDCR_HL field.
	SNVS_LPLR_LPTDCR_HL_Msk = 0x100
	// Bit LPTDCR_HL.
	SNVS_LPLR_LPTDCR_HL = 0x100
	// Write access is allowed.
	SNVS_LPLR_LPTDCR_HL_LPTDCR_HL_0 = 0x0
	// Write access is not allowed.
	SNVS_LPLR_LPTDCR_HL_LPTDCR_HL_1 = 0x1
	// Position of MKS_HL field.
	SNVS_LPLR_MKS_HL_Pos = 0x9
	// Bit mask of MKS_HL field.
	SNVS_LPLR_MKS_HL_Msk = 0x200
	// Bit MKS_HL.
	SNVS_LPLR_MKS_HL = 0x200
	// Write access is allowed.
	SNVS_LPLR_MKS_HL_MKS_HL_0 = 0x0
	// Write access is not allowed.
	SNVS_LPLR_MKS_HL_MKS_HL_1 = 0x1

	// LPCR: SNVS_LP Control Register
	// Position of SRTC_ENV field.
	SNVS_LPCR_SRTC_ENV_Pos = 0x0
	// Bit mask of SRTC_ENV field.
	SNVS_LPCR_SRTC_ENV_Msk = 0x1
	// Bit SRTC_ENV.
	SNVS_LPCR_SRTC_ENV = 0x1
	// SRTC is disabled or invalid.
	SNVS_LPCR_SRTC_ENV_SRTC_ENV_0 = 0x0
	// SRTC is enabled and valid.
	SNVS_LPCR_SRTC_ENV_SRTC_ENV_1 = 0x1
	// Position of LPTA_EN field.
	SNVS_LPCR_LPTA_EN_Pos = 0x1
	// Bit mask of LPTA_EN field.
	SNVS_LPCR_LPTA_EN_Msk = 0x2
	// Bit LPTA_EN.
	SNVS_LPCR_LPTA_EN = 0x2
	// LP time alarm interrupt is disabled.
	SNVS_LPCR_LPTA_EN_LPTA_EN_0 = 0x0
	// LP time alarm interrupt is enabled.
	SNVS_LPCR_LPTA_EN_LPTA_EN_1 = 0x1
	// Position of MC_ENV field.
	SNVS_LPCR_MC_ENV_Pos = 0x2
	// Bit mask of MC_ENV field.
	SNVS_LPCR_MC_ENV_Msk = 0x4
	// Bit MC_ENV.
	SNVS_LPCR_MC_ENV = 0x4
	// MC is disabled or invalid.
	SNVS_LPCR_MC_ENV_MC_ENV_0 = 0x0
	// MC is enabled and valid.
	SNVS_LPCR_MC_ENV_MC_ENV_1 = 0x1
	// Position of LPWUI_EN field.
	SNVS_LPCR_LPWUI_EN_Pos = 0x3
	// Bit mask of LPWUI_EN field.
	SNVS_LPCR_LPWUI_EN_Msk = 0x8
	// Bit LPWUI_EN.
	SNVS_LPCR_LPWUI_EN = 0x8
	// Position of SRTC_INV_EN field.
	SNVS_LPCR_SRTC_INV_EN_Pos = 0x4
	// Bit mask of SRTC_INV_EN field.
	SNVS_LPCR_SRTC_INV_EN_Msk = 0x10
	// Bit SRTC_INV_EN.
	SNVS_LPCR_SRTC_INV_EN = 0x10
	// SRTC stays valid in the case of security violation.
	SNVS_LPCR_SRTC_INV_EN_SRTC_INV_EN_0 = 0x0
	// SRTC is invalidated in the case of security violation.
	SNVS_LPCR_SRTC_INV_EN_SRTC_INV_EN_1 = 0x1
	// Position of DP_EN field.
	SNVS_LPCR_DP_EN_Pos = 0x5
	// Bit mask of DP_EN field.
	SNVS_LPCR_DP_EN_Msk = 0x20
	// Bit DP_EN.
	SNVS_LPCR_DP_EN = 0x20
	// Smart PMIC enabled.
	SNVS_LPCR_DP_EN_DP_EN_0 = 0x0
	// Dumb PMIC enabled.
	SNVS_LPCR_DP_EN_DP_EN_1 = 0x1
	// Position of TOP field.
	SNVS_LPCR_TOP_Pos = 0x6
	// Bit mask of TOP field.
	SNVS_LPCR_TOP_Msk = 0x40
	// Bit TOP.
	SNVS_LPCR_TOP = 0x40
	// Leave system power on.
	SNVS_LPCR_TOP_TOP_0 = 0x0
	// Turn off system power.
	SNVS_LPCR_TOP_TOP_1 = 0x1
	// Position of PWR_GLITCH_EN field.
	SNVS_LPCR_PWR_GLITCH_EN_Pos = 0x7
	// Bit mask of PWR_GLITCH_EN field.
	SNVS_LPCR_PWR_GLITCH_EN_Msk = 0x80
	// Bit PWR_GLITCH_EN.
	SNVS_LPCR_PWR_GLITCH_EN = 0x80
	// Position of LPCALB_EN field.
	SNVS_LPCR_LPCALB_EN_Pos = 0x8
	// Bit mask of LPCALB_EN field.
	SNVS_LPCR_LPCALB_EN_Msk = 0x100
	// Bit LPCALB_EN.
	SNVS_LPCR_LPCALB_EN = 0x100
	// SRTC Time calibration is disabled.
	SNVS_LPCR_LPCALB_EN_LPCALB_EN_0 = 0x0
	// SRTC Time calibration is enabled.
	SNVS_LPCR_LPCALB_EN_LPCALB_EN_1 = 0x1
	// Position of LPCALB_VAL field.
	SNVS_LPCR_LPCALB_VAL_Pos = 0xa
	// Bit mask of LPCALB_VAL field.
	SNVS_LPCR_LPCALB_VAL_Msk = 0x7c00
	// +0 counts per each 32768 ticks of the counter clock
	SNVS_LPCR_LPCALB_VAL_LPCALB_VAL_0 = 0x0
	// +1 counts per each 32768 ticks of the counter clock
	SNVS_LPCR_LPCALB_VAL_LPCALB_VAL_1 = 0x1
	// +2 counts per each 32768 ticks of the counter clock
	SNVS_LPCR_LPCALB_VAL_LPCALB_VAL_2 = 0x2
	// +15 counts per each 32768 ticks of the counter clock
	SNVS_LPCR_LPCALB_VAL_LPCALB_VAL_15 = 0xf
	// -16 counts per each 32768 ticks of the counter clock
	SNVS_LPCR_LPCALB_VAL_LPCALB_VAL_16 = 0x10
	// -15 counts per each 32768 ticks of the counter clock
	SNVS_LPCR_LPCALB_VAL_LPCALB_VAL_17 = 0x11
	// -2 counts per each 32768 ticks of the counter clock
	SNVS_LPCR_LPCALB_VAL_LPCALB_VAL_30 = 0x1e
	// -1 counts per each 32768 ticks of the counter clock
	SNVS_LPCR_LPCALB_VAL_LPCALB_VAL_31 = 0x1f
	// Position of BTN_PRESS_TIME field.
	SNVS_LPCR_BTN_PRESS_TIME_Pos = 0x10
	// Bit mask of BTN_PRESS_TIME field.
	SNVS_LPCR_BTN_PRESS_TIME_Msk = 0x30000
	// Position of DEBOUNCE field.
	SNVS_LPCR_DEBOUNCE_Pos = 0x12
	// Bit mask of DEBOUNCE field.
	SNVS_LPCR_DEBOUNCE_Msk = 0xc0000
	// Position of ON_TIME field.
	SNVS_LPCR_ON_TIME_Pos = 0x14
	// Bit mask of ON_TIME field.
	SNVS_LPCR_ON_TIME_Msk = 0x300000
	// Position of PK_EN field.
	SNVS_LPCR_PK_EN_Pos = 0x16
	// Bit mask of PK_EN field.
	SNVS_LPCR_PK_EN_Msk = 0x400000
	// Bit PK_EN.
	SNVS_LPCR_PK_EN = 0x400000
	// Position of PK_OVERRIDE field.
	SNVS_LPCR_PK_OVERRIDE_Pos = 0x17
	// Bit mask of PK_OVERRIDE field.
	SNVS_LPCR_PK_OVERRIDE_Msk = 0x800000
	// Bit PK_OVERRIDE.
	SNVS_LPCR_PK_OVERRIDE = 0x800000
	// Position of GPR_Z_DIS field.
	SNVS_LPCR_GPR_Z_DIS_Pos = 0x18
	// Bit mask of GPR_Z_DIS field.
	SNVS_LPCR_GPR_Z_DIS_Msk = 0x1000000
	// Bit GPR_Z_DIS.
	SNVS_LPCR_GPR_Z_DIS = 0x1000000

	// LPMKCR: SNVS_LP Master Key Control Register
	// Position of MASTER_KEY_SEL field.
	SNVS_LPMKCR_MASTER_KEY_SEL_Pos = 0x0
	// Bit mask of MASTER_KEY_SEL field.
	SNVS_LPMKCR_MASTER_KEY_SEL_Msk = 0x3
	// Select one time programmable master key.
	SNVS_LPMKCR_MASTER_KEY_SEL_MASTER_KEY_SEL_0 = 0x0
	// Select zeroizable master key when MKS_EN bit is set .
	SNVS_LPMKCR_MASTER_KEY_SEL_MASTER_KEY_SEL_2 = 0x2
	// Select combined master key when MKS_EN bit is set .
	SNVS_LPMKCR_MASTER_KEY_SEL_MASTER_KEY_SEL_3 = 0x3
	// Position of ZMK_HWP field.
	SNVS_LPMKCR_ZMK_HWP_Pos = 0x2
	// Bit mask of ZMK_HWP field.
	SNVS_LPMKCR_ZMK_HWP_Msk = 0x4
	// Bit ZMK_HWP.
	SNVS_LPMKCR_ZMK_HWP = 0x4
	// ZMK is in the software programming mode.
	SNVS_LPMKCR_ZMK_HWP_ZMK_HWP_0 = 0x0
	// ZMK is in the hardware programming mode.
	SNVS_LPMKCR_ZMK_HWP_ZMK_HWP_1 = 0x1
	// Position of ZMK_VAL field.
	SNVS_LPMKCR_ZMK_VAL_Pos = 0x3
	// Bit mask of ZMK_VAL field.
	SNVS_LPMKCR_ZMK_VAL_Msk = 0x8
	// Bit ZMK_VAL.
	SNVS_LPMKCR_ZMK_VAL = 0x8
	// ZMK is not valid.
	SNVS_LPMKCR_ZMK_VAL_ZMK_VAL_0 = 0x0
	// ZMK is valid.
	SNVS_LPMKCR_ZMK_VAL_ZMK_VAL_1 = 0x1
	// Position of ZMK_ECC_EN field.
	SNVS_LPMKCR_ZMK_ECC_EN_Pos = 0x4
	// Bit mask of ZMK_ECC_EN field.
	SNVS_LPMKCR_ZMK_ECC_EN_Msk = 0x10
	// Bit ZMK_ECC_EN.
	SNVS_LPMKCR_ZMK_ECC_EN = 0x10
	// ZMK ECC check is disabled.
	SNVS_LPMKCR_ZMK_ECC_EN_ZMK_ECC_EN_0 = 0x0
	// ZMK ECC check is enabled.
	SNVS_LPMKCR_ZMK_ECC_EN_ZMK_ECC_EN_1 = 0x1
	// Position of ZMK_ECC_VALUE field.
	SNVS_LPMKCR_ZMK_ECC_VALUE_Pos = 0x7
	// Bit mask of ZMK_ECC_VALUE field.
	SNVS_LPMKCR_ZMK_ECC_VALUE_Msk = 0xff80

	// LPSVCR: SNVS_LP Security Violation Control Register
	// Position of SV0_EN field.
	SNVS_LPSVCR_SV0_EN_Pos = 0x0
	// Bit mask of SV0_EN field.
	SNVS_LPSVCR_SV0_EN_Msk = 0x1
	// Bit SV0_EN.
	SNVS_LPSVCR_SV0_EN = 0x1
	// Security Violation 0 is disabled in the LP domain.
	SNVS_LPSVCR_SV0_EN_SV0_EN_0 = 0x0
	// Security Violation 0 is enabled in the LP domain.
	SNVS_LPSVCR_SV0_EN_SV0_EN_1 = 0x1
	// Position of SV1_EN field.
	SNVS_LPSVCR_SV1_EN_Pos = 0x1
	// Bit mask of SV1_EN field.
	SNVS_LPSVCR_SV1_EN_Msk = 0x2
	// Bit SV1_EN.
	SNVS_LPSVCR_SV1_EN = 0x2
	// Security Violation 1 is disabled in the LP domain.
	SNVS_LPSVCR_SV1_EN_SV1_EN_0 = 0x0
	// Security Violation 1 is enabled in the LP domain.
	SNVS_LPSVCR_SV1_EN_SV1_EN_1 = 0x1
	// Position of SV2_EN field.
	SNVS_LPSVCR_SV2_EN_Pos = 0x2
	// Bit mask of SV2_EN field.
	SNVS_LPSVCR_SV2_EN_Msk = 0x4
	// Bit SV2_EN.
	SNVS_LPSVCR_SV2_EN = 0x4
	// Security Violation 2 is disabled in the LP domain.
	SNVS_LPSVCR_SV2_EN_SV2_EN_0 = 0x0
	// Security Violation 2 is enabled in the LP domain.
	SNVS_LPSVCR_SV2_EN_SV2_EN_1 = 0x1
	// Position of SV3_EN field.
	SNVS_LPSVCR_SV3_EN_Pos = 0x3
	// Bit mask of SV3_EN field.
	SNVS_LPSVCR_SV3_EN_Msk = 0x8
	// Bit SV3_EN.
	SNVS_LPSVCR_SV3_EN = 0x8
	// Security Violation 3 is disabled in the LP domain.
	SNVS_LPSVCR_SV3_EN_SV3_EN_0 = 0x0
	// Security Violation 3 is enabled in the LP domain.
	SNVS_LPSVCR_SV3_EN_SV3_EN_1 = 0x1
	// Position of SV4_EN field.
	SNVS_LPSVCR_SV4_EN_Pos = 0x4
	// Bit mask of SV4_EN field.
	SNVS_LPSVCR_SV4_EN_Msk = 0x10
	// Bit SV4_EN.
	SNVS_LPSVCR_SV4_EN = 0x10
	// Security Violation 4 is disabled in the LP domain.
	SNVS_LPSVCR_SV4_EN_SV4_EN_0 = 0x0
	// Security Violation 4 is enabled in the LP domain.
	SNVS_LPSVCR_SV4_EN_SV4_EN_1 = 0x1
	// Position of SV5_EN field.
	SNVS_LPSVCR_SV5_EN_Pos = 0x5
	// Bit mask of SV5_EN field.
	SNVS_LPSVCR_SV5_EN_Msk = 0x20
	// Bit SV5_EN.
	SNVS_LPSVCR_SV5_EN = 0x20
	// Security Violation 5 is disabled in the LP domain.
	SNVS_LPSVCR_SV5_EN_SV5_EN_0 = 0x0
	// Security Violation 5 is enabled in the LP domain.
	SNVS_LPSVCR_SV5_EN_SV5_EN_1 = 0x1

	// LPTDCR: SNVS_LP Tamper Detectors Configuration Register
	// Position of SRTCR_EN field.
	SNVS_LPTDCR_SRTCR_EN_Pos = 0x1
	// Bit mask of SRTCR_EN field.
	SNVS_LPTDCR_SRTCR_EN_Msk = 0x2
	// Bit SRTCR_EN.
	SNVS_LPTDCR_SRTCR_EN = 0x2
	// SRTC rollover is disabled.
	SNVS_LPTDCR_SRTCR_EN_SRTCR_EN_0 = 0x0
	// SRTC rollover is enabled.
	SNVS_LPTDCR_SRTCR_EN_SRTCR_EN_1 = 0x1
	// Position of MCR_EN field.
	SNVS_LPTDCR_MCR_EN_Pos = 0x2
	// Bit mask of MCR_EN field.
	SNVS_LPTDCR_MCR_EN_Msk = 0x4
	// Bit MCR_EN.
	SNVS_LPTDCR_MCR_EN = 0x4
	// MC rollover is disabled.
	SNVS_LPTDCR_MCR_EN_MCR_EN_0 = 0x0
	// MC rollover is enabled.
	SNVS_LPTDCR_MCR_EN_MCR_EN_1 = 0x1
	// Position of ET1_EN field.
	SNVS_LPTDCR_ET1_EN_Pos = 0x9
	// Bit mask of ET1_EN field.
	SNVS_LPTDCR_ET1_EN_Msk = 0x200
	// Bit ET1_EN.
	SNVS_LPTDCR_ET1_EN = 0x200
	// External tamper 1 is disabled.
	SNVS_LPTDCR_ET1_EN_ET1_EN_0 = 0x0
	// External tamper 1 is enabled.
	SNVS_LPTDCR_ET1_EN_ET1_EN_1 = 0x1
	// Position of ET1P field.
	SNVS_LPTDCR_ET1P_Pos = 0xb
	// Bit mask of ET1P field.
	SNVS_LPTDCR_ET1P_Msk = 0x800
	// Bit ET1P.
	SNVS_LPTDCR_ET1P = 0x800
	// External tamper 1 is active low.
	SNVS_LPTDCR_ET1P_ET1P_0 = 0x0
	// External tamper 1 is active high.
	SNVS_LPTDCR_ET1P_ET1P_1 = 0x1
	// Position of PFD_OBSERV field.
	SNVS_LPTDCR_PFD_OBSERV_Pos = 0xe
	// Bit mask of PFD_OBSERV field.
	SNVS_LPTDCR_PFD_OBSERV_Msk = 0x4000
	// Bit PFD_OBSERV.
	SNVS_LPTDCR_PFD_OBSERV = 0x4000
	// Position of POR_OBSERV field.
	SNVS_LPTDCR_POR_OBSERV_Pos = 0xf
	// Bit mask of POR_OBSERV field.
	SNVS_LPTDCR_POR_OBSERV_Msk = 0x8000
	// Bit POR_OBSERV.
	SNVS_LPTDCR_POR_OBSERV = 0x8000
	// Position of OSCB field.
	SNVS_LPTDCR_OSCB_Pos = 0x1c
	// Bit mask of OSCB field.
	SNVS_LPTDCR_OSCB_Msk = 0x10000000
	// Bit OSCB.
	SNVS_LPTDCR_OSCB = 0x10000000
	// Normal SRTC clock oscillator not bypassed.
	SNVS_LPTDCR_OSCB_OSCB_0 = 0x0
	// Normal SRTC clock oscillator bypassed. Alternate clock can drive the SRTC clock source.
	SNVS_LPTDCR_OSCB_OSCB_1 = 0x1

	// LPSR: SNVS_LP Status Register
	// Position of LPTA field.
	SNVS_LPSR_LPTA_Pos = 0x0
	// Bit mask of LPTA field.
	SNVS_LPSR_LPTA_Msk = 0x1
	// Bit LPTA.
	SNVS_LPSR_LPTA = 0x1
	// No time alarm interrupt occurred.
	SNVS_LPSR_LPTA_LPTA_0 = 0x0
	// A time alarm interrupt occurred.
	SNVS_LPSR_LPTA_LPTA_1 = 0x1
	// Position of SRTCR field.
	SNVS_LPSR_SRTCR_Pos = 0x1
	// Bit mask of SRTCR field.
	SNVS_LPSR_SRTCR_Msk = 0x2
	// Bit SRTCR.
	SNVS_LPSR_SRTCR = 0x2
	// SRTC has not reached its maximum value.
	SNVS_LPSR_SRTCR_SRTCR_0 = 0x0
	// SRTC has reached its maximum value.
	SNVS_LPSR_SRTCR_SRTCR_1 = 0x1
	// Position of MCR field.
	SNVS_LPSR_MCR_Pos = 0x2
	// Bit mask of MCR field.
	SNVS_LPSR_MCR_Msk = 0x4
	// Bit MCR.
	SNVS_LPSR_MCR = 0x4
	// MC has not reached its maximum value.
	SNVS_LPSR_MCR_MCR_0 = 0x0
	// MC has reached its maximum value.
	SNVS_LPSR_MCR_MCR_1 = 0x1
	// Position of PGD field.
	SNVS_LPSR_PGD_Pos = 0x3
	// Bit mask of PGD field.
	SNVS_LPSR_PGD_Msk = 0x8
	// Bit PGD.
	SNVS_LPSR_PGD = 0x8
	// Position of ET1D field.
	SNVS_LPSR_ET1D_Pos = 0x9
	// Bit mask of ET1D field.
	SNVS_LPSR_ET1D_Msk = 0x200
	// Bit ET1D.
	SNVS_LPSR_ET1D = 0x200
	// External tampering 1 not detected.
	SNVS_LPSR_ET1D_ET1D_0 = 0x0
	// External tampering 1 detected.
	SNVS_LPSR_ET1D_ET1D_1 = 0x1
	// Position of ESVD field.
	SNVS_LPSR_ESVD_Pos = 0x10
	// Bit mask of ESVD field.
	SNVS_LPSR_ESVD_Msk = 0x10000
	// Bit ESVD.
	SNVS_LPSR_ESVD = 0x10000
	// No external security violation.
	SNVS_LPSR_ESVD_ESVD_0 = 0x0
	// External security violation is detected.
	SNVS_LPSR_ESVD_ESVD_1 = 0x1
	// Position of EO field.
	SNVS_LPSR_EO_Pos = 0x11
	// Bit mask of EO field.
	SNVS_LPSR_EO_Msk = 0x20000
	// Bit EO.
	SNVS_LPSR_EO = 0x20000
	// Emergency off was not detected.
	SNVS_LPSR_EO_EO_0 = 0x0
	// Emergency off was detected.
	SNVS_LPSR_EO_EO_1 = 0x1
	// Position of SPO field.
	SNVS_LPSR_SPO_Pos = 0x12
	// Bit mask of SPO field.
	SNVS_LPSR_SPO_Msk = 0x40000
	// Bit SPO.
	SNVS_LPSR_SPO = 0x40000
	// Set Power Off was not detected.
	SNVS_LPSR_SPO_SPO_0 = 0x0
	// Set Power Off was detected.
	SNVS_LPSR_SPO_SPO_1 = 0x1
	// Position of SED field.
	SNVS_LPSR_SED_Pos = 0x14
	// Bit mask of SED field.
	SNVS_LPSR_SED_Msk = 0x100000
	// Bit SED.
	SNVS_LPSR_SED = 0x100000
	// Scan exit was not detected.
	SNVS_LPSR_SED_SED_0 = 0x0
	// Scan exit was detected.
	SNVS_LPSR_SED_SED_1 = 0x1
	// Position of LPNS field.
	SNVS_LPSR_LPNS_Pos = 0x1e
	// Bit mask of LPNS field.
	SNVS_LPSR_LPNS_Msk = 0x40000000
	// Bit LPNS.
	SNVS_LPSR_LPNS = 0x40000000
	// LP section was not programmed in the non-secure state.
	SNVS_LPSR_LPNS_LPNS_0 = 0x0
	// LP section was programmed in the non-secure state.
	SNVS_LPSR_LPNS_LPNS_1 = 0x1
	// Position of LPS field.
	SNVS_LPSR_LPS_Pos = 0x1f
	// Bit mask of LPS field.
	SNVS_LPSR_LPS_Msk = 0x80000000
	// Bit LPS.
	SNVS_LPSR_LPS = 0x80000000
	// LP section was not programmed in secure or trusted state.
	SNVS_LPSR_LPS_LPS_0 = 0x0
	// LP section was programmed in secure or trusted state.
	SNVS_LPSR_LPS_LPS_1 = 0x1

	// LPSRTCMR: SNVS_LP Secure Real Time Counter MSB Register
	// Position of SRTC field.
	SNVS_LPSRTCMR_SRTC_Pos = 0x0
	// Bit mask of SRTC field.
	SNVS_LPSRTCMR_SRTC_Msk = 0x7fff

	// LPSRTCLR: SNVS_LP Secure Real Time Counter LSB Register
	// Position of SRTC field.
	SNVS_LPSRTCLR_SRTC_Pos = 0x0
	// Bit mask of SRTC field.
	SNVS_LPSRTCLR_SRTC_Msk = 0xffffffff

	// LPTAR: SNVS_LP Time Alarm Register
	// Position of LPTA field.
	SNVS_LPTAR_LPTA_Pos = 0x0
	// Bit mask of LPTA field.
	SNVS_LPTAR_LPTA_Msk = 0xffffffff

	// LPSMCMR: SNVS_LP Secure Monotonic Counter MSB Register
	// Position of MON_COUNTER field.
	SNVS_LPSMCMR_MON_COUNTER_Pos = 0x0
	// Bit mask of MON_COUNTER field.
	SNVS_LPSMCMR_MON_COUNTER_Msk = 0xffff
	// Position of MC_ERA_BITS field.
	SNVS_LPSMCMR_MC_ERA_BITS_Pos = 0x10
	// Bit mask of MC_ERA_BITS field.
	SNVS_LPSMCMR_MC_ERA_BITS_Msk = 0xffff0000

	// LPSMCLR: SNVS_LP Secure Monotonic Counter LSB Register
	// Position of MON_COUNTER field.
	SNVS_LPSMCLR_MON_COUNTER_Pos = 0x0
	// Bit mask of MON_COUNTER field.
	SNVS_LPSMCLR_MON_COUNTER_Msk = 0xffffffff

	// LPPGDR: SNVS_LP Power Glitch Detector Register
	// Position of PGD field.
	SNVS_LPPGDR_PGD_Pos = 0x0
	// Bit mask of PGD field.
	SNVS_LPPGDR_PGD_Msk = 0xffffffff

	// LPGPR0_legacy_alias: SNVS_LP General Purpose Register 0 (legacy alias)
	// Position of GPR field.
	SNVS_LPGPR0_legacy_alias_GPR_Pos = 0x0
	// Bit mask of GPR field.
	SNVS_LPGPR0_legacy_alias_GPR_Msk = 0xffffffff

	// LPZMKR: SNVS_LP Zeroizable Master Key Register
	// Position of ZMK field.
	SNVS_LPZMKR_ZMK_Pos = 0x0
	// Bit mask of ZMK field.
	SNVS_LPZMKR_ZMK_Msk = 0xffffffff

	// LPGPR_alias: SNVS_LP General Purpose Registers 0 .. 3
	// Position of GPR field.
	SNVS_LPGPR_alias_GPR_Pos = 0x0
	// Bit mask of GPR field.
	SNVS_LPGPR_alias_GPR_Msk = 0xffffffff

	// LPGPR: SNVS_LP General Purpose Registers 0 .. 7
	// Position of GPR field.
	SNVS_LPGPR_GPR_Pos = 0x0
	// Bit mask of GPR field.
	SNVS_LPGPR_GPR_Msk = 0xffffffff

	// HPVIDR1: SNVS_HP Version ID Register 1
	// Position of MINOR_REV field.
	SNVS_HPVIDR1_MINOR_REV_Pos = 0x0
	// Bit mask of MINOR_REV field.
	SNVS_HPVIDR1_MINOR_REV_Msk = 0xff
	// Position of MAJOR_REV field.
	SNVS_HPVIDR1_MAJOR_REV_Pos = 0x8
	// Bit mask of MAJOR_REV field.
	SNVS_HPVIDR1_MAJOR_REV_Msk = 0xff00
	// Position of IP_ID field.
	SNVS_HPVIDR1_IP_ID_Pos = 0x10
	// Bit mask of IP_ID field.
	SNVS_HPVIDR1_IP_ID_Msk = 0xffff0000

	// HPVIDR2: SNVS_HP Version ID Register 2
	// Position of CONFIG_OPT field.
	SNVS_HPVIDR2_CONFIG_OPT_Pos = 0x0
	// Bit mask of CONFIG_OPT field.
	SNVS_HPVIDR2_CONFIG_OPT_Msk = 0xff
	// Position of ECO_REV field.
	SNVS_HPVIDR2_ECO_REV_Pos = 0x8
	// Bit mask of ECO_REV field.
	SNVS_HPVIDR2_ECO_REV_Msk = 0xff00
	// Position of INTG_OPT field.
	SNVS_HPVIDR2_INTG_OPT_Pos = 0x10
	// Bit mask of INTG_OPT field.
	SNVS_HPVIDR2_INTG_OPT_Msk = 0xff0000
	// Position of IP_ERA field.
	SNVS_HPVIDR2_IP_ERA_Pos = 0x18
	// Bit mask of IP_ERA field.
	SNVS_HPVIDR2_IP_ERA_Msk = 0xff000000
)

// Bitfields for CCM_ANALOG: CCM_ANALOG
const (
	// PLL_ARM: Analog ARM PLL control Register
	// Position of DIV_SELECT field.
	CCM_ANALOG_PLL_ARM_DIV_SELECT_Pos = 0x0
	// Bit mask of DIV_SELECT field.
	CCM_ANALOG_PLL_ARM_DIV_SELECT_Msk = 0x7f
	// Position of POWERDOWN field.
	CCM_ANALOG_PLL_ARM_POWERDOWN_Pos = 0xc
	// Bit mask of POWERDOWN field.
	CCM_ANALOG_PLL_ARM_POWERDOWN_Msk = 0x1000
	// Bit POWERDOWN.
	CCM_ANALOG_PLL_ARM_POWERDOWN = 0x1000
	// Position of ENABLE field.
	CCM_ANALOG_PLL_ARM_ENABLE_Pos = 0xd
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_ARM_ENABLE_Msk = 0x2000
	// Bit ENABLE.
	CCM_ANALOG_PLL_ARM_ENABLE = 0x2000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_ARM_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_ARM_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_ARM_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Select the CLK1_N / CLK1_P as source.
	CCM_ANALOG_PLL_ARM_BYPASS_CLK_SRC_CLK1 = 0x1
	// Position of BYPASS field.
	CCM_ANALOG_PLL_ARM_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_ARM_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_ARM_BYPASS = 0x10000
	// Position of PLL_SEL field.
	CCM_ANALOG_PLL_ARM_PLL_SEL_Pos = 0x13
	// Bit mask of PLL_SEL field.
	CCM_ANALOG_PLL_ARM_PLL_SEL_Msk = 0x80000
	// Bit PLL_SEL.
	CCM_ANALOG_PLL_ARM_PLL_SEL = 0x80000
	// Position of LOCK field.
	CCM_ANALOG_PLL_ARM_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_ARM_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_ARM_LOCK = 0x80000000

	// PLL_ARM_SET: Analog ARM PLL control Register
	// Position of DIV_SELECT field.
	CCM_ANALOG_PLL_ARM_SET_DIV_SELECT_Pos = 0x0
	// Bit mask of DIV_SELECT field.
	CCM_ANALOG_PLL_ARM_SET_DIV_SELECT_Msk = 0x7f
	// Position of POWERDOWN field.
	CCM_ANALOG_PLL_ARM_SET_POWERDOWN_Pos = 0xc
	// Bit mask of POWERDOWN field.
	CCM_ANALOG_PLL_ARM_SET_POWERDOWN_Msk = 0x1000
	// Bit POWERDOWN.
	CCM_ANALOG_PLL_ARM_SET_POWERDOWN = 0x1000
	// Position of ENABLE field.
	CCM_ANALOG_PLL_ARM_SET_ENABLE_Pos = 0xd
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_ARM_SET_ENABLE_Msk = 0x2000
	// Bit ENABLE.
	CCM_ANALOG_PLL_ARM_SET_ENABLE = 0x2000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_ARM_SET_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_ARM_SET_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_ARM_SET_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Select the CLK1_N / CLK1_P as source.
	CCM_ANALOG_PLL_ARM_SET_BYPASS_CLK_SRC_CLK1 = 0x1
	// Position of BYPASS field.
	CCM_ANALOG_PLL_ARM_SET_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_ARM_SET_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_ARM_SET_BYPASS = 0x10000
	// Position of PLL_SEL field.
	CCM_ANALOG_PLL_ARM_SET_PLL_SEL_Pos = 0x13
	// Bit mask of PLL_SEL field.
	CCM_ANALOG_PLL_ARM_SET_PLL_SEL_Msk = 0x80000
	// Bit PLL_SEL.
	CCM_ANALOG_PLL_ARM_SET_PLL_SEL = 0x80000
	// Position of LOCK field.
	CCM_ANALOG_PLL_ARM_SET_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_ARM_SET_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_ARM_SET_LOCK = 0x80000000

	// PLL_ARM_CLR: Analog ARM PLL control Register
	// Position of DIV_SELECT field.
	CCM_ANALOG_PLL_ARM_CLR_DIV_SELECT_Pos = 0x0
	// Bit mask of DIV_SELECT field.
	CCM_ANALOG_PLL_ARM_CLR_DIV_SELECT_Msk = 0x7f
	// Position of POWERDOWN field.
	CCM_ANALOG_PLL_ARM_CLR_POWERDOWN_Pos = 0xc
	// Bit mask of POWERDOWN field.
	CCM_ANALOG_PLL_ARM_CLR_POWERDOWN_Msk = 0x1000
	// Bit POWERDOWN.
	CCM_ANALOG_PLL_ARM_CLR_POWERDOWN = 0x1000
	// Position of ENABLE field.
	CCM_ANALOG_PLL_ARM_CLR_ENABLE_Pos = 0xd
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_ARM_CLR_ENABLE_Msk = 0x2000
	// Bit ENABLE.
	CCM_ANALOG_PLL_ARM_CLR_ENABLE = 0x2000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_ARM_CLR_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_ARM_CLR_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_ARM_CLR_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Select the CLK1_N / CLK1_P as source.
	CCM_ANALOG_PLL_ARM_CLR_BYPASS_CLK_SRC_CLK1 = 0x1
	// Position of BYPASS field.
	CCM_ANALOG_PLL_ARM_CLR_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_ARM_CLR_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_ARM_CLR_BYPASS = 0x10000
	// Position of PLL_SEL field.
	CCM_ANALOG_PLL_ARM_CLR_PLL_SEL_Pos = 0x13
	// Bit mask of PLL_SEL field.
	CCM_ANALOG_PLL_ARM_CLR_PLL_SEL_Msk = 0x80000
	// Bit PLL_SEL.
	CCM_ANALOG_PLL_ARM_CLR_PLL_SEL = 0x80000
	// Position of LOCK field.
	CCM_ANALOG_PLL_ARM_CLR_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_ARM_CLR_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_ARM_CLR_LOCK = 0x80000000

	// PLL_ARM_TOG: Analog ARM PLL control Register
	// Position of DIV_SELECT field.
	CCM_ANALOG_PLL_ARM_TOG_DIV_SELECT_Pos = 0x0
	// Bit mask of DIV_SELECT field.
	CCM_ANALOG_PLL_ARM_TOG_DIV_SELECT_Msk = 0x7f
	// Position of POWERDOWN field.
	CCM_ANALOG_PLL_ARM_TOG_POWERDOWN_Pos = 0xc
	// Bit mask of POWERDOWN field.
	CCM_ANALOG_PLL_ARM_TOG_POWERDOWN_Msk = 0x1000
	// Bit POWERDOWN.
	CCM_ANALOG_PLL_ARM_TOG_POWERDOWN = 0x1000
	// Position of ENABLE field.
	CCM_ANALOG_PLL_ARM_TOG_ENABLE_Pos = 0xd
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_ARM_TOG_ENABLE_Msk = 0x2000
	// Bit ENABLE.
	CCM_ANALOG_PLL_ARM_TOG_ENABLE = 0x2000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_ARM_TOG_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_ARM_TOG_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_ARM_TOG_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Select the CLK1_N / CLK1_P as source.
	CCM_ANALOG_PLL_ARM_TOG_BYPASS_CLK_SRC_CLK1 = 0x1
	// Position of BYPASS field.
	CCM_ANALOG_PLL_ARM_TOG_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_ARM_TOG_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_ARM_TOG_BYPASS = 0x10000
	// Position of PLL_SEL field.
	CCM_ANALOG_PLL_ARM_TOG_PLL_SEL_Pos = 0x13
	// Bit mask of PLL_SEL field.
	CCM_ANALOG_PLL_ARM_TOG_PLL_SEL_Msk = 0x80000
	// Bit PLL_SEL.
	CCM_ANALOG_PLL_ARM_TOG_PLL_SEL = 0x80000
	// Position of LOCK field.
	CCM_ANALOG_PLL_ARM_TOG_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_ARM_TOG_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_ARM_TOG_LOCK = 0x80000000

	// PLL_USB1: Analog USB1 480MHz PLL Control Register
	// Position of DIV_SELECT field.
	CCM_ANALOG_PLL_USB1_DIV_SELECT_Pos = 0x1
	// Bit mask of DIV_SELECT field.
	CCM_ANALOG_PLL_USB1_DIV_SELECT_Msk = 0x2
	// Bit DIV_SELECT.
	CCM_ANALOG_PLL_USB1_DIV_SELECT = 0x2
	// Position of EN_USB_CLKS field.
	CCM_ANALOG_PLL_USB1_EN_USB_CLKS_Pos = 0x6
	// Bit mask of EN_USB_CLKS field.
	CCM_ANALOG_PLL_USB1_EN_USB_CLKS_Msk = 0x40
	// Bit EN_USB_CLKS.
	CCM_ANALOG_PLL_USB1_EN_USB_CLKS = 0x40
	// PLL outputs for USBPHYn off.
	CCM_ANALOG_PLL_USB1_EN_USB_CLKS_EN_USB_CLKS_0 = 0x0
	// PLL outputs for USBPHYn on.
	CCM_ANALOG_PLL_USB1_EN_USB_CLKS_EN_USB_CLKS_1 = 0x1
	// Position of POWER field.
	CCM_ANALOG_PLL_USB1_POWER_Pos = 0xc
	// Bit mask of POWER field.
	CCM_ANALOG_PLL_USB1_POWER_Msk = 0x1000
	// Bit POWER.
	CCM_ANALOG_PLL_USB1_POWER = 0x1000
	// Position of ENABLE field.
	CCM_ANALOG_PLL_USB1_ENABLE_Pos = 0xd
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_USB1_ENABLE_Msk = 0x2000
	// Bit ENABLE.
	CCM_ANALOG_PLL_USB1_ENABLE = 0x2000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_USB1_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_USB1_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_USB1_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Select the CLK1_N / CLK1_P as source.
	CCM_ANALOG_PLL_USB1_BYPASS_CLK_SRC_CLK1 = 0x1
	// Position of BYPASS field.
	CCM_ANALOG_PLL_USB1_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_USB1_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_USB1_BYPASS = 0x10000
	// Position of LOCK field.
	CCM_ANALOG_PLL_USB1_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_USB1_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_USB1_LOCK = 0x80000000

	// PLL_USB1_SET: Analog USB1 480MHz PLL Control Register
	// Position of DIV_SELECT field.
	CCM_ANALOG_PLL_USB1_SET_DIV_SELECT_Pos = 0x1
	// Bit mask of DIV_SELECT field.
	CCM_ANALOG_PLL_USB1_SET_DIV_SELECT_Msk = 0x2
	// Bit DIV_SELECT.
	CCM_ANALOG_PLL_USB1_SET_DIV_SELECT = 0x2
	// Position of EN_USB_CLKS field.
	CCM_ANALOG_PLL_USB1_SET_EN_USB_CLKS_Pos = 0x6
	// Bit mask of EN_USB_CLKS field.
	CCM_ANALOG_PLL_USB1_SET_EN_USB_CLKS_Msk = 0x40
	// Bit EN_USB_CLKS.
	CCM_ANALOG_PLL_USB1_SET_EN_USB_CLKS = 0x40
	// PLL outputs for USBPHYn off.
	CCM_ANALOG_PLL_USB1_SET_EN_USB_CLKS_EN_USB_CLKS_0 = 0x0
	// PLL outputs for USBPHYn on.
	CCM_ANALOG_PLL_USB1_SET_EN_USB_CLKS_EN_USB_CLKS_1 = 0x1
	// Position of POWER field.
	CCM_ANALOG_PLL_USB1_SET_POWER_Pos = 0xc
	// Bit mask of POWER field.
	CCM_ANALOG_PLL_USB1_SET_POWER_Msk = 0x1000
	// Bit POWER.
	CCM_ANALOG_PLL_USB1_SET_POWER = 0x1000
	// Position of ENABLE field.
	CCM_ANALOG_PLL_USB1_SET_ENABLE_Pos = 0xd
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_USB1_SET_ENABLE_Msk = 0x2000
	// Bit ENABLE.
	CCM_ANALOG_PLL_USB1_SET_ENABLE = 0x2000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_USB1_SET_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_USB1_SET_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_USB1_SET_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Select the CLK1_N / CLK1_P as source.
	CCM_ANALOG_PLL_USB1_SET_BYPASS_CLK_SRC_CLK1 = 0x1
	// Position of BYPASS field.
	CCM_ANALOG_PLL_USB1_SET_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_USB1_SET_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_USB1_SET_BYPASS = 0x10000
	// Position of LOCK field.
	CCM_ANALOG_PLL_USB1_SET_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_USB1_SET_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_USB1_SET_LOCK = 0x80000000

	// PLL_USB1_CLR: Analog USB1 480MHz PLL Control Register
	// Position of DIV_SELECT field.
	CCM_ANALOG_PLL_USB1_CLR_DIV_SELECT_Pos = 0x1
	// Bit mask of DIV_SELECT field.
	CCM_ANALOG_PLL_USB1_CLR_DIV_SELECT_Msk = 0x2
	// Bit DIV_SELECT.
	CCM_ANALOG_PLL_USB1_CLR_DIV_SELECT = 0x2
	// Position of EN_USB_CLKS field.
	CCM_ANALOG_PLL_USB1_CLR_EN_USB_CLKS_Pos = 0x6
	// Bit mask of EN_USB_CLKS field.
	CCM_ANALOG_PLL_USB1_CLR_EN_USB_CLKS_Msk = 0x40
	// Bit EN_USB_CLKS.
	CCM_ANALOG_PLL_USB1_CLR_EN_USB_CLKS = 0x40
	// PLL outputs for USBPHYn off.
	CCM_ANALOG_PLL_USB1_CLR_EN_USB_CLKS_EN_USB_CLKS_0 = 0x0
	// PLL outputs for USBPHYn on.
	CCM_ANALOG_PLL_USB1_CLR_EN_USB_CLKS_EN_USB_CLKS_1 = 0x1
	// Position of POWER field.
	CCM_ANALOG_PLL_USB1_CLR_POWER_Pos = 0xc
	// Bit mask of POWER field.
	CCM_ANALOG_PLL_USB1_CLR_POWER_Msk = 0x1000
	// Bit POWER.
	CCM_ANALOG_PLL_USB1_CLR_POWER = 0x1000
	// Position of ENABLE field.
	CCM_ANALOG_PLL_USB1_CLR_ENABLE_Pos = 0xd
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_USB1_CLR_ENABLE_Msk = 0x2000
	// Bit ENABLE.
	CCM_ANALOG_PLL_USB1_CLR_ENABLE = 0x2000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_USB1_CLR_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_USB1_CLR_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_USB1_CLR_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Select the CLK1_N / CLK1_P as source.
	CCM_ANALOG_PLL_USB1_CLR_BYPASS_CLK_SRC_CLK1 = 0x1
	// Position of BYPASS field.
	CCM_ANALOG_PLL_USB1_CLR_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_USB1_CLR_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_USB1_CLR_BYPASS = 0x10000
	// Position of LOCK field.
	CCM_ANALOG_PLL_USB1_CLR_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_USB1_CLR_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_USB1_CLR_LOCK = 0x80000000

	// PLL_USB1_TOG: Analog USB1 480MHz PLL Control Register
	// Position of DIV_SELECT field.
	CCM_ANALOG_PLL_USB1_TOG_DIV_SELECT_Pos = 0x1
	// Bit mask of DIV_SELECT field.
	CCM_ANALOG_PLL_USB1_TOG_DIV_SELECT_Msk = 0x2
	// Bit DIV_SELECT.
	CCM_ANALOG_PLL_USB1_TOG_DIV_SELECT = 0x2
	// Position of EN_USB_CLKS field.
	CCM_ANALOG_PLL_USB1_TOG_EN_USB_CLKS_Pos = 0x6
	// Bit mask of EN_USB_CLKS field.
	CCM_ANALOG_PLL_USB1_TOG_EN_USB_CLKS_Msk = 0x40
	// Bit EN_USB_CLKS.
	CCM_ANALOG_PLL_USB1_TOG_EN_USB_CLKS = 0x40
	// PLL outputs for USBPHYn off.
	CCM_ANALOG_PLL_USB1_TOG_EN_USB_CLKS_EN_USB_CLKS_0 = 0x0
	// PLL outputs for USBPHYn on.
	CCM_ANALOG_PLL_USB1_TOG_EN_USB_CLKS_EN_USB_CLKS_1 = 0x1
	// Position of POWER field.
	CCM_ANALOG_PLL_USB1_TOG_POWER_Pos = 0xc
	// Bit mask of POWER field.
	CCM_ANALOG_PLL_USB1_TOG_POWER_Msk = 0x1000
	// Bit POWER.
	CCM_ANALOG_PLL_USB1_TOG_POWER = 0x1000
	// Position of ENABLE field.
	CCM_ANALOG_PLL_USB1_TOG_ENABLE_Pos = 0xd
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_USB1_TOG_ENABLE_Msk = 0x2000
	// Bit ENABLE.
	CCM_ANALOG_PLL_USB1_TOG_ENABLE = 0x2000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_USB1_TOG_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_USB1_TOG_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_USB1_TOG_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Select the CLK1_N / CLK1_P as source.
	CCM_ANALOG_PLL_USB1_TOG_BYPASS_CLK_SRC_CLK1 = 0x1
	// Position of BYPASS field.
	CCM_ANALOG_PLL_USB1_TOG_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_USB1_TOG_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_USB1_TOG_BYPASS = 0x10000
	// Position of LOCK field.
	CCM_ANALOG_PLL_USB1_TOG_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_USB1_TOG_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_USB1_TOG_LOCK = 0x80000000

	// PLL_USB2: Analog USB2 480MHz PLL Control Register
	// Position of DIV_SELECT field.
	CCM_ANALOG_PLL_USB2_DIV_SELECT_Pos = 0x1
	// Bit mask of DIV_SELECT field.
	CCM_ANALOG_PLL_USB2_DIV_SELECT_Msk = 0x2
	// Bit DIV_SELECT.
	CCM_ANALOG_PLL_USB2_DIV_SELECT = 0x2
	// Position of EN_USB_CLKS field.
	CCM_ANALOG_PLL_USB2_EN_USB_CLKS_Pos = 0x6
	// Bit mask of EN_USB_CLKS field.
	CCM_ANALOG_PLL_USB2_EN_USB_CLKS_Msk = 0x40
	// Bit EN_USB_CLKS.
	CCM_ANALOG_PLL_USB2_EN_USB_CLKS = 0x40
	// Position of POWER field.
	CCM_ANALOG_PLL_USB2_POWER_Pos = 0xc
	// Bit mask of POWER field.
	CCM_ANALOG_PLL_USB2_POWER_Msk = 0x1000
	// Bit POWER.
	CCM_ANALOG_PLL_USB2_POWER = 0x1000
	// Position of ENABLE field.
	CCM_ANALOG_PLL_USB2_ENABLE_Pos = 0xd
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_USB2_ENABLE_Msk = 0x2000
	// Bit ENABLE.
	CCM_ANALOG_PLL_USB2_ENABLE = 0x2000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_USB2_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_USB2_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_USB2_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Select the CLK1_N / CLK1_P as source.
	CCM_ANALOG_PLL_USB2_BYPASS_CLK_SRC_CLK1 = 0x1
	// Position of BYPASS field.
	CCM_ANALOG_PLL_USB2_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_USB2_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_USB2_BYPASS = 0x10000
	// Position of LOCK field.
	CCM_ANALOG_PLL_USB2_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_USB2_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_USB2_LOCK = 0x80000000

	// PLL_USB2_SET: Analog USB2 480MHz PLL Control Register
	// Position of DIV_SELECT field.
	CCM_ANALOG_PLL_USB2_SET_DIV_SELECT_Pos = 0x1
	// Bit mask of DIV_SELECT field.
	CCM_ANALOG_PLL_USB2_SET_DIV_SELECT_Msk = 0x2
	// Bit DIV_SELECT.
	CCM_ANALOG_PLL_USB2_SET_DIV_SELECT = 0x2
	// Position of EN_USB_CLKS field.
	CCM_ANALOG_PLL_USB2_SET_EN_USB_CLKS_Pos = 0x6
	// Bit mask of EN_USB_CLKS field.
	CCM_ANALOG_PLL_USB2_SET_EN_USB_CLKS_Msk = 0x40
	// Bit EN_USB_CLKS.
	CCM_ANALOG_PLL_USB2_SET_EN_USB_CLKS = 0x40
	// Position of POWER field.
	CCM_ANALOG_PLL_USB2_SET_POWER_Pos = 0xc
	// Bit mask of POWER field.
	CCM_ANALOG_PLL_USB2_SET_POWER_Msk = 0x1000
	// Bit POWER.
	CCM_ANALOG_PLL_USB2_SET_POWER = 0x1000
	// Position of ENABLE field.
	CCM_ANALOG_PLL_USB2_SET_ENABLE_Pos = 0xd
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_USB2_SET_ENABLE_Msk = 0x2000
	// Bit ENABLE.
	CCM_ANALOG_PLL_USB2_SET_ENABLE = 0x2000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_USB2_SET_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_USB2_SET_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_USB2_SET_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Select the CLK1_N / CLK1_P as source.
	CCM_ANALOG_PLL_USB2_SET_BYPASS_CLK_SRC_CLK1 = 0x1
	// Position of BYPASS field.
	CCM_ANALOG_PLL_USB2_SET_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_USB2_SET_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_USB2_SET_BYPASS = 0x10000
	// Position of LOCK field.
	CCM_ANALOG_PLL_USB2_SET_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_USB2_SET_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_USB2_SET_LOCK = 0x80000000

	// PLL_USB2_CLR: Analog USB2 480MHz PLL Control Register
	// Position of DIV_SELECT field.
	CCM_ANALOG_PLL_USB2_CLR_DIV_SELECT_Pos = 0x1
	// Bit mask of DIV_SELECT field.
	CCM_ANALOG_PLL_USB2_CLR_DIV_SELECT_Msk = 0x2
	// Bit DIV_SELECT.
	CCM_ANALOG_PLL_USB2_CLR_DIV_SELECT = 0x2
	// Position of EN_USB_CLKS field.
	CCM_ANALOG_PLL_USB2_CLR_EN_USB_CLKS_Pos = 0x6
	// Bit mask of EN_USB_CLKS field.
	CCM_ANALOG_PLL_USB2_CLR_EN_USB_CLKS_Msk = 0x40
	// Bit EN_USB_CLKS.
	CCM_ANALOG_PLL_USB2_CLR_EN_USB_CLKS = 0x40
	// Position of POWER field.
	CCM_ANALOG_PLL_USB2_CLR_POWER_Pos = 0xc
	// Bit mask of POWER field.
	CCM_ANALOG_PLL_USB2_CLR_POWER_Msk = 0x1000
	// Bit POWER.
	CCM_ANALOG_PLL_USB2_CLR_POWER = 0x1000
	// Position of ENABLE field.
	CCM_ANALOG_PLL_USB2_CLR_ENABLE_Pos = 0xd
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_USB2_CLR_ENABLE_Msk = 0x2000
	// Bit ENABLE.
	CCM_ANALOG_PLL_USB2_CLR_ENABLE = 0x2000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_USB2_CLR_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_USB2_CLR_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_USB2_CLR_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Select the CLK1_N / CLK1_P as source.
	CCM_ANALOG_PLL_USB2_CLR_BYPASS_CLK_SRC_CLK1 = 0x1
	// Position of BYPASS field.
	CCM_ANALOG_PLL_USB2_CLR_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_USB2_CLR_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_USB2_CLR_BYPASS = 0x10000
	// Position of LOCK field.
	CCM_ANALOG_PLL_USB2_CLR_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_USB2_CLR_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_USB2_CLR_LOCK = 0x80000000

	// PLL_USB2_TOG: Analog USB2 480MHz PLL Control Register
	// Position of DIV_SELECT field.
	CCM_ANALOG_PLL_USB2_TOG_DIV_SELECT_Pos = 0x1
	// Bit mask of DIV_SELECT field.
	CCM_ANALOG_PLL_USB2_TOG_DIV_SELECT_Msk = 0x2
	// Bit DIV_SELECT.
	CCM_ANALOG_PLL_USB2_TOG_DIV_SELECT = 0x2
	// Position of EN_USB_CLKS field.
	CCM_ANALOG_PLL_USB2_TOG_EN_USB_CLKS_Pos = 0x6
	// Bit mask of EN_USB_CLKS field.
	CCM_ANALOG_PLL_USB2_TOG_EN_USB_CLKS_Msk = 0x40
	// Bit EN_USB_CLKS.
	CCM_ANALOG_PLL_USB2_TOG_EN_USB_CLKS = 0x40
	// Position of POWER field.
	CCM_ANALOG_PLL_USB2_TOG_POWER_Pos = 0xc
	// Bit mask of POWER field.
	CCM_ANALOG_PLL_USB2_TOG_POWER_Msk = 0x1000
	// Bit POWER.
	CCM_ANALOG_PLL_USB2_TOG_POWER = 0x1000
	// Position of ENABLE field.
	CCM_ANALOG_PLL_USB2_TOG_ENABLE_Pos = 0xd
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_USB2_TOG_ENABLE_Msk = 0x2000
	// Bit ENABLE.
	CCM_ANALOG_PLL_USB2_TOG_ENABLE = 0x2000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_USB2_TOG_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_USB2_TOG_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_USB2_TOG_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Select the CLK1_N / CLK1_P as source.
	CCM_ANALOG_PLL_USB2_TOG_BYPASS_CLK_SRC_CLK1 = 0x1
	// Position of BYPASS field.
	CCM_ANALOG_PLL_USB2_TOG_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_USB2_TOG_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_USB2_TOG_BYPASS = 0x10000
	// Position of LOCK field.
	CCM_ANALOG_PLL_USB2_TOG_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_USB2_TOG_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_USB2_TOG_LOCK = 0x80000000

	// PLL_SYS: Analog System PLL Control Register
	// Position of DIV_SELECT field.
	CCM_ANALOG_PLL_SYS_DIV_SELECT_Pos = 0x0
	// Bit mask of DIV_SELECT field.
	CCM_ANALOG_PLL_SYS_DIV_SELECT_Msk = 0x1
	// Bit DIV_SELECT.
	CCM_ANALOG_PLL_SYS_DIV_SELECT = 0x1
	// Position of POWERDOWN field.
	CCM_ANALOG_PLL_SYS_POWERDOWN_Pos = 0xc
	// Bit mask of POWERDOWN field.
	CCM_ANALOG_PLL_SYS_POWERDOWN_Msk = 0x1000
	// Bit POWERDOWN.
	CCM_ANALOG_PLL_SYS_POWERDOWN = 0x1000
	// Position of ENABLE field.
	CCM_ANALOG_PLL_SYS_ENABLE_Pos = 0xd
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_SYS_ENABLE_Msk = 0x2000
	// Bit ENABLE.
	CCM_ANALOG_PLL_SYS_ENABLE = 0x2000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_SYS_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_SYS_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_SYS_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Select the CLK1_N / CLK1_P as source.
	CCM_ANALOG_PLL_SYS_BYPASS_CLK_SRC_CLK1 = 0x1
	// Position of BYPASS field.
	CCM_ANALOG_PLL_SYS_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_SYS_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_SYS_BYPASS = 0x10000
	// Position of LOCK field.
	CCM_ANALOG_PLL_SYS_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_SYS_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_SYS_LOCK = 0x80000000

	// PLL_SYS_SET: Analog System PLL Control Register
	// Position of DIV_SELECT field.
	CCM_ANALOG_PLL_SYS_SET_DIV_SELECT_Pos = 0x0
	// Bit mask of DIV_SELECT field.
	CCM_ANALOG_PLL_SYS_SET_DIV_SELECT_Msk = 0x1
	// Bit DIV_SELECT.
	CCM_ANALOG_PLL_SYS_SET_DIV_SELECT = 0x1
	// Position of POWERDOWN field.
	CCM_ANALOG_PLL_SYS_SET_POWERDOWN_Pos = 0xc
	// Bit mask of POWERDOWN field.
	CCM_ANALOG_PLL_SYS_SET_POWERDOWN_Msk = 0x1000
	// Bit POWERDOWN.
	CCM_ANALOG_PLL_SYS_SET_POWERDOWN = 0x1000
	// Position of ENABLE field.
	CCM_ANALOG_PLL_SYS_SET_ENABLE_Pos = 0xd
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_SYS_SET_ENABLE_Msk = 0x2000
	// Bit ENABLE.
	CCM_ANALOG_PLL_SYS_SET_ENABLE = 0x2000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_SYS_SET_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_SYS_SET_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_SYS_SET_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Select the CLK1_N / CLK1_P as source.
	CCM_ANALOG_PLL_SYS_SET_BYPASS_CLK_SRC_CLK1 = 0x1
	// Position of BYPASS field.
	CCM_ANALOG_PLL_SYS_SET_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_SYS_SET_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_SYS_SET_BYPASS = 0x10000
	// Position of LOCK field.
	CCM_ANALOG_PLL_SYS_SET_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_SYS_SET_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_SYS_SET_LOCK = 0x80000000

	// PLL_SYS_CLR: Analog System PLL Control Register
	// Position of DIV_SELECT field.
	CCM_ANALOG_PLL_SYS_CLR_DIV_SELECT_Pos = 0x0
	// Bit mask of DIV_SELECT field.
	CCM_ANALOG_PLL_SYS_CLR_DIV_SELECT_Msk = 0x1
	// Bit DIV_SELECT.
	CCM_ANALOG_PLL_SYS_CLR_DIV_SELECT = 0x1
	// Position of POWERDOWN field.
	CCM_ANALOG_PLL_SYS_CLR_POWERDOWN_Pos = 0xc
	// Bit mask of POWERDOWN field.
	CCM_ANALOG_PLL_SYS_CLR_POWERDOWN_Msk = 0x1000
	// Bit POWERDOWN.
	CCM_ANALOG_PLL_SYS_CLR_POWERDOWN = 0x1000
	// Position of ENABLE field.
	CCM_ANALOG_PLL_SYS_CLR_ENABLE_Pos = 0xd
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_SYS_CLR_ENABLE_Msk = 0x2000
	// Bit ENABLE.
	CCM_ANALOG_PLL_SYS_CLR_ENABLE = 0x2000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_SYS_CLR_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_SYS_CLR_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_SYS_CLR_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Select the CLK1_N / CLK1_P as source.
	CCM_ANALOG_PLL_SYS_CLR_BYPASS_CLK_SRC_CLK1 = 0x1
	// Position of BYPASS field.
	CCM_ANALOG_PLL_SYS_CLR_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_SYS_CLR_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_SYS_CLR_BYPASS = 0x10000
	// Position of LOCK field.
	CCM_ANALOG_PLL_SYS_CLR_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_SYS_CLR_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_SYS_CLR_LOCK = 0x80000000

	// PLL_SYS_TOG: Analog System PLL Control Register
	// Position of DIV_SELECT field.
	CCM_ANALOG_PLL_SYS_TOG_DIV_SELECT_Pos = 0x0
	// Bit mask of DIV_SELECT field.
	CCM_ANALOG_PLL_SYS_TOG_DIV_SELECT_Msk = 0x1
	// Bit DIV_SELECT.
	CCM_ANALOG_PLL_SYS_TOG_DIV_SELECT = 0x1
	// Position of POWERDOWN field.
	CCM_ANALOG_PLL_SYS_TOG_POWERDOWN_Pos = 0xc
	// Bit mask of POWERDOWN field.
	CCM_ANALOG_PLL_SYS_TOG_POWERDOWN_Msk = 0x1000
	// Bit POWERDOWN.
	CCM_ANALOG_PLL_SYS_TOG_POWERDOWN = 0x1000
	// Position of ENABLE field.
	CCM_ANALOG_PLL_SYS_TOG_ENABLE_Pos = 0xd
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_SYS_TOG_ENABLE_Msk = 0x2000
	// Bit ENABLE.
	CCM_ANALOG_PLL_SYS_TOG_ENABLE = 0x2000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_SYS_TOG_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_SYS_TOG_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_SYS_TOG_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Select the CLK1_N / CLK1_P as source.
	CCM_ANALOG_PLL_SYS_TOG_BYPASS_CLK_SRC_CLK1 = 0x1
	// Position of BYPASS field.
	CCM_ANALOG_PLL_SYS_TOG_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_SYS_TOG_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_SYS_TOG_BYPASS = 0x10000
	// Position of LOCK field.
	CCM_ANALOG_PLL_SYS_TOG_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_SYS_TOG_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_SYS_TOG_LOCK = 0x80000000

	// PLL_SYS_SS: 528MHz System PLL Spread Spectrum Register
	// Position of STEP field.
	CCM_ANALOG_PLL_SYS_SS_STEP_Pos = 0x0
	// Bit mask of STEP field.
	CCM_ANALOG_PLL_SYS_SS_STEP_Msk = 0x7fff
	// Position of ENABLE field.
	CCM_ANALOG_PLL_SYS_SS_ENABLE_Pos = 0xf
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_SYS_SS_ENABLE_Msk = 0x8000
	// Bit ENABLE.
	CCM_ANALOG_PLL_SYS_SS_ENABLE = 0x8000
	// Spread spectrum modulation disabled
	CCM_ANALOG_PLL_SYS_SS_ENABLE_ENABLE_0 = 0x0
	// Soread spectrum modulation enabled
	CCM_ANALOG_PLL_SYS_SS_ENABLE_ENABLE_1 = 0x1
	// Position of STOP field.
	CCM_ANALOG_PLL_SYS_SS_STOP_Pos = 0x10
	// Bit mask of STOP field.
	CCM_ANALOG_PLL_SYS_SS_STOP_Msk = 0xffff0000

	// PLL_SYS_NUM: Numerator of 528MHz System PLL Fractional Loop Divider Register
	// Position of A field.
	CCM_ANALOG_PLL_SYS_NUM_A_Pos = 0x0
	// Bit mask of A field.
	CCM_ANALOG_PLL_SYS_NUM_A_Msk = 0x3fffffff

	// PLL_SYS_DENOM: Denominator of 528MHz System PLL Fractional Loop Divider Register
	// Position of B field.
	CCM_ANALOG_PLL_SYS_DENOM_B_Pos = 0x0
	// Bit mask of B field.
	CCM_ANALOG_PLL_SYS_DENOM_B_Msk = 0x3fffffff

	// PLL_AUDIO: Analog Audio PLL control Register
	// Position of DIV_SELECT field.
	CCM_ANALOG_PLL_AUDIO_DIV_SELECT_Pos = 0x0
	// Bit mask of DIV_SELECT field.
	CCM_ANALOG_PLL_AUDIO_DIV_SELECT_Msk = 0x7f
	// Position of POWERDOWN field.
	CCM_ANALOG_PLL_AUDIO_POWERDOWN_Pos = 0xc
	// Bit mask of POWERDOWN field.
	CCM_ANALOG_PLL_AUDIO_POWERDOWN_Msk = 0x1000
	// Bit POWERDOWN.
	CCM_ANALOG_PLL_AUDIO_POWERDOWN = 0x1000
	// Position of ENABLE field.
	CCM_ANALOG_PLL_AUDIO_ENABLE_Pos = 0xd
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_AUDIO_ENABLE_Msk = 0x2000
	// Bit ENABLE.
	CCM_ANALOG_PLL_AUDIO_ENABLE = 0x2000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_AUDIO_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_AUDIO_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_AUDIO_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Select the CLK1_N / CLK1_P as source.
	CCM_ANALOG_PLL_AUDIO_BYPASS_CLK_SRC_CLK1 = 0x1
	// Position of BYPASS field.
	CCM_ANALOG_PLL_AUDIO_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_AUDIO_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_AUDIO_BYPASS = 0x10000
	// Position of POST_DIV_SELECT field.
	CCM_ANALOG_PLL_AUDIO_POST_DIV_SELECT_Pos = 0x13
	// Bit mask of POST_DIV_SELECT field.
	CCM_ANALOG_PLL_AUDIO_POST_DIV_SELECT_Msk = 0x180000
	// Divide by 4.
	CCM_ANALOG_PLL_AUDIO_POST_DIV_SELECT_POST_DIV_SELECT_0 = 0x0
	// Divide by 2.
	CCM_ANALOG_PLL_AUDIO_POST_DIV_SELECT_POST_DIV_SELECT_1 = 0x1
	// Divide by 1.
	CCM_ANALOG_PLL_AUDIO_POST_DIV_SELECT_POST_DIV_SELECT_2 = 0x2
	// Position of LOCK field.
	CCM_ANALOG_PLL_AUDIO_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_AUDIO_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_AUDIO_LOCK = 0x80000000

	// PLL_AUDIO_SET: Analog Audio PLL control Register
	// Position of DIV_SELECT field.
	CCM_ANALOG_PLL_AUDIO_SET_DIV_SELECT_Pos = 0x0
	// Bit mask of DIV_SELECT field.
	CCM_ANALOG_PLL_AUDIO_SET_DIV_SELECT_Msk = 0x7f
	// Position of POWERDOWN field.
	CCM_ANALOG_PLL_AUDIO_SET_POWERDOWN_Pos = 0xc
	// Bit mask of POWERDOWN field.
	CCM_ANALOG_PLL_AUDIO_SET_POWERDOWN_Msk = 0x1000
	// Bit POWERDOWN.
	CCM_ANALOG_PLL_AUDIO_SET_POWERDOWN = 0x1000
	// Position of ENABLE field.
	CCM_ANALOG_PLL_AUDIO_SET_ENABLE_Pos = 0xd
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_AUDIO_SET_ENABLE_Msk = 0x2000
	// Bit ENABLE.
	CCM_ANALOG_PLL_AUDIO_SET_ENABLE = 0x2000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_AUDIO_SET_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_AUDIO_SET_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_AUDIO_SET_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Select the CLK1_N / CLK1_P as source.
	CCM_ANALOG_PLL_AUDIO_SET_BYPASS_CLK_SRC_CLK1 = 0x1
	// Position of BYPASS field.
	CCM_ANALOG_PLL_AUDIO_SET_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_AUDIO_SET_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_AUDIO_SET_BYPASS = 0x10000
	// Position of POST_DIV_SELECT field.
	CCM_ANALOG_PLL_AUDIO_SET_POST_DIV_SELECT_Pos = 0x13
	// Bit mask of POST_DIV_SELECT field.
	CCM_ANALOG_PLL_AUDIO_SET_POST_DIV_SELECT_Msk = 0x180000
	// Divide by 4.
	CCM_ANALOG_PLL_AUDIO_SET_POST_DIV_SELECT_POST_DIV_SELECT_0 = 0x0
	// Divide by 2.
	CCM_ANALOG_PLL_AUDIO_SET_POST_DIV_SELECT_POST_DIV_SELECT_1 = 0x1
	// Divide by 1.
	CCM_ANALOG_PLL_AUDIO_SET_POST_DIV_SELECT_POST_DIV_SELECT_2 = 0x2
	// Position of LOCK field.
	CCM_ANALOG_PLL_AUDIO_SET_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_AUDIO_SET_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_AUDIO_SET_LOCK = 0x80000000

	// PLL_AUDIO_CLR: Analog Audio PLL control Register
	// Position of DIV_SELECT field.
	CCM_ANALOG_PLL_AUDIO_CLR_DIV_SELECT_Pos = 0x0
	// Bit mask of DIV_SELECT field.
	CCM_ANALOG_PLL_AUDIO_CLR_DIV_SELECT_Msk = 0x7f
	// Position of POWERDOWN field.
	CCM_ANALOG_PLL_AUDIO_CLR_POWERDOWN_Pos = 0xc
	// Bit mask of POWERDOWN field.
	CCM_ANALOG_PLL_AUDIO_CLR_POWERDOWN_Msk = 0x1000
	// Bit POWERDOWN.
	CCM_ANALOG_PLL_AUDIO_CLR_POWERDOWN = 0x1000
	// Position of ENABLE field.
	CCM_ANALOG_PLL_AUDIO_CLR_ENABLE_Pos = 0xd
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_AUDIO_CLR_ENABLE_Msk = 0x2000
	// Bit ENABLE.
	CCM_ANALOG_PLL_AUDIO_CLR_ENABLE = 0x2000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_AUDIO_CLR_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_AUDIO_CLR_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_AUDIO_CLR_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Select the CLK1_N / CLK1_P as source.
	CCM_ANALOG_PLL_AUDIO_CLR_BYPASS_CLK_SRC_CLK1 = 0x1
	// Position of BYPASS field.
	CCM_ANALOG_PLL_AUDIO_CLR_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_AUDIO_CLR_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_AUDIO_CLR_BYPASS = 0x10000
	// Position of POST_DIV_SELECT field.
	CCM_ANALOG_PLL_AUDIO_CLR_POST_DIV_SELECT_Pos = 0x13
	// Bit mask of POST_DIV_SELECT field.
	CCM_ANALOG_PLL_AUDIO_CLR_POST_DIV_SELECT_Msk = 0x180000
	// Divide by 4.
	CCM_ANALOG_PLL_AUDIO_CLR_POST_DIV_SELECT_POST_DIV_SELECT_0 = 0x0
	// Divide by 2.
	CCM_ANALOG_PLL_AUDIO_CLR_POST_DIV_SELECT_POST_DIV_SELECT_1 = 0x1
	// Divide by 1.
	CCM_ANALOG_PLL_AUDIO_CLR_POST_DIV_SELECT_POST_DIV_SELECT_2 = 0x2
	// Position of LOCK field.
	CCM_ANALOG_PLL_AUDIO_CLR_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_AUDIO_CLR_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_AUDIO_CLR_LOCK = 0x80000000

	// PLL_AUDIO_TOG: Analog Audio PLL control Register
	// Position of DIV_SELECT field.
	CCM_ANALOG_PLL_AUDIO_TOG_DIV_SELECT_Pos = 0x0
	// Bit mask of DIV_SELECT field.
	CCM_ANALOG_PLL_AUDIO_TOG_DIV_SELECT_Msk = 0x7f
	// Position of POWERDOWN field.
	CCM_ANALOG_PLL_AUDIO_TOG_POWERDOWN_Pos = 0xc
	// Bit mask of POWERDOWN field.
	CCM_ANALOG_PLL_AUDIO_TOG_POWERDOWN_Msk = 0x1000
	// Bit POWERDOWN.
	CCM_ANALOG_PLL_AUDIO_TOG_POWERDOWN = 0x1000
	// Position of ENABLE field.
	CCM_ANALOG_PLL_AUDIO_TOG_ENABLE_Pos = 0xd
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_AUDIO_TOG_ENABLE_Msk = 0x2000
	// Bit ENABLE.
	CCM_ANALOG_PLL_AUDIO_TOG_ENABLE = 0x2000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_AUDIO_TOG_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_AUDIO_TOG_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_AUDIO_TOG_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Select the CLK1_N / CLK1_P as source.
	CCM_ANALOG_PLL_AUDIO_TOG_BYPASS_CLK_SRC_CLK1 = 0x1
	// Position of BYPASS field.
	CCM_ANALOG_PLL_AUDIO_TOG_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_AUDIO_TOG_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_AUDIO_TOG_BYPASS = 0x10000
	// Position of POST_DIV_SELECT field.
	CCM_ANALOG_PLL_AUDIO_TOG_POST_DIV_SELECT_Pos = 0x13
	// Bit mask of POST_DIV_SELECT field.
	CCM_ANALOG_PLL_AUDIO_TOG_POST_DIV_SELECT_Msk = 0x180000
	// Divide by 4.
	CCM_ANALOG_PLL_AUDIO_TOG_POST_DIV_SELECT_POST_DIV_SELECT_0 = 0x0
	// Divide by 2.
	CCM_ANALOG_PLL_AUDIO_TOG_POST_DIV_SELECT_POST_DIV_SELECT_1 = 0x1
	// Divide by 1.
	CCM_ANALOG_PLL_AUDIO_TOG_POST_DIV_SELECT_POST_DIV_SELECT_2 = 0x2
	// Position of LOCK field.
	CCM_ANALOG_PLL_AUDIO_TOG_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_AUDIO_TOG_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_AUDIO_TOG_LOCK = 0x80000000

	// PLL_AUDIO_NUM: Numerator of Audio PLL Fractional Loop Divider Register
	// Position of A field.
	CCM_ANALOG_PLL_AUDIO_NUM_A_Pos = 0x0
	// Bit mask of A field.
	CCM_ANALOG_PLL_AUDIO_NUM_A_Msk = 0x3fffffff

	// PLL_AUDIO_DENOM: Denominator of Audio PLL Fractional Loop Divider Register
	// Position of B field.
	CCM_ANALOG_PLL_AUDIO_DENOM_B_Pos = 0x0
	// Bit mask of B field.
	CCM_ANALOG_PLL_AUDIO_DENOM_B_Msk = 0x3fffffff

	// PLL_VIDEO: Analog Video PLL control Register
	// Position of DIV_SELECT field.
	CCM_ANALOG_PLL_VIDEO_DIV_SELECT_Pos = 0x0
	// Bit mask of DIV_SELECT field.
	CCM_ANALOG_PLL_VIDEO_DIV_SELECT_Msk = 0x7f
	// Position of POWERDOWN field.
	CCM_ANALOG_PLL_VIDEO_POWERDOWN_Pos = 0xc
	// Bit mask of POWERDOWN field.
	CCM_ANALOG_PLL_VIDEO_POWERDOWN_Msk = 0x1000
	// Bit POWERDOWN.
	CCM_ANALOG_PLL_VIDEO_POWERDOWN = 0x1000
	// Position of ENABLE field.
	CCM_ANALOG_PLL_VIDEO_ENABLE_Pos = 0xd
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_VIDEO_ENABLE_Msk = 0x2000
	// Bit ENABLE.
	CCM_ANALOG_PLL_VIDEO_ENABLE = 0x2000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_VIDEO_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_VIDEO_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_VIDEO_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Select the CLK1_N / CLK1_P as source.
	CCM_ANALOG_PLL_VIDEO_BYPASS_CLK_SRC_CLK1 = 0x1
	// Position of BYPASS field.
	CCM_ANALOG_PLL_VIDEO_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_VIDEO_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_VIDEO_BYPASS = 0x10000
	// Position of POST_DIV_SELECT field.
	CCM_ANALOG_PLL_VIDEO_POST_DIV_SELECT_Pos = 0x13
	// Bit mask of POST_DIV_SELECT field.
	CCM_ANALOG_PLL_VIDEO_POST_DIV_SELECT_Msk = 0x180000
	// Divide by 4.
	CCM_ANALOG_PLL_VIDEO_POST_DIV_SELECT_POST_DIV_SELECT_0 = 0x0
	// Divide by 2.
	CCM_ANALOG_PLL_VIDEO_POST_DIV_SELECT_POST_DIV_SELECT_1 = 0x1
	// Divide by 1.
	CCM_ANALOG_PLL_VIDEO_POST_DIV_SELECT_POST_DIV_SELECT_2 = 0x2
	// Position of LOCK field.
	CCM_ANALOG_PLL_VIDEO_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_VIDEO_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_VIDEO_LOCK = 0x80000000

	// PLL_VIDEO_SET: Analog Video PLL control Register
	// Position of DIV_SELECT field.
	CCM_ANALOG_PLL_VIDEO_SET_DIV_SELECT_Pos = 0x0
	// Bit mask of DIV_SELECT field.
	CCM_ANALOG_PLL_VIDEO_SET_DIV_SELECT_Msk = 0x7f
	// Position of POWERDOWN field.
	CCM_ANALOG_PLL_VIDEO_SET_POWERDOWN_Pos = 0xc
	// Bit mask of POWERDOWN field.
	CCM_ANALOG_PLL_VIDEO_SET_POWERDOWN_Msk = 0x1000
	// Bit POWERDOWN.
	CCM_ANALOG_PLL_VIDEO_SET_POWERDOWN = 0x1000
	// Position of ENABLE field.
	CCM_ANALOG_PLL_VIDEO_SET_ENABLE_Pos = 0xd
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_VIDEO_SET_ENABLE_Msk = 0x2000
	// Bit ENABLE.
	CCM_ANALOG_PLL_VIDEO_SET_ENABLE = 0x2000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_VIDEO_SET_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_VIDEO_SET_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_VIDEO_SET_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Select the CLK1_N / CLK1_P as source.
	CCM_ANALOG_PLL_VIDEO_SET_BYPASS_CLK_SRC_CLK1 = 0x1
	// Position of BYPASS field.
	CCM_ANALOG_PLL_VIDEO_SET_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_VIDEO_SET_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_VIDEO_SET_BYPASS = 0x10000
	// Position of POST_DIV_SELECT field.
	CCM_ANALOG_PLL_VIDEO_SET_POST_DIV_SELECT_Pos = 0x13
	// Bit mask of POST_DIV_SELECT field.
	CCM_ANALOG_PLL_VIDEO_SET_POST_DIV_SELECT_Msk = 0x180000
	// Divide by 4.
	CCM_ANALOG_PLL_VIDEO_SET_POST_DIV_SELECT_POST_DIV_SELECT_0 = 0x0
	// Divide by 2.
	CCM_ANALOG_PLL_VIDEO_SET_POST_DIV_SELECT_POST_DIV_SELECT_1 = 0x1
	// Divide by 1.
	CCM_ANALOG_PLL_VIDEO_SET_POST_DIV_SELECT_POST_DIV_SELECT_2 = 0x2
	// Position of LOCK field.
	CCM_ANALOG_PLL_VIDEO_SET_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_VIDEO_SET_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_VIDEO_SET_LOCK = 0x80000000

	// PLL_VIDEO_CLR: Analog Video PLL control Register
	// Position of DIV_SELECT field.
	CCM_ANALOG_PLL_VIDEO_CLR_DIV_SELECT_Pos = 0x0
	// Bit mask of DIV_SELECT field.
	CCM_ANALOG_PLL_VIDEO_CLR_DIV_SELECT_Msk = 0x7f
	// Position of POWERDOWN field.
	CCM_ANALOG_PLL_VIDEO_CLR_POWERDOWN_Pos = 0xc
	// Bit mask of POWERDOWN field.
	CCM_ANALOG_PLL_VIDEO_CLR_POWERDOWN_Msk = 0x1000
	// Bit POWERDOWN.
	CCM_ANALOG_PLL_VIDEO_CLR_POWERDOWN = 0x1000
	// Position of ENABLE field.
	CCM_ANALOG_PLL_VIDEO_CLR_ENABLE_Pos = 0xd
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_VIDEO_CLR_ENABLE_Msk = 0x2000
	// Bit ENABLE.
	CCM_ANALOG_PLL_VIDEO_CLR_ENABLE = 0x2000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_VIDEO_CLR_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_VIDEO_CLR_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_VIDEO_CLR_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Select the CLK1_N / CLK1_P as source.
	CCM_ANALOG_PLL_VIDEO_CLR_BYPASS_CLK_SRC_CLK1 = 0x1
	// Position of BYPASS field.
	CCM_ANALOG_PLL_VIDEO_CLR_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_VIDEO_CLR_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_VIDEO_CLR_BYPASS = 0x10000
	// Position of POST_DIV_SELECT field.
	CCM_ANALOG_PLL_VIDEO_CLR_POST_DIV_SELECT_Pos = 0x13
	// Bit mask of POST_DIV_SELECT field.
	CCM_ANALOG_PLL_VIDEO_CLR_POST_DIV_SELECT_Msk = 0x180000
	// Divide by 4.
	CCM_ANALOG_PLL_VIDEO_CLR_POST_DIV_SELECT_POST_DIV_SELECT_0 = 0x0
	// Divide by 2.
	CCM_ANALOG_PLL_VIDEO_CLR_POST_DIV_SELECT_POST_DIV_SELECT_1 = 0x1
	// Divide by 1.
	CCM_ANALOG_PLL_VIDEO_CLR_POST_DIV_SELECT_POST_DIV_SELECT_2 = 0x2
	// Position of LOCK field.
	CCM_ANALOG_PLL_VIDEO_CLR_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_VIDEO_CLR_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_VIDEO_CLR_LOCK = 0x80000000

	// PLL_VIDEO_TOG: Analog Video PLL control Register
	// Position of DIV_SELECT field.
	CCM_ANALOG_PLL_VIDEO_TOG_DIV_SELECT_Pos = 0x0
	// Bit mask of DIV_SELECT field.
	CCM_ANALOG_PLL_VIDEO_TOG_DIV_SELECT_Msk = 0x7f
	// Position of POWERDOWN field.
	CCM_ANALOG_PLL_VIDEO_TOG_POWERDOWN_Pos = 0xc
	// Bit mask of POWERDOWN field.
	CCM_ANALOG_PLL_VIDEO_TOG_POWERDOWN_Msk = 0x1000
	// Bit POWERDOWN.
	CCM_ANALOG_PLL_VIDEO_TOG_POWERDOWN = 0x1000
	// Position of ENABLE field.
	CCM_ANALOG_PLL_VIDEO_TOG_ENABLE_Pos = 0xd
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_VIDEO_TOG_ENABLE_Msk = 0x2000
	// Bit ENABLE.
	CCM_ANALOG_PLL_VIDEO_TOG_ENABLE = 0x2000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_VIDEO_TOG_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_VIDEO_TOG_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_VIDEO_TOG_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Select the CLK1_N / CLK1_P as source.
	CCM_ANALOG_PLL_VIDEO_TOG_BYPASS_CLK_SRC_CLK1 = 0x1
	// Position of BYPASS field.
	CCM_ANALOG_PLL_VIDEO_TOG_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_VIDEO_TOG_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_VIDEO_TOG_BYPASS = 0x10000
	// Position of POST_DIV_SELECT field.
	CCM_ANALOG_PLL_VIDEO_TOG_POST_DIV_SELECT_Pos = 0x13
	// Bit mask of POST_DIV_SELECT field.
	CCM_ANALOG_PLL_VIDEO_TOG_POST_DIV_SELECT_Msk = 0x180000
	// Divide by 4.
	CCM_ANALOG_PLL_VIDEO_TOG_POST_DIV_SELECT_POST_DIV_SELECT_0 = 0x0
	// Divide by 2.
	CCM_ANALOG_PLL_VIDEO_TOG_POST_DIV_SELECT_POST_DIV_SELECT_1 = 0x1
	// Divide by 1.
	CCM_ANALOG_PLL_VIDEO_TOG_POST_DIV_SELECT_POST_DIV_SELECT_2 = 0x2
	// Position of LOCK field.
	CCM_ANALOG_PLL_VIDEO_TOG_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_VIDEO_TOG_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_VIDEO_TOG_LOCK = 0x80000000

	// PLL_VIDEO_NUM: Numerator of Video PLL Fractional Loop Divider Register
	// Position of A field.
	CCM_ANALOG_PLL_VIDEO_NUM_A_Pos = 0x0
	// Bit mask of A field.
	CCM_ANALOG_PLL_VIDEO_NUM_A_Msk = 0x3fffffff

	// PLL_VIDEO_DENOM: Denominator of Video PLL Fractional Loop Divider Register
	// Position of B field.
	CCM_ANALOG_PLL_VIDEO_DENOM_B_Pos = 0x0
	// Bit mask of B field.
	CCM_ANALOG_PLL_VIDEO_DENOM_B_Msk = 0x3fffffff

	// PLL_ENET: Analog ENET PLL Control Register
	// Position of DIV_SELECT field.
	CCM_ANALOG_PLL_ENET_DIV_SELECT_Pos = 0x0
	// Bit mask of DIV_SELECT field.
	CCM_ANALOG_PLL_ENET_DIV_SELECT_Msk = 0x3
	// Position of ENET2_DIV_SELECT field.
	CCM_ANALOG_PLL_ENET_ENET2_DIV_SELECT_Pos = 0x2
	// Bit mask of ENET2_DIV_SELECT field.
	CCM_ANALOG_PLL_ENET_ENET2_DIV_SELECT_Msk = 0xc
	// 25MHz
	CCM_ANALOG_PLL_ENET_ENET2_DIV_SELECT_ENET2_DIV_SELECT_0 = 0x0
	// 50MHz
	CCM_ANALOG_PLL_ENET_ENET2_DIV_SELECT_ENET2_DIV_SELECT_1 = 0x1
	// 100MHz (not 50% duty cycle)
	CCM_ANALOG_PLL_ENET_ENET2_DIV_SELECT_ENET2_DIV_SELECT_2 = 0x2
	// 125MHz
	CCM_ANALOG_PLL_ENET_ENET2_DIV_SELECT_ENET2_DIV_SELECT_3 = 0x3
	// Position of POWERDOWN field.
	CCM_ANALOG_PLL_ENET_POWERDOWN_Pos = 0xc
	// Bit mask of POWERDOWN field.
	CCM_ANALOG_PLL_ENET_POWERDOWN_Msk = 0x1000
	// Bit POWERDOWN.
	CCM_ANALOG_PLL_ENET_POWERDOWN = 0x1000
	// Position of ENABLE field.
	CCM_ANALOG_PLL_ENET_ENABLE_Pos = 0xd
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_ENET_ENABLE_Msk = 0x2000
	// Bit ENABLE.
	CCM_ANALOG_PLL_ENET_ENABLE = 0x2000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_ENET_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_ENET_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_ENET_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Select the CLK1_N / CLK1_P as source.
	CCM_ANALOG_PLL_ENET_BYPASS_CLK_SRC_CLK1 = 0x1
	// Position of BYPASS field.
	CCM_ANALOG_PLL_ENET_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_ENET_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_ENET_BYPASS = 0x10000
	// Position of ENET2_REF_EN field.
	CCM_ANALOG_PLL_ENET_ENET2_REF_EN_Pos = 0x14
	// Bit mask of ENET2_REF_EN field.
	CCM_ANALOG_PLL_ENET_ENET2_REF_EN_Msk = 0x100000
	// Bit ENET2_REF_EN.
	CCM_ANALOG_PLL_ENET_ENET2_REF_EN = 0x100000
	// Position of ENET_25M_REF_EN field.
	CCM_ANALOG_PLL_ENET_ENET_25M_REF_EN_Pos = 0x15
	// Bit mask of ENET_25M_REF_EN field.
	CCM_ANALOG_PLL_ENET_ENET_25M_REF_EN_Msk = 0x200000
	// Bit ENET_25M_REF_EN.
	CCM_ANALOG_PLL_ENET_ENET_25M_REF_EN = 0x200000
	// Position of LOCK field.
	CCM_ANALOG_PLL_ENET_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_ENET_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_ENET_LOCK = 0x80000000

	// PLL_ENET_SET: Analog ENET PLL Control Register
	// Position of DIV_SELECT field.
	CCM_ANALOG_PLL_ENET_SET_DIV_SELECT_Pos = 0x0
	// Bit mask of DIV_SELECT field.
	CCM_ANALOG_PLL_ENET_SET_DIV_SELECT_Msk = 0x3
	// Position of ENET2_DIV_SELECT field.
	CCM_ANALOG_PLL_ENET_SET_ENET2_DIV_SELECT_Pos = 0x2
	// Bit mask of ENET2_DIV_SELECT field.
	CCM_ANALOG_PLL_ENET_SET_ENET2_DIV_SELECT_Msk = 0xc
	// 25MHz
	CCM_ANALOG_PLL_ENET_SET_ENET2_DIV_SELECT_ENET2_DIV_SELECT_0 = 0x0
	// 50MHz
	CCM_ANALOG_PLL_ENET_SET_ENET2_DIV_SELECT_ENET2_DIV_SELECT_1 = 0x1
	// 100MHz (not 50% duty cycle)
	CCM_ANALOG_PLL_ENET_SET_ENET2_DIV_SELECT_ENET2_DIV_SELECT_2 = 0x2
	// 125MHz
	CCM_ANALOG_PLL_ENET_SET_ENET2_DIV_SELECT_ENET2_DIV_SELECT_3 = 0x3
	// Position of POWERDOWN field.
	CCM_ANALOG_PLL_ENET_SET_POWERDOWN_Pos = 0xc
	// Bit mask of POWERDOWN field.
	CCM_ANALOG_PLL_ENET_SET_POWERDOWN_Msk = 0x1000
	// Bit POWERDOWN.
	CCM_ANALOG_PLL_ENET_SET_POWERDOWN = 0x1000
	// Position of ENABLE field.
	CCM_ANALOG_PLL_ENET_SET_ENABLE_Pos = 0xd
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_ENET_SET_ENABLE_Msk = 0x2000
	// Bit ENABLE.
	CCM_ANALOG_PLL_ENET_SET_ENABLE = 0x2000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_ENET_SET_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_ENET_SET_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_ENET_SET_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Select the CLK1_N / CLK1_P as source.
	CCM_ANALOG_PLL_ENET_SET_BYPASS_CLK_SRC_CLK1 = 0x1
	// Position of BYPASS field.
	CCM_ANALOG_PLL_ENET_SET_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_ENET_SET_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_ENET_SET_BYPASS = 0x10000
	// Position of ENET2_REF_EN field.
	CCM_ANALOG_PLL_ENET_SET_ENET2_REF_EN_Pos = 0x14
	// Bit mask of ENET2_REF_EN field.
	CCM_ANALOG_PLL_ENET_SET_ENET2_REF_EN_Msk = 0x100000
	// Bit ENET2_REF_EN.
	CCM_ANALOG_PLL_ENET_SET_ENET2_REF_EN = 0x100000
	// Position of ENET_25M_REF_EN field.
	CCM_ANALOG_PLL_ENET_SET_ENET_25M_REF_EN_Pos = 0x15
	// Bit mask of ENET_25M_REF_EN field.
	CCM_ANALOG_PLL_ENET_SET_ENET_25M_REF_EN_Msk = 0x200000
	// Bit ENET_25M_REF_EN.
	CCM_ANALOG_PLL_ENET_SET_ENET_25M_REF_EN = 0x200000
	// Position of LOCK field.
	CCM_ANALOG_PLL_ENET_SET_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_ENET_SET_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_ENET_SET_LOCK = 0x80000000

	// PLL_ENET_CLR: Analog ENET PLL Control Register
	// Position of DIV_SELECT field.
	CCM_ANALOG_PLL_ENET_CLR_DIV_SELECT_Pos = 0x0
	// Bit mask of DIV_SELECT field.
	CCM_ANALOG_PLL_ENET_CLR_DIV_SELECT_Msk = 0x3
	// Position of ENET2_DIV_SELECT field.
	CCM_ANALOG_PLL_ENET_CLR_ENET2_DIV_SELECT_Pos = 0x2
	// Bit mask of ENET2_DIV_SELECT field.
	CCM_ANALOG_PLL_ENET_CLR_ENET2_DIV_SELECT_Msk = 0xc
	// 25MHz
	CCM_ANALOG_PLL_ENET_CLR_ENET2_DIV_SELECT_ENET2_DIV_SELECT_0 = 0x0
	// 50MHz
	CCM_ANALOG_PLL_ENET_CLR_ENET2_DIV_SELECT_ENET2_DIV_SELECT_1 = 0x1
	// 100MHz (not 50% duty cycle)
	CCM_ANALOG_PLL_ENET_CLR_ENET2_DIV_SELECT_ENET2_DIV_SELECT_2 = 0x2
	// 125MHz
	CCM_ANALOG_PLL_ENET_CLR_ENET2_DIV_SELECT_ENET2_DIV_SELECT_3 = 0x3
	// Position of POWERDOWN field.
	CCM_ANALOG_PLL_ENET_CLR_POWERDOWN_Pos = 0xc
	// Bit mask of POWERDOWN field.
	CCM_ANALOG_PLL_ENET_CLR_POWERDOWN_Msk = 0x1000
	// Bit POWERDOWN.
	CCM_ANALOG_PLL_ENET_CLR_POWERDOWN = 0x1000
	// Position of ENABLE field.
	CCM_ANALOG_PLL_ENET_CLR_ENABLE_Pos = 0xd
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_ENET_CLR_ENABLE_Msk = 0x2000
	// Bit ENABLE.
	CCM_ANALOG_PLL_ENET_CLR_ENABLE = 0x2000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_ENET_CLR_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_ENET_CLR_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_ENET_CLR_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Select the CLK1_N / CLK1_P as source.
	CCM_ANALOG_PLL_ENET_CLR_BYPASS_CLK_SRC_CLK1 = 0x1
	// Position of BYPASS field.
	CCM_ANALOG_PLL_ENET_CLR_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_ENET_CLR_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_ENET_CLR_BYPASS = 0x10000
	// Position of ENET2_REF_EN field.
	CCM_ANALOG_PLL_ENET_CLR_ENET2_REF_EN_Pos = 0x14
	// Bit mask of ENET2_REF_EN field.
	CCM_ANALOG_PLL_ENET_CLR_ENET2_REF_EN_Msk = 0x100000
	// Bit ENET2_REF_EN.
	CCM_ANALOG_PLL_ENET_CLR_ENET2_REF_EN = 0x100000
	// Position of ENET_25M_REF_EN field.
	CCM_ANALOG_PLL_ENET_CLR_ENET_25M_REF_EN_Pos = 0x15
	// Bit mask of ENET_25M_REF_EN field.
	CCM_ANALOG_PLL_ENET_CLR_ENET_25M_REF_EN_Msk = 0x200000
	// Bit ENET_25M_REF_EN.
	CCM_ANALOG_PLL_ENET_CLR_ENET_25M_REF_EN = 0x200000
	// Position of LOCK field.
	CCM_ANALOG_PLL_ENET_CLR_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_ENET_CLR_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_ENET_CLR_LOCK = 0x80000000

	// PLL_ENET_TOG: Analog ENET PLL Control Register
	// Position of DIV_SELECT field.
	CCM_ANALOG_PLL_ENET_TOG_DIV_SELECT_Pos = 0x0
	// Bit mask of DIV_SELECT field.
	CCM_ANALOG_PLL_ENET_TOG_DIV_SELECT_Msk = 0x3
	// Position of ENET2_DIV_SELECT field.
	CCM_ANALOG_PLL_ENET_TOG_ENET2_DIV_SELECT_Pos = 0x2
	// Bit mask of ENET2_DIV_SELECT field.
	CCM_ANALOG_PLL_ENET_TOG_ENET2_DIV_SELECT_Msk = 0xc
	// 25MHz
	CCM_ANALOG_PLL_ENET_TOG_ENET2_DIV_SELECT_ENET2_DIV_SELECT_0 = 0x0
	// 50MHz
	CCM_ANALOG_PLL_ENET_TOG_ENET2_DIV_SELECT_ENET2_DIV_SELECT_1 = 0x1
	// 100MHz (not 50% duty cycle)
	CCM_ANALOG_PLL_ENET_TOG_ENET2_DIV_SELECT_ENET2_DIV_SELECT_2 = 0x2
	// 125MHz
	CCM_ANALOG_PLL_ENET_TOG_ENET2_DIV_SELECT_ENET2_DIV_SELECT_3 = 0x3
	// Position of POWERDOWN field.
	CCM_ANALOG_PLL_ENET_TOG_POWERDOWN_Pos = 0xc
	// Bit mask of POWERDOWN field.
	CCM_ANALOG_PLL_ENET_TOG_POWERDOWN_Msk = 0x1000
	// Bit POWERDOWN.
	CCM_ANALOG_PLL_ENET_TOG_POWERDOWN = 0x1000
	// Position of ENABLE field.
	CCM_ANALOG_PLL_ENET_TOG_ENABLE_Pos = 0xd
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_ENET_TOG_ENABLE_Msk = 0x2000
	// Bit ENABLE.
	CCM_ANALOG_PLL_ENET_TOG_ENABLE = 0x2000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_ENET_TOG_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_ENET_TOG_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_ENET_TOG_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Select the CLK1_N / CLK1_P as source.
	CCM_ANALOG_PLL_ENET_TOG_BYPASS_CLK_SRC_CLK1 = 0x1
	// Position of BYPASS field.
	CCM_ANALOG_PLL_ENET_TOG_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_ENET_TOG_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_ENET_TOG_BYPASS = 0x10000
	// Position of ENET2_REF_EN field.
	CCM_ANALOG_PLL_ENET_TOG_ENET2_REF_EN_Pos = 0x14
	// Bit mask of ENET2_REF_EN field.
	CCM_ANALOG_PLL_ENET_TOG_ENET2_REF_EN_Msk = 0x100000
	// Bit ENET2_REF_EN.
	CCM_ANALOG_PLL_ENET_TOG_ENET2_REF_EN = 0x100000
	// Position of ENET_25M_REF_EN field.
	CCM_ANALOG_PLL_ENET_TOG_ENET_25M_REF_EN_Pos = 0x15
	// Bit mask of ENET_25M_REF_EN field.
	CCM_ANALOG_PLL_ENET_TOG_ENET_25M_REF_EN_Msk = 0x200000
	// Bit ENET_25M_REF_EN.
	CCM_ANALOG_PLL_ENET_TOG_ENET_25M_REF_EN = 0x200000
	// Position of LOCK field.
	CCM_ANALOG_PLL_ENET_TOG_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_ENET_TOG_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_ENET_TOG_LOCK = 0x80000000

	// PFD_480: 480MHz Clock (PLL3) Phase Fractional Divider Control Register
	// Position of PFD0_FRAC field.
	CCM_ANALOG_PFD_480_PFD0_FRAC_Pos = 0x0
	// Bit mask of PFD0_FRAC field.
	CCM_ANALOG_PFD_480_PFD0_FRAC_Msk = 0x3f
	// Position of PFD0_STABLE field.
	CCM_ANALOG_PFD_480_PFD0_STABLE_Pos = 0x6
	// Bit mask of PFD0_STABLE field.
	CCM_ANALOG_PFD_480_PFD0_STABLE_Msk = 0x40
	// Bit PFD0_STABLE.
	CCM_ANALOG_PFD_480_PFD0_STABLE = 0x40
	// Position of PFD0_CLKGATE field.
	CCM_ANALOG_PFD_480_PFD0_CLKGATE_Pos = 0x7
	// Bit mask of PFD0_CLKGATE field.
	CCM_ANALOG_PFD_480_PFD0_CLKGATE_Msk = 0x80
	// Bit PFD0_CLKGATE.
	CCM_ANALOG_PFD_480_PFD0_CLKGATE = 0x80
	// Position of PFD1_FRAC field.
	CCM_ANALOG_PFD_480_PFD1_FRAC_Pos = 0x8
	// Bit mask of PFD1_FRAC field.
	CCM_ANALOG_PFD_480_PFD1_FRAC_Msk = 0x3f00
	// Position of PFD1_STABLE field.
	CCM_ANALOG_PFD_480_PFD1_STABLE_Pos = 0xe
	// Bit mask of PFD1_STABLE field.
	CCM_ANALOG_PFD_480_PFD1_STABLE_Msk = 0x4000
	// Bit PFD1_STABLE.
	CCM_ANALOG_PFD_480_PFD1_STABLE = 0x4000
	// Position of PFD1_CLKGATE field.
	CCM_ANALOG_PFD_480_PFD1_CLKGATE_Pos = 0xf
	// Bit mask of PFD1_CLKGATE field.
	CCM_ANALOG_PFD_480_PFD1_CLKGATE_Msk = 0x8000
	// Bit PFD1_CLKGATE.
	CCM_ANALOG_PFD_480_PFD1_CLKGATE = 0x8000
	// Position of PFD2_FRAC field.
	CCM_ANALOG_PFD_480_PFD2_FRAC_Pos = 0x10
	// Bit mask of PFD2_FRAC field.
	CCM_ANALOG_PFD_480_PFD2_FRAC_Msk = 0x3f0000
	// Position of PFD2_STABLE field.
	CCM_ANALOG_PFD_480_PFD2_STABLE_Pos = 0x16
	// Bit mask of PFD2_STABLE field.
	CCM_ANALOG_PFD_480_PFD2_STABLE_Msk = 0x400000
	// Bit PFD2_STABLE.
	CCM_ANALOG_PFD_480_PFD2_STABLE = 0x400000
	// Position of PFD2_CLKGATE field.
	CCM_ANALOG_PFD_480_PFD2_CLKGATE_Pos = 0x17
	// Bit mask of PFD2_CLKGATE field.
	CCM_ANALOG_PFD_480_PFD2_CLKGATE_Msk = 0x800000
	// Bit PFD2_CLKGATE.
	CCM_ANALOG_PFD_480_PFD2_CLKGATE = 0x800000
	// Position of PFD3_FRAC field.
	CCM_ANALOG_PFD_480_PFD3_FRAC_Pos = 0x18
	// Bit mask of PFD3_FRAC field.
	CCM_ANALOG_PFD_480_PFD3_FRAC_Msk = 0x3f000000
	// Position of PFD3_STABLE field.
	CCM_ANALOG_PFD_480_PFD3_STABLE_Pos = 0x1e
	// Bit mask of PFD3_STABLE field.
	CCM_ANALOG_PFD_480_PFD3_STABLE_Msk = 0x40000000
	// Bit PFD3_STABLE.
	CCM_ANALOG_PFD_480_PFD3_STABLE = 0x40000000
	// Position of PFD3_CLKGATE field.
	CCM_ANALOG_PFD_480_PFD3_CLKGATE_Pos = 0x1f
	// Bit mask of PFD3_CLKGATE field.
	CCM_ANALOG_PFD_480_PFD3_CLKGATE_Msk = 0x80000000
	// Bit PFD3_CLKGATE.
	CCM_ANALOG_PFD_480_PFD3_CLKGATE = 0x80000000

	// PFD_480_SET: 480MHz Clock (PLL3) Phase Fractional Divider Control Register
	// Position of PFD0_FRAC field.
	CCM_ANALOG_PFD_480_SET_PFD0_FRAC_Pos = 0x0
	// Bit mask of PFD0_FRAC field.
	CCM_ANALOG_PFD_480_SET_PFD0_FRAC_Msk = 0x3f
	// Position of PFD0_STABLE field.
	CCM_ANALOG_PFD_480_SET_PFD0_STABLE_Pos = 0x6
	// Bit mask of PFD0_STABLE field.
	CCM_ANALOG_PFD_480_SET_PFD0_STABLE_Msk = 0x40
	// Bit PFD0_STABLE.
	CCM_ANALOG_PFD_480_SET_PFD0_STABLE = 0x40
	// Position of PFD0_CLKGATE field.
	CCM_ANALOG_PFD_480_SET_PFD0_CLKGATE_Pos = 0x7
	// Bit mask of PFD0_CLKGATE field.
	CCM_ANALOG_PFD_480_SET_PFD0_CLKGATE_Msk = 0x80
	// Bit PFD0_CLKGATE.
	CCM_ANALOG_PFD_480_SET_PFD0_CLKGATE = 0x80
	// Position of PFD1_FRAC field.
	CCM_ANALOG_PFD_480_SET_PFD1_FRAC_Pos = 0x8
	// Bit mask of PFD1_FRAC field.
	CCM_ANALOG_PFD_480_SET_PFD1_FRAC_Msk = 0x3f00
	// Position of PFD1_STABLE field.
	CCM_ANALOG_PFD_480_SET_PFD1_STABLE_Pos = 0xe
	// Bit mask of PFD1_STABLE field.
	CCM_ANALOG_PFD_480_SET_PFD1_STABLE_Msk = 0x4000
	// Bit PFD1_STABLE.
	CCM_ANALOG_PFD_480_SET_PFD1_STABLE = 0x4000
	// Position of PFD1_CLKGATE field.
	CCM_ANALOG_PFD_480_SET_PFD1_CLKGATE_Pos = 0xf
	// Bit mask of PFD1_CLKGATE field.
	CCM_ANALOG_PFD_480_SET_PFD1_CLKGATE_Msk = 0x8000
	// Bit PFD1_CLKGATE.
	CCM_ANALOG_PFD_480_SET_PFD1_CLKGATE = 0x8000
	// Position of PFD2_FRAC field.
	CCM_ANALOG_PFD_480_SET_PFD2_FRAC_Pos = 0x10
	// Bit mask of PFD2_FRAC field.
	CCM_ANALOG_PFD_480_SET_PFD2_FRAC_Msk = 0x3f0000
	// Position of PFD2_STABLE field.
	CCM_ANALOG_PFD_480_SET_PFD2_STABLE_Pos = 0x16
	// Bit mask of PFD2_STABLE field.
	CCM_ANALOG_PFD_480_SET_PFD2_STABLE_Msk = 0x400000
	// Bit PFD2_STABLE.
	CCM_ANALOG_PFD_480_SET_PFD2_STABLE = 0x400000
	// Position of PFD2_CLKGATE field.
	CCM_ANALOG_PFD_480_SET_PFD2_CLKGATE_Pos = 0x17
	// Bit mask of PFD2_CLKGATE field.
	CCM_ANALOG_PFD_480_SET_PFD2_CLKGATE_Msk = 0x800000
	// Bit PFD2_CLKGATE.
	CCM_ANALOG_PFD_480_SET_PFD2_CLKGATE = 0x800000
	// Position of PFD3_FRAC field.
	CCM_ANALOG_PFD_480_SET_PFD3_FRAC_Pos = 0x18
	// Bit mask of PFD3_FRAC field.
	CCM_ANALOG_PFD_480_SET_PFD3_FRAC_Msk = 0x3f000000
	// Position of PFD3_STABLE field.
	CCM_ANALOG_PFD_480_SET_PFD3_STABLE_Pos = 0x1e
	// Bit mask of PFD3_STABLE field.
	CCM_ANALOG_PFD_480_SET_PFD3_STABLE_Msk = 0x40000000
	// Bit PFD3_STABLE.
	CCM_ANALOG_PFD_480_SET_PFD3_STABLE = 0x40000000
	// Position of PFD3_CLKGATE field.
	CCM_ANALOG_PFD_480_SET_PFD3_CLKGATE_Pos = 0x1f
	// Bit mask of PFD3_CLKGATE field.
	CCM_ANALOG_PFD_480_SET_PFD3_CLKGATE_Msk = 0x80000000
	// Bit PFD3_CLKGATE.
	CCM_ANALOG_PFD_480_SET_PFD3_CLKGATE = 0x80000000

	// PFD_480_CLR: 480MHz Clock (PLL3) Phase Fractional Divider Control Register
	// Position of PFD0_FRAC field.
	CCM_ANALOG_PFD_480_CLR_PFD0_FRAC_Pos = 0x0
	// Bit mask of PFD0_FRAC field.
	CCM_ANALOG_PFD_480_CLR_PFD0_FRAC_Msk = 0x3f
	// Position of PFD0_STABLE field.
	CCM_ANALOG_PFD_480_CLR_PFD0_STABLE_Pos = 0x6
	// Bit mask of PFD0_STABLE field.
	CCM_ANALOG_PFD_480_CLR_PFD0_STABLE_Msk = 0x40
	// Bit PFD0_STABLE.
	CCM_ANALOG_PFD_480_CLR_PFD0_STABLE = 0x40
	// Position of PFD0_CLKGATE field.
	CCM_ANALOG_PFD_480_CLR_PFD0_CLKGATE_Pos = 0x7
	// Bit mask of PFD0_CLKGATE field.
	CCM_ANALOG_PFD_480_CLR_PFD0_CLKGATE_Msk = 0x80
	// Bit PFD0_CLKGATE.
	CCM_ANALOG_PFD_480_CLR_PFD0_CLKGATE = 0x80
	// Position of PFD1_FRAC field.
	CCM_ANALOG_PFD_480_CLR_PFD1_FRAC_Pos = 0x8
	// Bit mask of PFD1_FRAC field.
	CCM_ANALOG_PFD_480_CLR_PFD1_FRAC_Msk = 0x3f00
	// Position of PFD1_STABLE field.
	CCM_ANALOG_PFD_480_CLR_PFD1_STABLE_Pos = 0xe
	// Bit mask of PFD1_STABLE field.
	CCM_ANALOG_PFD_480_CLR_PFD1_STABLE_Msk = 0x4000
	// Bit PFD1_STABLE.
	CCM_ANALOG_PFD_480_CLR_PFD1_STABLE = 0x4000
	// Position of PFD1_CLKGATE field.
	CCM_ANALOG_PFD_480_CLR_PFD1_CLKGATE_Pos = 0xf
	// Bit mask of PFD1_CLKGATE field.
	CCM_ANALOG_PFD_480_CLR_PFD1_CLKGATE_Msk = 0x8000
	// Bit PFD1_CLKGATE.
	CCM_ANALOG_PFD_480_CLR_PFD1_CLKGATE = 0x8000
	// Position of PFD2_FRAC field.
	CCM_ANALOG_PFD_480_CLR_PFD2_FRAC_Pos = 0x10
	// Bit mask of PFD2_FRAC field.
	CCM_ANALOG_PFD_480_CLR_PFD2_FRAC_Msk = 0x3f0000
	// Position of PFD2_STABLE field.
	CCM_ANALOG_PFD_480_CLR_PFD2_STABLE_Pos = 0x16
	// Bit mask of PFD2_STABLE field.
	CCM_ANALOG_PFD_480_CLR_PFD2_STABLE_Msk = 0x400000
	// Bit PFD2_STABLE.
	CCM_ANALOG_PFD_480_CLR_PFD2_STABLE = 0x400000
	// Position of PFD2_CLKGATE field.
	CCM_ANALOG_PFD_480_CLR_PFD2_CLKGATE_Pos = 0x17
	// Bit mask of PFD2_CLKGATE field.
	CCM_ANALOG_PFD_480_CLR_PFD2_CLKGATE_Msk = 0x800000
	// Bit PFD2_CLKGATE.
	CCM_ANALOG_PFD_480_CLR_PFD2_CLKGATE = 0x800000
	// Position of PFD3_FRAC field.
	CCM_ANALOG_PFD_480_CLR_PFD3_FRAC_Pos = 0x18
	// Bit mask of PFD3_FRAC field.
	CCM_ANALOG_PFD_480_CLR_PFD3_FRAC_Msk = 0x3f000000
	// Position of PFD3_STABLE field.
	CCM_ANALOG_PFD_480_CLR_PFD3_STABLE_Pos = 0x1e
	// Bit mask of PFD3_STABLE field.
	CCM_ANALOG_PFD_480_CLR_PFD3_STABLE_Msk = 0x40000000
	// Bit PFD3_STABLE.
	CCM_ANALOG_PFD_480_CLR_PFD3_STABLE = 0x40000000
	// Position of PFD3_CLKGATE field.
	CCM_ANALOG_PFD_480_CLR_PFD3_CLKGATE_Pos = 0x1f
	// Bit mask of PFD3_CLKGATE field.
	CCM_ANALOG_PFD_480_CLR_PFD3_CLKGATE_Msk = 0x80000000
	// Bit PFD3_CLKGATE.
	CCM_ANALOG_PFD_480_CLR_PFD3_CLKGATE = 0x80000000

	// PFD_480_TOG: 480MHz Clock (PLL3) Phase Fractional Divider Control Register
	// Position of PFD0_FRAC field.
	CCM_ANALOG_PFD_480_TOG_PFD0_FRAC_Pos = 0x0
	// Bit mask of PFD0_FRAC field.
	CCM_ANALOG_PFD_480_TOG_PFD0_FRAC_Msk = 0x3f
	// Position of PFD0_STABLE field.
	CCM_ANALOG_PFD_480_TOG_PFD0_STABLE_Pos = 0x6
	// Bit mask of PFD0_STABLE field.
	CCM_ANALOG_PFD_480_TOG_PFD0_STABLE_Msk = 0x40
	// Bit PFD0_STABLE.
	CCM_ANALOG_PFD_480_TOG_PFD0_STABLE = 0x40
	// Position of PFD0_CLKGATE field.
	CCM_ANALOG_PFD_480_TOG_PFD0_CLKGATE_Pos = 0x7
	// Bit mask of PFD0_CLKGATE field.
	CCM_ANALOG_PFD_480_TOG_PFD0_CLKGATE_Msk = 0x80
	// Bit PFD0_CLKGATE.
	CCM_ANALOG_PFD_480_TOG_PFD0_CLKGATE = 0x80
	// Position of PFD1_FRAC field.
	CCM_ANALOG_PFD_480_TOG_PFD1_FRAC_Pos = 0x8
	// Bit mask of PFD1_FRAC field.
	CCM_ANALOG_PFD_480_TOG_PFD1_FRAC_Msk = 0x3f00
	// Position of PFD1_STABLE field.
	CCM_ANALOG_PFD_480_TOG_PFD1_STABLE_Pos = 0xe
	// Bit mask of PFD1_STABLE field.
	CCM_ANALOG_PFD_480_TOG_PFD1_STABLE_Msk = 0x4000
	// Bit PFD1_STABLE.
	CCM_ANALOG_PFD_480_TOG_PFD1_STABLE = 0x4000
	// Position of PFD1_CLKGATE field.
	CCM_ANALOG_PFD_480_TOG_PFD1_CLKGATE_Pos = 0xf
	// Bit mask of PFD1_CLKGATE field.
	CCM_ANALOG_PFD_480_TOG_PFD1_CLKGATE_Msk = 0x8000
	// Bit PFD1_CLKGATE.
	CCM_ANALOG_PFD_480_TOG_PFD1_CLKGATE = 0x8000
	// Position of PFD2_FRAC field.
	CCM_ANALOG_PFD_480_TOG_PFD2_FRAC_Pos = 0x10
	// Bit mask of PFD2_FRAC field.
	CCM_ANALOG_PFD_480_TOG_PFD2_FRAC_Msk = 0x3f0000
	// Position of PFD2_STABLE field.
	CCM_ANALOG_PFD_480_TOG_PFD2_STABLE_Pos = 0x16
	// Bit mask of PFD2_STABLE field.
	CCM_ANALOG_PFD_480_TOG_PFD2_STABLE_Msk = 0x400000
	// Bit PFD2_STABLE.
	CCM_ANALOG_PFD_480_TOG_PFD2_STABLE = 0x400000
	// Position of PFD2_CLKGATE field.
	CCM_ANALOG_PFD_480_TOG_PFD2_CLKGATE_Pos = 0x17
	// Bit mask of PFD2_CLKGATE field.
	CCM_ANALOG_PFD_480_TOG_PFD2_CLKGATE_Msk = 0x800000
	// Bit PFD2_CLKGATE.
	CCM_ANALOG_PFD_480_TOG_PFD2_CLKGATE = 0x800000
	// Position of PFD3_FRAC field.
	CCM_ANALOG_PFD_480_TOG_PFD3_FRAC_Pos = 0x18
	// Bit mask of PFD3_FRAC field.
	CCM_ANALOG_PFD_480_TOG_PFD3_FRAC_Msk = 0x3f000000
	// Position of PFD3_STABLE field.
	CCM_ANALOG_PFD_480_TOG_PFD3_STABLE_Pos = 0x1e
	// Bit mask of PFD3_STABLE field.
	CCM_ANALOG_PFD_480_TOG_PFD3_STABLE_Msk = 0x40000000
	// Bit PFD3_STABLE.
	CCM_ANALOG_PFD_480_TOG_PFD3_STABLE = 0x40000000
	// Position of PFD3_CLKGATE field.
	CCM_ANALOG_PFD_480_TOG_PFD3_CLKGATE_Pos = 0x1f
	// Bit mask of PFD3_CLKGATE field.
	CCM_ANALOG_PFD_480_TOG_PFD3_CLKGATE_Msk = 0x80000000
	// Bit PFD3_CLKGATE.
	CCM_ANALOG_PFD_480_TOG_PFD3_CLKGATE = 0x80000000

	// PFD_528: 528MHz Clock (PLL2) Phase Fractional Divider Control Register
	// Position of PFD0_FRAC field.
	CCM_ANALOG_PFD_528_PFD0_FRAC_Pos = 0x0
	// Bit mask of PFD0_FRAC field.
	CCM_ANALOG_PFD_528_PFD0_FRAC_Msk = 0x3f
	// Position of PFD0_STABLE field.
	CCM_ANALOG_PFD_528_PFD0_STABLE_Pos = 0x6
	// Bit mask of PFD0_STABLE field.
	CCM_ANALOG_PFD_528_PFD0_STABLE_Msk = 0x40
	// Bit PFD0_STABLE.
	CCM_ANALOG_PFD_528_PFD0_STABLE = 0x40
	// Position of PFD0_CLKGATE field.
	CCM_ANALOG_PFD_528_PFD0_CLKGATE_Pos = 0x7
	// Bit mask of PFD0_CLKGATE field.
	CCM_ANALOG_PFD_528_PFD0_CLKGATE_Msk = 0x80
	// Bit PFD0_CLKGATE.
	CCM_ANALOG_PFD_528_PFD0_CLKGATE = 0x80
	// Position of PFD1_FRAC field.
	CCM_ANALOG_PFD_528_PFD1_FRAC_Pos = 0x8
	// Bit mask of PFD1_FRAC field.
	CCM_ANALOG_PFD_528_PFD1_FRAC_Msk = 0x3f00
	// Position of PFD1_STABLE field.
	CCM_ANALOG_PFD_528_PFD1_STABLE_Pos = 0xe
	// Bit mask of PFD1_STABLE field.
	CCM_ANALOG_PFD_528_PFD1_STABLE_Msk = 0x4000
	// Bit PFD1_STABLE.
	CCM_ANALOG_PFD_528_PFD1_STABLE = 0x4000
	// Position of PFD1_CLKGATE field.
	CCM_ANALOG_PFD_528_PFD1_CLKGATE_Pos = 0xf
	// Bit mask of PFD1_CLKGATE field.
	CCM_ANALOG_PFD_528_PFD1_CLKGATE_Msk = 0x8000
	// Bit PFD1_CLKGATE.
	CCM_ANALOG_PFD_528_PFD1_CLKGATE = 0x8000
	// Position of PFD2_FRAC field.
	CCM_ANALOG_PFD_528_PFD2_FRAC_Pos = 0x10
	// Bit mask of PFD2_FRAC field.
	CCM_ANALOG_PFD_528_PFD2_FRAC_Msk = 0x3f0000
	// Position of PFD2_STABLE field.
	CCM_ANALOG_PFD_528_PFD2_STABLE_Pos = 0x16
	// Bit mask of PFD2_STABLE field.
	CCM_ANALOG_PFD_528_PFD2_STABLE_Msk = 0x400000
	// Bit PFD2_STABLE.
	CCM_ANALOG_PFD_528_PFD2_STABLE = 0x400000
	// Position of PFD2_CLKGATE field.
	CCM_ANALOG_PFD_528_PFD2_CLKGATE_Pos = 0x17
	// Bit mask of PFD2_CLKGATE field.
	CCM_ANALOG_PFD_528_PFD2_CLKGATE_Msk = 0x800000
	// Bit PFD2_CLKGATE.
	CCM_ANALOG_PFD_528_PFD2_CLKGATE = 0x800000
	// Position of PFD3_FRAC field.
	CCM_ANALOG_PFD_528_PFD3_FRAC_Pos = 0x18
	// Bit mask of PFD3_FRAC field.
	CCM_ANALOG_PFD_528_PFD3_FRAC_Msk = 0x3f000000
	// Position of PFD3_STABLE field.
	CCM_ANALOG_PFD_528_PFD3_STABLE_Pos = 0x1e
	// Bit mask of PFD3_STABLE field.
	CCM_ANALOG_PFD_528_PFD3_STABLE_Msk = 0x40000000
	// Bit PFD3_STABLE.
	CCM_ANALOG_PFD_528_PFD3_STABLE = 0x40000000
	// Position of PFD3_CLKGATE field.
	CCM_ANALOG_PFD_528_PFD3_CLKGATE_Pos = 0x1f
	// Bit mask of PFD3_CLKGATE field.
	CCM_ANALOG_PFD_528_PFD3_CLKGATE_Msk = 0x80000000
	// Bit PFD3_CLKGATE.
	CCM_ANALOG_PFD_528_PFD3_CLKGATE = 0x80000000

	// PFD_528_SET: 528MHz Clock (PLL2) Phase Fractional Divider Control Register
	// Position of PFD0_FRAC field.
	CCM_ANALOG_PFD_528_SET_PFD0_FRAC_Pos = 0x0
	// Bit mask of PFD0_FRAC field.
	CCM_ANALOG_PFD_528_SET_PFD0_FRAC_Msk = 0x3f
	// Position of PFD0_STABLE field.
	CCM_ANALOG_PFD_528_SET_PFD0_STABLE_Pos = 0x6
	// Bit mask of PFD0_STABLE field.
	CCM_ANALOG_PFD_528_SET_PFD0_STABLE_Msk = 0x40
	// Bit PFD0_STABLE.
	CCM_ANALOG_PFD_528_SET_PFD0_STABLE = 0x40
	// Position of PFD0_CLKGATE field.
	CCM_ANALOG_PFD_528_SET_PFD0_CLKGATE_Pos = 0x7
	// Bit mask of PFD0_CLKGATE field.
	CCM_ANALOG_PFD_528_SET_PFD0_CLKGATE_Msk = 0x80
	// Bit PFD0_CLKGATE.
	CCM_ANALOG_PFD_528_SET_PFD0_CLKGATE = 0x80
	// Position of PFD1_FRAC field.
	CCM_ANALOG_PFD_528_SET_PFD1_FRAC_Pos = 0x8
	// Bit mask of PFD1_FRAC field.
	CCM_ANALOG_PFD_528_SET_PFD1_FRAC_Msk = 0x3f00
	// Position of PFD1_STABLE field.
	CCM_ANALOG_PFD_528_SET_PFD1_STABLE_Pos = 0xe
	// Bit mask of PFD1_STABLE field.
	CCM_ANALOG_PFD_528_SET_PFD1_STABLE_Msk = 0x4000
	// Bit PFD1_STABLE.
	CCM_ANALOG_PFD_528_SET_PFD1_STABLE = 0x4000
	// Position of PFD1_CLKGATE field.
	CCM_ANALOG_PFD_528_SET_PFD1_CLKGATE_Pos = 0xf
	// Bit mask of PFD1_CLKGATE field.
	CCM_ANALOG_PFD_528_SET_PFD1_CLKGATE_Msk = 0x8000
	// Bit PFD1_CLKGATE.
	CCM_ANALOG_PFD_528_SET_PFD1_CLKGATE = 0x8000
	// Position of PFD2_FRAC field.
	CCM_ANALOG_PFD_528_SET_PFD2_FRAC_Pos = 0x10
	// Bit mask of PFD2_FRAC field.
	CCM_ANALOG_PFD_528_SET_PFD2_FRAC_Msk = 0x3f0000
	// Position of PFD2_STABLE field.
	CCM_ANALOG_PFD_528_SET_PFD2_STABLE_Pos = 0x16
	// Bit mask of PFD2_STABLE field.
	CCM_ANALOG_PFD_528_SET_PFD2_STABLE_Msk = 0x400000
	// Bit PFD2_STABLE.
	CCM_ANALOG_PFD_528_SET_PFD2_STABLE = 0x400000
	// Position of PFD2_CLKGATE field.
	CCM_ANALOG_PFD_528_SET_PFD2_CLKGATE_Pos = 0x17
	// Bit mask of PFD2_CLKGATE field.
	CCM_ANALOG_PFD_528_SET_PFD2_CLKGATE_Msk = 0x800000
	// Bit PFD2_CLKGATE.
	CCM_ANALOG_PFD_528_SET_PFD2_CLKGATE = 0x800000
	// Position of PFD3_FRAC field.
	CCM_ANALOG_PFD_528_SET_PFD3_FRAC_Pos = 0x18
	// Bit mask of PFD3_FRAC field.
	CCM_ANALOG_PFD_528_SET_PFD3_FRAC_Msk = 0x3f000000
	// Position of PFD3_STABLE field.
	CCM_ANALOG_PFD_528_SET_PFD3_STABLE_Pos = 0x1e
	// Bit mask of PFD3_STABLE field.
	CCM_ANALOG_PFD_528_SET_PFD3_STABLE_Msk = 0x40000000
	// Bit PFD3_STABLE.
	CCM_ANALOG_PFD_528_SET_PFD3_STABLE = 0x40000000
	// Position of PFD3_CLKGATE field.
	CCM_ANALOG_PFD_528_SET_PFD3_CLKGATE_Pos = 0x1f
	// Bit mask of PFD3_CLKGATE field.
	CCM_ANALOG_PFD_528_SET_PFD3_CLKGATE_Msk = 0x80000000
	// Bit PFD3_CLKGATE.
	CCM_ANALOG_PFD_528_SET_PFD3_CLKGATE = 0x80000000

	// PFD_528_CLR: 528MHz Clock (PLL2) Phase Fractional Divider Control Register
	// Position of PFD0_FRAC field.
	CCM_ANALOG_PFD_528_CLR_PFD0_FRAC_Pos = 0x0
	// Bit mask of PFD0_FRAC field.
	CCM_ANALOG_PFD_528_CLR_PFD0_FRAC_Msk = 0x3f
	// Position of PFD0_STABLE field.
	CCM_ANALOG_PFD_528_CLR_PFD0_STABLE_Pos = 0x6
	// Bit mask of PFD0_STABLE field.
	CCM_ANALOG_PFD_528_CLR_PFD0_STABLE_Msk = 0x40
	// Bit PFD0_STABLE.
	CCM_ANALOG_PFD_528_CLR_PFD0_STABLE = 0x40
	// Position of PFD0_CLKGATE field.
	CCM_ANALOG_PFD_528_CLR_PFD0_CLKGATE_Pos = 0x7
	// Bit mask of PFD0_CLKGATE field.
	CCM_ANALOG_PFD_528_CLR_PFD0_CLKGATE_Msk = 0x80
	// Bit PFD0_CLKGATE.
	CCM_ANALOG_PFD_528_CLR_PFD0_CLKGATE = 0x80
	// Position of PFD1_FRAC field.
	CCM_ANALOG_PFD_528_CLR_PFD1_FRAC_Pos = 0x8
	// Bit mask of PFD1_FRAC field.
	CCM_ANALOG_PFD_528_CLR_PFD1_FRAC_Msk = 0x3f00
	// Position of PFD1_STABLE field.
	CCM_ANALOG_PFD_528_CLR_PFD1_STABLE_Pos = 0xe
	// Bit mask of PFD1_STABLE field.
	CCM_ANALOG_PFD_528_CLR_PFD1_STABLE_Msk = 0x4000
	// Bit PFD1_STABLE.
	CCM_ANALOG_PFD_528_CLR_PFD1_STABLE = 0x4000
	// Position of PFD1_CLKGATE field.
	CCM_ANALOG_PFD_528_CLR_PFD1_CLKGATE_Pos = 0xf
	// Bit mask of PFD1_CLKGATE field.
	CCM_ANALOG_PFD_528_CLR_PFD1_CLKGATE_Msk = 0x8000
	// Bit PFD1_CLKGATE.
	CCM_ANALOG_PFD_528_CLR_PFD1_CLKGATE = 0x8000
	// Position of PFD2_FRAC field.
	CCM_ANALOG_PFD_528_CLR_PFD2_FRAC_Pos = 0x10
	// Bit mask of PFD2_FRAC field.
	CCM_ANALOG_PFD_528_CLR_PFD2_FRAC_Msk = 0x3f0000
	// Position of PFD2_STABLE field.
	CCM_ANALOG_PFD_528_CLR_PFD2_STABLE_Pos = 0x16
	// Bit mask of PFD2_STABLE field.
	CCM_ANALOG_PFD_528_CLR_PFD2_STABLE_Msk = 0x400000
	// Bit PFD2_STABLE.
	CCM_ANALOG_PFD_528_CLR_PFD2_STABLE = 0x400000
	// Position of PFD2_CLKGATE field.
	CCM_ANALOG_PFD_528_CLR_PFD2_CLKGATE_Pos = 0x17
	// Bit mask of PFD2_CLKGATE field.
	CCM_ANALOG_PFD_528_CLR_PFD2_CLKGATE_Msk = 0x800000
	// Bit PFD2_CLKGATE.
	CCM_ANALOG_PFD_528_CLR_PFD2_CLKGATE = 0x800000
	// Position of PFD3_FRAC field.
	CCM_ANALOG_PFD_528_CLR_PFD3_FRAC_Pos = 0x18
	// Bit mask of PFD3_FRAC field.
	CCM_ANALOG_PFD_528_CLR_PFD3_FRAC_Msk = 0x3f000000
	// Position of PFD3_STABLE field.
	CCM_ANALOG_PFD_528_CLR_PFD3_STABLE_Pos = 0x1e
	// Bit mask of PFD3_STABLE field.
	CCM_ANALOG_PFD_528_CLR_PFD3_STABLE_Msk = 0x40000000
	// Bit PFD3_STABLE.
	CCM_ANALOG_PFD_528_CLR_PFD3_STABLE = 0x40000000
	// Position of PFD3_CLKGATE field.
	CCM_ANALOG_PFD_528_CLR_PFD3_CLKGATE_Pos = 0x1f
	// Bit mask of PFD3_CLKGATE field.
	CCM_ANALOG_PFD_528_CLR_PFD3_CLKGATE_Msk = 0x80000000
	// Bit PFD3_CLKGATE.
	CCM_ANALOG_PFD_528_CLR_PFD3_CLKGATE = 0x80000000

	// PFD_528_TOG: 528MHz Clock (PLL2) Phase Fractional Divider Control Register
	// Position of PFD0_FRAC field.
	CCM_ANALOG_PFD_528_TOG_PFD0_FRAC_Pos = 0x0
	// Bit mask of PFD0_FRAC field.
	CCM_ANALOG_PFD_528_TOG_PFD0_FRAC_Msk = 0x3f
	// Position of PFD0_STABLE field.
	CCM_ANALOG_PFD_528_TOG_PFD0_STABLE_Pos = 0x6
	// Bit mask of PFD0_STABLE field.
	CCM_ANALOG_PFD_528_TOG_PFD0_STABLE_Msk = 0x40
	// Bit PFD0_STABLE.
	CCM_ANALOG_PFD_528_TOG_PFD0_STABLE = 0x40
	// Position of PFD0_CLKGATE field.
	CCM_ANALOG_PFD_528_TOG_PFD0_CLKGATE_Pos = 0x7
	// Bit mask of PFD0_CLKGATE field.
	CCM_ANALOG_PFD_528_TOG_PFD0_CLKGATE_Msk = 0x80
	// Bit PFD0_CLKGATE.
	CCM_ANALOG_PFD_528_TOG_PFD0_CLKGATE = 0x80
	// Position of PFD1_FRAC field.
	CCM_ANALOG_PFD_528_TOG_PFD1_FRAC_Pos = 0x8
	// Bit mask of PFD1_FRAC field.
	CCM_ANALOG_PFD_528_TOG_PFD1_FRAC_Msk = 0x3f00
	// Position of PFD1_STABLE field.
	CCM_ANALOG_PFD_528_TOG_PFD1_STABLE_Pos = 0xe
	// Bit mask of PFD1_STABLE field.
	CCM_ANALOG_PFD_528_TOG_PFD1_STABLE_Msk = 0x4000
	// Bit PFD1_STABLE.
	CCM_ANALOG_PFD_528_TOG_PFD1_STABLE = 0x4000
	// Position of PFD1_CLKGATE field.
	CCM_ANALOG_PFD_528_TOG_PFD1_CLKGATE_Pos = 0xf
	// Bit mask of PFD1_CLKGATE field.
	CCM_ANALOG_PFD_528_TOG_PFD1_CLKGATE_Msk = 0x8000
	// Bit PFD1_CLKGATE.
	CCM_ANALOG_PFD_528_TOG_PFD1_CLKGATE = 0x8000
	// Position of PFD2_FRAC field.
	CCM_ANALOG_PFD_528_TOG_PFD2_FRAC_Pos = 0x10
	// Bit mask of PFD2_FRAC field.
	CCM_ANALOG_PFD_528_TOG_PFD2_FRAC_Msk = 0x3f0000
	// Position of PFD2_STABLE field.
	CCM_ANALOG_PFD_528_TOG_PFD2_STABLE_Pos = 0x16
	// Bit mask of PFD2_STABLE field.
	CCM_ANALOG_PFD_528_TOG_PFD2_STABLE_Msk = 0x400000
	// Bit PFD2_STABLE.
	CCM_ANALOG_PFD_528_TOG_PFD2_STABLE = 0x400000
	// Position of PFD2_CLKGATE field.
	CCM_ANALOG_PFD_528_TOG_PFD2_CLKGATE_Pos = 0x17
	// Bit mask of PFD2_CLKGATE field.
	CCM_ANALOG_PFD_528_TOG_PFD2_CLKGATE_Msk = 0x800000
	// Bit PFD2_CLKGATE.
	CCM_ANALOG_PFD_528_TOG_PFD2_CLKGATE = 0x800000
	// Position of PFD3_FRAC field.
	CCM_ANALOG_PFD_528_TOG_PFD3_FRAC_Pos = 0x18
	// Bit mask of PFD3_FRAC field.
	CCM_ANALOG_PFD_528_TOG_PFD3_FRAC_Msk = 0x3f000000
	// Position of PFD3_STABLE field.
	CCM_ANALOG_PFD_528_TOG_PFD3_STABLE_Pos = 0x1e
	// Bit mask of PFD3_STABLE field.
	CCM_ANALOG_PFD_528_TOG_PFD3_STABLE_Msk = 0x40000000
	// Bit PFD3_STABLE.
	CCM_ANALOG_PFD_528_TOG_PFD3_STABLE = 0x40000000
	// Position of PFD3_CLKGATE field.
	CCM_ANALOG_PFD_528_TOG_PFD3_CLKGATE_Pos = 0x1f
	// Bit mask of PFD3_CLKGATE field.
	CCM_ANALOG_PFD_528_TOG_PFD3_CLKGATE_Msk = 0x80000000
	// Bit PFD3_CLKGATE.
	CCM_ANALOG_PFD_528_TOG_PFD3_CLKGATE = 0x80000000

	// MISC0: Miscellaneous Register 0
	// Position of REFTOP_PWD field.
	CCM_ANALOG_MISC0_REFTOP_PWD_Pos = 0x0
	// Bit mask of REFTOP_PWD field.
	CCM_ANALOG_MISC0_REFTOP_PWD_Msk = 0x1
	// Bit REFTOP_PWD.
	CCM_ANALOG_MISC0_REFTOP_PWD = 0x1
	// Position of REFTOP_SELFBIASOFF field.
	CCM_ANALOG_MISC0_REFTOP_SELFBIASOFF_Pos = 0x3
	// Bit mask of REFTOP_SELFBIASOFF field.
	CCM_ANALOG_MISC0_REFTOP_SELFBIASOFF_Msk = 0x8
	// Bit REFTOP_SELFBIASOFF.
	CCM_ANALOG_MISC0_REFTOP_SELFBIASOFF = 0x8
	// Uses coarse bias currents for startup
	CCM_ANALOG_MISC0_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_0 = 0x0
	// Uses bandgap-based bias currents for best performance.
	CCM_ANALOG_MISC0_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_1 = 0x1
	// Position of REFTOP_VBGADJ field.
	CCM_ANALOG_MISC0_REFTOP_VBGADJ_Pos = 0x4
	// Bit mask of REFTOP_VBGADJ field.
	CCM_ANALOG_MISC0_REFTOP_VBGADJ_Msk = 0x70
	// Nominal VBG
	CCM_ANALOG_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_0 = 0x0
	// VBG+0.78%
	CCM_ANALOG_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_1 = 0x1
	// VBG+1.56%
	CCM_ANALOG_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_2 = 0x2
	// VBG+2.34%
	CCM_ANALOG_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_3 = 0x3
	// VBG-0.78%
	CCM_ANALOG_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_4 = 0x4
	// VBG-1.56%
	CCM_ANALOG_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_5 = 0x5
	// VBG-2.34%
	CCM_ANALOG_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_6 = 0x6
	// VBG-3.12%
	CCM_ANALOG_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_7 = 0x7
	// Position of REFTOP_VBGUP field.
	CCM_ANALOG_MISC0_REFTOP_VBGUP_Pos = 0x7
	// Bit mask of REFTOP_VBGUP field.
	CCM_ANALOG_MISC0_REFTOP_VBGUP_Msk = 0x80
	// Bit REFTOP_VBGUP.
	CCM_ANALOG_MISC0_REFTOP_VBGUP = 0x80
	// Position of STOP_MODE_CONFIG field.
	CCM_ANALOG_MISC0_STOP_MODE_CONFIG_Pos = 0xa
	// Bit mask of STOP_MODE_CONFIG field.
	CCM_ANALOG_MISC0_STOP_MODE_CONFIG_Msk = 0xc00
	// All analog except RTC powered down on stop mode assertion.
	CCM_ANALOG_MISC0_STOP_MODE_CONFIG_STOP_MODE_CONFIG_0 = 0x0
	// Beside RTC, analog bandgap, 1p1 and 2p5 regulators are also on.
	CCM_ANALOG_MISC0_STOP_MODE_CONFIG_STOP_MODE_CONFIG_1 = 0x1
	// Beside RTC, 1p1 and 2p5 regulators are also on, low-power bandgap is selected so that the normal analog bandgap together with the rest analog is powered down.
	CCM_ANALOG_MISC0_STOP_MODE_CONFIG_STOP_MODE_CONFIG_2 = 0x2
	// Beside RTC, low-power bandgap is selected and the rest analog is powered down.
	CCM_ANALOG_MISC0_STOP_MODE_CONFIG_STOP_MODE_CONFIG_3 = 0x3
	// Position of DISCON_HIGH_SNVS field.
	CCM_ANALOG_MISC0_DISCON_HIGH_SNVS_Pos = 0xc
	// Bit mask of DISCON_HIGH_SNVS field.
	CCM_ANALOG_MISC0_DISCON_HIGH_SNVS_Msk = 0x1000
	// Bit DISCON_HIGH_SNVS.
	CCM_ANALOG_MISC0_DISCON_HIGH_SNVS = 0x1000
	// Turn on the switch
	CCM_ANALOG_MISC0_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_0 = 0x0
	// Turn off the switch
	CCM_ANALOG_MISC0_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_1 = 0x1
	// Position of OSC_I field.
	CCM_ANALOG_MISC0_OSC_I_Pos = 0xd
	// Bit mask of OSC_I field.
	CCM_ANALOG_MISC0_OSC_I_Msk = 0x6000
	// Nominal
	CCM_ANALOG_MISC0_OSC_I_NOMINAL = 0x0
	// Decrease current by 12.5%
	CCM_ANALOG_MISC0_OSC_I_MINUS_12_5_PERCENT = 0x1
	// Decrease current by 25.0%
	CCM_ANALOG_MISC0_OSC_I_MINUS_25_PERCENT = 0x2
	// Decrease current by 37.5%
	CCM_ANALOG_MISC0_OSC_I_MINUS_37_5_PERCENT = 0x3
	// Position of OSC_XTALOK field.
	CCM_ANALOG_MISC0_OSC_XTALOK_Pos = 0xf
	// Bit mask of OSC_XTALOK field.
	CCM_ANALOG_MISC0_OSC_XTALOK_Msk = 0x8000
	// Bit OSC_XTALOK.
	CCM_ANALOG_MISC0_OSC_XTALOK = 0x8000
	// Position of OSC_XTALOK_EN field.
	CCM_ANALOG_MISC0_OSC_XTALOK_EN_Pos = 0x10
	// Bit mask of OSC_XTALOK_EN field.
	CCM_ANALOG_MISC0_OSC_XTALOK_EN_Msk = 0x10000
	// Bit OSC_XTALOK_EN.
	CCM_ANALOG_MISC0_OSC_XTALOK_EN = 0x10000
	// Position of CLKGATE_CTRL field.
	CCM_ANALOG_MISC0_CLKGATE_CTRL_Pos = 0x19
	// Bit mask of CLKGATE_CTRL field.
	CCM_ANALOG_MISC0_CLKGATE_CTRL_Msk = 0x2000000
	// Bit CLKGATE_CTRL.
	CCM_ANALOG_MISC0_CLKGATE_CTRL = 0x2000000
	// Allow the logic to automatically gate the clock when the XTAL is powered down.
	CCM_ANALOG_MISC0_CLKGATE_CTRL_ALLOW_AUTO_GATE = 0x0
	// Prevent the logic from ever gating off the clock.
	CCM_ANALOG_MISC0_CLKGATE_CTRL_NO_AUTO_GATE = 0x1
	// Position of CLKGATE_DELAY field.
	CCM_ANALOG_MISC0_CLKGATE_DELAY_Pos = 0x1a
	// Bit mask of CLKGATE_DELAY field.
	CCM_ANALOG_MISC0_CLKGATE_DELAY_Msk = 0x1c000000
	// 0.5ms
	CCM_ANALOG_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_0 = 0x0
	// 1.0ms
	CCM_ANALOG_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_1 = 0x1
	// 2.0ms
	CCM_ANALOG_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_2 = 0x2
	// 3.0ms
	CCM_ANALOG_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_3 = 0x3
	// 4.0ms
	CCM_ANALOG_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_4 = 0x4
	// 5.0ms
	CCM_ANALOG_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_5 = 0x5
	// 6.0ms
	CCM_ANALOG_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_6 = 0x6
	// 7.0ms
	CCM_ANALOG_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_7 = 0x7
	// Position of RTC_XTAL_SOURCE field.
	CCM_ANALOG_MISC0_RTC_XTAL_SOURCE_Pos = 0x1d
	// Bit mask of RTC_XTAL_SOURCE field.
	CCM_ANALOG_MISC0_RTC_XTAL_SOURCE_Msk = 0x20000000
	// Bit RTC_XTAL_SOURCE.
	CCM_ANALOG_MISC0_RTC_XTAL_SOURCE = 0x20000000
	// Internal ring oscillator
	CCM_ANALOG_MISC0_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_0 = 0x0
	// RTC_XTAL
	CCM_ANALOG_MISC0_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_1 = 0x1
	// Position of XTAL_24M_PWD field.
	CCM_ANALOG_MISC0_XTAL_24M_PWD_Pos = 0x1e
	// Bit mask of XTAL_24M_PWD field.
	CCM_ANALOG_MISC0_XTAL_24M_PWD_Msk = 0x40000000
	// Bit XTAL_24M_PWD.
	CCM_ANALOG_MISC0_XTAL_24M_PWD = 0x40000000

	// MISC0_SET: Miscellaneous Register 0
	// Position of REFTOP_PWD field.
	CCM_ANALOG_MISC0_SET_REFTOP_PWD_Pos = 0x0
	// Bit mask of REFTOP_PWD field.
	CCM_ANALOG_MISC0_SET_REFTOP_PWD_Msk = 0x1
	// Bit REFTOP_PWD.
	CCM_ANALOG_MISC0_SET_REFTOP_PWD = 0x1
	// Position of REFTOP_SELFBIASOFF field.
	CCM_ANALOG_MISC0_SET_REFTOP_SELFBIASOFF_Pos = 0x3
	// Bit mask of REFTOP_SELFBIASOFF field.
	CCM_ANALOG_MISC0_SET_REFTOP_SELFBIASOFF_Msk = 0x8
	// Bit REFTOP_SELFBIASOFF.
	CCM_ANALOG_MISC0_SET_REFTOP_SELFBIASOFF = 0x8
	// Uses coarse bias currents for startup
	CCM_ANALOG_MISC0_SET_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_0 = 0x0
	// Uses bandgap-based bias currents for best performance.
	CCM_ANALOG_MISC0_SET_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_1 = 0x1
	// Position of REFTOP_VBGADJ field.
	CCM_ANALOG_MISC0_SET_REFTOP_VBGADJ_Pos = 0x4
	// Bit mask of REFTOP_VBGADJ field.
	CCM_ANALOG_MISC0_SET_REFTOP_VBGADJ_Msk = 0x70
	// Nominal VBG
	CCM_ANALOG_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_0 = 0x0
	// VBG+0.78%
	CCM_ANALOG_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_1 = 0x1
	// VBG+1.56%
	CCM_ANALOG_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_2 = 0x2
	// VBG+2.34%
	CCM_ANALOG_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_3 = 0x3
	// VBG-0.78%
	CCM_ANALOG_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_4 = 0x4
	// VBG-1.56%
	CCM_ANALOG_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_5 = 0x5
	// VBG-2.34%
	CCM_ANALOG_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_6 = 0x6
	// VBG-3.12%
	CCM_ANALOG_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_7 = 0x7
	// Position of REFTOP_VBGUP field.
	CCM_ANALOG_MISC0_SET_REFTOP_VBGUP_Pos = 0x7
	// Bit mask of REFTOP_VBGUP field.
	CCM_ANALOG_MISC0_SET_REFTOP_VBGUP_Msk = 0x80
	// Bit REFTOP_VBGUP.
	CCM_ANALOG_MISC0_SET_REFTOP_VBGUP = 0x80
	// Position of STOP_MODE_CONFIG field.
	CCM_ANALOG_MISC0_SET_STOP_MODE_CONFIG_Pos = 0xa
	// Bit mask of STOP_MODE_CONFIG field.
	CCM_ANALOG_MISC0_SET_STOP_MODE_CONFIG_Msk = 0xc00
	// All analog except RTC powered down on stop mode assertion.
	CCM_ANALOG_MISC0_SET_STOP_MODE_CONFIG_STOP_MODE_CONFIG_0 = 0x0
	// Beside RTC, analog bandgap, 1p1 and 2p5 regulators are also on.
	CCM_ANALOG_MISC0_SET_STOP_MODE_CONFIG_STOP_MODE_CONFIG_1 = 0x1
	// Beside RTC, 1p1 and 2p5 regulators are also on, low-power bandgap is selected so that the normal analog bandgap together with the rest analog is powered down.
	CCM_ANALOG_MISC0_SET_STOP_MODE_CONFIG_STOP_MODE_CONFIG_2 = 0x2
	// Beside RTC, low-power bandgap is selected and the rest analog is powered down.
	CCM_ANALOG_MISC0_SET_STOP_MODE_CONFIG_STOP_MODE_CONFIG_3 = 0x3
	// Position of DISCON_HIGH_SNVS field.
	CCM_ANALOG_MISC0_SET_DISCON_HIGH_SNVS_Pos = 0xc
	// Bit mask of DISCON_HIGH_SNVS field.
	CCM_ANALOG_MISC0_SET_DISCON_HIGH_SNVS_Msk = 0x1000
	// Bit DISCON_HIGH_SNVS.
	CCM_ANALOG_MISC0_SET_DISCON_HIGH_SNVS = 0x1000
	// Turn on the switch
	CCM_ANALOG_MISC0_SET_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_0 = 0x0
	// Turn off the switch
	CCM_ANALOG_MISC0_SET_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_1 = 0x1
	// Position of OSC_I field.
	CCM_ANALOG_MISC0_SET_OSC_I_Pos = 0xd
	// Bit mask of OSC_I field.
	CCM_ANALOG_MISC0_SET_OSC_I_Msk = 0x6000
	// Nominal
	CCM_ANALOG_MISC0_SET_OSC_I_NOMINAL = 0x0
	// Decrease current by 12.5%
	CCM_ANALOG_MISC0_SET_OSC_I_MINUS_12_5_PERCENT = 0x1
	// Decrease current by 25.0%
	CCM_ANALOG_MISC0_SET_OSC_I_MINUS_25_PERCENT = 0x2
	// Decrease current by 37.5%
	CCM_ANALOG_MISC0_SET_OSC_I_MINUS_37_5_PERCENT = 0x3
	// Position of OSC_XTALOK field.
	CCM_ANALOG_MISC0_SET_OSC_XTALOK_Pos = 0xf
	// Bit mask of OSC_XTALOK field.
	CCM_ANALOG_MISC0_SET_OSC_XTALOK_Msk = 0x8000
	// Bit OSC_XTALOK.
	CCM_ANALOG_MISC0_SET_OSC_XTALOK = 0x8000
	// Position of OSC_XTALOK_EN field.
	CCM_ANALOG_MISC0_SET_OSC_XTALOK_EN_Pos = 0x10
	// Bit mask of OSC_XTALOK_EN field.
	CCM_ANALOG_MISC0_SET_OSC_XTALOK_EN_Msk = 0x10000
	// Bit OSC_XTALOK_EN.
	CCM_ANALOG_MISC0_SET_OSC_XTALOK_EN = 0x10000
	// Position of CLKGATE_CTRL field.
	CCM_ANALOG_MISC0_SET_CLKGATE_CTRL_Pos = 0x19
	// Bit mask of CLKGATE_CTRL field.
	CCM_ANALOG_MISC0_SET_CLKGATE_CTRL_Msk = 0x2000000
	// Bit CLKGATE_CTRL.
	CCM_ANALOG_MISC0_SET_CLKGATE_CTRL = 0x2000000
	// Allow the logic to automatically gate the clock when the XTAL is powered down.
	CCM_ANALOG_MISC0_SET_CLKGATE_CTRL_ALLOW_AUTO_GATE = 0x0
	// Prevent the logic from ever gating off the clock.
	CCM_ANALOG_MISC0_SET_CLKGATE_CTRL_NO_AUTO_GATE = 0x1
	// Position of CLKGATE_DELAY field.
	CCM_ANALOG_MISC0_SET_CLKGATE_DELAY_Pos = 0x1a
	// Bit mask of CLKGATE_DELAY field.
	CCM_ANALOG_MISC0_SET_CLKGATE_DELAY_Msk = 0x1c000000
	// 0.5ms
	CCM_ANALOG_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_0 = 0x0
	// 1.0ms
	CCM_ANALOG_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_1 = 0x1
	// 2.0ms
	CCM_ANALOG_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_2 = 0x2
	// 3.0ms
	CCM_ANALOG_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_3 = 0x3
	// 4.0ms
	CCM_ANALOG_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_4 = 0x4
	// 5.0ms
	CCM_ANALOG_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_5 = 0x5
	// 6.0ms
	CCM_ANALOG_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_6 = 0x6
	// 7.0ms
	CCM_ANALOG_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_7 = 0x7
	// Position of RTC_XTAL_SOURCE field.
	CCM_ANALOG_MISC0_SET_RTC_XTAL_SOURCE_Pos = 0x1d
	// Bit mask of RTC_XTAL_SOURCE field.
	CCM_ANALOG_MISC0_SET_RTC_XTAL_SOURCE_Msk = 0x20000000
	// Bit RTC_XTAL_SOURCE.
	CCM_ANALOG_MISC0_SET_RTC_XTAL_SOURCE = 0x20000000
	// Internal ring oscillator
	CCM_ANALOG_MISC0_SET_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_0 = 0x0
	// RTC_XTAL
	CCM_ANALOG_MISC0_SET_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_1 = 0x1
	// Position of XTAL_24M_PWD field.
	CCM_ANALOG_MISC0_SET_XTAL_24M_PWD_Pos = 0x1e
	// Bit mask of XTAL_24M_PWD field.
	CCM_ANALOG_MISC0_SET_XTAL_24M_PWD_Msk = 0x40000000
	// Bit XTAL_24M_PWD.
	CCM_ANALOG_MISC0_SET_XTAL_24M_PWD = 0x40000000

	// MISC0_CLR: Miscellaneous Register 0
	// Position of REFTOP_PWD field.
	CCM_ANALOG_MISC0_CLR_REFTOP_PWD_Pos = 0x0
	// Bit mask of REFTOP_PWD field.
	CCM_ANALOG_MISC0_CLR_REFTOP_PWD_Msk = 0x1
	// Bit REFTOP_PWD.
	CCM_ANALOG_MISC0_CLR_REFTOP_PWD = 0x1
	// Position of REFTOP_SELFBIASOFF field.
	CCM_ANALOG_MISC0_CLR_REFTOP_SELFBIASOFF_Pos = 0x3
	// Bit mask of REFTOP_SELFBIASOFF field.
	CCM_ANALOG_MISC0_CLR_REFTOP_SELFBIASOFF_Msk = 0x8
	// Bit REFTOP_SELFBIASOFF.
	CCM_ANALOG_MISC0_CLR_REFTOP_SELFBIASOFF = 0x8
	// Uses coarse bias currents for startup
	CCM_ANALOG_MISC0_CLR_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_0 = 0x0
	// Uses bandgap-based bias currents for best performance.
	CCM_ANALOG_MISC0_CLR_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_1 = 0x1
	// Position of REFTOP_VBGADJ field.
	CCM_ANALOG_MISC0_CLR_REFTOP_VBGADJ_Pos = 0x4
	// Bit mask of REFTOP_VBGADJ field.
	CCM_ANALOG_MISC0_CLR_REFTOP_VBGADJ_Msk = 0x70
	// Nominal VBG
	CCM_ANALOG_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_0 = 0x0
	// VBG+0.78%
	CCM_ANALOG_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_1 = 0x1
	// VBG+1.56%
	CCM_ANALOG_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_2 = 0x2
	// VBG+2.34%
	CCM_ANALOG_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_3 = 0x3
	// VBG-0.78%
	CCM_ANALOG_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_4 = 0x4
	// VBG-1.56%
	CCM_ANALOG_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_5 = 0x5
	// VBG-2.34%
	CCM_ANALOG_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_6 = 0x6
	// VBG-3.12%
	CCM_ANALOG_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_7 = 0x7
	// Position of REFTOP_VBGUP field.
	CCM_ANALOG_MISC0_CLR_REFTOP_VBGUP_Pos = 0x7
	// Bit mask of REFTOP_VBGUP field.
	CCM_ANALOG_MISC0_CLR_REFTOP_VBGUP_Msk = 0x80
	// Bit REFTOP_VBGUP.
	CCM_ANALOG_MISC0_CLR_REFTOP_VBGUP = 0x80
	// Position of STOP_MODE_CONFIG field.
	CCM_ANALOG_MISC0_CLR_STOP_MODE_CONFIG_Pos = 0xa
	// Bit mask of STOP_MODE_CONFIG field.
	CCM_ANALOG_MISC0_CLR_STOP_MODE_CONFIG_Msk = 0xc00
	// All analog except RTC powered down on stop mode assertion.
	CCM_ANALOG_MISC0_CLR_STOP_MODE_CONFIG_STOP_MODE_CONFIG_0 = 0x0
	// Beside RTC, analog bandgap, 1p1 and 2p5 regulators are also on.
	CCM_ANALOG_MISC0_CLR_STOP_MODE_CONFIG_STOP_MODE_CONFIG_1 = 0x1
	// Beside RTC, 1p1 and 2p5 regulators are also on, low-power bandgap is selected so that the normal analog bandgap together with the rest analog is powered down.
	CCM_ANALOG_MISC0_CLR_STOP_MODE_CONFIG_STOP_MODE_CONFIG_2 = 0x2
	// Beside RTC, low-power bandgap is selected and the rest analog is powered down.
	CCM_ANALOG_MISC0_CLR_STOP_MODE_CONFIG_STOP_MODE_CONFIG_3 = 0x3
	// Position of DISCON_HIGH_SNVS field.
	CCM_ANALOG_MISC0_CLR_DISCON_HIGH_SNVS_Pos = 0xc
	// Bit mask of DISCON_HIGH_SNVS field.
	CCM_ANALOG_MISC0_CLR_DISCON_HIGH_SNVS_Msk = 0x1000
	// Bit DISCON_HIGH_SNVS.
	CCM_ANALOG_MISC0_CLR_DISCON_HIGH_SNVS = 0x1000
	// Turn on the switch
	CCM_ANALOG_MISC0_CLR_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_0 = 0x0
	// Turn off the switch
	CCM_ANALOG_MISC0_CLR_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_1 = 0x1
	// Position of OSC_I field.
	CCM_ANALOG_MISC0_CLR_OSC_I_Pos = 0xd
	// Bit mask of OSC_I field.
	CCM_ANALOG_MISC0_CLR_OSC_I_Msk = 0x6000
	// Nominal
	CCM_ANALOG_MISC0_CLR_OSC_I_NOMINAL = 0x0
	// Decrease current by 12.5%
	CCM_ANALOG_MISC0_CLR_OSC_I_MINUS_12_5_PERCENT = 0x1
	// Decrease current by 25.0%
	CCM_ANALOG_MISC0_CLR_OSC_I_MINUS_25_PERCENT = 0x2
	// Decrease current by 37.5%
	CCM_ANALOG_MISC0_CLR_OSC_I_MINUS_37_5_PERCENT = 0x3
	// Position of OSC_XTALOK field.
	CCM_ANALOG_MISC0_CLR_OSC_XTALOK_Pos = 0xf
	// Bit mask of OSC_XTALOK field.
	CCM_ANALOG_MISC0_CLR_OSC_XTALOK_Msk = 0x8000
	// Bit OSC_XTALOK.
	CCM_ANALOG_MISC0_CLR_OSC_XTALOK = 0x8000
	// Position of OSC_XTALOK_EN field.
	CCM_ANALOG_MISC0_CLR_OSC_XTALOK_EN_Pos = 0x10
	// Bit mask of OSC_XTALOK_EN field.
	CCM_ANALOG_MISC0_CLR_OSC_XTALOK_EN_Msk = 0x10000
	// Bit OSC_XTALOK_EN.
	CCM_ANALOG_MISC0_CLR_OSC_XTALOK_EN = 0x10000
	// Position of CLKGATE_CTRL field.
	CCM_ANALOG_MISC0_CLR_CLKGATE_CTRL_Pos = 0x19
	// Bit mask of CLKGATE_CTRL field.
	CCM_ANALOG_MISC0_CLR_CLKGATE_CTRL_Msk = 0x2000000
	// Bit CLKGATE_CTRL.
	CCM_ANALOG_MISC0_CLR_CLKGATE_CTRL = 0x2000000
	// Allow the logic to automatically gate the clock when the XTAL is powered down.
	CCM_ANALOG_MISC0_CLR_CLKGATE_CTRL_ALLOW_AUTO_GATE = 0x0
	// Prevent the logic from ever gating off the clock.
	CCM_ANALOG_MISC0_CLR_CLKGATE_CTRL_NO_AUTO_GATE = 0x1
	// Position of CLKGATE_DELAY field.
	CCM_ANALOG_MISC0_CLR_CLKGATE_DELAY_Pos = 0x1a
	// Bit mask of CLKGATE_DELAY field.
	CCM_ANALOG_MISC0_CLR_CLKGATE_DELAY_Msk = 0x1c000000
	// 0.5ms
	CCM_ANALOG_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_0 = 0x0
	// 1.0ms
	CCM_ANALOG_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_1 = 0x1
	// 2.0ms
	CCM_ANALOG_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_2 = 0x2
	// 3.0ms
	CCM_ANALOG_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_3 = 0x3
	// 4.0ms
	CCM_ANALOG_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_4 = 0x4
	// 5.0ms
	CCM_ANALOG_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_5 = 0x5
	// 6.0ms
	CCM_ANALOG_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_6 = 0x6
	// 7.0ms
	CCM_ANALOG_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_7 = 0x7
	// Position of RTC_XTAL_SOURCE field.
	CCM_ANALOG_MISC0_CLR_RTC_XTAL_SOURCE_Pos = 0x1d
	// Bit mask of RTC_XTAL_SOURCE field.
	CCM_ANALOG_MISC0_CLR_RTC_XTAL_SOURCE_Msk = 0x20000000
	// Bit RTC_XTAL_SOURCE.
	CCM_ANALOG_MISC0_CLR_RTC_XTAL_SOURCE = 0x20000000
	// Internal ring oscillator
	CCM_ANALOG_MISC0_CLR_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_0 = 0x0
	// RTC_XTAL
	CCM_ANALOG_MISC0_CLR_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_1 = 0x1
	// Position of XTAL_24M_PWD field.
	CCM_ANALOG_MISC0_CLR_XTAL_24M_PWD_Pos = 0x1e
	// Bit mask of XTAL_24M_PWD field.
	CCM_ANALOG_MISC0_CLR_XTAL_24M_PWD_Msk = 0x40000000
	// Bit XTAL_24M_PWD.
	CCM_ANALOG_MISC0_CLR_XTAL_24M_PWD = 0x40000000

	// MISC0_TOG: Miscellaneous Register 0
	// Position of REFTOP_PWD field.
	CCM_ANALOG_MISC0_TOG_REFTOP_PWD_Pos = 0x0
	// Bit mask of REFTOP_PWD field.
	CCM_ANALOG_MISC0_TOG_REFTOP_PWD_Msk = 0x1
	// Bit REFTOP_PWD.
	CCM_ANALOG_MISC0_TOG_REFTOP_PWD = 0x1
	// Position of REFTOP_SELFBIASOFF field.
	CCM_ANALOG_MISC0_TOG_REFTOP_SELFBIASOFF_Pos = 0x3
	// Bit mask of REFTOP_SELFBIASOFF field.
	CCM_ANALOG_MISC0_TOG_REFTOP_SELFBIASOFF_Msk = 0x8
	// Bit REFTOP_SELFBIASOFF.
	CCM_ANALOG_MISC0_TOG_REFTOP_SELFBIASOFF = 0x8
	// Uses coarse bias currents for startup
	CCM_ANALOG_MISC0_TOG_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_0 = 0x0
	// Uses bandgap-based bias currents for best performance.
	CCM_ANALOG_MISC0_TOG_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_1 = 0x1
	// Position of REFTOP_VBGADJ field.
	CCM_ANALOG_MISC0_TOG_REFTOP_VBGADJ_Pos = 0x4
	// Bit mask of REFTOP_VBGADJ field.
	CCM_ANALOG_MISC0_TOG_REFTOP_VBGADJ_Msk = 0x70
	// Nominal VBG
	CCM_ANALOG_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_0 = 0x0
	// VBG+0.78%
	CCM_ANALOG_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_1 = 0x1
	// VBG+1.56%
	CCM_ANALOG_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_2 = 0x2
	// VBG+2.34%
	CCM_ANALOG_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_3 = 0x3
	// VBG-0.78%
	CCM_ANALOG_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_4 = 0x4
	// VBG-1.56%
	CCM_ANALOG_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_5 = 0x5
	// VBG-2.34%
	CCM_ANALOG_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_6 = 0x6
	// VBG-3.12%
	CCM_ANALOG_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_7 = 0x7
	// Position of REFTOP_VBGUP field.
	CCM_ANALOG_MISC0_TOG_REFTOP_VBGUP_Pos = 0x7
	// Bit mask of REFTOP_VBGUP field.
	CCM_ANALOG_MISC0_TOG_REFTOP_VBGUP_Msk = 0x80
	// Bit REFTOP_VBGUP.
	CCM_ANALOG_MISC0_TOG_REFTOP_VBGUP = 0x80
	// Position of STOP_MODE_CONFIG field.
	CCM_ANALOG_MISC0_TOG_STOP_MODE_CONFIG_Pos = 0xa
	// Bit mask of STOP_MODE_CONFIG field.
	CCM_ANALOG_MISC0_TOG_STOP_MODE_CONFIG_Msk = 0xc00
	// All analog except RTC powered down on stop mode assertion.
	CCM_ANALOG_MISC0_TOG_STOP_MODE_CONFIG_STOP_MODE_CONFIG_0 = 0x0
	// Beside RTC, analog bandgap, 1p1 and 2p5 regulators are also on.
	CCM_ANALOG_MISC0_TOG_STOP_MODE_CONFIG_STOP_MODE_CONFIG_1 = 0x1
	// Beside RTC, 1p1 and 2p5 regulators are also on, low-power bandgap is selected so that the normal analog bandgap together with the rest analog is powered down.
	CCM_ANALOG_MISC0_TOG_STOP_MODE_CONFIG_STOP_MODE_CONFIG_2 = 0x2
	// Beside RTC, low-power bandgap is selected and the rest analog is powered down.
	CCM_ANALOG_MISC0_TOG_STOP_MODE_CONFIG_STOP_MODE_CONFIG_3 = 0x3
	// Position of DISCON_HIGH_SNVS field.
	CCM_ANALOG_MISC0_TOG_DISCON_HIGH_SNVS_Pos = 0xc
	// Bit mask of DISCON_HIGH_SNVS field.
	CCM_ANALOG_MISC0_TOG_DISCON_HIGH_SNVS_Msk = 0x1000
	// Bit DISCON_HIGH_SNVS.
	CCM_ANALOG_MISC0_TOG_DISCON_HIGH_SNVS = 0x1000
	// Turn on the switch
	CCM_ANALOG_MISC0_TOG_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_0 = 0x0
	// Turn off the switch
	CCM_ANALOG_MISC0_TOG_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_1 = 0x1
	// Position of OSC_I field.
	CCM_ANALOG_MISC0_TOG_OSC_I_Pos = 0xd
	// Bit mask of OSC_I field.
	CCM_ANALOG_MISC0_TOG_OSC_I_Msk = 0x6000
	// Nominal
	CCM_ANALOG_MISC0_TOG_OSC_I_NOMINAL = 0x0
	// Decrease current by 12.5%
	CCM_ANALOG_MISC0_TOG_OSC_I_MINUS_12_5_PERCENT = 0x1
	// Decrease current by 25.0%
	CCM_ANALOG_MISC0_TOG_OSC_I_MINUS_25_PERCENT = 0x2
	// Decrease current by 37.5%
	CCM_ANALOG_MISC0_TOG_OSC_I_MINUS_37_5_PERCENT = 0x3
	// Position of OSC_XTALOK field.
	CCM_ANALOG_MISC0_TOG_OSC_XTALOK_Pos = 0xf
	// Bit mask of OSC_XTALOK field.
	CCM_ANALOG_MISC0_TOG_OSC_XTALOK_Msk = 0x8000
	// Bit OSC_XTALOK.
	CCM_ANALOG_MISC0_TOG_OSC_XTALOK = 0x8000
	// Position of OSC_XTALOK_EN field.
	CCM_ANALOG_MISC0_TOG_OSC_XTALOK_EN_Pos = 0x10
	// Bit mask of OSC_XTALOK_EN field.
	CCM_ANALOG_MISC0_TOG_OSC_XTALOK_EN_Msk = 0x10000
	// Bit OSC_XTALOK_EN.
	CCM_ANALOG_MISC0_TOG_OSC_XTALOK_EN = 0x10000
	// Position of CLKGATE_CTRL field.
	CCM_ANALOG_MISC0_TOG_CLKGATE_CTRL_Pos = 0x19
	// Bit mask of CLKGATE_CTRL field.
	CCM_ANALOG_MISC0_TOG_CLKGATE_CTRL_Msk = 0x2000000
	// Bit CLKGATE_CTRL.
	CCM_ANALOG_MISC0_TOG_CLKGATE_CTRL = 0x2000000
	// Allow the logic to automatically gate the clock when the XTAL is powered down.
	CCM_ANALOG_MISC0_TOG_CLKGATE_CTRL_ALLOW_AUTO_GATE = 0x0
	// Prevent the logic from ever gating off the clock.
	CCM_ANALOG_MISC0_TOG_CLKGATE_CTRL_NO_AUTO_GATE = 0x1
	// Position of CLKGATE_DELAY field.
	CCM_ANALOG_MISC0_TOG_CLKGATE_DELAY_Pos = 0x1a
	// Bit mask of CLKGATE_DELAY field.
	CCM_ANALOG_MISC0_TOG_CLKGATE_DELAY_Msk = 0x1c000000
	// 0.5ms
	CCM_ANALOG_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_0 = 0x0
	// 1.0ms
	CCM_ANALOG_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_1 = 0x1
	// 2.0ms
	CCM_ANALOG_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_2 = 0x2
	// 3.0ms
	CCM_ANALOG_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_3 = 0x3
	// 4.0ms
	CCM_ANALOG_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_4 = 0x4
	// 5.0ms
	CCM_ANALOG_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_5 = 0x5
	// 6.0ms
	CCM_ANALOG_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_6 = 0x6
	// 7.0ms
	CCM_ANALOG_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_7 = 0x7
	// Position of RTC_XTAL_SOURCE field.
	CCM_ANALOG_MISC0_TOG_RTC_XTAL_SOURCE_Pos = 0x1d
	// Bit mask of RTC_XTAL_SOURCE field.
	CCM_ANALOG_MISC0_TOG_RTC_XTAL_SOURCE_Msk = 0x20000000
	// Bit RTC_XTAL_SOURCE.
	CCM_ANALOG_MISC0_TOG_RTC_XTAL_SOURCE = 0x20000000
	// Internal ring oscillator
	CCM_ANALOG_MISC0_TOG_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_0 = 0x0
	// RTC_XTAL
	CCM_ANALOG_MISC0_TOG_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_1 = 0x1
	// Position of XTAL_24M_PWD field.
	CCM_ANALOG_MISC0_TOG_XTAL_24M_PWD_Pos = 0x1e
	// Bit mask of XTAL_24M_PWD field.
	CCM_ANALOG_MISC0_TOG_XTAL_24M_PWD_Msk = 0x40000000
	// Bit XTAL_24M_PWD.
	CCM_ANALOG_MISC0_TOG_XTAL_24M_PWD = 0x40000000

	// MISC1: Miscellaneous Register 1
	// Position of LVDS1_CLK_SEL field.
	CCM_ANALOG_MISC1_LVDS1_CLK_SEL_Pos = 0x0
	// Bit mask of LVDS1_CLK_SEL field.
	CCM_ANALOG_MISC1_LVDS1_CLK_SEL_Msk = 0x1f
	// Arm PLL
	CCM_ANALOG_MISC1_LVDS1_CLK_SEL_ARM_PLL = 0x0
	// System PLL
	CCM_ANALOG_MISC1_LVDS1_CLK_SEL_SYS_PLL = 0x1
	// ref_pfd4_clk == pll2_pfd0_clk
	CCM_ANALOG_MISC1_LVDS1_CLK_SEL_PFD4 = 0x2
	// ref_pfd5_clk == pll2_pfd1_clk
	CCM_ANALOG_MISC1_LVDS1_CLK_SEL_PFD5 = 0x3
	// ref_pfd6_clk == pll2_pfd2_clk
	CCM_ANALOG_MISC1_LVDS1_CLK_SEL_PFD6 = 0x4
	// ref_pfd7_clk == pll2_pfd3_clk
	CCM_ANALOG_MISC1_LVDS1_CLK_SEL_PFD7 = 0x5
	// Audio PLL
	CCM_ANALOG_MISC1_LVDS1_CLK_SEL_AUDIO_PLL = 0x6
	// Video PLL
	CCM_ANALOG_MISC1_LVDS1_CLK_SEL_VIDEO_PLL = 0x7
	// ethernet ref clock (ENET_PLL)
	CCM_ANALOG_MISC1_LVDS1_CLK_SEL_ETHERNET_REF = 0x9
	// USB1 PLL clock
	CCM_ANALOG_MISC1_LVDS1_CLK_SEL_USB1_PLL = 0xc
	// USB2 PLL clock
	CCM_ANALOG_MISC1_LVDS1_CLK_SEL_USB2_PLL = 0xd
	// ref_pfd0_clk == pll3_pfd0_clk
	CCM_ANALOG_MISC1_LVDS1_CLK_SEL_PFD0 = 0xe
	// ref_pfd1_clk == pll3_pfd1_clk
	CCM_ANALOG_MISC1_LVDS1_CLK_SEL_PFD1 = 0xf
	// ref_pfd2_clk == pll3_pfd2_clk
	CCM_ANALOG_MISC1_LVDS1_CLK_SEL_PFD2 = 0x10
	// ref_pfd3_clk == pll3_pfd3_clk
	CCM_ANALOG_MISC1_LVDS1_CLK_SEL_PFD3 = 0x11
	// xtal (24M)
	CCM_ANALOG_MISC1_LVDS1_CLK_SEL_XTAL = 0x12
	// Position of LVDSCLK1_OBEN field.
	CCM_ANALOG_MISC1_LVDSCLK1_OBEN_Pos = 0xa
	// Bit mask of LVDSCLK1_OBEN field.
	CCM_ANALOG_MISC1_LVDSCLK1_OBEN_Msk = 0x400
	// Bit LVDSCLK1_OBEN.
	CCM_ANALOG_MISC1_LVDSCLK1_OBEN = 0x400
	// Position of LVDSCLK1_IBEN field.
	CCM_ANALOG_MISC1_LVDSCLK1_IBEN_Pos = 0xc
	// Bit mask of LVDSCLK1_IBEN field.
	CCM_ANALOG_MISC1_LVDSCLK1_IBEN_Msk = 0x1000
	// Bit LVDSCLK1_IBEN.
	CCM_ANALOG_MISC1_LVDSCLK1_IBEN = 0x1000
	// Position of PFD_480_AUTOGATE_EN field.
	CCM_ANALOG_MISC1_PFD_480_AUTOGATE_EN_Pos = 0x10
	// Bit mask of PFD_480_AUTOGATE_EN field.
	CCM_ANALOG_MISC1_PFD_480_AUTOGATE_EN_Msk = 0x10000
	// Bit PFD_480_AUTOGATE_EN.
	CCM_ANALOG_MISC1_PFD_480_AUTOGATE_EN = 0x10000
	// Position of PFD_528_AUTOGATE_EN field.
	CCM_ANALOG_MISC1_PFD_528_AUTOGATE_EN_Pos = 0x11
	// Bit mask of PFD_528_AUTOGATE_EN field.
	CCM_ANALOG_MISC1_PFD_528_AUTOGATE_EN_Msk = 0x20000
	// Bit PFD_528_AUTOGATE_EN.
	CCM_ANALOG_MISC1_PFD_528_AUTOGATE_EN = 0x20000
	// Position of IRQ_TEMPPANIC field.
	CCM_ANALOG_MISC1_IRQ_TEMPPANIC_Pos = 0x1b
	// Bit mask of IRQ_TEMPPANIC field.
	CCM_ANALOG_MISC1_IRQ_TEMPPANIC_Msk = 0x8000000
	// Bit IRQ_TEMPPANIC.
	CCM_ANALOG_MISC1_IRQ_TEMPPANIC = 0x8000000
	// Position of IRQ_TEMPLOW field.
	CCM_ANALOG_MISC1_IRQ_TEMPLOW_Pos = 0x1c
	// Bit mask of IRQ_TEMPLOW field.
	CCM_ANALOG_MISC1_IRQ_TEMPLOW_Msk = 0x10000000
	// Bit IRQ_TEMPLOW.
	CCM_ANALOG_MISC1_IRQ_TEMPLOW = 0x10000000
	// Position of IRQ_TEMPHIGH field.
	CCM_ANALOG_MISC1_IRQ_TEMPHIGH_Pos = 0x1d
	// Bit mask of IRQ_TEMPHIGH field.
	CCM_ANALOG_MISC1_IRQ_TEMPHIGH_Msk = 0x20000000
	// Bit IRQ_TEMPHIGH.
	CCM_ANALOG_MISC1_IRQ_TEMPHIGH = 0x20000000
	// Position of IRQ_ANA_BO field.
	CCM_ANALOG_MISC1_IRQ_ANA_BO_Pos = 0x1e
	// Bit mask of IRQ_ANA_BO field.
	CCM_ANALOG_MISC1_IRQ_ANA_BO_Msk = 0x40000000
	// Bit IRQ_ANA_BO.
	CCM_ANALOG_MISC1_IRQ_ANA_BO = 0x40000000
	// Position of IRQ_DIG_BO field.
	CCM_ANALOG_MISC1_IRQ_DIG_BO_Pos = 0x1f
	// Bit mask of IRQ_DIG_BO field.
	CCM_ANALOG_MISC1_IRQ_DIG_BO_Msk = 0x80000000
	// Bit IRQ_DIG_BO.
	CCM_ANALOG_MISC1_IRQ_DIG_BO = 0x80000000

	// MISC1_SET: Miscellaneous Register 1
	// Position of LVDS1_CLK_SEL field.
	CCM_ANALOG_MISC1_SET_LVDS1_CLK_SEL_Pos = 0x0
	// Bit mask of LVDS1_CLK_SEL field.
	CCM_ANALOG_MISC1_SET_LVDS1_CLK_SEL_Msk = 0x1f
	// Arm PLL
	CCM_ANALOG_MISC1_SET_LVDS1_CLK_SEL_ARM_PLL = 0x0
	// System PLL
	CCM_ANALOG_MISC1_SET_LVDS1_CLK_SEL_SYS_PLL = 0x1
	// ref_pfd4_clk == pll2_pfd0_clk
	CCM_ANALOG_MISC1_SET_LVDS1_CLK_SEL_PFD4 = 0x2
	// ref_pfd5_clk == pll2_pfd1_clk
	CCM_ANALOG_MISC1_SET_LVDS1_CLK_SEL_PFD5 = 0x3
	// ref_pfd6_clk == pll2_pfd2_clk
	CCM_ANALOG_MISC1_SET_LVDS1_CLK_SEL_PFD6 = 0x4
	// ref_pfd7_clk == pll2_pfd3_clk
	CCM_ANALOG_MISC1_SET_LVDS1_CLK_SEL_PFD7 = 0x5
	// Audio PLL
	CCM_ANALOG_MISC1_SET_LVDS1_CLK_SEL_AUDIO_PLL = 0x6
	// Video PLL
	CCM_ANALOG_MISC1_SET_LVDS1_CLK_SEL_VIDEO_PLL = 0x7
	// ethernet ref clock (ENET_PLL)
	CCM_ANALOG_MISC1_SET_LVDS1_CLK_SEL_ETHERNET_REF = 0x9
	// USB1 PLL clock
	CCM_ANALOG_MISC1_SET_LVDS1_CLK_SEL_USB1_PLL = 0xc
	// USB2 PLL clock
	CCM_ANALOG_MISC1_SET_LVDS1_CLK_SEL_USB2_PLL = 0xd
	// ref_pfd0_clk == pll3_pfd0_clk
	CCM_ANALOG_MISC1_SET_LVDS1_CLK_SEL_PFD0 = 0xe
	// ref_pfd1_clk == pll3_pfd1_clk
	CCM_ANALOG_MISC1_SET_LVDS1_CLK_SEL_PFD1 = 0xf
	// ref_pfd2_clk == pll3_pfd2_clk
	CCM_ANALOG_MISC1_SET_LVDS1_CLK_SEL_PFD2 = 0x10
	// ref_pfd3_clk == pll3_pfd3_clk
	CCM_ANALOG_MISC1_SET_LVDS1_CLK_SEL_PFD3 = 0x11
	// xtal (24M)
	CCM_ANALOG_MISC1_SET_LVDS1_CLK_SEL_XTAL = 0x12
	// Position of LVDSCLK1_OBEN field.
	CCM_ANALOG_MISC1_SET_LVDSCLK1_OBEN_Pos = 0xa
	// Bit mask of LVDSCLK1_OBEN field.
	CCM_ANALOG_MISC1_SET_LVDSCLK1_OBEN_Msk = 0x400
	// Bit LVDSCLK1_OBEN.
	CCM_ANALOG_MISC1_SET_LVDSCLK1_OBEN = 0x400
	// Position of LVDSCLK1_IBEN field.
	CCM_ANALOG_MISC1_SET_LVDSCLK1_IBEN_Pos = 0xc
	// Bit mask of LVDSCLK1_IBEN field.
	CCM_ANALOG_MISC1_SET_LVDSCLK1_IBEN_Msk = 0x1000
	// Bit LVDSCLK1_IBEN.
	CCM_ANALOG_MISC1_SET_LVDSCLK1_IBEN = 0x1000
	// Position of PFD_480_AUTOGATE_EN field.
	CCM_ANALOG_MISC1_SET_PFD_480_AUTOGATE_EN_Pos = 0x10
	// Bit mask of PFD_480_AUTOGATE_EN field.
	CCM_ANALOG_MISC1_SET_PFD_480_AUTOGATE_EN_Msk = 0x10000
	// Bit PFD_480_AUTOGATE_EN.
	CCM_ANALOG_MISC1_SET_PFD_480_AUTOGATE_EN = 0x10000
	// Position of PFD_528_AUTOGATE_EN field.
	CCM_ANALOG_MISC1_SET_PFD_528_AUTOGATE_EN_Pos = 0x11
	// Bit mask of PFD_528_AUTOGATE_EN field.
	CCM_ANALOG_MISC1_SET_PFD_528_AUTOGATE_EN_Msk = 0x20000
	// Bit PFD_528_AUTOGATE_EN.
	CCM_ANALOG_MISC1_SET_PFD_528_AUTOGATE_EN = 0x20000
	// Position of IRQ_TEMPPANIC field.
	CCM_ANALOG_MISC1_SET_IRQ_TEMPPANIC_Pos = 0x1b
	// Bit mask of IRQ_TEMPPANIC field.
	CCM_ANALOG_MISC1_SET_IRQ_TEMPPANIC_Msk = 0x8000000
	// Bit IRQ_TEMPPANIC.
	CCM_ANALOG_MISC1_SET_IRQ_TEMPPANIC = 0x8000000
	// Position of IRQ_TEMPLOW field.
	CCM_ANALOG_MISC1_SET_IRQ_TEMPLOW_Pos = 0x1c
	// Bit mask of IRQ_TEMPLOW field.
	CCM_ANALOG_MISC1_SET_IRQ_TEMPLOW_Msk = 0x10000000
	// Bit IRQ_TEMPLOW.
	CCM_ANALOG_MISC1_SET_IRQ_TEMPLOW = 0x10000000
	// Position of IRQ_TEMPHIGH field.
	CCM_ANALOG_MISC1_SET_IRQ_TEMPHIGH_Pos = 0x1d
	// Bit mask of IRQ_TEMPHIGH field.
	CCM_ANALOG_MISC1_SET_IRQ_TEMPHIGH_Msk = 0x20000000
	// Bit IRQ_TEMPHIGH.
	CCM_ANALOG_MISC1_SET_IRQ_TEMPHIGH = 0x20000000
	// Position of IRQ_ANA_BO field.
	CCM_ANALOG_MISC1_SET_IRQ_ANA_BO_Pos = 0x1e
	// Bit mask of IRQ_ANA_BO field.
	CCM_ANALOG_MISC1_SET_IRQ_ANA_BO_Msk = 0x40000000
	// Bit IRQ_ANA_BO.
	CCM_ANALOG_MISC1_SET_IRQ_ANA_BO = 0x40000000
	// Position of IRQ_DIG_BO field.
	CCM_ANALOG_MISC1_SET_IRQ_DIG_BO_Pos = 0x1f
	// Bit mask of IRQ_DIG_BO field.
	CCM_ANALOG_MISC1_SET_IRQ_DIG_BO_Msk = 0x80000000
	// Bit IRQ_DIG_BO.
	CCM_ANALOG_MISC1_SET_IRQ_DIG_BO = 0x80000000

	// MISC1_CLR: Miscellaneous Register 1
	// Position of LVDS1_CLK_SEL field.
	CCM_ANALOG_MISC1_CLR_LVDS1_CLK_SEL_Pos = 0x0
	// Bit mask of LVDS1_CLK_SEL field.
	CCM_ANALOG_MISC1_CLR_LVDS1_CLK_SEL_Msk = 0x1f
	// Arm PLL
	CCM_ANALOG_MISC1_CLR_LVDS1_CLK_SEL_ARM_PLL = 0x0
	// System PLL
	CCM_ANALOG_MISC1_CLR_LVDS1_CLK_SEL_SYS_PLL = 0x1
	// ref_pfd4_clk == pll2_pfd0_clk
	CCM_ANALOG_MISC1_CLR_LVDS1_CLK_SEL_PFD4 = 0x2
	// ref_pfd5_clk == pll2_pfd1_clk
	CCM_ANALOG_MISC1_CLR_LVDS1_CLK_SEL_PFD5 = 0x3
	// ref_pfd6_clk == pll2_pfd2_clk
	CCM_ANALOG_MISC1_CLR_LVDS1_CLK_SEL_PFD6 = 0x4
	// ref_pfd7_clk == pll2_pfd3_clk
	CCM_ANALOG_MISC1_CLR_LVDS1_CLK_SEL_PFD7 = 0x5
	// Audio PLL
	CCM_ANALOG_MISC1_CLR_LVDS1_CLK_SEL_AUDIO_PLL = 0x6
	// Video PLL
	CCM_ANALOG_MISC1_CLR_LVDS1_CLK_SEL_VIDEO_PLL = 0x7
	// ethernet ref clock (ENET_PLL)
	CCM_ANALOG_MISC1_CLR_LVDS1_CLK_SEL_ETHERNET_REF = 0x9
	// USB1 PLL clock
	CCM_ANALOG_MISC1_CLR_LVDS1_CLK_SEL_USB1_PLL = 0xc
	// USB2 PLL clock
	CCM_ANALOG_MISC1_CLR_LVDS1_CLK_SEL_USB2_PLL = 0xd
	// ref_pfd0_clk == pll3_pfd0_clk
	CCM_ANALOG_MISC1_CLR_LVDS1_CLK_SEL_PFD0 = 0xe
	// ref_pfd1_clk == pll3_pfd1_clk
	CCM_ANALOG_MISC1_CLR_LVDS1_CLK_SEL_PFD1 = 0xf
	// ref_pfd2_clk == pll3_pfd2_clk
	CCM_ANALOG_MISC1_CLR_LVDS1_CLK_SEL_PFD2 = 0x10
	// ref_pfd3_clk == pll3_pfd3_clk
	CCM_ANALOG_MISC1_CLR_LVDS1_CLK_SEL_PFD3 = 0x11
	// xtal (24M)
	CCM_ANALOG_MISC1_CLR_LVDS1_CLK_SEL_XTAL = 0x12
	// Position of LVDSCLK1_OBEN field.
	CCM_ANALOG_MISC1_CLR_LVDSCLK1_OBEN_Pos = 0xa
	// Bit mask of LVDSCLK1_OBEN field.
	CCM_ANALOG_MISC1_CLR_LVDSCLK1_OBEN_Msk = 0x400
	// Bit LVDSCLK1_OBEN.
	CCM_ANALOG_MISC1_CLR_LVDSCLK1_OBEN = 0x400
	// Position of LVDSCLK1_IBEN field.
	CCM_ANALOG_MISC1_CLR_LVDSCLK1_IBEN_Pos = 0xc
	// Bit mask of LVDSCLK1_IBEN field.
	CCM_ANALOG_MISC1_CLR_LVDSCLK1_IBEN_Msk = 0x1000
	// Bit LVDSCLK1_IBEN.
	CCM_ANALOG_MISC1_CLR_LVDSCLK1_IBEN = 0x1000
	// Position of PFD_480_AUTOGATE_EN field.
	CCM_ANALOG_MISC1_CLR_PFD_480_AUTOGATE_EN_Pos = 0x10
	// Bit mask of PFD_480_AUTOGATE_EN field.
	CCM_ANALOG_MISC1_CLR_PFD_480_AUTOGATE_EN_Msk = 0x10000
	// Bit PFD_480_AUTOGATE_EN.
	CCM_ANALOG_MISC1_CLR_PFD_480_AUTOGATE_EN = 0x10000
	// Position of PFD_528_AUTOGATE_EN field.
	CCM_ANALOG_MISC1_CLR_PFD_528_AUTOGATE_EN_Pos = 0x11
	// Bit mask of PFD_528_AUTOGATE_EN field.
	CCM_ANALOG_MISC1_CLR_PFD_528_AUTOGATE_EN_Msk = 0x20000
	// Bit PFD_528_AUTOGATE_EN.
	CCM_ANALOG_MISC1_CLR_PFD_528_AUTOGATE_EN = 0x20000
	// Position of IRQ_TEMPPANIC field.
	CCM_ANALOG_MISC1_CLR_IRQ_TEMPPANIC_Pos = 0x1b
	// Bit mask of IRQ_TEMPPANIC field.
	CCM_ANALOG_MISC1_CLR_IRQ_TEMPPANIC_Msk = 0x8000000
	// Bit IRQ_TEMPPANIC.
	CCM_ANALOG_MISC1_CLR_IRQ_TEMPPANIC = 0x8000000
	// Position of IRQ_TEMPLOW field.
	CCM_ANALOG_MISC1_CLR_IRQ_TEMPLOW_Pos = 0x1c
	// Bit mask of IRQ_TEMPLOW field.
	CCM_ANALOG_MISC1_CLR_IRQ_TEMPLOW_Msk = 0x10000000
	// Bit IRQ_TEMPLOW.
	CCM_ANALOG_MISC1_CLR_IRQ_TEMPLOW = 0x10000000
	// Position of IRQ_TEMPHIGH field.
	CCM_ANALOG_MISC1_CLR_IRQ_TEMPHIGH_Pos = 0x1d
	// Bit mask of IRQ_TEMPHIGH field.
	CCM_ANALOG_MISC1_CLR_IRQ_TEMPHIGH_Msk = 0x20000000
	// Bit IRQ_TEMPHIGH.
	CCM_ANALOG_MISC1_CLR_IRQ_TEMPHIGH = 0x20000000
	// Position of IRQ_ANA_BO field.
	CCM_ANALOG_MISC1_CLR_IRQ_ANA_BO_Pos = 0x1e
	// Bit mask of IRQ_ANA_BO field.
	CCM_ANALOG_MISC1_CLR_IRQ_ANA_BO_Msk = 0x40000000
	// Bit IRQ_ANA_BO.
	CCM_ANALOG_MISC1_CLR_IRQ_ANA_BO = 0x40000000
	// Position of IRQ_DIG_BO field.
	CCM_ANALOG_MISC1_CLR_IRQ_DIG_BO_Pos = 0x1f
	// Bit mask of IRQ_DIG_BO field.
	CCM_ANALOG_MISC1_CLR_IRQ_DIG_BO_Msk = 0x80000000
	// Bit IRQ_DIG_BO.
	CCM_ANALOG_MISC1_CLR_IRQ_DIG_BO = 0x80000000

	// MISC1_TOG: Miscellaneous Register 1
	// Position of LVDS1_CLK_SEL field.
	CCM_ANALOG_MISC1_TOG_LVDS1_CLK_SEL_Pos = 0x0
	// Bit mask of LVDS1_CLK_SEL field.
	CCM_ANALOG_MISC1_TOG_LVDS1_CLK_SEL_Msk = 0x1f
	// Arm PLL
	CCM_ANALOG_MISC1_TOG_LVDS1_CLK_SEL_ARM_PLL = 0x0
	// System PLL
	CCM_ANALOG_MISC1_TOG_LVDS1_CLK_SEL_SYS_PLL = 0x1
	// ref_pfd4_clk == pll2_pfd0_clk
	CCM_ANALOG_MISC1_TOG_LVDS1_CLK_SEL_PFD4 = 0x2
	// ref_pfd5_clk == pll2_pfd1_clk
	CCM_ANALOG_MISC1_TOG_LVDS1_CLK_SEL_PFD5 = 0x3
	// ref_pfd6_clk == pll2_pfd2_clk
	CCM_ANALOG_MISC1_TOG_LVDS1_CLK_SEL_PFD6 = 0x4
	// ref_pfd7_clk == pll2_pfd3_clk
	CCM_ANALOG_MISC1_TOG_LVDS1_CLK_SEL_PFD7 = 0x5
	// Audio PLL
	CCM_ANALOG_MISC1_TOG_LVDS1_CLK_SEL_AUDIO_PLL = 0x6
	// Video PLL
	CCM_ANALOG_MISC1_TOG_LVDS1_CLK_SEL_VIDEO_PLL = 0x7
	// ethernet ref clock (ENET_PLL)
	CCM_ANALOG_MISC1_TOG_LVDS1_CLK_SEL_ETHERNET_REF = 0x9
	// USB1 PLL clock
	CCM_ANALOG_MISC1_TOG_LVDS1_CLK_SEL_USB1_PLL = 0xc
	// USB2 PLL clock
	CCM_ANALOG_MISC1_TOG_LVDS1_CLK_SEL_USB2_PLL = 0xd
	// ref_pfd0_clk == pll3_pfd0_clk
	CCM_ANALOG_MISC1_TOG_LVDS1_CLK_SEL_PFD0 = 0xe
	// ref_pfd1_clk == pll3_pfd1_clk
	CCM_ANALOG_MISC1_TOG_LVDS1_CLK_SEL_PFD1 = 0xf
	// ref_pfd2_clk == pll3_pfd2_clk
	CCM_ANALOG_MISC1_TOG_LVDS1_CLK_SEL_PFD2 = 0x10
	// ref_pfd3_clk == pll3_pfd3_clk
	CCM_ANALOG_MISC1_TOG_LVDS1_CLK_SEL_PFD3 = 0x11
	// xtal (24M)
	CCM_ANALOG_MISC1_TOG_LVDS1_CLK_SEL_XTAL = 0x12
	// Position of LVDSCLK1_OBEN field.
	CCM_ANALOG_MISC1_TOG_LVDSCLK1_OBEN_Pos = 0xa
	// Bit mask of LVDSCLK1_OBEN field.
	CCM_ANALOG_MISC1_TOG_LVDSCLK1_OBEN_Msk = 0x400
	// Bit LVDSCLK1_OBEN.
	CCM_ANALOG_MISC1_TOG_LVDSCLK1_OBEN = 0x400
	// Position of LVDSCLK1_IBEN field.
	CCM_ANALOG_MISC1_TOG_LVDSCLK1_IBEN_Pos = 0xc
	// Bit mask of LVDSCLK1_IBEN field.
	CCM_ANALOG_MISC1_TOG_LVDSCLK1_IBEN_Msk = 0x1000
	// Bit LVDSCLK1_IBEN.
	CCM_ANALOG_MISC1_TOG_LVDSCLK1_IBEN = 0x1000
	// Position of PFD_480_AUTOGATE_EN field.
	CCM_ANALOG_MISC1_TOG_PFD_480_AUTOGATE_EN_Pos = 0x10
	// Bit mask of PFD_480_AUTOGATE_EN field.
	CCM_ANALOG_MISC1_TOG_PFD_480_AUTOGATE_EN_Msk = 0x10000
	// Bit PFD_480_AUTOGATE_EN.
	CCM_ANALOG_MISC1_TOG_PFD_480_AUTOGATE_EN = 0x10000
	// Position of PFD_528_AUTOGATE_EN field.
	CCM_ANALOG_MISC1_TOG_PFD_528_AUTOGATE_EN_Pos = 0x11
	// Bit mask of PFD_528_AUTOGATE_EN field.
	CCM_ANALOG_MISC1_TOG_PFD_528_AUTOGATE_EN_Msk = 0x20000
	// Bit PFD_528_AUTOGATE_EN.
	CCM_ANALOG_MISC1_TOG_PFD_528_AUTOGATE_EN = 0x20000
	// Position of IRQ_TEMPPANIC field.
	CCM_ANALOG_MISC1_TOG_IRQ_TEMPPANIC_Pos = 0x1b
	// Bit mask of IRQ_TEMPPANIC field.
	CCM_ANALOG_MISC1_TOG_IRQ_TEMPPANIC_Msk = 0x8000000
	// Bit IRQ_TEMPPANIC.
	CCM_ANALOG_MISC1_TOG_IRQ_TEMPPANIC = 0x8000000
	// Position of IRQ_TEMPLOW field.
	CCM_ANALOG_MISC1_TOG_IRQ_TEMPLOW_Pos = 0x1c
	// Bit mask of IRQ_TEMPLOW field.
	CCM_ANALOG_MISC1_TOG_IRQ_TEMPLOW_Msk = 0x10000000
	// Bit IRQ_TEMPLOW.
	CCM_ANALOG_MISC1_TOG_IRQ_TEMPLOW = 0x10000000
	// Position of IRQ_TEMPHIGH field.
	CCM_ANALOG_MISC1_TOG_IRQ_TEMPHIGH_Pos = 0x1d
	// Bit mask of IRQ_TEMPHIGH field.
	CCM_ANALOG_MISC1_TOG_IRQ_TEMPHIGH_Msk = 0x20000000
	// Bit IRQ_TEMPHIGH.
	CCM_ANALOG_MISC1_TOG_IRQ_TEMPHIGH = 0x20000000
	// Position of IRQ_ANA_BO field.
	CCM_ANALOG_MISC1_TOG_IRQ_ANA_BO_Pos = 0x1e
	// Bit mask of IRQ_ANA_BO field.
	CCM_ANALOG_MISC1_TOG_IRQ_ANA_BO_Msk = 0x40000000
	// Bit IRQ_ANA_BO.
	CCM_ANALOG_MISC1_TOG_IRQ_ANA_BO = 0x40000000
	// Position of IRQ_DIG_BO field.
	CCM_ANALOG_MISC1_TOG_IRQ_DIG_BO_Pos = 0x1f
	// Bit mask of IRQ_DIG_BO field.
	CCM_ANALOG_MISC1_TOG_IRQ_DIG_BO_Msk = 0x80000000
	// Bit IRQ_DIG_BO.
	CCM_ANALOG_MISC1_TOG_IRQ_DIG_BO = 0x80000000

	// MISC2: Miscellaneous Register 2
	// Position of REG0_BO_OFFSET field.
	CCM_ANALOG_MISC2_REG0_BO_OFFSET_Pos = 0x0
	// Bit mask of REG0_BO_OFFSET field.
	CCM_ANALOG_MISC2_REG0_BO_OFFSET_Msk = 0x7
	// Brownout offset = 0.100V
	CCM_ANALOG_MISC2_REG0_BO_OFFSET_REG0_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	CCM_ANALOG_MISC2_REG0_BO_OFFSET_REG0_BO_OFFSET_7 = 0x7
	// Position of REG0_BO_STATUS field.
	CCM_ANALOG_MISC2_REG0_BO_STATUS_Pos = 0x3
	// Bit mask of REG0_BO_STATUS field.
	CCM_ANALOG_MISC2_REG0_BO_STATUS_Msk = 0x8
	// Bit REG0_BO_STATUS.
	CCM_ANALOG_MISC2_REG0_BO_STATUS = 0x8
	// Brownout, supply is below target minus brownout offset.
	CCM_ANALOG_MISC2_REG0_BO_STATUS_REG0_BO_STATUS_1 = 0x1
	// Position of REG0_ENABLE_BO field.
	CCM_ANALOG_MISC2_REG0_ENABLE_BO_Pos = 0x5
	// Bit mask of REG0_ENABLE_BO field.
	CCM_ANALOG_MISC2_REG0_ENABLE_BO_Msk = 0x20
	// Bit REG0_ENABLE_BO.
	CCM_ANALOG_MISC2_REG0_ENABLE_BO = 0x20
	// Position of REG0_OK field.
	CCM_ANALOG_MISC2_REG0_OK_Pos = 0x6
	// Bit mask of REG0_OK field.
	CCM_ANALOG_MISC2_REG0_OK_Msk = 0x40
	// Bit REG0_OK.
	CCM_ANALOG_MISC2_REG0_OK = 0x40
	// Position of PLL3_DISABLE field.
	CCM_ANALOG_MISC2_PLL3_DISABLE_Pos = 0x7
	// Bit mask of PLL3_DISABLE field.
	CCM_ANALOG_MISC2_PLL3_DISABLE_Msk = 0x80
	// Bit PLL3_DISABLE.
	CCM_ANALOG_MISC2_PLL3_DISABLE = 0x80
	// PLL3 is being used by peripherals and is enabled when SoC is not in any low power mode
	CCM_ANALOG_MISC2_PLL3_DISABLE_PLL3_DISABLE_0 = 0x0
	// PLL3 can be disabled when the SoC is not in any low power mode
	CCM_ANALOG_MISC2_PLL3_DISABLE_PLL3_DISABLE_1 = 0x1
	// Position of REG1_BO_OFFSET field.
	CCM_ANALOG_MISC2_REG1_BO_OFFSET_Pos = 0x8
	// Bit mask of REG1_BO_OFFSET field.
	CCM_ANALOG_MISC2_REG1_BO_OFFSET_Msk = 0x700
	// Brownout offset = 0.100V
	CCM_ANALOG_MISC2_REG1_BO_OFFSET_REG1_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	CCM_ANALOG_MISC2_REG1_BO_OFFSET_REG1_BO_OFFSET_7 = 0x7
	// Position of REG1_BO_STATUS field.
	CCM_ANALOG_MISC2_REG1_BO_STATUS_Pos = 0xb
	// Bit mask of REG1_BO_STATUS field.
	CCM_ANALOG_MISC2_REG1_BO_STATUS_Msk = 0x800
	// Bit REG1_BO_STATUS.
	CCM_ANALOG_MISC2_REG1_BO_STATUS = 0x800
	// Brownout, supply is below target minus brownout offset.
	CCM_ANALOG_MISC2_REG1_BO_STATUS_REG1_BO_STATUS_1 = 0x1
	// Position of REG1_ENABLE_BO field.
	CCM_ANALOG_MISC2_REG1_ENABLE_BO_Pos = 0xd
	// Bit mask of REG1_ENABLE_BO field.
	CCM_ANALOG_MISC2_REG1_ENABLE_BO_Msk = 0x2000
	// Bit REG1_ENABLE_BO.
	CCM_ANALOG_MISC2_REG1_ENABLE_BO = 0x2000
	// Position of REG1_OK field.
	CCM_ANALOG_MISC2_REG1_OK_Pos = 0xe
	// Bit mask of REG1_OK field.
	CCM_ANALOG_MISC2_REG1_OK_Msk = 0x4000
	// Bit REG1_OK.
	CCM_ANALOG_MISC2_REG1_OK = 0x4000
	// Position of AUDIO_DIV_LSB field.
	CCM_ANALOG_MISC2_AUDIO_DIV_LSB_Pos = 0xf
	// Bit mask of AUDIO_DIV_LSB field.
	CCM_ANALOG_MISC2_AUDIO_DIV_LSB_Msk = 0x8000
	// Bit AUDIO_DIV_LSB.
	CCM_ANALOG_MISC2_AUDIO_DIV_LSB = 0x8000
	// divide by 1 (Default)
	CCM_ANALOG_MISC2_AUDIO_DIV_LSB_AUDIO_DIV_LSB_0 = 0x0
	// divide by 2
	CCM_ANALOG_MISC2_AUDIO_DIV_LSB_AUDIO_DIV_LSB_1 = 0x1
	// Position of REG2_BO_OFFSET field.
	CCM_ANALOG_MISC2_REG2_BO_OFFSET_Pos = 0x10
	// Bit mask of REG2_BO_OFFSET field.
	CCM_ANALOG_MISC2_REG2_BO_OFFSET_Msk = 0x70000
	// Brownout offset = 0.100V
	CCM_ANALOG_MISC2_REG2_BO_OFFSET_REG2_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	CCM_ANALOG_MISC2_REG2_BO_OFFSET_REG2_BO_OFFSET_7 = 0x7
	// Position of REG2_BO_STATUS field.
	CCM_ANALOG_MISC2_REG2_BO_STATUS_Pos = 0x13
	// Bit mask of REG2_BO_STATUS field.
	CCM_ANALOG_MISC2_REG2_BO_STATUS_Msk = 0x80000
	// Bit REG2_BO_STATUS.
	CCM_ANALOG_MISC2_REG2_BO_STATUS = 0x80000
	// Position of REG2_ENABLE_BO field.
	CCM_ANALOG_MISC2_REG2_ENABLE_BO_Pos = 0x15
	// Bit mask of REG2_ENABLE_BO field.
	CCM_ANALOG_MISC2_REG2_ENABLE_BO_Msk = 0x200000
	// Bit REG2_ENABLE_BO.
	CCM_ANALOG_MISC2_REG2_ENABLE_BO = 0x200000
	// Position of REG2_OK field.
	CCM_ANALOG_MISC2_REG2_OK_Pos = 0x16
	// Bit mask of REG2_OK field.
	CCM_ANALOG_MISC2_REG2_OK_Msk = 0x400000
	// Bit REG2_OK.
	CCM_ANALOG_MISC2_REG2_OK = 0x400000
	// Position of AUDIO_DIV_MSB field.
	CCM_ANALOG_MISC2_AUDIO_DIV_MSB_Pos = 0x17
	// Bit mask of AUDIO_DIV_MSB field.
	CCM_ANALOG_MISC2_AUDIO_DIV_MSB_Msk = 0x800000
	// Bit AUDIO_DIV_MSB.
	CCM_ANALOG_MISC2_AUDIO_DIV_MSB = 0x800000
	// divide by 1 (Default)
	CCM_ANALOG_MISC2_AUDIO_DIV_MSB_AUDIO_DIV_MSB_0 = 0x0
	// divide by 2
	CCM_ANALOG_MISC2_AUDIO_DIV_MSB_AUDIO_DIV_MSB_1 = 0x1
	// Position of REG0_STEP_TIME field.
	CCM_ANALOG_MISC2_REG0_STEP_TIME_Pos = 0x18
	// Bit mask of REG0_STEP_TIME field.
	CCM_ANALOG_MISC2_REG0_STEP_TIME_Msk = 0x3000000
	// 64
	CCM_ANALOG_MISC2_REG0_STEP_TIME_64_CLOCKS = 0x0
	// 128
	CCM_ANALOG_MISC2_REG0_STEP_TIME_128_CLOCKS = 0x1
	// 256
	CCM_ANALOG_MISC2_REG0_STEP_TIME_256_CLOCKS = 0x2
	// 512
	CCM_ANALOG_MISC2_REG0_STEP_TIME_512_CLOCKS = 0x3
	// Position of REG1_STEP_TIME field.
	CCM_ANALOG_MISC2_REG1_STEP_TIME_Pos = 0x1a
	// Bit mask of REG1_STEP_TIME field.
	CCM_ANALOG_MISC2_REG1_STEP_TIME_Msk = 0xc000000
	// 64
	CCM_ANALOG_MISC2_REG1_STEP_TIME_64_CLOCKS = 0x0
	// 128
	CCM_ANALOG_MISC2_REG1_STEP_TIME_128_CLOCKS = 0x1
	// 256
	CCM_ANALOG_MISC2_REG1_STEP_TIME_256_CLOCKS = 0x2
	// 512
	CCM_ANALOG_MISC2_REG1_STEP_TIME_512_CLOCKS = 0x3
	// Position of REG2_STEP_TIME field.
	CCM_ANALOG_MISC2_REG2_STEP_TIME_Pos = 0x1c
	// Bit mask of REG2_STEP_TIME field.
	CCM_ANALOG_MISC2_REG2_STEP_TIME_Msk = 0x30000000
	// 64
	CCM_ANALOG_MISC2_REG2_STEP_TIME_64_CLOCKS = 0x0
	// 128
	CCM_ANALOG_MISC2_REG2_STEP_TIME_128_CLOCKS = 0x1
	// 256
	CCM_ANALOG_MISC2_REG2_STEP_TIME_256_CLOCKS = 0x2
	// 512
	CCM_ANALOG_MISC2_REG2_STEP_TIME_512_CLOCKS = 0x3
	// Position of VIDEO_DIV field.
	CCM_ANALOG_MISC2_VIDEO_DIV_Pos = 0x1e
	// Bit mask of VIDEO_DIV field.
	CCM_ANALOG_MISC2_VIDEO_DIV_Msk = 0xc0000000
	// divide by 1 (Default)
	CCM_ANALOG_MISC2_VIDEO_DIV_VIDEO_DIV_0 = 0x0
	// divide by 2
	CCM_ANALOG_MISC2_VIDEO_DIV_VIDEO_DIV_1 = 0x1
	// divide by 1
	CCM_ANALOG_MISC2_VIDEO_DIV_VIDEO_DIV_2 = 0x2
	// divide by 4
	CCM_ANALOG_MISC2_VIDEO_DIV_VIDEO_DIV_3 = 0x3

	// MISC2_SET: Miscellaneous Register 2
	// Position of REG0_BO_OFFSET field.
	CCM_ANALOG_MISC2_SET_REG0_BO_OFFSET_Pos = 0x0
	// Bit mask of REG0_BO_OFFSET field.
	CCM_ANALOG_MISC2_SET_REG0_BO_OFFSET_Msk = 0x7
	// Brownout offset = 0.100V
	CCM_ANALOG_MISC2_SET_REG0_BO_OFFSET_REG0_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	CCM_ANALOG_MISC2_SET_REG0_BO_OFFSET_REG0_BO_OFFSET_7 = 0x7
	// Position of REG0_BO_STATUS field.
	CCM_ANALOG_MISC2_SET_REG0_BO_STATUS_Pos = 0x3
	// Bit mask of REG0_BO_STATUS field.
	CCM_ANALOG_MISC2_SET_REG0_BO_STATUS_Msk = 0x8
	// Bit REG0_BO_STATUS.
	CCM_ANALOG_MISC2_SET_REG0_BO_STATUS = 0x8
	// Brownout, supply is below target minus brownout offset.
	CCM_ANALOG_MISC2_SET_REG0_BO_STATUS_REG0_BO_STATUS_1 = 0x1
	// Position of REG0_ENABLE_BO field.
	CCM_ANALOG_MISC2_SET_REG0_ENABLE_BO_Pos = 0x5
	// Bit mask of REG0_ENABLE_BO field.
	CCM_ANALOG_MISC2_SET_REG0_ENABLE_BO_Msk = 0x20
	// Bit REG0_ENABLE_BO.
	CCM_ANALOG_MISC2_SET_REG0_ENABLE_BO = 0x20
	// Position of REG0_OK field.
	CCM_ANALOG_MISC2_SET_REG0_OK_Pos = 0x6
	// Bit mask of REG0_OK field.
	CCM_ANALOG_MISC2_SET_REG0_OK_Msk = 0x40
	// Bit REG0_OK.
	CCM_ANALOG_MISC2_SET_REG0_OK = 0x40
	// Position of PLL3_DISABLE field.
	CCM_ANALOG_MISC2_SET_PLL3_DISABLE_Pos = 0x7
	// Bit mask of PLL3_DISABLE field.
	CCM_ANALOG_MISC2_SET_PLL3_DISABLE_Msk = 0x80
	// Bit PLL3_DISABLE.
	CCM_ANALOG_MISC2_SET_PLL3_DISABLE = 0x80
	// PLL3 is being used by peripherals and is enabled when SoC is not in any low power mode
	CCM_ANALOG_MISC2_SET_PLL3_DISABLE_PLL3_DISABLE_0 = 0x0
	// PLL3 can be disabled when the SoC is not in any low power mode
	CCM_ANALOG_MISC2_SET_PLL3_DISABLE_PLL3_DISABLE_1 = 0x1
	// Position of REG1_BO_OFFSET field.
	CCM_ANALOG_MISC2_SET_REG1_BO_OFFSET_Pos = 0x8
	// Bit mask of REG1_BO_OFFSET field.
	CCM_ANALOG_MISC2_SET_REG1_BO_OFFSET_Msk = 0x700
	// Brownout offset = 0.100V
	CCM_ANALOG_MISC2_SET_REG1_BO_OFFSET_REG1_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	CCM_ANALOG_MISC2_SET_REG1_BO_OFFSET_REG1_BO_OFFSET_7 = 0x7
	// Position of REG1_BO_STATUS field.
	CCM_ANALOG_MISC2_SET_REG1_BO_STATUS_Pos = 0xb
	// Bit mask of REG1_BO_STATUS field.
	CCM_ANALOG_MISC2_SET_REG1_BO_STATUS_Msk = 0x800
	// Bit REG1_BO_STATUS.
	CCM_ANALOG_MISC2_SET_REG1_BO_STATUS = 0x800
	// Brownout, supply is below target minus brownout offset.
	CCM_ANALOG_MISC2_SET_REG1_BO_STATUS_REG1_BO_STATUS_1 = 0x1
	// Position of REG1_ENABLE_BO field.
	CCM_ANALOG_MISC2_SET_REG1_ENABLE_BO_Pos = 0xd
	// Bit mask of REG1_ENABLE_BO field.
	CCM_ANALOG_MISC2_SET_REG1_ENABLE_BO_Msk = 0x2000
	// Bit REG1_ENABLE_BO.
	CCM_ANALOG_MISC2_SET_REG1_ENABLE_BO = 0x2000
	// Position of REG1_OK field.
	CCM_ANALOG_MISC2_SET_REG1_OK_Pos = 0xe
	// Bit mask of REG1_OK field.
	CCM_ANALOG_MISC2_SET_REG1_OK_Msk = 0x4000
	// Bit REG1_OK.
	CCM_ANALOG_MISC2_SET_REG1_OK = 0x4000
	// Position of AUDIO_DIV_LSB field.
	CCM_ANALOG_MISC2_SET_AUDIO_DIV_LSB_Pos = 0xf
	// Bit mask of AUDIO_DIV_LSB field.
	CCM_ANALOG_MISC2_SET_AUDIO_DIV_LSB_Msk = 0x8000
	// Bit AUDIO_DIV_LSB.
	CCM_ANALOG_MISC2_SET_AUDIO_DIV_LSB = 0x8000
	// divide by 1 (Default)
	CCM_ANALOG_MISC2_SET_AUDIO_DIV_LSB_AUDIO_DIV_LSB_0 = 0x0
	// divide by 2
	CCM_ANALOG_MISC2_SET_AUDIO_DIV_LSB_AUDIO_DIV_LSB_1 = 0x1
	// Position of REG2_BO_OFFSET field.
	CCM_ANALOG_MISC2_SET_REG2_BO_OFFSET_Pos = 0x10
	// Bit mask of REG2_BO_OFFSET field.
	CCM_ANALOG_MISC2_SET_REG2_BO_OFFSET_Msk = 0x70000
	// Brownout offset = 0.100V
	CCM_ANALOG_MISC2_SET_REG2_BO_OFFSET_REG2_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	CCM_ANALOG_MISC2_SET_REG2_BO_OFFSET_REG2_BO_OFFSET_7 = 0x7
	// Position of REG2_BO_STATUS field.
	CCM_ANALOG_MISC2_SET_REG2_BO_STATUS_Pos = 0x13
	// Bit mask of REG2_BO_STATUS field.
	CCM_ANALOG_MISC2_SET_REG2_BO_STATUS_Msk = 0x80000
	// Bit REG2_BO_STATUS.
	CCM_ANALOG_MISC2_SET_REG2_BO_STATUS = 0x80000
	// Position of REG2_ENABLE_BO field.
	CCM_ANALOG_MISC2_SET_REG2_ENABLE_BO_Pos = 0x15
	// Bit mask of REG2_ENABLE_BO field.
	CCM_ANALOG_MISC2_SET_REG2_ENABLE_BO_Msk = 0x200000
	// Bit REG2_ENABLE_BO.
	CCM_ANALOG_MISC2_SET_REG2_ENABLE_BO = 0x200000
	// Position of REG2_OK field.
	CCM_ANALOG_MISC2_SET_REG2_OK_Pos = 0x16
	// Bit mask of REG2_OK field.
	CCM_ANALOG_MISC2_SET_REG2_OK_Msk = 0x400000
	// Bit REG2_OK.
	CCM_ANALOG_MISC2_SET_REG2_OK = 0x400000
	// Position of AUDIO_DIV_MSB field.
	CCM_ANALOG_MISC2_SET_AUDIO_DIV_MSB_Pos = 0x17
	// Bit mask of AUDIO_DIV_MSB field.
	CCM_ANALOG_MISC2_SET_AUDIO_DIV_MSB_Msk = 0x800000
	// Bit AUDIO_DIV_MSB.
	CCM_ANALOG_MISC2_SET_AUDIO_DIV_MSB = 0x800000
	// divide by 1 (Default)
	CCM_ANALOG_MISC2_SET_AUDIO_DIV_MSB_AUDIO_DIV_MSB_0 = 0x0
	// divide by 2
	CCM_ANALOG_MISC2_SET_AUDIO_DIV_MSB_AUDIO_DIV_MSB_1 = 0x1
	// Position of REG0_STEP_TIME field.
	CCM_ANALOG_MISC2_SET_REG0_STEP_TIME_Pos = 0x18
	// Bit mask of REG0_STEP_TIME field.
	CCM_ANALOG_MISC2_SET_REG0_STEP_TIME_Msk = 0x3000000
	// 64
	CCM_ANALOG_MISC2_SET_REG0_STEP_TIME_64_CLOCKS = 0x0
	// 128
	CCM_ANALOG_MISC2_SET_REG0_STEP_TIME_128_CLOCKS = 0x1
	// 256
	CCM_ANALOG_MISC2_SET_REG0_STEP_TIME_256_CLOCKS = 0x2
	// 512
	CCM_ANALOG_MISC2_SET_REG0_STEP_TIME_512_CLOCKS = 0x3
	// Position of REG1_STEP_TIME field.
	CCM_ANALOG_MISC2_SET_REG1_STEP_TIME_Pos = 0x1a
	// Bit mask of REG1_STEP_TIME field.
	CCM_ANALOG_MISC2_SET_REG1_STEP_TIME_Msk = 0xc000000
	// 64
	CCM_ANALOG_MISC2_SET_REG1_STEP_TIME_64_CLOCKS = 0x0
	// 128
	CCM_ANALOG_MISC2_SET_REG1_STEP_TIME_128_CLOCKS = 0x1
	// 256
	CCM_ANALOG_MISC2_SET_REG1_STEP_TIME_256_CLOCKS = 0x2
	// 512
	CCM_ANALOG_MISC2_SET_REG1_STEP_TIME_512_CLOCKS = 0x3
	// Position of REG2_STEP_TIME field.
	CCM_ANALOG_MISC2_SET_REG2_STEP_TIME_Pos = 0x1c
	// Bit mask of REG2_STEP_TIME field.
	CCM_ANALOG_MISC2_SET_REG2_STEP_TIME_Msk = 0x30000000
	// 64
	CCM_ANALOG_MISC2_SET_REG2_STEP_TIME_64_CLOCKS = 0x0
	// 128
	CCM_ANALOG_MISC2_SET_REG2_STEP_TIME_128_CLOCKS = 0x1
	// 256
	CCM_ANALOG_MISC2_SET_REG2_STEP_TIME_256_CLOCKS = 0x2
	// 512
	CCM_ANALOG_MISC2_SET_REG2_STEP_TIME_512_CLOCKS = 0x3
	// Position of VIDEO_DIV field.
	CCM_ANALOG_MISC2_SET_VIDEO_DIV_Pos = 0x1e
	// Bit mask of VIDEO_DIV field.
	CCM_ANALOG_MISC2_SET_VIDEO_DIV_Msk = 0xc0000000
	// divide by 1 (Default)
	CCM_ANALOG_MISC2_SET_VIDEO_DIV_VIDEO_DIV_0 = 0x0
	// divide by 2
	CCM_ANALOG_MISC2_SET_VIDEO_DIV_VIDEO_DIV_1 = 0x1
	// divide by 1
	CCM_ANALOG_MISC2_SET_VIDEO_DIV_VIDEO_DIV_2 = 0x2
	// divide by 4
	CCM_ANALOG_MISC2_SET_VIDEO_DIV_VIDEO_DIV_3 = 0x3

	// MISC2_CLR: Miscellaneous Register 2
	// Position of REG0_BO_OFFSET field.
	CCM_ANALOG_MISC2_CLR_REG0_BO_OFFSET_Pos = 0x0
	// Bit mask of REG0_BO_OFFSET field.
	CCM_ANALOG_MISC2_CLR_REG0_BO_OFFSET_Msk = 0x7
	// Brownout offset = 0.100V
	CCM_ANALOG_MISC2_CLR_REG0_BO_OFFSET_REG0_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	CCM_ANALOG_MISC2_CLR_REG0_BO_OFFSET_REG0_BO_OFFSET_7 = 0x7
	// Position of REG0_BO_STATUS field.
	CCM_ANALOG_MISC2_CLR_REG0_BO_STATUS_Pos = 0x3
	// Bit mask of REG0_BO_STATUS field.
	CCM_ANALOG_MISC2_CLR_REG0_BO_STATUS_Msk = 0x8
	// Bit REG0_BO_STATUS.
	CCM_ANALOG_MISC2_CLR_REG0_BO_STATUS = 0x8
	// Brownout, supply is below target minus brownout offset.
	CCM_ANALOG_MISC2_CLR_REG0_BO_STATUS_REG0_BO_STATUS_1 = 0x1
	// Position of REG0_ENABLE_BO field.
	CCM_ANALOG_MISC2_CLR_REG0_ENABLE_BO_Pos = 0x5
	// Bit mask of REG0_ENABLE_BO field.
	CCM_ANALOG_MISC2_CLR_REG0_ENABLE_BO_Msk = 0x20
	// Bit REG0_ENABLE_BO.
	CCM_ANALOG_MISC2_CLR_REG0_ENABLE_BO = 0x20
	// Position of REG0_OK field.
	CCM_ANALOG_MISC2_CLR_REG0_OK_Pos = 0x6
	// Bit mask of REG0_OK field.
	CCM_ANALOG_MISC2_CLR_REG0_OK_Msk = 0x40
	// Bit REG0_OK.
	CCM_ANALOG_MISC2_CLR_REG0_OK = 0x40
	// Position of PLL3_DISABLE field.
	CCM_ANALOG_MISC2_CLR_PLL3_DISABLE_Pos = 0x7
	// Bit mask of PLL3_DISABLE field.
	CCM_ANALOG_MISC2_CLR_PLL3_DISABLE_Msk = 0x80
	// Bit PLL3_DISABLE.
	CCM_ANALOG_MISC2_CLR_PLL3_DISABLE = 0x80
	// PLL3 is being used by peripherals and is enabled when SoC is not in any low power mode
	CCM_ANALOG_MISC2_CLR_PLL3_DISABLE_PLL3_DISABLE_0 = 0x0
	// PLL3 can be disabled when the SoC is not in any low power mode
	CCM_ANALOG_MISC2_CLR_PLL3_DISABLE_PLL3_DISABLE_1 = 0x1
	// Position of REG1_BO_OFFSET field.
	CCM_ANALOG_MISC2_CLR_REG1_BO_OFFSET_Pos = 0x8
	// Bit mask of REG1_BO_OFFSET field.
	CCM_ANALOG_MISC2_CLR_REG1_BO_OFFSET_Msk = 0x700
	// Brownout offset = 0.100V
	CCM_ANALOG_MISC2_CLR_REG1_BO_OFFSET_REG1_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	CCM_ANALOG_MISC2_CLR_REG1_BO_OFFSET_REG1_BO_OFFSET_7 = 0x7
	// Position of REG1_BO_STATUS field.
	CCM_ANALOG_MISC2_CLR_REG1_BO_STATUS_Pos = 0xb
	// Bit mask of REG1_BO_STATUS field.
	CCM_ANALOG_MISC2_CLR_REG1_BO_STATUS_Msk = 0x800
	// Bit REG1_BO_STATUS.
	CCM_ANALOG_MISC2_CLR_REG1_BO_STATUS = 0x800
	// Brownout, supply is below target minus brownout offset.
	CCM_ANALOG_MISC2_CLR_REG1_BO_STATUS_REG1_BO_STATUS_1 = 0x1
	// Position of REG1_ENABLE_BO field.
	CCM_ANALOG_MISC2_CLR_REG1_ENABLE_BO_Pos = 0xd
	// Bit mask of REG1_ENABLE_BO field.
	CCM_ANALOG_MISC2_CLR_REG1_ENABLE_BO_Msk = 0x2000
	// Bit REG1_ENABLE_BO.
	CCM_ANALOG_MISC2_CLR_REG1_ENABLE_BO = 0x2000
	// Position of REG1_OK field.
	CCM_ANALOG_MISC2_CLR_REG1_OK_Pos = 0xe
	// Bit mask of REG1_OK field.
	CCM_ANALOG_MISC2_CLR_REG1_OK_Msk = 0x4000
	// Bit REG1_OK.
	CCM_ANALOG_MISC2_CLR_REG1_OK = 0x4000
	// Position of AUDIO_DIV_LSB field.
	CCM_ANALOG_MISC2_CLR_AUDIO_DIV_LSB_Pos = 0xf
	// Bit mask of AUDIO_DIV_LSB field.
	CCM_ANALOG_MISC2_CLR_AUDIO_DIV_LSB_Msk = 0x8000
	// Bit AUDIO_DIV_LSB.
	CCM_ANALOG_MISC2_CLR_AUDIO_DIV_LSB = 0x8000
	// divide by 1 (Default)
	CCM_ANALOG_MISC2_CLR_AUDIO_DIV_LSB_AUDIO_DIV_LSB_0 = 0x0
	// divide by 2
	CCM_ANALOG_MISC2_CLR_AUDIO_DIV_LSB_AUDIO_DIV_LSB_1 = 0x1
	// Position of REG2_BO_OFFSET field.
	CCM_ANALOG_MISC2_CLR_REG2_BO_OFFSET_Pos = 0x10
	// Bit mask of REG2_BO_OFFSET field.
	CCM_ANALOG_MISC2_CLR_REG2_BO_OFFSET_Msk = 0x70000
	// Brownout offset = 0.100V
	CCM_ANALOG_MISC2_CLR_REG2_BO_OFFSET_REG2_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	CCM_ANALOG_MISC2_CLR_REG2_BO_OFFSET_REG2_BO_OFFSET_7 = 0x7
	// Position of REG2_BO_STATUS field.
	CCM_ANALOG_MISC2_CLR_REG2_BO_STATUS_Pos = 0x13
	// Bit mask of REG2_BO_STATUS field.
	CCM_ANALOG_MISC2_CLR_REG2_BO_STATUS_Msk = 0x80000
	// Bit REG2_BO_STATUS.
	CCM_ANALOG_MISC2_CLR_REG2_BO_STATUS = 0x80000
	// Position of REG2_ENABLE_BO field.
	CCM_ANALOG_MISC2_CLR_REG2_ENABLE_BO_Pos = 0x15
	// Bit mask of REG2_ENABLE_BO field.
	CCM_ANALOG_MISC2_CLR_REG2_ENABLE_BO_Msk = 0x200000
	// Bit REG2_ENABLE_BO.
	CCM_ANALOG_MISC2_CLR_REG2_ENABLE_BO = 0x200000
	// Position of REG2_OK field.
	CCM_ANALOG_MISC2_CLR_REG2_OK_Pos = 0x16
	// Bit mask of REG2_OK field.
	CCM_ANALOG_MISC2_CLR_REG2_OK_Msk = 0x400000
	// Bit REG2_OK.
	CCM_ANALOG_MISC2_CLR_REG2_OK = 0x400000
	// Position of AUDIO_DIV_MSB field.
	CCM_ANALOG_MISC2_CLR_AUDIO_DIV_MSB_Pos = 0x17
	// Bit mask of AUDIO_DIV_MSB field.
	CCM_ANALOG_MISC2_CLR_AUDIO_DIV_MSB_Msk = 0x800000
	// Bit AUDIO_DIV_MSB.
	CCM_ANALOG_MISC2_CLR_AUDIO_DIV_MSB = 0x800000
	// divide by 1 (Default)
	CCM_ANALOG_MISC2_CLR_AUDIO_DIV_MSB_AUDIO_DIV_MSB_0 = 0x0
	// divide by 2
	CCM_ANALOG_MISC2_CLR_AUDIO_DIV_MSB_AUDIO_DIV_MSB_1 = 0x1
	// Position of REG0_STEP_TIME field.
	CCM_ANALOG_MISC2_CLR_REG0_STEP_TIME_Pos = 0x18
	// Bit mask of REG0_STEP_TIME field.
	CCM_ANALOG_MISC2_CLR_REG0_STEP_TIME_Msk = 0x3000000
	// 64
	CCM_ANALOG_MISC2_CLR_REG0_STEP_TIME_64_CLOCKS = 0x0
	// 128
	CCM_ANALOG_MISC2_CLR_REG0_STEP_TIME_128_CLOCKS = 0x1
	// 256
	CCM_ANALOG_MISC2_CLR_REG0_STEP_TIME_256_CLOCKS = 0x2
	// 512
	CCM_ANALOG_MISC2_CLR_REG0_STEP_TIME_512_CLOCKS = 0x3
	// Position of REG1_STEP_TIME field.
	CCM_ANALOG_MISC2_CLR_REG1_STEP_TIME_Pos = 0x1a
	// Bit mask of REG1_STEP_TIME field.
	CCM_ANALOG_MISC2_CLR_REG1_STEP_TIME_Msk = 0xc000000
	// 64
	CCM_ANALOG_MISC2_CLR_REG1_STEP_TIME_64_CLOCKS = 0x0
	// 128
	CCM_ANALOG_MISC2_CLR_REG1_STEP_TIME_128_CLOCKS = 0x1
	// 256
	CCM_ANALOG_MISC2_CLR_REG1_STEP_TIME_256_CLOCKS = 0x2
	// 512
	CCM_ANALOG_MISC2_CLR_REG1_STEP_TIME_512_CLOCKS = 0x3
	// Position of REG2_STEP_TIME field.
	CCM_ANALOG_MISC2_CLR_REG2_STEP_TIME_Pos = 0x1c
	// Bit mask of REG2_STEP_TIME field.
	CCM_ANALOG_MISC2_CLR_REG2_STEP_TIME_Msk = 0x30000000
	// 64
	CCM_ANALOG_MISC2_CLR_REG2_STEP_TIME_64_CLOCKS = 0x0
	// 128
	CCM_ANALOG_MISC2_CLR_REG2_STEP_TIME_128_CLOCKS = 0x1
	// 256
	CCM_ANALOG_MISC2_CLR_REG2_STEP_TIME_256_CLOCKS = 0x2
	// 512
	CCM_ANALOG_MISC2_CLR_REG2_STEP_TIME_512_CLOCKS = 0x3
	// Position of VIDEO_DIV field.
	CCM_ANALOG_MISC2_CLR_VIDEO_DIV_Pos = 0x1e
	// Bit mask of VIDEO_DIV field.
	CCM_ANALOG_MISC2_CLR_VIDEO_DIV_Msk = 0xc0000000
	// divide by 1 (Default)
	CCM_ANALOG_MISC2_CLR_VIDEO_DIV_VIDEO_DIV_0 = 0x0
	// divide by 2
	CCM_ANALOG_MISC2_CLR_VIDEO_DIV_VIDEO_DIV_1 = 0x1
	// divide by 1
	CCM_ANALOG_MISC2_CLR_VIDEO_DIV_VIDEO_DIV_2 = 0x2
	// divide by 4
	CCM_ANALOG_MISC2_CLR_VIDEO_DIV_VIDEO_DIV_3 = 0x3

	// MISC2_TOG: Miscellaneous Register 2
	// Position of REG0_BO_OFFSET field.
	CCM_ANALOG_MISC2_TOG_REG0_BO_OFFSET_Pos = 0x0
	// Bit mask of REG0_BO_OFFSET field.
	CCM_ANALOG_MISC2_TOG_REG0_BO_OFFSET_Msk = 0x7
	// Brownout offset = 0.100V
	CCM_ANALOG_MISC2_TOG_REG0_BO_OFFSET_REG0_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	CCM_ANALOG_MISC2_TOG_REG0_BO_OFFSET_REG0_BO_OFFSET_7 = 0x7
	// Position of REG0_BO_STATUS field.
	CCM_ANALOG_MISC2_TOG_REG0_BO_STATUS_Pos = 0x3
	// Bit mask of REG0_BO_STATUS field.
	CCM_ANALOG_MISC2_TOG_REG0_BO_STATUS_Msk = 0x8
	// Bit REG0_BO_STATUS.
	CCM_ANALOG_MISC2_TOG_REG0_BO_STATUS = 0x8
	// Brownout, supply is below target minus brownout offset.
	CCM_ANALOG_MISC2_TOG_REG0_BO_STATUS_REG0_BO_STATUS_1 = 0x1
	// Position of REG0_ENABLE_BO field.
	CCM_ANALOG_MISC2_TOG_REG0_ENABLE_BO_Pos = 0x5
	// Bit mask of REG0_ENABLE_BO field.
	CCM_ANALOG_MISC2_TOG_REG0_ENABLE_BO_Msk = 0x20
	// Bit REG0_ENABLE_BO.
	CCM_ANALOG_MISC2_TOG_REG0_ENABLE_BO = 0x20
	// Position of REG0_OK field.
	CCM_ANALOG_MISC2_TOG_REG0_OK_Pos = 0x6
	// Bit mask of REG0_OK field.
	CCM_ANALOG_MISC2_TOG_REG0_OK_Msk = 0x40
	// Bit REG0_OK.
	CCM_ANALOG_MISC2_TOG_REG0_OK = 0x40
	// Position of PLL3_DISABLE field.
	CCM_ANALOG_MISC2_TOG_PLL3_DISABLE_Pos = 0x7
	// Bit mask of PLL3_DISABLE field.
	CCM_ANALOG_MISC2_TOG_PLL3_DISABLE_Msk = 0x80
	// Bit PLL3_DISABLE.
	CCM_ANALOG_MISC2_TOG_PLL3_DISABLE = 0x80
	// PLL3 is being used by peripherals and is enabled when SoC is not in any low power mode
	CCM_ANALOG_MISC2_TOG_PLL3_DISABLE_PLL3_DISABLE_0 = 0x0
	// PLL3 can be disabled when the SoC is not in any low power mode
	CCM_ANALOG_MISC2_TOG_PLL3_DISABLE_PLL3_DISABLE_1 = 0x1
	// Position of REG1_BO_OFFSET field.
	CCM_ANALOG_MISC2_TOG_REG1_BO_OFFSET_Pos = 0x8
	// Bit mask of REG1_BO_OFFSET field.
	CCM_ANALOG_MISC2_TOG_REG1_BO_OFFSET_Msk = 0x700
	// Brownout offset = 0.100V
	CCM_ANALOG_MISC2_TOG_REG1_BO_OFFSET_REG1_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	CCM_ANALOG_MISC2_TOG_REG1_BO_OFFSET_REG1_BO_OFFSET_7 = 0x7
	// Position of REG1_BO_STATUS field.
	CCM_ANALOG_MISC2_TOG_REG1_BO_STATUS_Pos = 0xb
	// Bit mask of REG1_BO_STATUS field.
	CCM_ANALOG_MISC2_TOG_REG1_BO_STATUS_Msk = 0x800
	// Bit REG1_BO_STATUS.
	CCM_ANALOG_MISC2_TOG_REG1_BO_STATUS = 0x800
	// Brownout, supply is below target minus brownout offset.
	CCM_ANALOG_MISC2_TOG_REG1_BO_STATUS_REG1_BO_STATUS_1 = 0x1
	// Position of REG1_ENABLE_BO field.
	CCM_ANALOG_MISC2_TOG_REG1_ENABLE_BO_Pos = 0xd
	// Bit mask of REG1_ENABLE_BO field.
	CCM_ANALOG_MISC2_TOG_REG1_ENABLE_BO_Msk = 0x2000
	// Bit REG1_ENABLE_BO.
	CCM_ANALOG_MISC2_TOG_REG1_ENABLE_BO = 0x2000
	// Position of REG1_OK field.
	CCM_ANALOG_MISC2_TOG_REG1_OK_Pos = 0xe
	// Bit mask of REG1_OK field.
	CCM_ANALOG_MISC2_TOG_REG1_OK_Msk = 0x4000
	// Bit REG1_OK.
	CCM_ANALOG_MISC2_TOG_REG1_OK = 0x4000
	// Position of AUDIO_DIV_LSB field.
	CCM_ANALOG_MISC2_TOG_AUDIO_DIV_LSB_Pos = 0xf
	// Bit mask of AUDIO_DIV_LSB field.
	CCM_ANALOG_MISC2_TOG_AUDIO_DIV_LSB_Msk = 0x8000
	// Bit AUDIO_DIV_LSB.
	CCM_ANALOG_MISC2_TOG_AUDIO_DIV_LSB = 0x8000
	// divide by 1 (Default)
	CCM_ANALOG_MISC2_TOG_AUDIO_DIV_LSB_AUDIO_DIV_LSB_0 = 0x0
	// divide by 2
	CCM_ANALOG_MISC2_TOG_AUDIO_DIV_LSB_AUDIO_DIV_LSB_1 = 0x1
	// Position of REG2_BO_OFFSET field.
	CCM_ANALOG_MISC2_TOG_REG2_BO_OFFSET_Pos = 0x10
	// Bit mask of REG2_BO_OFFSET field.
	CCM_ANALOG_MISC2_TOG_REG2_BO_OFFSET_Msk = 0x70000
	// Brownout offset = 0.100V
	CCM_ANALOG_MISC2_TOG_REG2_BO_OFFSET_REG2_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	CCM_ANALOG_MISC2_TOG_REG2_BO_OFFSET_REG2_BO_OFFSET_7 = 0x7
	// Position of REG2_BO_STATUS field.
	CCM_ANALOG_MISC2_TOG_REG2_BO_STATUS_Pos = 0x13
	// Bit mask of REG2_BO_STATUS field.
	CCM_ANALOG_MISC2_TOG_REG2_BO_STATUS_Msk = 0x80000
	// Bit REG2_BO_STATUS.
	CCM_ANALOG_MISC2_TOG_REG2_BO_STATUS = 0x80000
	// Position of REG2_ENABLE_BO field.
	CCM_ANALOG_MISC2_TOG_REG2_ENABLE_BO_Pos = 0x15
	// Bit mask of REG2_ENABLE_BO field.
	CCM_ANALOG_MISC2_TOG_REG2_ENABLE_BO_Msk = 0x200000
	// Bit REG2_ENABLE_BO.
	CCM_ANALOG_MISC2_TOG_REG2_ENABLE_BO = 0x200000
	// Position of REG2_OK field.
	CCM_ANALOG_MISC2_TOG_REG2_OK_Pos = 0x16
	// Bit mask of REG2_OK field.
	CCM_ANALOG_MISC2_TOG_REG2_OK_Msk = 0x400000
	// Bit REG2_OK.
	CCM_ANALOG_MISC2_TOG_REG2_OK = 0x400000
	// Position of AUDIO_DIV_MSB field.
	CCM_ANALOG_MISC2_TOG_AUDIO_DIV_MSB_Pos = 0x17
	// Bit mask of AUDIO_DIV_MSB field.
	CCM_ANALOG_MISC2_TOG_AUDIO_DIV_MSB_Msk = 0x800000
	// Bit AUDIO_DIV_MSB.
	CCM_ANALOG_MISC2_TOG_AUDIO_DIV_MSB = 0x800000
	// divide by 1 (Default)
	CCM_ANALOG_MISC2_TOG_AUDIO_DIV_MSB_AUDIO_DIV_MSB_0 = 0x0
	// divide by 2
	CCM_ANALOG_MISC2_TOG_AUDIO_DIV_MSB_AUDIO_DIV_MSB_1 = 0x1
	// Position of REG0_STEP_TIME field.
	CCM_ANALOG_MISC2_TOG_REG0_STEP_TIME_Pos = 0x18
	// Bit mask of REG0_STEP_TIME field.
	CCM_ANALOG_MISC2_TOG_REG0_STEP_TIME_Msk = 0x3000000
	// 64
	CCM_ANALOG_MISC2_TOG_REG0_STEP_TIME_64_CLOCKS = 0x0
	// 128
	CCM_ANALOG_MISC2_TOG_REG0_STEP_TIME_128_CLOCKS = 0x1
	// 256
	CCM_ANALOG_MISC2_TOG_REG0_STEP_TIME_256_CLOCKS = 0x2
	// 512
	CCM_ANALOG_MISC2_TOG_REG0_STEP_TIME_512_CLOCKS = 0x3
	// Position of REG1_STEP_TIME field.
	CCM_ANALOG_MISC2_TOG_REG1_STEP_TIME_Pos = 0x1a
	// Bit mask of REG1_STEP_TIME field.
	CCM_ANALOG_MISC2_TOG_REG1_STEP_TIME_Msk = 0xc000000
	// 64
	CCM_ANALOG_MISC2_TOG_REG1_STEP_TIME_64_CLOCKS = 0x0
	// 128
	CCM_ANALOG_MISC2_TOG_REG1_STEP_TIME_128_CLOCKS = 0x1
	// 256
	CCM_ANALOG_MISC2_TOG_REG1_STEP_TIME_256_CLOCKS = 0x2
	// 512
	CCM_ANALOG_MISC2_TOG_REG1_STEP_TIME_512_CLOCKS = 0x3
	// Position of REG2_STEP_TIME field.
	CCM_ANALOG_MISC2_TOG_REG2_STEP_TIME_Pos = 0x1c
	// Bit mask of REG2_STEP_TIME field.
	CCM_ANALOG_MISC2_TOG_REG2_STEP_TIME_Msk = 0x30000000
	// 64
	CCM_ANALOG_MISC2_TOG_REG2_STEP_TIME_64_CLOCKS = 0x0
	// 128
	CCM_ANALOG_MISC2_TOG_REG2_STEP_TIME_128_CLOCKS = 0x1
	// 256
	CCM_ANALOG_MISC2_TOG_REG2_STEP_TIME_256_CLOCKS = 0x2
	// 512
	CCM_ANALOG_MISC2_TOG_REG2_STEP_TIME_512_CLOCKS = 0x3
	// Position of VIDEO_DIV field.
	CCM_ANALOG_MISC2_TOG_VIDEO_DIV_Pos = 0x1e
	// Bit mask of VIDEO_DIV field.
	CCM_ANALOG_MISC2_TOG_VIDEO_DIV_Msk = 0xc0000000
	// divide by 1 (Default)
	CCM_ANALOG_MISC2_TOG_VIDEO_DIV_VIDEO_DIV_0 = 0x0
	// divide by 2
	CCM_ANALOG_MISC2_TOG_VIDEO_DIV_VIDEO_DIV_1 = 0x1
	// divide by 1
	CCM_ANALOG_MISC2_TOG_VIDEO_DIV_VIDEO_DIV_2 = 0x2
	// divide by 4
	CCM_ANALOG_MISC2_TOG_VIDEO_DIV_VIDEO_DIV_3 = 0x3
)

// Bitfields for PMU: PMU
const (
	// REG_1P1: Regulator 1P1 Register
	// Position of ENABLE_LINREG field.
	PMU_REG_1P1_ENABLE_LINREG_Pos = 0x0
	// Bit mask of ENABLE_LINREG field.
	PMU_REG_1P1_ENABLE_LINREG_Msk = 0x1
	// Bit ENABLE_LINREG.
	PMU_REG_1P1_ENABLE_LINREG = 0x1
	// Position of ENABLE_BO field.
	PMU_REG_1P1_ENABLE_BO_Pos = 0x1
	// Bit mask of ENABLE_BO field.
	PMU_REG_1P1_ENABLE_BO_Msk = 0x2
	// Bit ENABLE_BO.
	PMU_REG_1P1_ENABLE_BO = 0x2
	// Position of ENABLE_ILIMIT field.
	PMU_REG_1P1_ENABLE_ILIMIT_Pos = 0x2
	// Bit mask of ENABLE_ILIMIT field.
	PMU_REG_1P1_ENABLE_ILIMIT_Msk = 0x4
	// Bit ENABLE_ILIMIT.
	PMU_REG_1P1_ENABLE_ILIMIT = 0x4
	// Position of ENABLE_PULLDOWN field.
	PMU_REG_1P1_ENABLE_PULLDOWN_Pos = 0x3
	// Bit mask of ENABLE_PULLDOWN field.
	PMU_REG_1P1_ENABLE_PULLDOWN_Msk = 0x8
	// Bit ENABLE_PULLDOWN.
	PMU_REG_1P1_ENABLE_PULLDOWN = 0x8
	// Position of BO_OFFSET field.
	PMU_REG_1P1_BO_OFFSET_Pos = 0x4
	// Bit mask of BO_OFFSET field.
	PMU_REG_1P1_BO_OFFSET_Msk = 0x70
	// Position of OUTPUT_TRG field.
	PMU_REG_1P1_OUTPUT_TRG_Pos = 0x8
	// Bit mask of OUTPUT_TRG field.
	PMU_REG_1P1_OUTPUT_TRG_Msk = 0x1f00
	// 0.8V
	PMU_REG_1P1_OUTPUT_TRG_OUTPUT_TRG_4 = 0x4
	// 1.1V
	PMU_REG_1P1_OUTPUT_TRG_OUTPUT_TRG_16 = 0x10
	// Position of BO_VDD1P1 field.
	PMU_REG_1P1_BO_VDD1P1_Pos = 0x10
	// Bit mask of BO_VDD1P1 field.
	PMU_REG_1P1_BO_VDD1P1_Msk = 0x10000
	// Bit BO_VDD1P1.
	PMU_REG_1P1_BO_VDD1P1 = 0x10000
	// Position of OK_VDD1P1 field.
	PMU_REG_1P1_OK_VDD1P1_Pos = 0x11
	// Bit mask of OK_VDD1P1 field.
	PMU_REG_1P1_OK_VDD1P1_Msk = 0x20000
	// Bit OK_VDD1P1.
	PMU_REG_1P1_OK_VDD1P1 = 0x20000
	// Position of ENABLE_WEAK_LINREG field.
	PMU_REG_1P1_ENABLE_WEAK_LINREG_Pos = 0x12
	// Bit mask of ENABLE_WEAK_LINREG field.
	PMU_REG_1P1_ENABLE_WEAK_LINREG_Msk = 0x40000
	// Bit ENABLE_WEAK_LINREG.
	PMU_REG_1P1_ENABLE_WEAK_LINREG = 0x40000
	// Position of SELREF_WEAK_LINREG field.
	PMU_REG_1P1_SELREF_WEAK_LINREG_Pos = 0x13
	// Bit mask of SELREF_WEAK_LINREG field.
	PMU_REG_1P1_SELREF_WEAK_LINREG_Msk = 0x80000
	// Bit SELREF_WEAK_LINREG.
	PMU_REG_1P1_SELREF_WEAK_LINREG = 0x80000
	// Weak-linreg output tracks low-power-bandgap voltage
	PMU_REG_1P1_SELREF_WEAK_LINREG_SELREF_WEAK_LINREG_0 = 0x0
	// Weak-linreg output tracks VDD_SOC_IN voltage
	PMU_REG_1P1_SELREF_WEAK_LINREG_SELREF_WEAK_LINREG_1 = 0x1

	// REG_1P1_SET: Regulator 1P1 Register
	// Position of ENABLE_LINREG field.
	PMU_REG_1P1_SET_ENABLE_LINREG_Pos = 0x0
	// Bit mask of ENABLE_LINREG field.
	PMU_REG_1P1_SET_ENABLE_LINREG_Msk = 0x1
	// Bit ENABLE_LINREG.
	PMU_REG_1P1_SET_ENABLE_LINREG = 0x1
	// Position of ENABLE_BO field.
	PMU_REG_1P1_SET_ENABLE_BO_Pos = 0x1
	// Bit mask of ENABLE_BO field.
	PMU_REG_1P1_SET_ENABLE_BO_Msk = 0x2
	// Bit ENABLE_BO.
	PMU_REG_1P1_SET_ENABLE_BO = 0x2
	// Position of ENABLE_ILIMIT field.
	PMU_REG_1P1_SET_ENABLE_ILIMIT_Pos = 0x2
	// Bit mask of ENABLE_ILIMIT field.
	PMU_REG_1P1_SET_ENABLE_ILIMIT_Msk = 0x4
	// Bit ENABLE_ILIMIT.
	PMU_REG_1P1_SET_ENABLE_ILIMIT = 0x4
	// Position of ENABLE_PULLDOWN field.
	PMU_REG_1P1_SET_ENABLE_PULLDOWN_Pos = 0x3
	// Bit mask of ENABLE_PULLDOWN field.
	PMU_REG_1P1_SET_ENABLE_PULLDOWN_Msk = 0x8
	// Bit ENABLE_PULLDOWN.
	PMU_REG_1P1_SET_ENABLE_PULLDOWN = 0x8
	// Position of BO_OFFSET field.
	PMU_REG_1P1_SET_BO_OFFSET_Pos = 0x4
	// Bit mask of BO_OFFSET field.
	PMU_REG_1P1_SET_BO_OFFSET_Msk = 0x70
	// Position of OUTPUT_TRG field.
	PMU_REG_1P1_SET_OUTPUT_TRG_Pos = 0x8
	// Bit mask of OUTPUT_TRG field.
	PMU_REG_1P1_SET_OUTPUT_TRG_Msk = 0x1f00
	// 0.8V
	PMU_REG_1P1_SET_OUTPUT_TRG_OUTPUT_TRG_4 = 0x4
	// 1.1V
	PMU_REG_1P1_SET_OUTPUT_TRG_OUTPUT_TRG_16 = 0x10
	// Position of BO_VDD1P1 field.
	PMU_REG_1P1_SET_BO_VDD1P1_Pos = 0x10
	// Bit mask of BO_VDD1P1 field.
	PMU_REG_1P1_SET_BO_VDD1P1_Msk = 0x10000
	// Bit BO_VDD1P1.
	PMU_REG_1P1_SET_BO_VDD1P1 = 0x10000
	// Position of OK_VDD1P1 field.
	PMU_REG_1P1_SET_OK_VDD1P1_Pos = 0x11
	// Bit mask of OK_VDD1P1 field.
	PMU_REG_1P1_SET_OK_VDD1P1_Msk = 0x20000
	// Bit OK_VDD1P1.
	PMU_REG_1P1_SET_OK_VDD1P1 = 0x20000
	// Position of ENABLE_WEAK_LINREG field.
	PMU_REG_1P1_SET_ENABLE_WEAK_LINREG_Pos = 0x12
	// Bit mask of ENABLE_WEAK_LINREG field.
	PMU_REG_1P1_SET_ENABLE_WEAK_LINREG_Msk = 0x40000
	// Bit ENABLE_WEAK_LINREG.
	PMU_REG_1P1_SET_ENABLE_WEAK_LINREG = 0x40000
	// Position of SELREF_WEAK_LINREG field.
	PMU_REG_1P1_SET_SELREF_WEAK_LINREG_Pos = 0x13
	// Bit mask of SELREF_WEAK_LINREG field.
	PMU_REG_1P1_SET_SELREF_WEAK_LINREG_Msk = 0x80000
	// Bit SELREF_WEAK_LINREG.
	PMU_REG_1P1_SET_SELREF_WEAK_LINREG = 0x80000
	// Weak-linreg output tracks low-power-bandgap voltage
	PMU_REG_1P1_SET_SELREF_WEAK_LINREG_SELREF_WEAK_LINREG_0 = 0x0
	// Weak-linreg output tracks VDD_SOC_IN voltage
	PMU_REG_1P1_SET_SELREF_WEAK_LINREG_SELREF_WEAK_LINREG_1 = 0x1

	// REG_1P1_CLR: Regulator 1P1 Register
	// Position of ENABLE_LINREG field.
	PMU_REG_1P1_CLR_ENABLE_LINREG_Pos = 0x0
	// Bit mask of ENABLE_LINREG field.
	PMU_REG_1P1_CLR_ENABLE_LINREG_Msk = 0x1
	// Bit ENABLE_LINREG.
	PMU_REG_1P1_CLR_ENABLE_LINREG = 0x1
	// Position of ENABLE_BO field.
	PMU_REG_1P1_CLR_ENABLE_BO_Pos = 0x1
	// Bit mask of ENABLE_BO field.
	PMU_REG_1P1_CLR_ENABLE_BO_Msk = 0x2
	// Bit ENABLE_BO.
	PMU_REG_1P1_CLR_ENABLE_BO = 0x2
	// Position of ENABLE_ILIMIT field.
	PMU_REG_1P1_CLR_ENABLE_ILIMIT_Pos = 0x2
	// Bit mask of ENABLE_ILIMIT field.
	PMU_REG_1P1_CLR_ENABLE_ILIMIT_Msk = 0x4
	// Bit ENABLE_ILIMIT.
	PMU_REG_1P1_CLR_ENABLE_ILIMIT = 0x4
	// Position of ENABLE_PULLDOWN field.
	PMU_REG_1P1_CLR_ENABLE_PULLDOWN_Pos = 0x3
	// Bit mask of ENABLE_PULLDOWN field.
	PMU_REG_1P1_CLR_ENABLE_PULLDOWN_Msk = 0x8
	// Bit ENABLE_PULLDOWN.
	PMU_REG_1P1_CLR_ENABLE_PULLDOWN = 0x8
	// Position of BO_OFFSET field.
	PMU_REG_1P1_CLR_BO_OFFSET_Pos = 0x4
	// Bit mask of BO_OFFSET field.
	PMU_REG_1P1_CLR_BO_OFFSET_Msk = 0x70
	// Position of OUTPUT_TRG field.
	PMU_REG_1P1_CLR_OUTPUT_TRG_Pos = 0x8
	// Bit mask of OUTPUT_TRG field.
	PMU_REG_1P1_CLR_OUTPUT_TRG_Msk = 0x1f00
	// 0.8V
	PMU_REG_1P1_CLR_OUTPUT_TRG_OUTPUT_TRG_4 = 0x4
	// 1.1V
	PMU_REG_1P1_CLR_OUTPUT_TRG_OUTPUT_TRG_16 = 0x10
	// Position of BO_VDD1P1 field.
	PMU_REG_1P1_CLR_BO_VDD1P1_Pos = 0x10
	// Bit mask of BO_VDD1P1 field.
	PMU_REG_1P1_CLR_BO_VDD1P1_Msk = 0x10000
	// Bit BO_VDD1P1.
	PMU_REG_1P1_CLR_BO_VDD1P1 = 0x10000
	// Position of OK_VDD1P1 field.
	PMU_REG_1P1_CLR_OK_VDD1P1_Pos = 0x11
	// Bit mask of OK_VDD1P1 field.
	PMU_REG_1P1_CLR_OK_VDD1P1_Msk = 0x20000
	// Bit OK_VDD1P1.
	PMU_REG_1P1_CLR_OK_VDD1P1 = 0x20000
	// Position of ENABLE_WEAK_LINREG field.
	PMU_REG_1P1_CLR_ENABLE_WEAK_LINREG_Pos = 0x12
	// Bit mask of ENABLE_WEAK_LINREG field.
	PMU_REG_1P1_CLR_ENABLE_WEAK_LINREG_Msk = 0x40000
	// Bit ENABLE_WEAK_LINREG.
	PMU_REG_1P1_CLR_ENABLE_WEAK_LINREG = 0x40000
	// Position of SELREF_WEAK_LINREG field.
	PMU_REG_1P1_CLR_SELREF_WEAK_LINREG_Pos = 0x13
	// Bit mask of SELREF_WEAK_LINREG field.
	PMU_REG_1P1_CLR_SELREF_WEAK_LINREG_Msk = 0x80000
	// Bit SELREF_WEAK_LINREG.
	PMU_REG_1P1_CLR_SELREF_WEAK_LINREG = 0x80000
	// Weak-linreg output tracks low-power-bandgap voltage
	PMU_REG_1P1_CLR_SELREF_WEAK_LINREG_SELREF_WEAK_LINREG_0 = 0x0
	// Weak-linreg output tracks VDD_SOC_IN voltage
	PMU_REG_1P1_CLR_SELREF_WEAK_LINREG_SELREF_WEAK_LINREG_1 = 0x1

	// REG_1P1_TOG: Regulator 1P1 Register
	// Position of ENABLE_LINREG field.
	PMU_REG_1P1_TOG_ENABLE_LINREG_Pos = 0x0
	// Bit mask of ENABLE_LINREG field.
	PMU_REG_1P1_TOG_ENABLE_LINREG_Msk = 0x1
	// Bit ENABLE_LINREG.
	PMU_REG_1P1_TOG_ENABLE_LINREG = 0x1
	// Position of ENABLE_BO field.
	PMU_REG_1P1_TOG_ENABLE_BO_Pos = 0x1
	// Bit mask of ENABLE_BO field.
	PMU_REG_1P1_TOG_ENABLE_BO_Msk = 0x2
	// Bit ENABLE_BO.
	PMU_REG_1P1_TOG_ENABLE_BO = 0x2
	// Position of ENABLE_ILIMIT field.
	PMU_REG_1P1_TOG_ENABLE_ILIMIT_Pos = 0x2
	// Bit mask of ENABLE_ILIMIT field.
	PMU_REG_1P1_TOG_ENABLE_ILIMIT_Msk = 0x4
	// Bit ENABLE_ILIMIT.
	PMU_REG_1P1_TOG_ENABLE_ILIMIT = 0x4
	// Position of ENABLE_PULLDOWN field.
	PMU_REG_1P1_TOG_ENABLE_PULLDOWN_Pos = 0x3
	// Bit mask of ENABLE_PULLDOWN field.
	PMU_REG_1P1_TOG_ENABLE_PULLDOWN_Msk = 0x8
	// Bit ENABLE_PULLDOWN.
	PMU_REG_1P1_TOG_ENABLE_PULLDOWN = 0x8
	// Position of BO_OFFSET field.
	PMU_REG_1P1_TOG_BO_OFFSET_Pos = 0x4
	// Bit mask of BO_OFFSET field.
	PMU_REG_1P1_TOG_BO_OFFSET_Msk = 0x70
	// Position of OUTPUT_TRG field.
	PMU_REG_1P1_TOG_OUTPUT_TRG_Pos = 0x8
	// Bit mask of OUTPUT_TRG field.
	PMU_REG_1P1_TOG_OUTPUT_TRG_Msk = 0x1f00
	// 0.8V
	PMU_REG_1P1_TOG_OUTPUT_TRG_OUTPUT_TRG_4 = 0x4
	// 1.1V
	PMU_REG_1P1_TOG_OUTPUT_TRG_OUTPUT_TRG_16 = 0x10
	// Position of BO_VDD1P1 field.
	PMU_REG_1P1_TOG_BO_VDD1P1_Pos = 0x10
	// Bit mask of BO_VDD1P1 field.
	PMU_REG_1P1_TOG_BO_VDD1P1_Msk = 0x10000
	// Bit BO_VDD1P1.
	PMU_REG_1P1_TOG_BO_VDD1P1 = 0x10000
	// Position of OK_VDD1P1 field.
	PMU_REG_1P1_TOG_OK_VDD1P1_Pos = 0x11
	// Bit mask of OK_VDD1P1 field.
	PMU_REG_1P1_TOG_OK_VDD1P1_Msk = 0x20000
	// Bit OK_VDD1P1.
	PMU_REG_1P1_TOG_OK_VDD1P1 = 0x20000
	// Position of ENABLE_WEAK_LINREG field.
	PMU_REG_1P1_TOG_ENABLE_WEAK_LINREG_Pos = 0x12
	// Bit mask of ENABLE_WEAK_LINREG field.
	PMU_REG_1P1_TOG_ENABLE_WEAK_LINREG_Msk = 0x40000
	// Bit ENABLE_WEAK_LINREG.
	PMU_REG_1P1_TOG_ENABLE_WEAK_LINREG = 0x40000
	// Position of SELREF_WEAK_LINREG field.
	PMU_REG_1P1_TOG_SELREF_WEAK_LINREG_Pos = 0x13
	// Bit mask of SELREF_WEAK_LINREG field.
	PMU_REG_1P1_TOG_SELREF_WEAK_LINREG_Msk = 0x80000
	// Bit SELREF_WEAK_LINREG.
	PMU_REG_1P1_TOG_SELREF_WEAK_LINREG = 0x80000
	// Weak-linreg output tracks low-power-bandgap voltage
	PMU_REG_1P1_TOG_SELREF_WEAK_LINREG_SELREF_WEAK_LINREG_0 = 0x0
	// Weak-linreg output tracks VDD_SOC_IN voltage
	PMU_REG_1P1_TOG_SELREF_WEAK_LINREG_SELREF_WEAK_LINREG_1 = 0x1

	// REG_3P0: Regulator 3P0 Register
	// Position of ENABLE_LINREG field.
	PMU_REG_3P0_ENABLE_LINREG_Pos = 0x0
	// Bit mask of ENABLE_LINREG field.
	PMU_REG_3P0_ENABLE_LINREG_Msk = 0x1
	// Bit ENABLE_LINREG.
	PMU_REG_3P0_ENABLE_LINREG = 0x1
	// Position of ENABLE_BO field.
	PMU_REG_3P0_ENABLE_BO_Pos = 0x1
	// Bit mask of ENABLE_BO field.
	PMU_REG_3P0_ENABLE_BO_Msk = 0x2
	// Bit ENABLE_BO.
	PMU_REG_3P0_ENABLE_BO = 0x2
	// Position of ENABLE_ILIMIT field.
	PMU_REG_3P0_ENABLE_ILIMIT_Pos = 0x2
	// Bit mask of ENABLE_ILIMIT field.
	PMU_REG_3P0_ENABLE_ILIMIT_Msk = 0x4
	// Bit ENABLE_ILIMIT.
	PMU_REG_3P0_ENABLE_ILIMIT = 0x4
	// Position of BO_OFFSET field.
	PMU_REG_3P0_BO_OFFSET_Pos = 0x4
	// Bit mask of BO_OFFSET field.
	PMU_REG_3P0_BO_OFFSET_Msk = 0x70
	// Position of VBUS_SEL field.
	PMU_REG_3P0_VBUS_SEL_Pos = 0x7
	// Bit mask of VBUS_SEL field.
	PMU_REG_3P0_VBUS_SEL_Msk = 0x80
	// Bit VBUS_SEL.
	PMU_REG_3P0_VBUS_SEL = 0x80
	// Utilize VBUS OTG2 power
	PMU_REG_3P0_VBUS_SEL_USB_OTG2_VBUS = 0x0
	// Utilize VBUS OTG1 power
	PMU_REG_3P0_VBUS_SEL_USB_OTG1_VBUS = 0x1
	// Position of OUTPUT_TRG field.
	PMU_REG_3P0_OUTPUT_TRG_Pos = 0x8
	// Bit mask of OUTPUT_TRG field.
	PMU_REG_3P0_OUTPUT_TRG_Msk = 0x1f00
	// 2.625V
	PMU_REG_3P0_OUTPUT_TRG_OUTPUT_TRG_0 = 0x0
	// 3.000V
	PMU_REG_3P0_OUTPUT_TRG_OUTPUT_TRG_15 = 0xf
	// 3.400V
	PMU_REG_3P0_OUTPUT_TRG_OUTPUT_TRG_31 = 0x1f
	// Position of BO_VDD3P0 field.
	PMU_REG_3P0_BO_VDD3P0_Pos = 0x10
	// Bit mask of BO_VDD3P0 field.
	PMU_REG_3P0_BO_VDD3P0_Msk = 0x10000
	// Bit BO_VDD3P0.
	PMU_REG_3P0_BO_VDD3P0 = 0x10000
	// Position of OK_VDD3P0 field.
	PMU_REG_3P0_OK_VDD3P0_Pos = 0x11
	// Bit mask of OK_VDD3P0 field.
	PMU_REG_3P0_OK_VDD3P0_Msk = 0x20000
	// Bit OK_VDD3P0.
	PMU_REG_3P0_OK_VDD3P0 = 0x20000

	// REG_3P0_SET: Regulator 3P0 Register
	// Position of ENABLE_LINREG field.
	PMU_REG_3P0_SET_ENABLE_LINREG_Pos = 0x0
	// Bit mask of ENABLE_LINREG field.
	PMU_REG_3P0_SET_ENABLE_LINREG_Msk = 0x1
	// Bit ENABLE_LINREG.
	PMU_REG_3P0_SET_ENABLE_LINREG = 0x1
	// Position of ENABLE_BO field.
	PMU_REG_3P0_SET_ENABLE_BO_Pos = 0x1
	// Bit mask of ENABLE_BO field.
	PMU_REG_3P0_SET_ENABLE_BO_Msk = 0x2
	// Bit ENABLE_BO.
	PMU_REG_3P0_SET_ENABLE_BO = 0x2
	// Position of ENABLE_ILIMIT field.
	PMU_REG_3P0_SET_ENABLE_ILIMIT_Pos = 0x2
	// Bit mask of ENABLE_ILIMIT field.
	PMU_REG_3P0_SET_ENABLE_ILIMIT_Msk = 0x4
	// Bit ENABLE_ILIMIT.
	PMU_REG_3P0_SET_ENABLE_ILIMIT = 0x4
	// Position of BO_OFFSET field.
	PMU_REG_3P0_SET_BO_OFFSET_Pos = 0x4
	// Bit mask of BO_OFFSET field.
	PMU_REG_3P0_SET_BO_OFFSET_Msk = 0x70
	// Position of VBUS_SEL field.
	PMU_REG_3P0_SET_VBUS_SEL_Pos = 0x7
	// Bit mask of VBUS_SEL field.
	PMU_REG_3P0_SET_VBUS_SEL_Msk = 0x80
	// Bit VBUS_SEL.
	PMU_REG_3P0_SET_VBUS_SEL = 0x80
	// Utilize VBUS OTG2 power
	PMU_REG_3P0_SET_VBUS_SEL_USB_OTG2_VBUS = 0x0
	// Utilize VBUS OTG1 power
	PMU_REG_3P0_SET_VBUS_SEL_USB_OTG1_VBUS = 0x1
	// Position of OUTPUT_TRG field.
	PMU_REG_3P0_SET_OUTPUT_TRG_Pos = 0x8
	// Bit mask of OUTPUT_TRG field.
	PMU_REG_3P0_SET_OUTPUT_TRG_Msk = 0x1f00
	// 2.625V
	PMU_REG_3P0_SET_OUTPUT_TRG_OUTPUT_TRG_0 = 0x0
	// 3.000V
	PMU_REG_3P0_SET_OUTPUT_TRG_OUTPUT_TRG_15 = 0xf
	// 3.400V
	PMU_REG_3P0_SET_OUTPUT_TRG_OUTPUT_TRG_31 = 0x1f
	// Position of BO_VDD3P0 field.
	PMU_REG_3P0_SET_BO_VDD3P0_Pos = 0x10
	// Bit mask of BO_VDD3P0 field.
	PMU_REG_3P0_SET_BO_VDD3P0_Msk = 0x10000
	// Bit BO_VDD3P0.
	PMU_REG_3P0_SET_BO_VDD3P0 = 0x10000
	// Position of OK_VDD3P0 field.
	PMU_REG_3P0_SET_OK_VDD3P0_Pos = 0x11
	// Bit mask of OK_VDD3P0 field.
	PMU_REG_3P0_SET_OK_VDD3P0_Msk = 0x20000
	// Bit OK_VDD3P0.
	PMU_REG_3P0_SET_OK_VDD3P0 = 0x20000

	// REG_3P0_CLR: Regulator 3P0 Register
	// Position of ENABLE_LINREG field.
	PMU_REG_3P0_CLR_ENABLE_LINREG_Pos = 0x0
	// Bit mask of ENABLE_LINREG field.
	PMU_REG_3P0_CLR_ENABLE_LINREG_Msk = 0x1
	// Bit ENABLE_LINREG.
	PMU_REG_3P0_CLR_ENABLE_LINREG = 0x1
	// Position of ENABLE_BO field.
	PMU_REG_3P0_CLR_ENABLE_BO_Pos = 0x1
	// Bit mask of ENABLE_BO field.
	PMU_REG_3P0_CLR_ENABLE_BO_Msk = 0x2
	// Bit ENABLE_BO.
	PMU_REG_3P0_CLR_ENABLE_BO = 0x2
	// Position of ENABLE_ILIMIT field.
	PMU_REG_3P0_CLR_ENABLE_ILIMIT_Pos = 0x2
	// Bit mask of ENABLE_ILIMIT field.
	PMU_REG_3P0_CLR_ENABLE_ILIMIT_Msk = 0x4
	// Bit ENABLE_ILIMIT.
	PMU_REG_3P0_CLR_ENABLE_ILIMIT = 0x4
	// Position of BO_OFFSET field.
	PMU_REG_3P0_CLR_BO_OFFSET_Pos = 0x4
	// Bit mask of BO_OFFSET field.
	PMU_REG_3P0_CLR_BO_OFFSET_Msk = 0x70
	// Position of VBUS_SEL field.
	PMU_REG_3P0_CLR_VBUS_SEL_Pos = 0x7
	// Bit mask of VBUS_SEL field.
	PMU_REG_3P0_CLR_VBUS_SEL_Msk = 0x80
	// Bit VBUS_SEL.
	PMU_REG_3P0_CLR_VBUS_SEL = 0x80
	// Utilize VBUS OTG2 power
	PMU_REG_3P0_CLR_VBUS_SEL_USB_OTG2_VBUS = 0x0
	// Utilize VBUS OTG1 power
	PMU_REG_3P0_CLR_VBUS_SEL_USB_OTG1_VBUS = 0x1
	// Position of OUTPUT_TRG field.
	PMU_REG_3P0_CLR_OUTPUT_TRG_Pos = 0x8
	// Bit mask of OUTPUT_TRG field.
	PMU_REG_3P0_CLR_OUTPUT_TRG_Msk = 0x1f00
	// 2.625V
	PMU_REG_3P0_CLR_OUTPUT_TRG_OUTPUT_TRG_0 = 0x0
	// 3.000V
	PMU_REG_3P0_CLR_OUTPUT_TRG_OUTPUT_TRG_15 = 0xf
	// 3.400V
	PMU_REG_3P0_CLR_OUTPUT_TRG_OUTPUT_TRG_31 = 0x1f
	// Position of BO_VDD3P0 field.
	PMU_REG_3P0_CLR_BO_VDD3P0_Pos = 0x10
	// Bit mask of BO_VDD3P0 field.
	PMU_REG_3P0_CLR_BO_VDD3P0_Msk = 0x10000
	// Bit BO_VDD3P0.
	PMU_REG_3P0_CLR_BO_VDD3P0 = 0x10000
	// Position of OK_VDD3P0 field.
	PMU_REG_3P0_CLR_OK_VDD3P0_Pos = 0x11
	// Bit mask of OK_VDD3P0 field.
	PMU_REG_3P0_CLR_OK_VDD3P0_Msk = 0x20000
	// Bit OK_VDD3P0.
	PMU_REG_3P0_CLR_OK_VDD3P0 = 0x20000

	// REG_3P0_TOG: Regulator 3P0 Register
	// Position of ENABLE_LINREG field.
	PMU_REG_3P0_TOG_ENABLE_LINREG_Pos = 0x0
	// Bit mask of ENABLE_LINREG field.
	PMU_REG_3P0_TOG_ENABLE_LINREG_Msk = 0x1
	// Bit ENABLE_LINREG.
	PMU_REG_3P0_TOG_ENABLE_LINREG = 0x1
	// Position of ENABLE_BO field.
	PMU_REG_3P0_TOG_ENABLE_BO_Pos = 0x1
	// Bit mask of ENABLE_BO field.
	PMU_REG_3P0_TOG_ENABLE_BO_Msk = 0x2
	// Bit ENABLE_BO.
	PMU_REG_3P0_TOG_ENABLE_BO = 0x2
	// Position of ENABLE_ILIMIT field.
	PMU_REG_3P0_TOG_ENABLE_ILIMIT_Pos = 0x2
	// Bit mask of ENABLE_ILIMIT field.
	PMU_REG_3P0_TOG_ENABLE_ILIMIT_Msk = 0x4
	// Bit ENABLE_ILIMIT.
	PMU_REG_3P0_TOG_ENABLE_ILIMIT = 0x4
	// Position of BO_OFFSET field.
	PMU_REG_3P0_TOG_BO_OFFSET_Pos = 0x4
	// Bit mask of BO_OFFSET field.
	PMU_REG_3P0_TOG_BO_OFFSET_Msk = 0x70
	// Position of VBUS_SEL field.
	PMU_REG_3P0_TOG_VBUS_SEL_Pos = 0x7
	// Bit mask of VBUS_SEL field.
	PMU_REG_3P0_TOG_VBUS_SEL_Msk = 0x80
	// Bit VBUS_SEL.
	PMU_REG_3P0_TOG_VBUS_SEL = 0x80
	// Utilize VBUS OTG2 power
	PMU_REG_3P0_TOG_VBUS_SEL_USB_OTG2_VBUS = 0x0
	// Utilize VBUS OTG1 power
	PMU_REG_3P0_TOG_VBUS_SEL_USB_OTG1_VBUS = 0x1
	// Position of OUTPUT_TRG field.
	PMU_REG_3P0_TOG_OUTPUT_TRG_Pos = 0x8
	// Bit mask of OUTPUT_TRG field.
	PMU_REG_3P0_TOG_OUTPUT_TRG_Msk = 0x1f00
	// 2.625V
	PMU_REG_3P0_TOG_OUTPUT_TRG_OUTPUT_TRG_0 = 0x0
	// 3.000V
	PMU_REG_3P0_TOG_OUTPUT_TRG_OUTPUT_TRG_15 = 0xf
	// 3.400V
	PMU_REG_3P0_TOG_OUTPUT_TRG_OUTPUT_TRG_31 = 0x1f
	// Position of BO_VDD3P0 field.
	PMU_REG_3P0_TOG_BO_VDD3P0_Pos = 0x10
	// Bit mask of BO_VDD3P0 field.
	PMU_REG_3P0_TOG_BO_VDD3P0_Msk = 0x10000
	// Bit BO_VDD3P0.
	PMU_REG_3P0_TOG_BO_VDD3P0 = 0x10000
	// Position of OK_VDD3P0 field.
	PMU_REG_3P0_TOG_OK_VDD3P0_Pos = 0x11
	// Bit mask of OK_VDD3P0 field.
	PMU_REG_3P0_TOG_OK_VDD3P0_Msk = 0x20000
	// Bit OK_VDD3P0.
	PMU_REG_3P0_TOG_OK_VDD3P0 = 0x20000

	// REG_2P5: Regulator 2P5 Register
	// Position of ENABLE_LINREG field.
	PMU_REG_2P5_ENABLE_LINREG_Pos = 0x0
	// Bit mask of ENABLE_LINREG field.
	PMU_REG_2P5_ENABLE_LINREG_Msk = 0x1
	// Bit ENABLE_LINREG.
	PMU_REG_2P5_ENABLE_LINREG = 0x1
	// Position of ENABLE_BO field.
	PMU_REG_2P5_ENABLE_BO_Pos = 0x1
	// Bit mask of ENABLE_BO field.
	PMU_REG_2P5_ENABLE_BO_Msk = 0x2
	// Bit ENABLE_BO.
	PMU_REG_2P5_ENABLE_BO = 0x2
	// Position of ENABLE_ILIMIT field.
	PMU_REG_2P5_ENABLE_ILIMIT_Pos = 0x2
	// Bit mask of ENABLE_ILIMIT field.
	PMU_REG_2P5_ENABLE_ILIMIT_Msk = 0x4
	// Bit ENABLE_ILIMIT.
	PMU_REG_2P5_ENABLE_ILIMIT = 0x4
	// Position of ENABLE_PULLDOWN field.
	PMU_REG_2P5_ENABLE_PULLDOWN_Pos = 0x3
	// Bit mask of ENABLE_PULLDOWN field.
	PMU_REG_2P5_ENABLE_PULLDOWN_Msk = 0x8
	// Bit ENABLE_PULLDOWN.
	PMU_REG_2P5_ENABLE_PULLDOWN = 0x8
	// Position of BO_OFFSET field.
	PMU_REG_2P5_BO_OFFSET_Pos = 0x4
	// Bit mask of BO_OFFSET field.
	PMU_REG_2P5_BO_OFFSET_Msk = 0x70
	// Position of OUTPUT_TRG field.
	PMU_REG_2P5_OUTPUT_TRG_Pos = 0x8
	// Bit mask of OUTPUT_TRG field.
	PMU_REG_2P5_OUTPUT_TRG_Msk = 0x1f00
	// 2.10V
	PMU_REG_2P5_OUTPUT_TRG_OUTPUT_TRG_0 = 0x0
	// 2.50V
	PMU_REG_2P5_OUTPUT_TRG_OUTPUT_TRG_16 = 0x10
	// 2.875V
	PMU_REG_2P5_OUTPUT_TRG_OUTPUT_TRG_31 = 0x1f
	// Position of BO_VDD2P5 field.
	PMU_REG_2P5_BO_VDD2P5_Pos = 0x10
	// Bit mask of BO_VDD2P5 field.
	PMU_REG_2P5_BO_VDD2P5_Msk = 0x10000
	// Bit BO_VDD2P5.
	PMU_REG_2P5_BO_VDD2P5 = 0x10000
	// Position of OK_VDD2P5 field.
	PMU_REG_2P5_OK_VDD2P5_Pos = 0x11
	// Bit mask of OK_VDD2P5 field.
	PMU_REG_2P5_OK_VDD2P5_Msk = 0x20000
	// Bit OK_VDD2P5.
	PMU_REG_2P5_OK_VDD2P5 = 0x20000
	// Position of ENABLE_WEAK_LINREG field.
	PMU_REG_2P5_ENABLE_WEAK_LINREG_Pos = 0x12
	// Bit mask of ENABLE_WEAK_LINREG field.
	PMU_REG_2P5_ENABLE_WEAK_LINREG_Msk = 0x40000
	// Bit ENABLE_WEAK_LINREG.
	PMU_REG_2P5_ENABLE_WEAK_LINREG = 0x40000

	// REG_2P5_SET: Regulator 2P5 Register
	// Position of ENABLE_LINREG field.
	PMU_REG_2P5_SET_ENABLE_LINREG_Pos = 0x0
	// Bit mask of ENABLE_LINREG field.
	PMU_REG_2P5_SET_ENABLE_LINREG_Msk = 0x1
	// Bit ENABLE_LINREG.
	PMU_REG_2P5_SET_ENABLE_LINREG = 0x1
	// Position of ENABLE_BO field.
	PMU_REG_2P5_SET_ENABLE_BO_Pos = 0x1
	// Bit mask of ENABLE_BO field.
	PMU_REG_2P5_SET_ENABLE_BO_Msk = 0x2
	// Bit ENABLE_BO.
	PMU_REG_2P5_SET_ENABLE_BO = 0x2
	// Position of ENABLE_ILIMIT field.
	PMU_REG_2P5_SET_ENABLE_ILIMIT_Pos = 0x2
	// Bit mask of ENABLE_ILIMIT field.
	PMU_REG_2P5_SET_ENABLE_ILIMIT_Msk = 0x4
	// Bit ENABLE_ILIMIT.
	PMU_REG_2P5_SET_ENABLE_ILIMIT = 0x4
	// Position of ENABLE_PULLDOWN field.
	PMU_REG_2P5_SET_ENABLE_PULLDOWN_Pos = 0x3
	// Bit mask of ENABLE_PULLDOWN field.
	PMU_REG_2P5_SET_ENABLE_PULLDOWN_Msk = 0x8
	// Bit ENABLE_PULLDOWN.
	PMU_REG_2P5_SET_ENABLE_PULLDOWN = 0x8
	// Position of BO_OFFSET field.
	PMU_REG_2P5_SET_BO_OFFSET_Pos = 0x4
	// Bit mask of BO_OFFSET field.
	PMU_REG_2P5_SET_BO_OFFSET_Msk = 0x70
	// Position of OUTPUT_TRG field.
	PMU_REG_2P5_SET_OUTPUT_TRG_Pos = 0x8
	// Bit mask of OUTPUT_TRG field.
	PMU_REG_2P5_SET_OUTPUT_TRG_Msk = 0x1f00
	// 2.10V
	PMU_REG_2P5_SET_OUTPUT_TRG_OUTPUT_TRG_0 = 0x0
	// 2.50V
	PMU_REG_2P5_SET_OUTPUT_TRG_OUTPUT_TRG_16 = 0x10
	// 2.875V
	PMU_REG_2P5_SET_OUTPUT_TRG_OUTPUT_TRG_31 = 0x1f
	// Position of BO_VDD2P5 field.
	PMU_REG_2P5_SET_BO_VDD2P5_Pos = 0x10
	// Bit mask of BO_VDD2P5 field.
	PMU_REG_2P5_SET_BO_VDD2P5_Msk = 0x10000
	// Bit BO_VDD2P5.
	PMU_REG_2P5_SET_BO_VDD2P5 = 0x10000
	// Position of OK_VDD2P5 field.
	PMU_REG_2P5_SET_OK_VDD2P5_Pos = 0x11
	// Bit mask of OK_VDD2P5 field.
	PMU_REG_2P5_SET_OK_VDD2P5_Msk = 0x20000
	// Bit OK_VDD2P5.
	PMU_REG_2P5_SET_OK_VDD2P5 = 0x20000
	// Position of ENABLE_WEAK_LINREG field.
	PMU_REG_2P5_SET_ENABLE_WEAK_LINREG_Pos = 0x12
	// Bit mask of ENABLE_WEAK_LINREG field.
	PMU_REG_2P5_SET_ENABLE_WEAK_LINREG_Msk = 0x40000
	// Bit ENABLE_WEAK_LINREG.
	PMU_REG_2P5_SET_ENABLE_WEAK_LINREG = 0x40000

	// REG_2P5_CLR: Regulator 2P5 Register
	// Position of ENABLE_LINREG field.
	PMU_REG_2P5_CLR_ENABLE_LINREG_Pos = 0x0
	// Bit mask of ENABLE_LINREG field.
	PMU_REG_2P5_CLR_ENABLE_LINREG_Msk = 0x1
	// Bit ENABLE_LINREG.
	PMU_REG_2P5_CLR_ENABLE_LINREG = 0x1
	// Position of ENABLE_BO field.
	PMU_REG_2P5_CLR_ENABLE_BO_Pos = 0x1
	// Bit mask of ENABLE_BO field.
	PMU_REG_2P5_CLR_ENABLE_BO_Msk = 0x2
	// Bit ENABLE_BO.
	PMU_REG_2P5_CLR_ENABLE_BO = 0x2
	// Position of ENABLE_ILIMIT field.
	PMU_REG_2P5_CLR_ENABLE_ILIMIT_Pos = 0x2
	// Bit mask of ENABLE_ILIMIT field.
	PMU_REG_2P5_CLR_ENABLE_ILIMIT_Msk = 0x4
	// Bit ENABLE_ILIMIT.
	PMU_REG_2P5_CLR_ENABLE_ILIMIT = 0x4
	// Position of ENABLE_PULLDOWN field.
	PMU_REG_2P5_CLR_ENABLE_PULLDOWN_Pos = 0x3
	// Bit mask of ENABLE_PULLDOWN field.
	PMU_REG_2P5_CLR_ENABLE_PULLDOWN_Msk = 0x8
	// Bit ENABLE_PULLDOWN.
	PMU_REG_2P5_CLR_ENABLE_PULLDOWN = 0x8
	// Position of BO_OFFSET field.
	PMU_REG_2P5_CLR_BO_OFFSET_Pos = 0x4
	// Bit mask of BO_OFFSET field.
	PMU_REG_2P5_CLR_BO_OFFSET_Msk = 0x70
	// Position of OUTPUT_TRG field.
	PMU_REG_2P5_CLR_OUTPUT_TRG_Pos = 0x8
	// Bit mask of OUTPUT_TRG field.
	PMU_REG_2P5_CLR_OUTPUT_TRG_Msk = 0x1f00
	// 2.10V
	PMU_REG_2P5_CLR_OUTPUT_TRG_OUTPUT_TRG_0 = 0x0
	// 2.50V
	PMU_REG_2P5_CLR_OUTPUT_TRG_OUTPUT_TRG_16 = 0x10
	// 2.875V
	PMU_REG_2P5_CLR_OUTPUT_TRG_OUTPUT_TRG_31 = 0x1f
	// Position of BO_VDD2P5 field.
	PMU_REG_2P5_CLR_BO_VDD2P5_Pos = 0x10
	// Bit mask of BO_VDD2P5 field.
	PMU_REG_2P5_CLR_BO_VDD2P5_Msk = 0x10000
	// Bit BO_VDD2P5.
	PMU_REG_2P5_CLR_BO_VDD2P5 = 0x10000
	// Position of OK_VDD2P5 field.
	PMU_REG_2P5_CLR_OK_VDD2P5_Pos = 0x11
	// Bit mask of OK_VDD2P5 field.
	PMU_REG_2P5_CLR_OK_VDD2P5_Msk = 0x20000
	// Bit OK_VDD2P5.
	PMU_REG_2P5_CLR_OK_VDD2P5 = 0x20000
	// Position of ENABLE_WEAK_LINREG field.
	PMU_REG_2P5_CLR_ENABLE_WEAK_LINREG_Pos = 0x12
	// Bit mask of ENABLE_WEAK_LINREG field.
	PMU_REG_2P5_CLR_ENABLE_WEAK_LINREG_Msk = 0x40000
	// Bit ENABLE_WEAK_LINREG.
	PMU_REG_2P5_CLR_ENABLE_WEAK_LINREG = 0x40000

	// REG_2P5_TOG: Regulator 2P5 Register
	// Position of ENABLE_LINREG field.
	PMU_REG_2P5_TOG_ENABLE_LINREG_Pos = 0x0
	// Bit mask of ENABLE_LINREG field.
	PMU_REG_2P5_TOG_ENABLE_LINREG_Msk = 0x1
	// Bit ENABLE_LINREG.
	PMU_REG_2P5_TOG_ENABLE_LINREG = 0x1
	// Position of ENABLE_BO field.
	PMU_REG_2P5_TOG_ENABLE_BO_Pos = 0x1
	// Bit mask of ENABLE_BO field.
	PMU_REG_2P5_TOG_ENABLE_BO_Msk = 0x2
	// Bit ENABLE_BO.
	PMU_REG_2P5_TOG_ENABLE_BO = 0x2
	// Position of ENABLE_ILIMIT field.
	PMU_REG_2P5_TOG_ENABLE_ILIMIT_Pos = 0x2
	// Bit mask of ENABLE_ILIMIT field.
	PMU_REG_2P5_TOG_ENABLE_ILIMIT_Msk = 0x4
	// Bit ENABLE_ILIMIT.
	PMU_REG_2P5_TOG_ENABLE_ILIMIT = 0x4
	// Position of ENABLE_PULLDOWN field.
	PMU_REG_2P5_TOG_ENABLE_PULLDOWN_Pos = 0x3
	// Bit mask of ENABLE_PULLDOWN field.
	PMU_REG_2P5_TOG_ENABLE_PULLDOWN_Msk = 0x8
	// Bit ENABLE_PULLDOWN.
	PMU_REG_2P5_TOG_ENABLE_PULLDOWN = 0x8
	// Position of BO_OFFSET field.
	PMU_REG_2P5_TOG_BO_OFFSET_Pos = 0x4
	// Bit mask of BO_OFFSET field.
	PMU_REG_2P5_TOG_BO_OFFSET_Msk = 0x70
	// Position of OUTPUT_TRG field.
	PMU_REG_2P5_TOG_OUTPUT_TRG_Pos = 0x8
	// Bit mask of OUTPUT_TRG field.
	PMU_REG_2P5_TOG_OUTPUT_TRG_Msk = 0x1f00
	// 2.10V
	PMU_REG_2P5_TOG_OUTPUT_TRG_OUTPUT_TRG_0 = 0x0
	// 2.50V
	PMU_REG_2P5_TOG_OUTPUT_TRG_OUTPUT_TRG_16 = 0x10
	// 2.875V
	PMU_REG_2P5_TOG_OUTPUT_TRG_OUTPUT_TRG_31 = 0x1f
	// Position of BO_VDD2P5 field.
	PMU_REG_2P5_TOG_BO_VDD2P5_Pos = 0x10
	// Bit mask of BO_VDD2P5 field.
	PMU_REG_2P5_TOG_BO_VDD2P5_Msk = 0x10000
	// Bit BO_VDD2P5.
	PMU_REG_2P5_TOG_BO_VDD2P5 = 0x10000
	// Position of OK_VDD2P5 field.
	PMU_REG_2P5_TOG_OK_VDD2P5_Pos = 0x11
	// Bit mask of OK_VDD2P5 field.
	PMU_REG_2P5_TOG_OK_VDD2P5_Msk = 0x20000
	// Bit OK_VDD2P5.
	PMU_REG_2P5_TOG_OK_VDD2P5 = 0x20000
	// Position of ENABLE_WEAK_LINREG field.
	PMU_REG_2P5_TOG_ENABLE_WEAK_LINREG_Pos = 0x12
	// Bit mask of ENABLE_WEAK_LINREG field.
	PMU_REG_2P5_TOG_ENABLE_WEAK_LINREG_Msk = 0x40000
	// Bit ENABLE_WEAK_LINREG.
	PMU_REG_2P5_TOG_ENABLE_WEAK_LINREG = 0x40000

	// REG_CORE: Digital Regulator Core Register
	// Position of REG0_TARG field.
	PMU_REG_CORE_REG0_TARG_Pos = 0x0
	// Bit mask of REG0_TARG field.
	PMU_REG_CORE_REG0_TARG_Msk = 0x1f
	// Power gated off
	PMU_REG_CORE_REG0_TARG_REG0_TARG_0 = 0x0
	// Target core voltage = 0.725V
	PMU_REG_CORE_REG0_TARG_REG0_TARG_1 = 0x1
	// Target core voltage = 0.750V
	PMU_REG_CORE_REG0_TARG_REG0_TARG_2 = 0x2
	// Target core voltage = 0.775V
	PMU_REG_CORE_REG0_TARG_REG0_TARG_3 = 0x3
	// Target core voltage = 1.100V
	PMU_REG_CORE_REG0_TARG_REG0_TARG_16 = 0x10
	// Target core voltage = 1.450V
	PMU_REG_CORE_REG0_TARG_REG0_TARG_30 = 0x1e
	// Power FET switched full on. No regulation.
	PMU_REG_CORE_REG0_TARG_REG0_TARG_31 = 0x1f
	// Position of REG0_ADJ field.
	PMU_REG_CORE_REG0_ADJ_Pos = 0x5
	// Bit mask of REG0_ADJ field.
	PMU_REG_CORE_REG0_ADJ_Msk = 0x1e0
	// No adjustment
	PMU_REG_CORE_REG0_ADJ_REG0_ADJ_0 = 0x0
	// + 0.25%
	PMU_REG_CORE_REG0_ADJ_REG0_ADJ_1 = 0x1
	// + 0.50%
	PMU_REG_CORE_REG0_ADJ_REG0_ADJ_2 = 0x2
	// + 0.75%
	PMU_REG_CORE_REG0_ADJ_REG0_ADJ_3 = 0x3
	// + 1.00%
	PMU_REG_CORE_REG0_ADJ_REG0_ADJ_4 = 0x4
	// + 1.25%
	PMU_REG_CORE_REG0_ADJ_REG0_ADJ_5 = 0x5
	// + 1.50%
	PMU_REG_CORE_REG0_ADJ_REG0_ADJ_6 = 0x6
	// + 1.75%
	PMU_REG_CORE_REG0_ADJ_REG0_ADJ_7 = 0x7
	// - 0.25%
	PMU_REG_CORE_REG0_ADJ_REG0_ADJ_8 = 0x8
	// - 0.50%
	PMU_REG_CORE_REG0_ADJ_REG0_ADJ_9 = 0x9
	// - 0.75%
	PMU_REG_CORE_REG0_ADJ_REG0_ADJ_10 = 0xa
	// - 1.00%
	PMU_REG_CORE_REG0_ADJ_REG0_ADJ_11 = 0xb
	// - 1.25%
	PMU_REG_CORE_REG0_ADJ_REG0_ADJ_12 = 0xc
	// - 1.50%
	PMU_REG_CORE_REG0_ADJ_REG0_ADJ_13 = 0xd
	// - 1.75%
	PMU_REG_CORE_REG0_ADJ_REG0_ADJ_14 = 0xe
	// - 2.00%
	PMU_REG_CORE_REG0_ADJ_REG0_ADJ_15 = 0xf
	// Position of REG1_TARG field.
	PMU_REG_CORE_REG1_TARG_Pos = 0x9
	// Bit mask of REG1_TARG field.
	PMU_REG_CORE_REG1_TARG_Msk = 0x3e00
	// Power gated off
	PMU_REG_CORE_REG1_TARG_REG1_TARG_0 = 0x0
	// Target core voltage = 0.725V
	PMU_REG_CORE_REG1_TARG_REG1_TARG_1 = 0x1
	// Target core voltage = 0.750V
	PMU_REG_CORE_REG1_TARG_REG1_TARG_2 = 0x2
	// Target core voltage = 0.775V
	PMU_REG_CORE_REG1_TARG_REG1_TARG_3 = 0x3
	// Target core voltage = 1.100V
	PMU_REG_CORE_REG1_TARG_REG1_TARG_16 = 0x10
	// Target core voltage = 1.450V
	PMU_REG_CORE_REG1_TARG_REG1_TARG_30 = 0x1e
	// Power FET switched full on. No regulation.
	PMU_REG_CORE_REG1_TARG_REG1_TARG_31 = 0x1f
	// Position of REG1_ADJ field.
	PMU_REG_CORE_REG1_ADJ_Pos = 0xe
	// Bit mask of REG1_ADJ field.
	PMU_REG_CORE_REG1_ADJ_Msk = 0x3c000
	// No adjustment
	PMU_REG_CORE_REG1_ADJ_REG1_ADJ_0 = 0x0
	// + 0.25%
	PMU_REG_CORE_REG1_ADJ_REG1_ADJ_1 = 0x1
	// + 0.50%
	PMU_REG_CORE_REG1_ADJ_REG1_ADJ_2 = 0x2
	// + 0.75%
	PMU_REG_CORE_REG1_ADJ_REG1_ADJ_3 = 0x3
	// + 1.00%
	PMU_REG_CORE_REG1_ADJ_REG1_ADJ_4 = 0x4
	// + 1.25%
	PMU_REG_CORE_REG1_ADJ_REG1_ADJ_5 = 0x5
	// + 1.50%
	PMU_REG_CORE_REG1_ADJ_REG1_ADJ_6 = 0x6
	// + 1.75%
	PMU_REG_CORE_REG1_ADJ_REG1_ADJ_7 = 0x7
	// - 0.25%
	PMU_REG_CORE_REG1_ADJ_REG1_ADJ_8 = 0x8
	// - 0.50%
	PMU_REG_CORE_REG1_ADJ_REG1_ADJ_9 = 0x9
	// - 0.75%
	PMU_REG_CORE_REG1_ADJ_REG1_ADJ_10 = 0xa
	// - 1.00%
	PMU_REG_CORE_REG1_ADJ_REG1_ADJ_11 = 0xb
	// - 1.25%
	PMU_REG_CORE_REG1_ADJ_REG1_ADJ_12 = 0xc
	// - 1.50%
	PMU_REG_CORE_REG1_ADJ_REG1_ADJ_13 = 0xd
	// - 1.75%
	PMU_REG_CORE_REG1_ADJ_REG1_ADJ_14 = 0xe
	// - 2.00%
	PMU_REG_CORE_REG1_ADJ_REG1_ADJ_15 = 0xf
	// Position of REG2_TARG field.
	PMU_REG_CORE_REG2_TARG_Pos = 0x12
	// Bit mask of REG2_TARG field.
	PMU_REG_CORE_REG2_TARG_Msk = 0x7c0000
	// Power gated off
	PMU_REG_CORE_REG2_TARG_REG2_TARG_0 = 0x0
	// Target core voltage = 0.725V
	PMU_REG_CORE_REG2_TARG_REG2_TARG_1 = 0x1
	// Target core voltage = 0.750V
	PMU_REG_CORE_REG2_TARG_REG2_TARG_2 = 0x2
	// Target core voltage = 0.775V
	PMU_REG_CORE_REG2_TARG_REG2_TARG_3 = 0x3
	// Target core voltage = 1.100V
	PMU_REG_CORE_REG2_TARG_REG2_TARG_16 = 0x10
	// Target core voltage = 1.450V
	PMU_REG_CORE_REG2_TARG_REG2_TARG_30 = 0x1e
	// Power FET switched full on. No regulation.
	PMU_REG_CORE_REG2_TARG_REG2_TARG_31 = 0x1f
	// Position of REG2_ADJ field.
	PMU_REG_CORE_REG2_ADJ_Pos = 0x17
	// Bit mask of REG2_ADJ field.
	PMU_REG_CORE_REG2_ADJ_Msk = 0x7800000
	// No adjustment
	PMU_REG_CORE_REG2_ADJ_REG2_ADJ_0 = 0x0
	// + 0.25%
	PMU_REG_CORE_REG2_ADJ_REG2_ADJ_1 = 0x1
	// + 0.50%
	PMU_REG_CORE_REG2_ADJ_REG2_ADJ_2 = 0x2
	// + 0.75%
	PMU_REG_CORE_REG2_ADJ_REG2_ADJ_3 = 0x3
	// + 1.00%
	PMU_REG_CORE_REG2_ADJ_REG2_ADJ_4 = 0x4
	// + 1.25%
	PMU_REG_CORE_REG2_ADJ_REG2_ADJ_5 = 0x5
	// + 1.50%
	PMU_REG_CORE_REG2_ADJ_REG2_ADJ_6 = 0x6
	// + 1.75%
	PMU_REG_CORE_REG2_ADJ_REG2_ADJ_7 = 0x7
	// - 0.25%
	PMU_REG_CORE_REG2_ADJ_REG2_ADJ_8 = 0x8
	// - 0.50%
	PMU_REG_CORE_REG2_ADJ_REG2_ADJ_9 = 0x9
	// - 0.75%
	PMU_REG_CORE_REG2_ADJ_REG2_ADJ_10 = 0xa
	// - 1.00%
	PMU_REG_CORE_REG2_ADJ_REG2_ADJ_11 = 0xb
	// - 1.25%
	PMU_REG_CORE_REG2_ADJ_REG2_ADJ_12 = 0xc
	// - 1.50%
	PMU_REG_CORE_REG2_ADJ_REG2_ADJ_13 = 0xd
	// - 1.75%
	PMU_REG_CORE_REG2_ADJ_REG2_ADJ_14 = 0xe
	// - 2.00%
	PMU_REG_CORE_REG2_ADJ_REG2_ADJ_15 = 0xf
	// Position of RAMP_RATE field.
	PMU_REG_CORE_RAMP_RATE_Pos = 0x1b
	// Bit mask of RAMP_RATE field.
	PMU_REG_CORE_RAMP_RATE_Msk = 0x18000000
	// Fast
	PMU_REG_CORE_RAMP_RATE_RAMP_RATE_0 = 0x0
	// Medium Fast
	PMU_REG_CORE_RAMP_RATE_RAMP_RATE_1 = 0x1
	// Medium Slow
	PMU_REG_CORE_RAMP_RATE_RAMP_RATE_2 = 0x2
	// Slow
	PMU_REG_CORE_RAMP_RATE_RAMP_RATE_3 = 0x3
	// Position of FET_ODRIVE field.
	PMU_REG_CORE_FET_ODRIVE_Pos = 0x1d
	// Bit mask of FET_ODRIVE field.
	PMU_REG_CORE_FET_ODRIVE_Msk = 0x20000000
	// Bit FET_ODRIVE.
	PMU_REG_CORE_FET_ODRIVE = 0x20000000

	// REG_CORE_SET: Digital Regulator Core Register
	// Position of REG0_TARG field.
	PMU_REG_CORE_SET_REG0_TARG_Pos = 0x0
	// Bit mask of REG0_TARG field.
	PMU_REG_CORE_SET_REG0_TARG_Msk = 0x1f
	// Power gated off
	PMU_REG_CORE_SET_REG0_TARG_REG0_TARG_0 = 0x0
	// Target core voltage = 0.725V
	PMU_REG_CORE_SET_REG0_TARG_REG0_TARG_1 = 0x1
	// Target core voltage = 0.750V
	PMU_REG_CORE_SET_REG0_TARG_REG0_TARG_2 = 0x2
	// Target core voltage = 0.775V
	PMU_REG_CORE_SET_REG0_TARG_REG0_TARG_3 = 0x3
	// Target core voltage = 1.100V
	PMU_REG_CORE_SET_REG0_TARG_REG0_TARG_16 = 0x10
	// Target core voltage = 1.450V
	PMU_REG_CORE_SET_REG0_TARG_REG0_TARG_30 = 0x1e
	// Power FET switched full on. No regulation.
	PMU_REG_CORE_SET_REG0_TARG_REG0_TARG_31 = 0x1f
	// Position of REG0_ADJ field.
	PMU_REG_CORE_SET_REG0_ADJ_Pos = 0x5
	// Bit mask of REG0_ADJ field.
	PMU_REG_CORE_SET_REG0_ADJ_Msk = 0x1e0
	// No adjustment
	PMU_REG_CORE_SET_REG0_ADJ_REG0_ADJ_0 = 0x0
	// + 0.25%
	PMU_REG_CORE_SET_REG0_ADJ_REG0_ADJ_1 = 0x1
	// + 0.50%
	PMU_REG_CORE_SET_REG0_ADJ_REG0_ADJ_2 = 0x2
	// + 0.75%
	PMU_REG_CORE_SET_REG0_ADJ_REG0_ADJ_3 = 0x3
	// + 1.00%
	PMU_REG_CORE_SET_REG0_ADJ_REG0_ADJ_4 = 0x4
	// + 1.25%
	PMU_REG_CORE_SET_REG0_ADJ_REG0_ADJ_5 = 0x5
	// + 1.50%
	PMU_REG_CORE_SET_REG0_ADJ_REG0_ADJ_6 = 0x6
	// + 1.75%
	PMU_REG_CORE_SET_REG0_ADJ_REG0_ADJ_7 = 0x7
	// - 0.25%
	PMU_REG_CORE_SET_REG0_ADJ_REG0_ADJ_8 = 0x8
	// - 0.50%
	PMU_REG_CORE_SET_REG0_ADJ_REG0_ADJ_9 = 0x9
	// - 0.75%
	PMU_REG_CORE_SET_REG0_ADJ_REG0_ADJ_10 = 0xa
	// - 1.00%
	PMU_REG_CORE_SET_REG0_ADJ_REG0_ADJ_11 = 0xb
	// - 1.25%
	PMU_REG_CORE_SET_REG0_ADJ_REG0_ADJ_12 = 0xc
	// - 1.50%
	PMU_REG_CORE_SET_REG0_ADJ_REG0_ADJ_13 = 0xd
	// - 1.75%
	PMU_REG_CORE_SET_REG0_ADJ_REG0_ADJ_14 = 0xe
	// - 2.00%
	PMU_REG_CORE_SET_REG0_ADJ_REG0_ADJ_15 = 0xf
	// Position of REG1_TARG field.
	PMU_REG_CORE_SET_REG1_TARG_Pos = 0x9
	// Bit mask of REG1_TARG field.
	PMU_REG_CORE_SET_REG1_TARG_Msk = 0x3e00
	// Power gated off
	PMU_REG_CORE_SET_REG1_TARG_REG1_TARG_0 = 0x0
	// Target core voltage = 0.725V
	PMU_REG_CORE_SET_REG1_TARG_REG1_TARG_1 = 0x1
	// Target core voltage = 0.750V
	PMU_REG_CORE_SET_REG1_TARG_REG1_TARG_2 = 0x2
	// Target core voltage = 0.775V
	PMU_REG_CORE_SET_REG1_TARG_REG1_TARG_3 = 0x3
	// Target core voltage = 1.100V
	PMU_REG_CORE_SET_REG1_TARG_REG1_TARG_16 = 0x10
	// Target core voltage = 1.450V
	PMU_REG_CORE_SET_REG1_TARG_REG1_TARG_30 = 0x1e
	// Power FET switched full on. No regulation.
	PMU_REG_CORE_SET_REG1_TARG_REG1_TARG_31 = 0x1f
	// Position of REG1_ADJ field.
	PMU_REG_CORE_SET_REG1_ADJ_Pos = 0xe
	// Bit mask of REG1_ADJ field.
	PMU_REG_CORE_SET_REG1_ADJ_Msk = 0x3c000
	// No adjustment
	PMU_REG_CORE_SET_REG1_ADJ_REG1_ADJ_0 = 0x0
	// + 0.25%
	PMU_REG_CORE_SET_REG1_ADJ_REG1_ADJ_1 = 0x1
	// + 0.50%
	PMU_REG_CORE_SET_REG1_ADJ_REG1_ADJ_2 = 0x2
	// + 0.75%
	PMU_REG_CORE_SET_REG1_ADJ_REG1_ADJ_3 = 0x3
	// + 1.00%
	PMU_REG_CORE_SET_REG1_ADJ_REG1_ADJ_4 = 0x4
	// + 1.25%
	PMU_REG_CORE_SET_REG1_ADJ_REG1_ADJ_5 = 0x5
	// + 1.50%
	PMU_REG_CORE_SET_REG1_ADJ_REG1_ADJ_6 = 0x6
	// + 1.75%
	PMU_REG_CORE_SET_REG1_ADJ_REG1_ADJ_7 = 0x7
	// - 0.25%
	PMU_REG_CORE_SET_REG1_ADJ_REG1_ADJ_8 = 0x8
	// - 0.50%
	PMU_REG_CORE_SET_REG1_ADJ_REG1_ADJ_9 = 0x9
	// - 0.75%
	PMU_REG_CORE_SET_REG1_ADJ_REG1_ADJ_10 = 0xa
	// - 1.00%
	PMU_REG_CORE_SET_REG1_ADJ_REG1_ADJ_11 = 0xb
	// - 1.25%
	PMU_REG_CORE_SET_REG1_ADJ_REG1_ADJ_12 = 0xc
	// - 1.50%
	PMU_REG_CORE_SET_REG1_ADJ_REG1_ADJ_13 = 0xd
	// - 1.75%
	PMU_REG_CORE_SET_REG1_ADJ_REG1_ADJ_14 = 0xe
	// - 2.00%
	PMU_REG_CORE_SET_REG1_ADJ_REG1_ADJ_15 = 0xf
	// Position of REG2_TARG field.
	PMU_REG_CORE_SET_REG2_TARG_Pos = 0x12
	// Bit mask of REG2_TARG field.
	PMU_REG_CORE_SET_REG2_TARG_Msk = 0x7c0000
	// Power gated off
	PMU_REG_CORE_SET_REG2_TARG_REG2_TARG_0 = 0x0
	// Target core voltage = 0.725V
	PMU_REG_CORE_SET_REG2_TARG_REG2_TARG_1 = 0x1
	// Target core voltage = 0.750V
	PMU_REG_CORE_SET_REG2_TARG_REG2_TARG_2 = 0x2
	// Target core voltage = 0.775V
	PMU_REG_CORE_SET_REG2_TARG_REG2_TARG_3 = 0x3
	// Target core voltage = 1.100V
	PMU_REG_CORE_SET_REG2_TARG_REG2_TARG_16 = 0x10
	// Target core voltage = 1.450V
	PMU_REG_CORE_SET_REG2_TARG_REG2_TARG_30 = 0x1e
	// Power FET switched full on. No regulation.
	PMU_REG_CORE_SET_REG2_TARG_REG2_TARG_31 = 0x1f
	// Position of REG2_ADJ field.
	PMU_REG_CORE_SET_REG2_ADJ_Pos = 0x17
	// Bit mask of REG2_ADJ field.
	PMU_REG_CORE_SET_REG2_ADJ_Msk = 0x7800000
	// No adjustment
	PMU_REG_CORE_SET_REG2_ADJ_REG2_ADJ_0 = 0x0
	// + 0.25%
	PMU_REG_CORE_SET_REG2_ADJ_REG2_ADJ_1 = 0x1
	// + 0.50%
	PMU_REG_CORE_SET_REG2_ADJ_REG2_ADJ_2 = 0x2
	// + 0.75%
	PMU_REG_CORE_SET_REG2_ADJ_REG2_ADJ_3 = 0x3
	// + 1.00%
	PMU_REG_CORE_SET_REG2_ADJ_REG2_ADJ_4 = 0x4
	// + 1.25%
	PMU_REG_CORE_SET_REG2_ADJ_REG2_ADJ_5 = 0x5
	// + 1.50%
	PMU_REG_CORE_SET_REG2_ADJ_REG2_ADJ_6 = 0x6
	// + 1.75%
	PMU_REG_CORE_SET_REG2_ADJ_REG2_ADJ_7 = 0x7
	// - 0.25%
	PMU_REG_CORE_SET_REG2_ADJ_REG2_ADJ_8 = 0x8
	// - 0.50%
	PMU_REG_CORE_SET_REG2_ADJ_REG2_ADJ_9 = 0x9
	// - 0.75%
	PMU_REG_CORE_SET_REG2_ADJ_REG2_ADJ_10 = 0xa
	// - 1.00%
	PMU_REG_CORE_SET_REG2_ADJ_REG2_ADJ_11 = 0xb
	// - 1.25%
	PMU_REG_CORE_SET_REG2_ADJ_REG2_ADJ_12 = 0xc
	// - 1.50%
	PMU_REG_CORE_SET_REG2_ADJ_REG2_ADJ_13 = 0xd
	// - 1.75%
	PMU_REG_CORE_SET_REG2_ADJ_REG2_ADJ_14 = 0xe
	// - 2.00%
	PMU_REG_CORE_SET_REG2_ADJ_REG2_ADJ_15 = 0xf
	// Position of RAMP_RATE field.
	PMU_REG_CORE_SET_RAMP_RATE_Pos = 0x1b
	// Bit mask of RAMP_RATE field.
	PMU_REG_CORE_SET_RAMP_RATE_Msk = 0x18000000
	// Fast
	PMU_REG_CORE_SET_RAMP_RATE_RAMP_RATE_0 = 0x0
	// Medium Fast
	PMU_REG_CORE_SET_RAMP_RATE_RAMP_RATE_1 = 0x1
	// Medium Slow
	PMU_REG_CORE_SET_RAMP_RATE_RAMP_RATE_2 = 0x2
	// Slow
	PMU_REG_CORE_SET_RAMP_RATE_RAMP_RATE_3 = 0x3
	// Position of FET_ODRIVE field.
	PMU_REG_CORE_SET_FET_ODRIVE_Pos = 0x1d
	// Bit mask of FET_ODRIVE field.
	PMU_REG_CORE_SET_FET_ODRIVE_Msk = 0x20000000
	// Bit FET_ODRIVE.
	PMU_REG_CORE_SET_FET_ODRIVE = 0x20000000

	// REG_CORE_CLR: Digital Regulator Core Register
	// Position of REG0_TARG field.
	PMU_REG_CORE_CLR_REG0_TARG_Pos = 0x0
	// Bit mask of REG0_TARG field.
	PMU_REG_CORE_CLR_REG0_TARG_Msk = 0x1f
	// Power gated off
	PMU_REG_CORE_CLR_REG0_TARG_REG0_TARG_0 = 0x0
	// Target core voltage = 0.725V
	PMU_REG_CORE_CLR_REG0_TARG_REG0_TARG_1 = 0x1
	// Target core voltage = 0.750V
	PMU_REG_CORE_CLR_REG0_TARG_REG0_TARG_2 = 0x2
	// Target core voltage = 0.775V
	PMU_REG_CORE_CLR_REG0_TARG_REG0_TARG_3 = 0x3
	// Target core voltage = 1.100V
	PMU_REG_CORE_CLR_REG0_TARG_REG0_TARG_16 = 0x10
	// Target core voltage = 1.450V
	PMU_REG_CORE_CLR_REG0_TARG_REG0_TARG_30 = 0x1e
	// Power FET switched full on. No regulation.
	PMU_REG_CORE_CLR_REG0_TARG_REG0_TARG_31 = 0x1f
	// Position of REG0_ADJ field.
	PMU_REG_CORE_CLR_REG0_ADJ_Pos = 0x5
	// Bit mask of REG0_ADJ field.
	PMU_REG_CORE_CLR_REG0_ADJ_Msk = 0x1e0
	// No adjustment
	PMU_REG_CORE_CLR_REG0_ADJ_REG0_ADJ_0 = 0x0
	// + 0.25%
	PMU_REG_CORE_CLR_REG0_ADJ_REG0_ADJ_1 = 0x1
	// + 0.50%
	PMU_REG_CORE_CLR_REG0_ADJ_REG0_ADJ_2 = 0x2
	// + 0.75%
	PMU_REG_CORE_CLR_REG0_ADJ_REG0_ADJ_3 = 0x3
	// + 1.00%
	PMU_REG_CORE_CLR_REG0_ADJ_REG0_ADJ_4 = 0x4
	// + 1.25%
	PMU_REG_CORE_CLR_REG0_ADJ_REG0_ADJ_5 = 0x5
	// + 1.50%
	PMU_REG_CORE_CLR_REG0_ADJ_REG0_ADJ_6 = 0x6
	// + 1.75%
	PMU_REG_CORE_CLR_REG0_ADJ_REG0_ADJ_7 = 0x7
	// - 0.25%
	PMU_REG_CORE_CLR_REG0_ADJ_REG0_ADJ_8 = 0x8
	// - 0.50%
	PMU_REG_CORE_CLR_REG0_ADJ_REG0_ADJ_9 = 0x9
	// - 0.75%
	PMU_REG_CORE_CLR_REG0_ADJ_REG0_ADJ_10 = 0xa
	// - 1.00%
	PMU_REG_CORE_CLR_REG0_ADJ_REG0_ADJ_11 = 0xb
	// - 1.25%
	PMU_REG_CORE_CLR_REG0_ADJ_REG0_ADJ_12 = 0xc
	// - 1.50%
	PMU_REG_CORE_CLR_REG0_ADJ_REG0_ADJ_13 = 0xd
	// - 1.75%
	PMU_REG_CORE_CLR_REG0_ADJ_REG0_ADJ_14 = 0xe
	// - 2.00%
	PMU_REG_CORE_CLR_REG0_ADJ_REG0_ADJ_15 = 0xf
	// Position of REG1_TARG field.
	PMU_REG_CORE_CLR_REG1_TARG_Pos = 0x9
	// Bit mask of REG1_TARG field.
	PMU_REG_CORE_CLR_REG1_TARG_Msk = 0x3e00
	// Power gated off
	PMU_REG_CORE_CLR_REG1_TARG_REG1_TARG_0 = 0x0
	// Target core voltage = 0.725V
	PMU_REG_CORE_CLR_REG1_TARG_REG1_TARG_1 = 0x1
	// Target core voltage = 0.750V
	PMU_REG_CORE_CLR_REG1_TARG_REG1_TARG_2 = 0x2
	// Target core voltage = 0.775V
	PMU_REG_CORE_CLR_REG1_TARG_REG1_TARG_3 = 0x3
	// Target core voltage = 1.100V
	PMU_REG_CORE_CLR_REG1_TARG_REG1_TARG_16 = 0x10
	// Target core voltage = 1.450V
	PMU_REG_CORE_CLR_REG1_TARG_REG1_TARG_30 = 0x1e
	// Power FET switched full on. No regulation.
	PMU_REG_CORE_CLR_REG1_TARG_REG1_TARG_31 = 0x1f
	// Position of REG1_ADJ field.
	PMU_REG_CORE_CLR_REG1_ADJ_Pos = 0xe
	// Bit mask of REG1_ADJ field.
	PMU_REG_CORE_CLR_REG1_ADJ_Msk = 0x3c000
	// No adjustment
	PMU_REG_CORE_CLR_REG1_ADJ_REG1_ADJ_0 = 0x0
	// + 0.25%
	PMU_REG_CORE_CLR_REG1_ADJ_REG1_ADJ_1 = 0x1
	// + 0.50%
	PMU_REG_CORE_CLR_REG1_ADJ_REG1_ADJ_2 = 0x2
	// + 0.75%
	PMU_REG_CORE_CLR_REG1_ADJ_REG1_ADJ_3 = 0x3
	// + 1.00%
	PMU_REG_CORE_CLR_REG1_ADJ_REG1_ADJ_4 = 0x4
	// + 1.25%
	PMU_REG_CORE_CLR_REG1_ADJ_REG1_ADJ_5 = 0x5
	// + 1.50%
	PMU_REG_CORE_CLR_REG1_ADJ_REG1_ADJ_6 = 0x6
	// + 1.75%
	PMU_REG_CORE_CLR_REG1_ADJ_REG1_ADJ_7 = 0x7
	// - 0.25%
	PMU_REG_CORE_CLR_REG1_ADJ_REG1_ADJ_8 = 0x8
	// - 0.50%
	PMU_REG_CORE_CLR_REG1_ADJ_REG1_ADJ_9 = 0x9
	// - 0.75%
	PMU_REG_CORE_CLR_REG1_ADJ_REG1_ADJ_10 = 0xa
	// - 1.00%
	PMU_REG_CORE_CLR_REG1_ADJ_REG1_ADJ_11 = 0xb
	// - 1.25%
	PMU_REG_CORE_CLR_REG1_ADJ_REG1_ADJ_12 = 0xc
	// - 1.50%
	PMU_REG_CORE_CLR_REG1_ADJ_REG1_ADJ_13 = 0xd
	// - 1.75%
	PMU_REG_CORE_CLR_REG1_ADJ_REG1_ADJ_14 = 0xe
	// - 2.00%
	PMU_REG_CORE_CLR_REG1_ADJ_REG1_ADJ_15 = 0xf
	// Position of REG2_TARG field.
	PMU_REG_CORE_CLR_REG2_TARG_Pos = 0x12
	// Bit mask of REG2_TARG field.
	PMU_REG_CORE_CLR_REG2_TARG_Msk = 0x7c0000
	// Power gated off
	PMU_REG_CORE_CLR_REG2_TARG_REG2_TARG_0 = 0x0
	// Target core voltage = 0.725V
	PMU_REG_CORE_CLR_REG2_TARG_REG2_TARG_1 = 0x1
	// Target core voltage = 0.750V
	PMU_REG_CORE_CLR_REG2_TARG_REG2_TARG_2 = 0x2
	// Target core voltage = 0.775V
	PMU_REG_CORE_CLR_REG2_TARG_REG2_TARG_3 = 0x3
	// Target core voltage = 1.100V
	PMU_REG_CORE_CLR_REG2_TARG_REG2_TARG_16 = 0x10
	// Target core voltage = 1.450V
	PMU_REG_CORE_CLR_REG2_TARG_REG2_TARG_30 = 0x1e
	// Power FET switched full on. No regulation.
	PMU_REG_CORE_CLR_REG2_TARG_REG2_TARG_31 = 0x1f
	// Position of REG2_ADJ field.
	PMU_REG_CORE_CLR_REG2_ADJ_Pos = 0x17
	// Bit mask of REG2_ADJ field.
	PMU_REG_CORE_CLR_REG2_ADJ_Msk = 0x7800000
	// No adjustment
	PMU_REG_CORE_CLR_REG2_ADJ_REG2_ADJ_0 = 0x0
	// + 0.25%
	PMU_REG_CORE_CLR_REG2_ADJ_REG2_ADJ_1 = 0x1
	// + 0.50%
	PMU_REG_CORE_CLR_REG2_ADJ_REG2_ADJ_2 = 0x2
	// + 0.75%
	PMU_REG_CORE_CLR_REG2_ADJ_REG2_ADJ_3 = 0x3
	// + 1.00%
	PMU_REG_CORE_CLR_REG2_ADJ_REG2_ADJ_4 = 0x4
	// + 1.25%
	PMU_REG_CORE_CLR_REG2_ADJ_REG2_ADJ_5 = 0x5
	// + 1.50%
	PMU_REG_CORE_CLR_REG2_ADJ_REG2_ADJ_6 = 0x6
	// + 1.75%
	PMU_REG_CORE_CLR_REG2_ADJ_REG2_ADJ_7 = 0x7
	// - 0.25%
	PMU_REG_CORE_CLR_REG2_ADJ_REG2_ADJ_8 = 0x8
	// - 0.50%
	PMU_REG_CORE_CLR_REG2_ADJ_REG2_ADJ_9 = 0x9
	// - 0.75%
	PMU_REG_CORE_CLR_REG2_ADJ_REG2_ADJ_10 = 0xa
	// - 1.00%
	PMU_REG_CORE_CLR_REG2_ADJ_REG2_ADJ_11 = 0xb
	// - 1.25%
	PMU_REG_CORE_CLR_REG2_ADJ_REG2_ADJ_12 = 0xc
	// - 1.50%
	PMU_REG_CORE_CLR_REG2_ADJ_REG2_ADJ_13 = 0xd
	// - 1.75%
	PMU_REG_CORE_CLR_REG2_ADJ_REG2_ADJ_14 = 0xe
	// - 2.00%
	PMU_REG_CORE_CLR_REG2_ADJ_REG2_ADJ_15 = 0xf
	// Position of RAMP_RATE field.
	PMU_REG_CORE_CLR_RAMP_RATE_Pos = 0x1b
	// Bit mask of RAMP_RATE field.
	PMU_REG_CORE_CLR_RAMP_RATE_Msk = 0x18000000
	// Fast
	PMU_REG_CORE_CLR_RAMP_RATE_RAMP_RATE_0 = 0x0
	// Medium Fast
	PMU_REG_CORE_CLR_RAMP_RATE_RAMP_RATE_1 = 0x1
	// Medium Slow
	PMU_REG_CORE_CLR_RAMP_RATE_RAMP_RATE_2 = 0x2
	// Slow
	PMU_REG_CORE_CLR_RAMP_RATE_RAMP_RATE_3 = 0x3
	// Position of FET_ODRIVE field.
	PMU_REG_CORE_CLR_FET_ODRIVE_Pos = 0x1d
	// Bit mask of FET_ODRIVE field.
	PMU_REG_CORE_CLR_FET_ODRIVE_Msk = 0x20000000
	// Bit FET_ODRIVE.
	PMU_REG_CORE_CLR_FET_ODRIVE = 0x20000000

	// REG_CORE_TOG: Digital Regulator Core Register
	// Position of REG0_TARG field.
	PMU_REG_CORE_TOG_REG0_TARG_Pos = 0x0
	// Bit mask of REG0_TARG field.
	PMU_REG_CORE_TOG_REG0_TARG_Msk = 0x1f
	// Power gated off
	PMU_REG_CORE_TOG_REG0_TARG_REG0_TARG_0 = 0x0
	// Target core voltage = 0.725V
	PMU_REG_CORE_TOG_REG0_TARG_REG0_TARG_1 = 0x1
	// Target core voltage = 0.750V
	PMU_REG_CORE_TOG_REG0_TARG_REG0_TARG_2 = 0x2
	// Target core voltage = 0.775V
	PMU_REG_CORE_TOG_REG0_TARG_REG0_TARG_3 = 0x3
	// Target core voltage = 1.100V
	PMU_REG_CORE_TOG_REG0_TARG_REG0_TARG_16 = 0x10
	// Target core voltage = 1.450V
	PMU_REG_CORE_TOG_REG0_TARG_REG0_TARG_30 = 0x1e
	// Power FET switched full on. No regulation.
	PMU_REG_CORE_TOG_REG0_TARG_REG0_TARG_31 = 0x1f
	// Position of REG0_ADJ field.
	PMU_REG_CORE_TOG_REG0_ADJ_Pos = 0x5
	// Bit mask of REG0_ADJ field.
	PMU_REG_CORE_TOG_REG0_ADJ_Msk = 0x1e0
	// No adjustment
	PMU_REG_CORE_TOG_REG0_ADJ_REG0_ADJ_0 = 0x0
	// + 0.25%
	PMU_REG_CORE_TOG_REG0_ADJ_REG0_ADJ_1 = 0x1
	// + 0.50%
	PMU_REG_CORE_TOG_REG0_ADJ_REG0_ADJ_2 = 0x2
	// + 0.75%
	PMU_REG_CORE_TOG_REG0_ADJ_REG0_ADJ_3 = 0x3
	// + 1.00%
	PMU_REG_CORE_TOG_REG0_ADJ_REG0_ADJ_4 = 0x4
	// + 1.25%
	PMU_REG_CORE_TOG_REG0_ADJ_REG0_ADJ_5 = 0x5
	// + 1.50%
	PMU_REG_CORE_TOG_REG0_ADJ_REG0_ADJ_6 = 0x6
	// + 1.75%
	PMU_REG_CORE_TOG_REG0_ADJ_REG0_ADJ_7 = 0x7
	// - 0.25%
	PMU_REG_CORE_TOG_REG0_ADJ_REG0_ADJ_8 = 0x8
	// - 0.50%
	PMU_REG_CORE_TOG_REG0_ADJ_REG0_ADJ_9 = 0x9
	// - 0.75%
	PMU_REG_CORE_TOG_REG0_ADJ_REG0_ADJ_10 = 0xa
	// - 1.00%
	PMU_REG_CORE_TOG_REG0_ADJ_REG0_ADJ_11 = 0xb
	// - 1.25%
	PMU_REG_CORE_TOG_REG0_ADJ_REG0_ADJ_12 = 0xc
	// - 1.50%
	PMU_REG_CORE_TOG_REG0_ADJ_REG0_ADJ_13 = 0xd
	// - 1.75%
	PMU_REG_CORE_TOG_REG0_ADJ_REG0_ADJ_14 = 0xe
	// - 2.00%
	PMU_REG_CORE_TOG_REG0_ADJ_REG0_ADJ_15 = 0xf
	// Position of REG1_TARG field.
	PMU_REG_CORE_TOG_REG1_TARG_Pos = 0x9
	// Bit mask of REG1_TARG field.
	PMU_REG_CORE_TOG_REG1_TARG_Msk = 0x3e00
	// Power gated off
	PMU_REG_CORE_TOG_REG1_TARG_REG1_TARG_0 = 0x0
	// Target core voltage = 0.725V
	PMU_REG_CORE_TOG_REG1_TARG_REG1_TARG_1 = 0x1
	// Target core voltage = 0.750V
	PMU_REG_CORE_TOG_REG1_TARG_REG1_TARG_2 = 0x2
	// Target core voltage = 0.775V
	PMU_REG_CORE_TOG_REG1_TARG_REG1_TARG_3 = 0x3
	// Target core voltage = 1.100V
	PMU_REG_CORE_TOG_REG1_TARG_REG1_TARG_16 = 0x10
	// Target core voltage = 1.450V
	PMU_REG_CORE_TOG_REG1_TARG_REG1_TARG_30 = 0x1e
	// Power FET switched full on. No regulation.
	PMU_REG_CORE_TOG_REG1_TARG_REG1_TARG_31 = 0x1f
	// Position of REG1_ADJ field.
	PMU_REG_CORE_TOG_REG1_ADJ_Pos = 0xe
	// Bit mask of REG1_ADJ field.
	PMU_REG_CORE_TOG_REG1_ADJ_Msk = 0x3c000
	// No adjustment
	PMU_REG_CORE_TOG_REG1_ADJ_REG1_ADJ_0 = 0x0
	// + 0.25%
	PMU_REG_CORE_TOG_REG1_ADJ_REG1_ADJ_1 = 0x1
	// + 0.50%
	PMU_REG_CORE_TOG_REG1_ADJ_REG1_ADJ_2 = 0x2
	// + 0.75%
	PMU_REG_CORE_TOG_REG1_ADJ_REG1_ADJ_3 = 0x3
	// + 1.00%
	PMU_REG_CORE_TOG_REG1_ADJ_REG1_ADJ_4 = 0x4
	// + 1.25%
	PMU_REG_CORE_TOG_REG1_ADJ_REG1_ADJ_5 = 0x5
	// + 1.50%
	PMU_REG_CORE_TOG_REG1_ADJ_REG1_ADJ_6 = 0x6
	// + 1.75%
	PMU_REG_CORE_TOG_REG1_ADJ_REG1_ADJ_7 = 0x7
	// - 0.25%
	PMU_REG_CORE_TOG_REG1_ADJ_REG1_ADJ_8 = 0x8
	// - 0.50%
	PMU_REG_CORE_TOG_REG1_ADJ_REG1_ADJ_9 = 0x9
	// - 0.75%
	PMU_REG_CORE_TOG_REG1_ADJ_REG1_ADJ_10 = 0xa
	// - 1.00%
	PMU_REG_CORE_TOG_REG1_ADJ_REG1_ADJ_11 = 0xb
	// - 1.25%
	PMU_REG_CORE_TOG_REG1_ADJ_REG1_ADJ_12 = 0xc
	// - 1.50%
	PMU_REG_CORE_TOG_REG1_ADJ_REG1_ADJ_13 = 0xd
	// - 1.75%
	PMU_REG_CORE_TOG_REG1_ADJ_REG1_ADJ_14 = 0xe
	// - 2.00%
	PMU_REG_CORE_TOG_REG1_ADJ_REG1_ADJ_15 = 0xf
	// Position of REG2_TARG field.
	PMU_REG_CORE_TOG_REG2_TARG_Pos = 0x12
	// Bit mask of REG2_TARG field.
	PMU_REG_CORE_TOG_REG2_TARG_Msk = 0x7c0000
	// Power gated off
	PMU_REG_CORE_TOG_REG2_TARG_REG2_TARG_0 = 0x0
	// Target core voltage = 0.725V
	PMU_REG_CORE_TOG_REG2_TARG_REG2_TARG_1 = 0x1
	// Target core voltage = 0.750V
	PMU_REG_CORE_TOG_REG2_TARG_REG2_TARG_2 = 0x2
	// Target core voltage = 0.775V
	PMU_REG_CORE_TOG_REG2_TARG_REG2_TARG_3 = 0x3
	// Target core voltage = 1.100V
	PMU_REG_CORE_TOG_REG2_TARG_REG2_TARG_16 = 0x10
	// Target core voltage = 1.450V
	PMU_REG_CORE_TOG_REG2_TARG_REG2_TARG_30 = 0x1e
	// Power FET switched full on. No regulation.
	PMU_REG_CORE_TOG_REG2_TARG_REG2_TARG_31 = 0x1f
	// Position of REG2_ADJ field.
	PMU_REG_CORE_TOG_REG2_ADJ_Pos = 0x17
	// Bit mask of REG2_ADJ field.
	PMU_REG_CORE_TOG_REG2_ADJ_Msk = 0x7800000
	// No adjustment
	PMU_REG_CORE_TOG_REG2_ADJ_REG2_ADJ_0 = 0x0
	// + 0.25%
	PMU_REG_CORE_TOG_REG2_ADJ_REG2_ADJ_1 = 0x1
	// + 0.50%
	PMU_REG_CORE_TOG_REG2_ADJ_REG2_ADJ_2 = 0x2
	// + 0.75%
	PMU_REG_CORE_TOG_REG2_ADJ_REG2_ADJ_3 = 0x3
	// + 1.00%
	PMU_REG_CORE_TOG_REG2_ADJ_REG2_ADJ_4 = 0x4
	// + 1.25%
	PMU_REG_CORE_TOG_REG2_ADJ_REG2_ADJ_5 = 0x5
	// + 1.50%
	PMU_REG_CORE_TOG_REG2_ADJ_REG2_ADJ_6 = 0x6
	// + 1.75%
	PMU_REG_CORE_TOG_REG2_ADJ_REG2_ADJ_7 = 0x7
	// - 0.25%
	PMU_REG_CORE_TOG_REG2_ADJ_REG2_ADJ_8 = 0x8
	// - 0.50%
	PMU_REG_CORE_TOG_REG2_ADJ_REG2_ADJ_9 = 0x9
	// - 0.75%
	PMU_REG_CORE_TOG_REG2_ADJ_REG2_ADJ_10 = 0xa
	// - 1.00%
	PMU_REG_CORE_TOG_REG2_ADJ_REG2_ADJ_11 = 0xb
	// - 1.25%
	PMU_REG_CORE_TOG_REG2_ADJ_REG2_ADJ_12 = 0xc
	// - 1.50%
	PMU_REG_CORE_TOG_REG2_ADJ_REG2_ADJ_13 = 0xd
	// - 1.75%
	PMU_REG_CORE_TOG_REG2_ADJ_REG2_ADJ_14 = 0xe
	// - 2.00%
	PMU_REG_CORE_TOG_REG2_ADJ_REG2_ADJ_15 = 0xf
	// Position of RAMP_RATE field.
	PMU_REG_CORE_TOG_RAMP_RATE_Pos = 0x1b
	// Bit mask of RAMP_RATE field.
	PMU_REG_CORE_TOG_RAMP_RATE_Msk = 0x18000000
	// Fast
	PMU_REG_CORE_TOG_RAMP_RATE_RAMP_RATE_0 = 0x0
	// Medium Fast
	PMU_REG_CORE_TOG_RAMP_RATE_RAMP_RATE_1 = 0x1
	// Medium Slow
	PMU_REG_CORE_TOG_RAMP_RATE_RAMP_RATE_2 = 0x2
	// Slow
	PMU_REG_CORE_TOG_RAMP_RATE_RAMP_RATE_3 = 0x3
	// Position of FET_ODRIVE field.
	PMU_REG_CORE_TOG_FET_ODRIVE_Pos = 0x1d
	// Bit mask of FET_ODRIVE field.
	PMU_REG_CORE_TOG_FET_ODRIVE_Msk = 0x20000000
	// Bit FET_ODRIVE.
	PMU_REG_CORE_TOG_FET_ODRIVE = 0x20000000

	// MISC0: Miscellaneous Register 0
	// Position of REFTOP_PWD field.
	PMU_MISC0_REFTOP_PWD_Pos = 0x0
	// Bit mask of REFTOP_PWD field.
	PMU_MISC0_REFTOP_PWD_Msk = 0x1
	// Bit REFTOP_PWD.
	PMU_MISC0_REFTOP_PWD = 0x1
	// Position of REFTOP_SELFBIASOFF field.
	PMU_MISC0_REFTOP_SELFBIASOFF_Pos = 0x3
	// Bit mask of REFTOP_SELFBIASOFF field.
	PMU_MISC0_REFTOP_SELFBIASOFF_Msk = 0x8
	// Bit REFTOP_SELFBIASOFF.
	PMU_MISC0_REFTOP_SELFBIASOFF = 0x8
	// Uses coarse bias currents for startup
	PMU_MISC0_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_0 = 0x0
	// Uses bandgap-based bias currents for best performance.
	PMU_MISC0_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_1 = 0x1
	// Position of REFTOP_VBGADJ field.
	PMU_MISC0_REFTOP_VBGADJ_Pos = 0x4
	// Bit mask of REFTOP_VBGADJ field.
	PMU_MISC0_REFTOP_VBGADJ_Msk = 0x70
	// Nominal VBG
	PMU_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_0 = 0x0
	// VBG+0.78%
	PMU_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_1 = 0x1
	// VBG+1.56%
	PMU_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_2 = 0x2
	// VBG+2.34%
	PMU_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_3 = 0x3
	// VBG-0.78%
	PMU_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_4 = 0x4
	// VBG-1.56%
	PMU_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_5 = 0x5
	// VBG-2.34%
	PMU_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_6 = 0x6
	// VBG-3.12%
	PMU_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_7 = 0x7
	// Position of REFTOP_VBGUP field.
	PMU_MISC0_REFTOP_VBGUP_Pos = 0x7
	// Bit mask of REFTOP_VBGUP field.
	PMU_MISC0_REFTOP_VBGUP_Msk = 0x80
	// Bit REFTOP_VBGUP.
	PMU_MISC0_REFTOP_VBGUP = 0x80
	// Position of STOP_MODE_CONFIG field.
	PMU_MISC0_STOP_MODE_CONFIG_Pos = 0xa
	// Bit mask of STOP_MODE_CONFIG field.
	PMU_MISC0_STOP_MODE_CONFIG_Msk = 0xc00
	// SUSPEND (DSM)
	PMU_MISC0_STOP_MODE_CONFIG_STOP_MODE_CONFIG_0 = 0x0
	// Analog regulators are ON.
	PMU_MISC0_STOP_MODE_CONFIG_STANDBY = 0x1
	// STOP (lower power)
	PMU_MISC0_STOP_MODE_CONFIG_STOP_MODE_CONFIG_2 = 0x2
	// STOP (very lower power)
	PMU_MISC0_STOP_MODE_CONFIG_STOP_MODE_CONFIG_3 = 0x3
	// Position of DISCON_HIGH_SNVS field.
	PMU_MISC0_DISCON_HIGH_SNVS_Pos = 0xc
	// Bit mask of DISCON_HIGH_SNVS field.
	PMU_MISC0_DISCON_HIGH_SNVS_Msk = 0x1000
	// Bit DISCON_HIGH_SNVS.
	PMU_MISC0_DISCON_HIGH_SNVS = 0x1000
	// Turn on the switch
	PMU_MISC0_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_0 = 0x0
	// Turn off the switch
	PMU_MISC0_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_1 = 0x1
	// Position of OSC_I field.
	PMU_MISC0_OSC_I_Pos = 0xd
	// Bit mask of OSC_I field.
	PMU_MISC0_OSC_I_Msk = 0x6000
	// Nominal
	PMU_MISC0_OSC_I_NOMINAL = 0x0
	// Decrease current by 12.5%
	PMU_MISC0_OSC_I_MINUS_12_5_PERCENT = 0x1
	// Decrease current by 25.0%
	PMU_MISC0_OSC_I_MINUS_25_PERCENT = 0x2
	// Decrease current by 37.5%
	PMU_MISC0_OSC_I_MINUS_37_5_PERCENT = 0x3
	// Position of OSC_XTALOK field.
	PMU_MISC0_OSC_XTALOK_Pos = 0xf
	// Bit mask of OSC_XTALOK field.
	PMU_MISC0_OSC_XTALOK_Msk = 0x8000
	// Bit OSC_XTALOK.
	PMU_MISC0_OSC_XTALOK = 0x8000
	// Position of OSC_XTALOK_EN field.
	PMU_MISC0_OSC_XTALOK_EN_Pos = 0x10
	// Bit mask of OSC_XTALOK_EN field.
	PMU_MISC0_OSC_XTALOK_EN_Msk = 0x10000
	// Bit OSC_XTALOK_EN.
	PMU_MISC0_OSC_XTALOK_EN = 0x10000
	// Position of CLKGATE_CTRL field.
	PMU_MISC0_CLKGATE_CTRL_Pos = 0x19
	// Bit mask of CLKGATE_CTRL field.
	PMU_MISC0_CLKGATE_CTRL_Msk = 0x2000000
	// Bit CLKGATE_CTRL.
	PMU_MISC0_CLKGATE_CTRL = 0x2000000
	// Allow the logic to automatically gate the clock when the XTAL is powered down.
	PMU_MISC0_CLKGATE_CTRL_ALLOW_AUTO_GATE = 0x0
	// Prevent the logic from ever gating off the clock.
	PMU_MISC0_CLKGATE_CTRL_NO_AUTO_GATE = 0x1
	// Position of CLKGATE_DELAY field.
	PMU_MISC0_CLKGATE_DELAY_Pos = 0x1a
	// Bit mask of CLKGATE_DELAY field.
	PMU_MISC0_CLKGATE_DELAY_Msk = 0x1c000000
	// 0.5ms
	PMU_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_0 = 0x0
	// 1.0ms
	PMU_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_1 = 0x1
	// 2.0ms
	PMU_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_2 = 0x2
	// 3.0ms
	PMU_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_3 = 0x3
	// 4.0ms
	PMU_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_4 = 0x4
	// 5.0ms
	PMU_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_5 = 0x5
	// 6.0ms
	PMU_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_6 = 0x6
	// 7.0ms
	PMU_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_7 = 0x7
	// Position of RTC_XTAL_SOURCE field.
	PMU_MISC0_RTC_XTAL_SOURCE_Pos = 0x1d
	// Bit mask of RTC_XTAL_SOURCE field.
	PMU_MISC0_RTC_XTAL_SOURCE_Msk = 0x20000000
	// Bit RTC_XTAL_SOURCE.
	PMU_MISC0_RTC_XTAL_SOURCE = 0x20000000
	// Internal ring oscillator
	PMU_MISC0_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_0 = 0x0
	// RTC_XTAL
	PMU_MISC0_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_1 = 0x1
	// Position of XTAL_24M_PWD field.
	PMU_MISC0_XTAL_24M_PWD_Pos = 0x1e
	// Bit mask of XTAL_24M_PWD field.
	PMU_MISC0_XTAL_24M_PWD_Msk = 0x40000000
	// Bit XTAL_24M_PWD.
	PMU_MISC0_XTAL_24M_PWD = 0x40000000
	// Position of VID_PLL_PREDIV field.
	PMU_MISC0_VID_PLL_PREDIV_Pos = 0x1f
	// Bit mask of VID_PLL_PREDIV field.
	PMU_MISC0_VID_PLL_PREDIV_Msk = 0x80000000
	// Bit VID_PLL_PREDIV.
	PMU_MISC0_VID_PLL_PREDIV = 0x80000000
	// Divide by 1
	PMU_MISC0_VID_PLL_PREDIV_VID_PLL_PREDIV_0 = 0x0
	// Divide by 2
	PMU_MISC0_VID_PLL_PREDIV_VID_PLL_PREDIV_1 = 0x1

	// MISC0_SET: Miscellaneous Register 0
	// Position of REFTOP_PWD field.
	PMU_MISC0_SET_REFTOP_PWD_Pos = 0x0
	// Bit mask of REFTOP_PWD field.
	PMU_MISC0_SET_REFTOP_PWD_Msk = 0x1
	// Bit REFTOP_PWD.
	PMU_MISC0_SET_REFTOP_PWD = 0x1
	// Position of REFTOP_SELFBIASOFF field.
	PMU_MISC0_SET_REFTOP_SELFBIASOFF_Pos = 0x3
	// Bit mask of REFTOP_SELFBIASOFF field.
	PMU_MISC0_SET_REFTOP_SELFBIASOFF_Msk = 0x8
	// Bit REFTOP_SELFBIASOFF.
	PMU_MISC0_SET_REFTOP_SELFBIASOFF = 0x8
	// Uses coarse bias currents for startup
	PMU_MISC0_SET_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_0 = 0x0
	// Uses bandgap-based bias currents for best performance.
	PMU_MISC0_SET_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_1 = 0x1
	// Position of REFTOP_VBGADJ field.
	PMU_MISC0_SET_REFTOP_VBGADJ_Pos = 0x4
	// Bit mask of REFTOP_VBGADJ field.
	PMU_MISC0_SET_REFTOP_VBGADJ_Msk = 0x70
	// Nominal VBG
	PMU_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_0 = 0x0
	// VBG+0.78%
	PMU_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_1 = 0x1
	// VBG+1.56%
	PMU_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_2 = 0x2
	// VBG+2.34%
	PMU_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_3 = 0x3
	// VBG-0.78%
	PMU_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_4 = 0x4
	// VBG-1.56%
	PMU_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_5 = 0x5
	// VBG-2.34%
	PMU_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_6 = 0x6
	// VBG-3.12%
	PMU_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_7 = 0x7
	// Position of REFTOP_VBGUP field.
	PMU_MISC0_SET_REFTOP_VBGUP_Pos = 0x7
	// Bit mask of REFTOP_VBGUP field.
	PMU_MISC0_SET_REFTOP_VBGUP_Msk = 0x80
	// Bit REFTOP_VBGUP.
	PMU_MISC0_SET_REFTOP_VBGUP = 0x80
	// Position of STOP_MODE_CONFIG field.
	PMU_MISC0_SET_STOP_MODE_CONFIG_Pos = 0xa
	// Bit mask of STOP_MODE_CONFIG field.
	PMU_MISC0_SET_STOP_MODE_CONFIG_Msk = 0xc00
	// SUSPEND (DSM)
	PMU_MISC0_SET_STOP_MODE_CONFIG_STOP_MODE_CONFIG_0 = 0x0
	// Analog regulators are ON.
	PMU_MISC0_SET_STOP_MODE_CONFIG_STANDBY = 0x1
	// STOP (lower power)
	PMU_MISC0_SET_STOP_MODE_CONFIG_STOP_MODE_CONFIG_2 = 0x2
	// STOP (very lower power)
	PMU_MISC0_SET_STOP_MODE_CONFIG_STOP_MODE_CONFIG_3 = 0x3
	// Position of DISCON_HIGH_SNVS field.
	PMU_MISC0_SET_DISCON_HIGH_SNVS_Pos = 0xc
	// Bit mask of DISCON_HIGH_SNVS field.
	PMU_MISC0_SET_DISCON_HIGH_SNVS_Msk = 0x1000
	// Bit DISCON_HIGH_SNVS.
	PMU_MISC0_SET_DISCON_HIGH_SNVS = 0x1000
	// Turn on the switch
	PMU_MISC0_SET_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_0 = 0x0
	// Turn off the switch
	PMU_MISC0_SET_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_1 = 0x1
	// Position of OSC_I field.
	PMU_MISC0_SET_OSC_I_Pos = 0xd
	// Bit mask of OSC_I field.
	PMU_MISC0_SET_OSC_I_Msk = 0x6000
	// Nominal
	PMU_MISC0_SET_OSC_I_NOMINAL = 0x0
	// Decrease current by 12.5%
	PMU_MISC0_SET_OSC_I_MINUS_12_5_PERCENT = 0x1
	// Decrease current by 25.0%
	PMU_MISC0_SET_OSC_I_MINUS_25_PERCENT = 0x2
	// Decrease current by 37.5%
	PMU_MISC0_SET_OSC_I_MINUS_37_5_PERCENT = 0x3
	// Position of OSC_XTALOK field.
	PMU_MISC0_SET_OSC_XTALOK_Pos = 0xf
	// Bit mask of OSC_XTALOK field.
	PMU_MISC0_SET_OSC_XTALOK_Msk = 0x8000
	// Bit OSC_XTALOK.
	PMU_MISC0_SET_OSC_XTALOK = 0x8000
	// Position of OSC_XTALOK_EN field.
	PMU_MISC0_SET_OSC_XTALOK_EN_Pos = 0x10
	// Bit mask of OSC_XTALOK_EN field.
	PMU_MISC0_SET_OSC_XTALOK_EN_Msk = 0x10000
	// Bit OSC_XTALOK_EN.
	PMU_MISC0_SET_OSC_XTALOK_EN = 0x10000
	// Position of CLKGATE_CTRL field.
	PMU_MISC0_SET_CLKGATE_CTRL_Pos = 0x19
	// Bit mask of CLKGATE_CTRL field.
	PMU_MISC0_SET_CLKGATE_CTRL_Msk = 0x2000000
	// Bit CLKGATE_CTRL.
	PMU_MISC0_SET_CLKGATE_CTRL = 0x2000000
	// Allow the logic to automatically gate the clock when the XTAL is powered down.
	PMU_MISC0_SET_CLKGATE_CTRL_ALLOW_AUTO_GATE = 0x0
	// Prevent the logic from ever gating off the clock.
	PMU_MISC0_SET_CLKGATE_CTRL_NO_AUTO_GATE = 0x1
	// Position of CLKGATE_DELAY field.
	PMU_MISC0_SET_CLKGATE_DELAY_Pos = 0x1a
	// Bit mask of CLKGATE_DELAY field.
	PMU_MISC0_SET_CLKGATE_DELAY_Msk = 0x1c000000
	// 0.5ms
	PMU_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_0 = 0x0
	// 1.0ms
	PMU_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_1 = 0x1
	// 2.0ms
	PMU_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_2 = 0x2
	// 3.0ms
	PMU_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_3 = 0x3
	// 4.0ms
	PMU_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_4 = 0x4
	// 5.0ms
	PMU_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_5 = 0x5
	// 6.0ms
	PMU_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_6 = 0x6
	// 7.0ms
	PMU_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_7 = 0x7
	// Position of RTC_XTAL_SOURCE field.
	PMU_MISC0_SET_RTC_XTAL_SOURCE_Pos = 0x1d
	// Bit mask of RTC_XTAL_SOURCE field.
	PMU_MISC0_SET_RTC_XTAL_SOURCE_Msk = 0x20000000
	// Bit RTC_XTAL_SOURCE.
	PMU_MISC0_SET_RTC_XTAL_SOURCE = 0x20000000
	// Internal ring oscillator
	PMU_MISC0_SET_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_0 = 0x0
	// RTC_XTAL
	PMU_MISC0_SET_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_1 = 0x1
	// Position of XTAL_24M_PWD field.
	PMU_MISC0_SET_XTAL_24M_PWD_Pos = 0x1e
	// Bit mask of XTAL_24M_PWD field.
	PMU_MISC0_SET_XTAL_24M_PWD_Msk = 0x40000000
	// Bit XTAL_24M_PWD.
	PMU_MISC0_SET_XTAL_24M_PWD = 0x40000000
	// Position of VID_PLL_PREDIV field.
	PMU_MISC0_SET_VID_PLL_PREDIV_Pos = 0x1f
	// Bit mask of VID_PLL_PREDIV field.
	PMU_MISC0_SET_VID_PLL_PREDIV_Msk = 0x80000000
	// Bit VID_PLL_PREDIV.
	PMU_MISC0_SET_VID_PLL_PREDIV = 0x80000000
	// Divide by 1
	PMU_MISC0_SET_VID_PLL_PREDIV_VID_PLL_PREDIV_0 = 0x0
	// Divide by 2
	PMU_MISC0_SET_VID_PLL_PREDIV_VID_PLL_PREDIV_1 = 0x1

	// MISC0_CLR: Miscellaneous Register 0
	// Position of REFTOP_PWD field.
	PMU_MISC0_CLR_REFTOP_PWD_Pos = 0x0
	// Bit mask of REFTOP_PWD field.
	PMU_MISC0_CLR_REFTOP_PWD_Msk = 0x1
	// Bit REFTOP_PWD.
	PMU_MISC0_CLR_REFTOP_PWD = 0x1
	// Position of REFTOP_SELFBIASOFF field.
	PMU_MISC0_CLR_REFTOP_SELFBIASOFF_Pos = 0x3
	// Bit mask of REFTOP_SELFBIASOFF field.
	PMU_MISC0_CLR_REFTOP_SELFBIASOFF_Msk = 0x8
	// Bit REFTOP_SELFBIASOFF.
	PMU_MISC0_CLR_REFTOP_SELFBIASOFF = 0x8
	// Uses coarse bias currents for startup
	PMU_MISC0_CLR_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_0 = 0x0
	// Uses bandgap-based bias currents for best performance.
	PMU_MISC0_CLR_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_1 = 0x1
	// Position of REFTOP_VBGADJ field.
	PMU_MISC0_CLR_REFTOP_VBGADJ_Pos = 0x4
	// Bit mask of REFTOP_VBGADJ field.
	PMU_MISC0_CLR_REFTOP_VBGADJ_Msk = 0x70
	// Nominal VBG
	PMU_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_0 = 0x0
	// VBG+0.78%
	PMU_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_1 = 0x1
	// VBG+1.56%
	PMU_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_2 = 0x2
	// VBG+2.34%
	PMU_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_3 = 0x3
	// VBG-0.78%
	PMU_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_4 = 0x4
	// VBG-1.56%
	PMU_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_5 = 0x5
	// VBG-2.34%
	PMU_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_6 = 0x6
	// VBG-3.12%
	PMU_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_7 = 0x7
	// Position of REFTOP_VBGUP field.
	PMU_MISC0_CLR_REFTOP_VBGUP_Pos = 0x7
	// Bit mask of REFTOP_VBGUP field.
	PMU_MISC0_CLR_REFTOP_VBGUP_Msk = 0x80
	// Bit REFTOP_VBGUP.
	PMU_MISC0_CLR_REFTOP_VBGUP = 0x80
	// Position of STOP_MODE_CONFIG field.
	PMU_MISC0_CLR_STOP_MODE_CONFIG_Pos = 0xa
	// Bit mask of STOP_MODE_CONFIG field.
	PMU_MISC0_CLR_STOP_MODE_CONFIG_Msk = 0xc00
	// SUSPEND (DSM)
	PMU_MISC0_CLR_STOP_MODE_CONFIG_STOP_MODE_CONFIG_0 = 0x0
	// Analog regulators are ON.
	PMU_MISC0_CLR_STOP_MODE_CONFIG_STANDBY = 0x1
	// STOP (lower power)
	PMU_MISC0_CLR_STOP_MODE_CONFIG_STOP_MODE_CONFIG_2 = 0x2
	// STOP (very lower power)
	PMU_MISC0_CLR_STOP_MODE_CONFIG_STOP_MODE_CONFIG_3 = 0x3
	// Position of DISCON_HIGH_SNVS field.
	PMU_MISC0_CLR_DISCON_HIGH_SNVS_Pos = 0xc
	// Bit mask of DISCON_HIGH_SNVS field.
	PMU_MISC0_CLR_DISCON_HIGH_SNVS_Msk = 0x1000
	// Bit DISCON_HIGH_SNVS.
	PMU_MISC0_CLR_DISCON_HIGH_SNVS = 0x1000
	// Turn on the switch
	PMU_MISC0_CLR_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_0 = 0x0
	// Turn off the switch
	PMU_MISC0_CLR_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_1 = 0x1
	// Position of OSC_I field.
	PMU_MISC0_CLR_OSC_I_Pos = 0xd
	// Bit mask of OSC_I field.
	PMU_MISC0_CLR_OSC_I_Msk = 0x6000
	// Nominal
	PMU_MISC0_CLR_OSC_I_NOMINAL = 0x0
	// Decrease current by 12.5%
	PMU_MISC0_CLR_OSC_I_MINUS_12_5_PERCENT = 0x1
	// Decrease current by 25.0%
	PMU_MISC0_CLR_OSC_I_MINUS_25_PERCENT = 0x2
	// Decrease current by 37.5%
	PMU_MISC0_CLR_OSC_I_MINUS_37_5_PERCENT = 0x3
	// Position of OSC_XTALOK field.
	PMU_MISC0_CLR_OSC_XTALOK_Pos = 0xf
	// Bit mask of OSC_XTALOK field.
	PMU_MISC0_CLR_OSC_XTALOK_Msk = 0x8000
	// Bit OSC_XTALOK.
	PMU_MISC0_CLR_OSC_XTALOK = 0x8000
	// Position of OSC_XTALOK_EN field.
	PMU_MISC0_CLR_OSC_XTALOK_EN_Pos = 0x10
	// Bit mask of OSC_XTALOK_EN field.
	PMU_MISC0_CLR_OSC_XTALOK_EN_Msk = 0x10000
	// Bit OSC_XTALOK_EN.
	PMU_MISC0_CLR_OSC_XTALOK_EN = 0x10000
	// Position of CLKGATE_CTRL field.
	PMU_MISC0_CLR_CLKGATE_CTRL_Pos = 0x19
	// Bit mask of CLKGATE_CTRL field.
	PMU_MISC0_CLR_CLKGATE_CTRL_Msk = 0x2000000
	// Bit CLKGATE_CTRL.
	PMU_MISC0_CLR_CLKGATE_CTRL = 0x2000000
	// Allow the logic to automatically gate the clock when the XTAL is powered down.
	PMU_MISC0_CLR_CLKGATE_CTRL_ALLOW_AUTO_GATE = 0x0
	// Prevent the logic from ever gating off the clock.
	PMU_MISC0_CLR_CLKGATE_CTRL_NO_AUTO_GATE = 0x1
	// Position of CLKGATE_DELAY field.
	PMU_MISC0_CLR_CLKGATE_DELAY_Pos = 0x1a
	// Bit mask of CLKGATE_DELAY field.
	PMU_MISC0_CLR_CLKGATE_DELAY_Msk = 0x1c000000
	// 0.5ms
	PMU_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_0 = 0x0
	// 1.0ms
	PMU_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_1 = 0x1
	// 2.0ms
	PMU_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_2 = 0x2
	// 3.0ms
	PMU_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_3 = 0x3
	// 4.0ms
	PMU_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_4 = 0x4
	// 5.0ms
	PMU_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_5 = 0x5
	// 6.0ms
	PMU_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_6 = 0x6
	// 7.0ms
	PMU_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_7 = 0x7
	// Position of RTC_XTAL_SOURCE field.
	PMU_MISC0_CLR_RTC_XTAL_SOURCE_Pos = 0x1d
	// Bit mask of RTC_XTAL_SOURCE field.
	PMU_MISC0_CLR_RTC_XTAL_SOURCE_Msk = 0x20000000
	// Bit RTC_XTAL_SOURCE.
	PMU_MISC0_CLR_RTC_XTAL_SOURCE = 0x20000000
	// Internal ring oscillator
	PMU_MISC0_CLR_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_0 = 0x0
	// RTC_XTAL
	PMU_MISC0_CLR_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_1 = 0x1
	// Position of XTAL_24M_PWD field.
	PMU_MISC0_CLR_XTAL_24M_PWD_Pos = 0x1e
	// Bit mask of XTAL_24M_PWD field.
	PMU_MISC0_CLR_XTAL_24M_PWD_Msk = 0x40000000
	// Bit XTAL_24M_PWD.
	PMU_MISC0_CLR_XTAL_24M_PWD = 0x40000000
	// Position of VID_PLL_PREDIV field.
	PMU_MISC0_CLR_VID_PLL_PREDIV_Pos = 0x1f
	// Bit mask of VID_PLL_PREDIV field.
	PMU_MISC0_CLR_VID_PLL_PREDIV_Msk = 0x80000000
	// Bit VID_PLL_PREDIV.
	PMU_MISC0_CLR_VID_PLL_PREDIV = 0x80000000
	// Divide by 1
	PMU_MISC0_CLR_VID_PLL_PREDIV_VID_PLL_PREDIV_0 = 0x0
	// Divide by 2
	PMU_MISC0_CLR_VID_PLL_PREDIV_VID_PLL_PREDIV_1 = 0x1

	// MISC0_TOG: Miscellaneous Register 0
	// Position of REFTOP_PWD field.
	PMU_MISC0_TOG_REFTOP_PWD_Pos = 0x0
	// Bit mask of REFTOP_PWD field.
	PMU_MISC0_TOG_REFTOP_PWD_Msk = 0x1
	// Bit REFTOP_PWD.
	PMU_MISC0_TOG_REFTOP_PWD = 0x1
	// Position of REFTOP_SELFBIASOFF field.
	PMU_MISC0_TOG_REFTOP_SELFBIASOFF_Pos = 0x3
	// Bit mask of REFTOP_SELFBIASOFF field.
	PMU_MISC0_TOG_REFTOP_SELFBIASOFF_Msk = 0x8
	// Bit REFTOP_SELFBIASOFF.
	PMU_MISC0_TOG_REFTOP_SELFBIASOFF = 0x8
	// Uses coarse bias currents for startup
	PMU_MISC0_TOG_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_0 = 0x0
	// Uses bandgap-based bias currents for best performance.
	PMU_MISC0_TOG_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_1 = 0x1
	// Position of REFTOP_VBGADJ field.
	PMU_MISC0_TOG_REFTOP_VBGADJ_Pos = 0x4
	// Bit mask of REFTOP_VBGADJ field.
	PMU_MISC0_TOG_REFTOP_VBGADJ_Msk = 0x70
	// Nominal VBG
	PMU_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_0 = 0x0
	// VBG+0.78%
	PMU_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_1 = 0x1
	// VBG+1.56%
	PMU_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_2 = 0x2
	// VBG+2.34%
	PMU_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_3 = 0x3
	// VBG-0.78%
	PMU_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_4 = 0x4
	// VBG-1.56%
	PMU_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_5 = 0x5
	// VBG-2.34%
	PMU_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_6 = 0x6
	// VBG-3.12%
	PMU_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_7 = 0x7
	// Position of REFTOP_VBGUP field.
	PMU_MISC0_TOG_REFTOP_VBGUP_Pos = 0x7
	// Bit mask of REFTOP_VBGUP field.
	PMU_MISC0_TOG_REFTOP_VBGUP_Msk = 0x80
	// Bit REFTOP_VBGUP.
	PMU_MISC0_TOG_REFTOP_VBGUP = 0x80
	// Position of STOP_MODE_CONFIG field.
	PMU_MISC0_TOG_STOP_MODE_CONFIG_Pos = 0xa
	// Bit mask of STOP_MODE_CONFIG field.
	PMU_MISC0_TOG_STOP_MODE_CONFIG_Msk = 0xc00
	// SUSPEND (DSM)
	PMU_MISC0_TOG_STOP_MODE_CONFIG_STOP_MODE_CONFIG_0 = 0x0
	// Analog regulators are ON.
	PMU_MISC0_TOG_STOP_MODE_CONFIG_STANDBY = 0x1
	// STOP (lower power)
	PMU_MISC0_TOG_STOP_MODE_CONFIG_STOP_MODE_CONFIG_2 = 0x2
	// STOP (very lower power)
	PMU_MISC0_TOG_STOP_MODE_CONFIG_STOP_MODE_CONFIG_3 = 0x3
	// Position of DISCON_HIGH_SNVS field.
	PMU_MISC0_TOG_DISCON_HIGH_SNVS_Pos = 0xc
	// Bit mask of DISCON_HIGH_SNVS field.
	PMU_MISC0_TOG_DISCON_HIGH_SNVS_Msk = 0x1000
	// Bit DISCON_HIGH_SNVS.
	PMU_MISC0_TOG_DISCON_HIGH_SNVS = 0x1000
	// Turn on the switch
	PMU_MISC0_TOG_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_0 = 0x0
	// Turn off the switch
	PMU_MISC0_TOG_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_1 = 0x1
	// Position of OSC_I field.
	PMU_MISC0_TOG_OSC_I_Pos = 0xd
	// Bit mask of OSC_I field.
	PMU_MISC0_TOG_OSC_I_Msk = 0x6000
	// Nominal
	PMU_MISC0_TOG_OSC_I_NOMINAL = 0x0
	// Decrease current by 12.5%
	PMU_MISC0_TOG_OSC_I_MINUS_12_5_PERCENT = 0x1
	// Decrease current by 25.0%
	PMU_MISC0_TOG_OSC_I_MINUS_25_PERCENT = 0x2
	// Decrease current by 37.5%
	PMU_MISC0_TOG_OSC_I_MINUS_37_5_PERCENT = 0x3
	// Position of OSC_XTALOK field.
	PMU_MISC0_TOG_OSC_XTALOK_Pos = 0xf
	// Bit mask of OSC_XTALOK field.
	PMU_MISC0_TOG_OSC_XTALOK_Msk = 0x8000
	// Bit OSC_XTALOK.
	PMU_MISC0_TOG_OSC_XTALOK = 0x8000
	// Position of OSC_XTALOK_EN field.
	PMU_MISC0_TOG_OSC_XTALOK_EN_Pos = 0x10
	// Bit mask of OSC_XTALOK_EN field.
	PMU_MISC0_TOG_OSC_XTALOK_EN_Msk = 0x10000
	// Bit OSC_XTALOK_EN.
	PMU_MISC0_TOG_OSC_XTALOK_EN = 0x10000
	// Position of CLKGATE_CTRL field.
	PMU_MISC0_TOG_CLKGATE_CTRL_Pos = 0x19
	// Bit mask of CLKGATE_CTRL field.
	PMU_MISC0_TOG_CLKGATE_CTRL_Msk = 0x2000000
	// Bit CLKGATE_CTRL.
	PMU_MISC0_TOG_CLKGATE_CTRL = 0x2000000
	// Allow the logic to automatically gate the clock when the XTAL is powered down.
	PMU_MISC0_TOG_CLKGATE_CTRL_ALLOW_AUTO_GATE = 0x0
	// Prevent the logic from ever gating off the clock.
	PMU_MISC0_TOG_CLKGATE_CTRL_NO_AUTO_GATE = 0x1
	// Position of CLKGATE_DELAY field.
	PMU_MISC0_TOG_CLKGATE_DELAY_Pos = 0x1a
	// Bit mask of CLKGATE_DELAY field.
	PMU_MISC0_TOG_CLKGATE_DELAY_Msk = 0x1c000000
	// 0.5ms
	PMU_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_0 = 0x0
	// 1.0ms
	PMU_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_1 = 0x1
	// 2.0ms
	PMU_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_2 = 0x2
	// 3.0ms
	PMU_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_3 = 0x3
	// 4.0ms
	PMU_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_4 = 0x4
	// 5.0ms
	PMU_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_5 = 0x5
	// 6.0ms
	PMU_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_6 = 0x6
	// 7.0ms
	PMU_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_7 = 0x7
	// Position of RTC_XTAL_SOURCE field.
	PMU_MISC0_TOG_RTC_XTAL_SOURCE_Pos = 0x1d
	// Bit mask of RTC_XTAL_SOURCE field.
	PMU_MISC0_TOG_RTC_XTAL_SOURCE_Msk = 0x20000000
	// Bit RTC_XTAL_SOURCE.
	PMU_MISC0_TOG_RTC_XTAL_SOURCE = 0x20000000
	// Internal ring oscillator
	PMU_MISC0_TOG_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_0 = 0x0
	// RTC_XTAL
	PMU_MISC0_TOG_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_1 = 0x1
	// Position of XTAL_24M_PWD field.
	PMU_MISC0_TOG_XTAL_24M_PWD_Pos = 0x1e
	// Bit mask of XTAL_24M_PWD field.
	PMU_MISC0_TOG_XTAL_24M_PWD_Msk = 0x40000000
	// Bit XTAL_24M_PWD.
	PMU_MISC0_TOG_XTAL_24M_PWD = 0x40000000
	// Position of VID_PLL_PREDIV field.
	PMU_MISC0_TOG_VID_PLL_PREDIV_Pos = 0x1f
	// Bit mask of VID_PLL_PREDIV field.
	PMU_MISC0_TOG_VID_PLL_PREDIV_Msk = 0x80000000
	// Bit VID_PLL_PREDIV.
	PMU_MISC0_TOG_VID_PLL_PREDIV = 0x80000000
	// Divide by 1
	PMU_MISC0_TOG_VID_PLL_PREDIV_VID_PLL_PREDIV_0 = 0x0
	// Divide by 2
	PMU_MISC0_TOG_VID_PLL_PREDIV_VID_PLL_PREDIV_1 = 0x1

	// MISC1: Miscellaneous Register 1
	// Position of LVDS1_CLK_SEL field.
	PMU_MISC1_LVDS1_CLK_SEL_Pos = 0x0
	// Bit mask of LVDS1_CLK_SEL field.
	PMU_MISC1_LVDS1_CLK_SEL_Msk = 0x1f
	// Arm PLL
	PMU_MISC1_LVDS1_CLK_SEL_ARM_PLL = 0x0
	// System PLL
	PMU_MISC1_LVDS1_CLK_SEL_SYS_PLL = 0x1
	// ref_pfd4_clk == pll2_pfd0_clk
	PMU_MISC1_LVDS1_CLK_SEL_PFD4 = 0x2
	// ref_pfd5_clk == pll2_pfd1_clk
	PMU_MISC1_LVDS1_CLK_SEL_PFD5 = 0x3
	// ref_pfd6_clk == pll2_pfd2_clk
	PMU_MISC1_LVDS1_CLK_SEL_PFD6 = 0x4
	// ref_pfd7_clk == pll2_pfd3_clk
	PMU_MISC1_LVDS1_CLK_SEL_PFD7 = 0x5
	// Audio PLL
	PMU_MISC1_LVDS1_CLK_SEL_AUDIO_PLL = 0x6
	// Video PLL
	PMU_MISC1_LVDS1_CLK_SEL_VIDEO_PLL = 0x7
	// ethernet ref clock (ENET_PLL)
	PMU_MISC1_LVDS1_CLK_SEL_ETHERNET_REF = 0x9
	// USB1 PLL clock
	PMU_MISC1_LVDS1_CLK_SEL_USB1_PLL = 0xc
	// USB2 PLL clock
	PMU_MISC1_LVDS1_CLK_SEL_USB2_PLL = 0xd
	// ref_pfd0_clk == pll3_pfd0_clk
	PMU_MISC1_LVDS1_CLK_SEL_PFD0 = 0xe
	// ref_pfd1_clk == pll3_pfd1_clk
	PMU_MISC1_LVDS1_CLK_SEL_PFD1 = 0xf
	// ref_pfd2_clk == pll3_pfd2_clk
	PMU_MISC1_LVDS1_CLK_SEL_PFD2 = 0x10
	// ref_pfd3_clk == pll3_pfd3_clk
	PMU_MISC1_LVDS1_CLK_SEL_PFD3 = 0x11
	// xtal (24M)
	PMU_MISC1_LVDS1_CLK_SEL_XTAL = 0x12
	// Position of LVDS2_CLK_SEL field.
	PMU_MISC1_LVDS2_CLK_SEL_Pos = 0x5
	// Bit mask of LVDS2_CLK_SEL field.
	PMU_MISC1_LVDS2_CLK_SEL_Msk = 0x3e0
	// Arm PLL
	PMU_MISC1_LVDS2_CLK_SEL_ARM_PLL = 0x0
	// System PLL
	PMU_MISC1_LVDS2_CLK_SEL_SYS_PLL = 0x1
	// ref_pfd4_clk == pll2_pfd0_clk
	PMU_MISC1_LVDS2_CLK_SEL_PFD4 = 0x2
	// ref_pfd5_clk == pll2_pfd1_clk
	PMU_MISC1_LVDS2_CLK_SEL_PFD5 = 0x3
	// ref_pfd6_clk == pll2_pfd2_clk
	PMU_MISC1_LVDS2_CLK_SEL_PFD6 = 0x4
	// ref_pfd7_clk == pll2_pfd3_clk
	PMU_MISC1_LVDS2_CLK_SEL_PFD7 = 0x5
	// Audio PLL
	PMU_MISC1_LVDS2_CLK_SEL_AUDIO_PLL = 0x6
	// Video PLL
	PMU_MISC1_LVDS2_CLK_SEL_VIDEO_PLL = 0x7
	// MLB PLL
	PMU_MISC1_LVDS2_CLK_SEL_MLB_PLL = 0x8
	// ethernet ref clock (ENET_PLL)
	PMU_MISC1_LVDS2_CLK_SEL_ETHERNET_REF = 0x9
	// PCIe ref clock (125M)
	PMU_MISC1_LVDS2_CLK_SEL_PCIE_REF = 0xa
	// SATA ref clock (100M)
	PMU_MISC1_LVDS2_CLK_SEL_SATA_REF = 0xb
	// USB1 PLL clock
	PMU_MISC1_LVDS2_CLK_SEL_USB1_PLL = 0xc
	// USB2 PLL clock
	PMU_MISC1_LVDS2_CLK_SEL_USB2_PLL = 0xd
	// ref_pfd0_clk == pll3_pfd0_clk
	PMU_MISC1_LVDS2_CLK_SEL_PFD0 = 0xe
	// ref_pfd1_clk == pll3_pfd1_clk
	PMU_MISC1_LVDS2_CLK_SEL_PFD1 = 0xf
	// ref_pfd2_clk == pll3_pfd2_clk
	PMU_MISC1_LVDS2_CLK_SEL_PFD2 = 0x10
	// ref_pfd3_clk == pll3_pfd3_clk
	PMU_MISC1_LVDS2_CLK_SEL_PFD3 = 0x11
	// xtal (24M)
	PMU_MISC1_LVDS2_CLK_SEL_XTAL = 0x12
	// LVDS1 (loopback)
	PMU_MISC1_LVDS2_CLK_SEL_LVDS1 = 0x13
	// LVDS2 (not useful)
	PMU_MISC1_LVDS2_CLK_SEL_LVDS2 = 0x14
	// Position of LVDSCLK1_OBEN field.
	PMU_MISC1_LVDSCLK1_OBEN_Pos = 0xa
	// Bit mask of LVDSCLK1_OBEN field.
	PMU_MISC1_LVDSCLK1_OBEN_Msk = 0x400
	// Bit LVDSCLK1_OBEN.
	PMU_MISC1_LVDSCLK1_OBEN = 0x400
	// Position of LVDSCLK2_OBEN field.
	PMU_MISC1_LVDSCLK2_OBEN_Pos = 0xb
	// Bit mask of LVDSCLK2_OBEN field.
	PMU_MISC1_LVDSCLK2_OBEN_Msk = 0x800
	// Bit LVDSCLK2_OBEN.
	PMU_MISC1_LVDSCLK2_OBEN = 0x800
	// Position of LVDSCLK1_IBEN field.
	PMU_MISC1_LVDSCLK1_IBEN_Pos = 0xc
	// Bit mask of LVDSCLK1_IBEN field.
	PMU_MISC1_LVDSCLK1_IBEN_Msk = 0x1000
	// Bit LVDSCLK1_IBEN.
	PMU_MISC1_LVDSCLK1_IBEN = 0x1000
	// Position of LVDSCLK2_IBEN field.
	PMU_MISC1_LVDSCLK2_IBEN_Pos = 0xd
	// Bit mask of LVDSCLK2_IBEN field.
	PMU_MISC1_LVDSCLK2_IBEN_Msk = 0x2000
	// Bit LVDSCLK2_IBEN.
	PMU_MISC1_LVDSCLK2_IBEN = 0x2000
	// Position of PFD_480_AUTOGATE_EN field.
	PMU_MISC1_PFD_480_AUTOGATE_EN_Pos = 0x10
	// Bit mask of PFD_480_AUTOGATE_EN field.
	PMU_MISC1_PFD_480_AUTOGATE_EN_Msk = 0x10000
	// Bit PFD_480_AUTOGATE_EN.
	PMU_MISC1_PFD_480_AUTOGATE_EN = 0x10000
	// Position of PFD_528_AUTOGATE_EN field.
	PMU_MISC1_PFD_528_AUTOGATE_EN_Pos = 0x11
	// Bit mask of PFD_528_AUTOGATE_EN field.
	PMU_MISC1_PFD_528_AUTOGATE_EN_Msk = 0x20000
	// Bit PFD_528_AUTOGATE_EN.
	PMU_MISC1_PFD_528_AUTOGATE_EN = 0x20000
	// Position of IRQ_TEMPPANIC field.
	PMU_MISC1_IRQ_TEMPPANIC_Pos = 0x1b
	// Bit mask of IRQ_TEMPPANIC field.
	PMU_MISC1_IRQ_TEMPPANIC_Msk = 0x8000000
	// Bit IRQ_TEMPPANIC.
	PMU_MISC1_IRQ_TEMPPANIC = 0x8000000
	// Position of IRQ_TEMPLOW field.
	PMU_MISC1_IRQ_TEMPLOW_Pos = 0x1c
	// Bit mask of IRQ_TEMPLOW field.
	PMU_MISC1_IRQ_TEMPLOW_Msk = 0x10000000
	// Bit IRQ_TEMPLOW.
	PMU_MISC1_IRQ_TEMPLOW = 0x10000000
	// Position of IRQ_TEMPHIGH field.
	PMU_MISC1_IRQ_TEMPHIGH_Pos = 0x1d
	// Bit mask of IRQ_TEMPHIGH field.
	PMU_MISC1_IRQ_TEMPHIGH_Msk = 0x20000000
	// Bit IRQ_TEMPHIGH.
	PMU_MISC1_IRQ_TEMPHIGH = 0x20000000
	// Position of IRQ_ANA_BO field.
	PMU_MISC1_IRQ_ANA_BO_Pos = 0x1e
	// Bit mask of IRQ_ANA_BO field.
	PMU_MISC1_IRQ_ANA_BO_Msk = 0x40000000
	// Bit IRQ_ANA_BO.
	PMU_MISC1_IRQ_ANA_BO = 0x40000000
	// Position of IRQ_DIG_BO field.
	PMU_MISC1_IRQ_DIG_BO_Pos = 0x1f
	// Bit mask of IRQ_DIG_BO field.
	PMU_MISC1_IRQ_DIG_BO_Msk = 0x80000000
	// Bit IRQ_DIG_BO.
	PMU_MISC1_IRQ_DIG_BO = 0x80000000

	// MISC1_SET: Miscellaneous Register 1
	// Position of LVDS1_CLK_SEL field.
	PMU_MISC1_SET_LVDS1_CLK_SEL_Pos = 0x0
	// Bit mask of LVDS1_CLK_SEL field.
	PMU_MISC1_SET_LVDS1_CLK_SEL_Msk = 0x1f
	// Arm PLL
	PMU_MISC1_SET_LVDS1_CLK_SEL_ARM_PLL = 0x0
	// System PLL
	PMU_MISC1_SET_LVDS1_CLK_SEL_SYS_PLL = 0x1
	// ref_pfd4_clk == pll2_pfd0_clk
	PMU_MISC1_SET_LVDS1_CLK_SEL_PFD4 = 0x2
	// ref_pfd5_clk == pll2_pfd1_clk
	PMU_MISC1_SET_LVDS1_CLK_SEL_PFD5 = 0x3
	// ref_pfd6_clk == pll2_pfd2_clk
	PMU_MISC1_SET_LVDS1_CLK_SEL_PFD6 = 0x4
	// ref_pfd7_clk == pll2_pfd3_clk
	PMU_MISC1_SET_LVDS1_CLK_SEL_PFD7 = 0x5
	// Audio PLL
	PMU_MISC1_SET_LVDS1_CLK_SEL_AUDIO_PLL = 0x6
	// Video PLL
	PMU_MISC1_SET_LVDS1_CLK_SEL_VIDEO_PLL = 0x7
	// ethernet ref clock (ENET_PLL)
	PMU_MISC1_SET_LVDS1_CLK_SEL_ETHERNET_REF = 0x9
	// USB1 PLL clock
	PMU_MISC1_SET_LVDS1_CLK_SEL_USB1_PLL = 0xc
	// USB2 PLL clock
	PMU_MISC1_SET_LVDS1_CLK_SEL_USB2_PLL = 0xd
	// ref_pfd0_clk == pll3_pfd0_clk
	PMU_MISC1_SET_LVDS1_CLK_SEL_PFD0 = 0xe
	// ref_pfd1_clk == pll3_pfd1_clk
	PMU_MISC1_SET_LVDS1_CLK_SEL_PFD1 = 0xf
	// ref_pfd2_clk == pll3_pfd2_clk
	PMU_MISC1_SET_LVDS1_CLK_SEL_PFD2 = 0x10
	// ref_pfd3_clk == pll3_pfd3_clk
	PMU_MISC1_SET_LVDS1_CLK_SEL_PFD3 = 0x11
	// xtal (24M)
	PMU_MISC1_SET_LVDS1_CLK_SEL_XTAL = 0x12
	// Position of LVDS2_CLK_SEL field.
	PMU_MISC1_SET_LVDS2_CLK_SEL_Pos = 0x5
	// Bit mask of LVDS2_CLK_SEL field.
	PMU_MISC1_SET_LVDS2_CLK_SEL_Msk = 0x3e0
	// Arm PLL
	PMU_MISC1_SET_LVDS2_CLK_SEL_ARM_PLL = 0x0
	// System PLL
	PMU_MISC1_SET_LVDS2_CLK_SEL_SYS_PLL = 0x1
	// ref_pfd4_clk == pll2_pfd0_clk
	PMU_MISC1_SET_LVDS2_CLK_SEL_PFD4 = 0x2
	// ref_pfd5_clk == pll2_pfd1_clk
	PMU_MISC1_SET_LVDS2_CLK_SEL_PFD5 = 0x3
	// ref_pfd6_clk == pll2_pfd2_clk
	PMU_MISC1_SET_LVDS2_CLK_SEL_PFD6 = 0x4
	// ref_pfd7_clk == pll2_pfd3_clk
	PMU_MISC1_SET_LVDS2_CLK_SEL_PFD7 = 0x5
	// Audio PLL
	PMU_MISC1_SET_LVDS2_CLK_SEL_AUDIO_PLL = 0x6
	// Video PLL
	PMU_MISC1_SET_LVDS2_CLK_SEL_VIDEO_PLL = 0x7
	// MLB PLL
	PMU_MISC1_SET_LVDS2_CLK_SEL_MLB_PLL = 0x8
	// ethernet ref clock (ENET_PLL)
	PMU_MISC1_SET_LVDS2_CLK_SEL_ETHERNET_REF = 0x9
	// PCIe ref clock (125M)
	PMU_MISC1_SET_LVDS2_CLK_SEL_PCIE_REF = 0xa
	// SATA ref clock (100M)
	PMU_MISC1_SET_LVDS2_CLK_SEL_SATA_REF = 0xb
	// USB1 PLL clock
	PMU_MISC1_SET_LVDS2_CLK_SEL_USB1_PLL = 0xc
	// USB2 PLL clock
	PMU_MISC1_SET_LVDS2_CLK_SEL_USB2_PLL = 0xd
	// ref_pfd0_clk == pll3_pfd0_clk
	PMU_MISC1_SET_LVDS2_CLK_SEL_PFD0 = 0xe
	// ref_pfd1_clk == pll3_pfd1_clk
	PMU_MISC1_SET_LVDS2_CLK_SEL_PFD1 = 0xf
	// ref_pfd2_clk == pll3_pfd2_clk
	PMU_MISC1_SET_LVDS2_CLK_SEL_PFD2 = 0x10
	// ref_pfd3_clk == pll3_pfd3_clk
	PMU_MISC1_SET_LVDS2_CLK_SEL_PFD3 = 0x11
	// xtal (24M)
	PMU_MISC1_SET_LVDS2_CLK_SEL_XTAL = 0x12
	// LVDS1 (loopback)
	PMU_MISC1_SET_LVDS2_CLK_SEL_LVDS1 = 0x13
	// LVDS2 (not useful)
	PMU_MISC1_SET_LVDS2_CLK_SEL_LVDS2 = 0x14
	// Position of LVDSCLK1_OBEN field.
	PMU_MISC1_SET_LVDSCLK1_OBEN_Pos = 0xa
	// Bit mask of LVDSCLK1_OBEN field.
	PMU_MISC1_SET_LVDSCLK1_OBEN_Msk = 0x400
	// Bit LVDSCLK1_OBEN.
	PMU_MISC1_SET_LVDSCLK1_OBEN = 0x400
	// Position of LVDSCLK2_OBEN field.
	PMU_MISC1_SET_LVDSCLK2_OBEN_Pos = 0xb
	// Bit mask of LVDSCLK2_OBEN field.
	PMU_MISC1_SET_LVDSCLK2_OBEN_Msk = 0x800
	// Bit LVDSCLK2_OBEN.
	PMU_MISC1_SET_LVDSCLK2_OBEN = 0x800
	// Position of LVDSCLK1_IBEN field.
	PMU_MISC1_SET_LVDSCLK1_IBEN_Pos = 0xc
	// Bit mask of LVDSCLK1_IBEN field.
	PMU_MISC1_SET_LVDSCLK1_IBEN_Msk = 0x1000
	// Bit LVDSCLK1_IBEN.
	PMU_MISC1_SET_LVDSCLK1_IBEN = 0x1000
	// Position of LVDSCLK2_IBEN field.
	PMU_MISC1_SET_LVDSCLK2_IBEN_Pos = 0xd
	// Bit mask of LVDSCLK2_IBEN field.
	PMU_MISC1_SET_LVDSCLK2_IBEN_Msk = 0x2000
	// Bit LVDSCLK2_IBEN.
	PMU_MISC1_SET_LVDSCLK2_IBEN = 0x2000
	// Position of PFD_480_AUTOGATE_EN field.
	PMU_MISC1_SET_PFD_480_AUTOGATE_EN_Pos = 0x10
	// Bit mask of PFD_480_AUTOGATE_EN field.
	PMU_MISC1_SET_PFD_480_AUTOGATE_EN_Msk = 0x10000
	// Bit PFD_480_AUTOGATE_EN.
	PMU_MISC1_SET_PFD_480_AUTOGATE_EN = 0x10000
	// Position of PFD_528_AUTOGATE_EN field.
	PMU_MISC1_SET_PFD_528_AUTOGATE_EN_Pos = 0x11
	// Bit mask of PFD_528_AUTOGATE_EN field.
	PMU_MISC1_SET_PFD_528_AUTOGATE_EN_Msk = 0x20000
	// Bit PFD_528_AUTOGATE_EN.
	PMU_MISC1_SET_PFD_528_AUTOGATE_EN = 0x20000
	// Position of IRQ_TEMPPANIC field.
	PMU_MISC1_SET_IRQ_TEMPPANIC_Pos = 0x1b
	// Bit mask of IRQ_TEMPPANIC field.
	PMU_MISC1_SET_IRQ_TEMPPANIC_Msk = 0x8000000
	// Bit IRQ_TEMPPANIC.
	PMU_MISC1_SET_IRQ_TEMPPANIC = 0x8000000
	// Position of IRQ_TEMPLOW field.
	PMU_MISC1_SET_IRQ_TEMPLOW_Pos = 0x1c
	// Bit mask of IRQ_TEMPLOW field.
	PMU_MISC1_SET_IRQ_TEMPLOW_Msk = 0x10000000
	// Bit IRQ_TEMPLOW.
	PMU_MISC1_SET_IRQ_TEMPLOW = 0x10000000
	// Position of IRQ_TEMPHIGH field.
	PMU_MISC1_SET_IRQ_TEMPHIGH_Pos = 0x1d
	// Bit mask of IRQ_TEMPHIGH field.
	PMU_MISC1_SET_IRQ_TEMPHIGH_Msk = 0x20000000
	// Bit IRQ_TEMPHIGH.
	PMU_MISC1_SET_IRQ_TEMPHIGH = 0x20000000
	// Position of IRQ_ANA_BO field.
	PMU_MISC1_SET_IRQ_ANA_BO_Pos = 0x1e
	// Bit mask of IRQ_ANA_BO field.
	PMU_MISC1_SET_IRQ_ANA_BO_Msk = 0x40000000
	// Bit IRQ_ANA_BO.
	PMU_MISC1_SET_IRQ_ANA_BO = 0x40000000
	// Position of IRQ_DIG_BO field.
	PMU_MISC1_SET_IRQ_DIG_BO_Pos = 0x1f
	// Bit mask of IRQ_DIG_BO field.
	PMU_MISC1_SET_IRQ_DIG_BO_Msk = 0x80000000
	// Bit IRQ_DIG_BO.
	PMU_MISC1_SET_IRQ_DIG_BO = 0x80000000

	// MISC1_CLR: Miscellaneous Register 1
	// Position of LVDS1_CLK_SEL field.
	PMU_MISC1_CLR_LVDS1_CLK_SEL_Pos = 0x0
	// Bit mask of LVDS1_CLK_SEL field.
	PMU_MISC1_CLR_LVDS1_CLK_SEL_Msk = 0x1f
	// Arm PLL
	PMU_MISC1_CLR_LVDS1_CLK_SEL_ARM_PLL = 0x0
	// System PLL
	PMU_MISC1_CLR_LVDS1_CLK_SEL_SYS_PLL = 0x1
	// ref_pfd4_clk == pll2_pfd0_clk
	PMU_MISC1_CLR_LVDS1_CLK_SEL_PFD4 = 0x2
	// ref_pfd5_clk == pll2_pfd1_clk
	PMU_MISC1_CLR_LVDS1_CLK_SEL_PFD5 = 0x3
	// ref_pfd6_clk == pll2_pfd2_clk
	PMU_MISC1_CLR_LVDS1_CLK_SEL_PFD6 = 0x4
	// ref_pfd7_clk == pll2_pfd3_clk
	PMU_MISC1_CLR_LVDS1_CLK_SEL_PFD7 = 0x5
	// Audio PLL
	PMU_MISC1_CLR_LVDS1_CLK_SEL_AUDIO_PLL = 0x6
	// Video PLL
	PMU_MISC1_CLR_LVDS1_CLK_SEL_VIDEO_PLL = 0x7
	// ethernet ref clock (ENET_PLL)
	PMU_MISC1_CLR_LVDS1_CLK_SEL_ETHERNET_REF = 0x9
	// USB1 PLL clock
	PMU_MISC1_CLR_LVDS1_CLK_SEL_USB1_PLL = 0xc
	// USB2 PLL clock
	PMU_MISC1_CLR_LVDS1_CLK_SEL_USB2_PLL = 0xd
	// ref_pfd0_clk == pll3_pfd0_clk
	PMU_MISC1_CLR_LVDS1_CLK_SEL_PFD0 = 0xe
	// ref_pfd1_clk == pll3_pfd1_clk
	PMU_MISC1_CLR_LVDS1_CLK_SEL_PFD1 = 0xf
	// ref_pfd2_clk == pll3_pfd2_clk
	PMU_MISC1_CLR_LVDS1_CLK_SEL_PFD2 = 0x10
	// ref_pfd3_clk == pll3_pfd3_clk
	PMU_MISC1_CLR_LVDS1_CLK_SEL_PFD3 = 0x11
	// xtal (24M)
	PMU_MISC1_CLR_LVDS1_CLK_SEL_XTAL = 0x12
	// Position of LVDS2_CLK_SEL field.
	PMU_MISC1_CLR_LVDS2_CLK_SEL_Pos = 0x5
	// Bit mask of LVDS2_CLK_SEL field.
	PMU_MISC1_CLR_LVDS2_CLK_SEL_Msk = 0x3e0
	// Arm PLL
	PMU_MISC1_CLR_LVDS2_CLK_SEL_ARM_PLL = 0x0
	// System PLL
	PMU_MISC1_CLR_LVDS2_CLK_SEL_SYS_PLL = 0x1
	// ref_pfd4_clk == pll2_pfd0_clk
	PMU_MISC1_CLR_LVDS2_CLK_SEL_PFD4 = 0x2
	// ref_pfd5_clk == pll2_pfd1_clk
	PMU_MISC1_CLR_LVDS2_CLK_SEL_PFD5 = 0x3
	// ref_pfd6_clk == pll2_pfd2_clk
	PMU_MISC1_CLR_LVDS2_CLK_SEL_PFD6 = 0x4
	// ref_pfd7_clk == pll2_pfd3_clk
	PMU_MISC1_CLR_LVDS2_CLK_SEL_PFD7 = 0x5
	// Audio PLL
	PMU_MISC1_CLR_LVDS2_CLK_SEL_AUDIO_PLL = 0x6
	// Video PLL
	PMU_MISC1_CLR_LVDS2_CLK_SEL_VIDEO_PLL = 0x7
	// MLB PLL
	PMU_MISC1_CLR_LVDS2_CLK_SEL_MLB_PLL = 0x8
	// ethernet ref clock (ENET_PLL)
	PMU_MISC1_CLR_LVDS2_CLK_SEL_ETHERNET_REF = 0x9
	// PCIe ref clock (125M)
	PMU_MISC1_CLR_LVDS2_CLK_SEL_PCIE_REF = 0xa
	// SATA ref clock (100M)
	PMU_MISC1_CLR_LVDS2_CLK_SEL_SATA_REF = 0xb
	// USB1 PLL clock
	PMU_MISC1_CLR_LVDS2_CLK_SEL_USB1_PLL = 0xc
	// USB2 PLL clock
	PMU_MISC1_CLR_LVDS2_CLK_SEL_USB2_PLL = 0xd
	// ref_pfd0_clk == pll3_pfd0_clk
	PMU_MISC1_CLR_LVDS2_CLK_SEL_PFD0 = 0xe
	// ref_pfd1_clk == pll3_pfd1_clk
	PMU_MISC1_CLR_LVDS2_CLK_SEL_PFD1 = 0xf
	// ref_pfd2_clk == pll3_pfd2_clk
	PMU_MISC1_CLR_LVDS2_CLK_SEL_PFD2 = 0x10
	// ref_pfd3_clk == pll3_pfd3_clk
	PMU_MISC1_CLR_LVDS2_CLK_SEL_PFD3 = 0x11
	// xtal (24M)
	PMU_MISC1_CLR_LVDS2_CLK_SEL_XTAL = 0x12
	// LVDS1 (loopback)
	PMU_MISC1_CLR_LVDS2_CLK_SEL_LVDS1 = 0x13
	// LVDS2 (not useful)
	PMU_MISC1_CLR_LVDS2_CLK_SEL_LVDS2 = 0x14
	// Position of LVDSCLK1_OBEN field.
	PMU_MISC1_CLR_LVDSCLK1_OBEN_Pos = 0xa
	// Bit mask of LVDSCLK1_OBEN field.
	PMU_MISC1_CLR_LVDSCLK1_OBEN_Msk = 0x400
	// Bit LVDSCLK1_OBEN.
	PMU_MISC1_CLR_LVDSCLK1_OBEN = 0x400
	// Position of LVDSCLK2_OBEN field.
	PMU_MISC1_CLR_LVDSCLK2_OBEN_Pos = 0xb
	// Bit mask of LVDSCLK2_OBEN field.
	PMU_MISC1_CLR_LVDSCLK2_OBEN_Msk = 0x800
	// Bit LVDSCLK2_OBEN.
	PMU_MISC1_CLR_LVDSCLK2_OBEN = 0x800
	// Position of LVDSCLK1_IBEN field.
	PMU_MISC1_CLR_LVDSCLK1_IBEN_Pos = 0xc
	// Bit mask of LVDSCLK1_IBEN field.
	PMU_MISC1_CLR_LVDSCLK1_IBEN_Msk = 0x1000
	// Bit LVDSCLK1_IBEN.
	PMU_MISC1_CLR_LVDSCLK1_IBEN = 0x1000
	// Position of LVDSCLK2_IBEN field.
	PMU_MISC1_CLR_LVDSCLK2_IBEN_Pos = 0xd
	// Bit mask of LVDSCLK2_IBEN field.
	PMU_MISC1_CLR_LVDSCLK2_IBEN_Msk = 0x2000
	// Bit LVDSCLK2_IBEN.
	PMU_MISC1_CLR_LVDSCLK2_IBEN = 0x2000
	// Position of PFD_480_AUTOGATE_EN field.
	PMU_MISC1_CLR_PFD_480_AUTOGATE_EN_Pos = 0x10
	// Bit mask of PFD_480_AUTOGATE_EN field.
	PMU_MISC1_CLR_PFD_480_AUTOGATE_EN_Msk = 0x10000
	// Bit PFD_480_AUTOGATE_EN.
	PMU_MISC1_CLR_PFD_480_AUTOGATE_EN = 0x10000
	// Position of PFD_528_AUTOGATE_EN field.
	PMU_MISC1_CLR_PFD_528_AUTOGATE_EN_Pos = 0x11
	// Bit mask of PFD_528_AUTOGATE_EN field.
	PMU_MISC1_CLR_PFD_528_AUTOGATE_EN_Msk = 0x20000
	// Bit PFD_528_AUTOGATE_EN.
	PMU_MISC1_CLR_PFD_528_AUTOGATE_EN = 0x20000
	// Position of IRQ_TEMPPANIC field.
	PMU_MISC1_CLR_IRQ_TEMPPANIC_Pos = 0x1b
	// Bit mask of IRQ_TEMPPANIC field.
	PMU_MISC1_CLR_IRQ_TEMPPANIC_Msk = 0x8000000
	// Bit IRQ_TEMPPANIC.
	PMU_MISC1_CLR_IRQ_TEMPPANIC = 0x8000000
	// Position of IRQ_TEMPLOW field.
	PMU_MISC1_CLR_IRQ_TEMPLOW_Pos = 0x1c
	// Bit mask of IRQ_TEMPLOW field.
	PMU_MISC1_CLR_IRQ_TEMPLOW_Msk = 0x10000000
	// Bit IRQ_TEMPLOW.
	PMU_MISC1_CLR_IRQ_TEMPLOW = 0x10000000
	// Position of IRQ_TEMPHIGH field.
	PMU_MISC1_CLR_IRQ_TEMPHIGH_Pos = 0x1d
	// Bit mask of IRQ_TEMPHIGH field.
	PMU_MISC1_CLR_IRQ_TEMPHIGH_Msk = 0x20000000
	// Bit IRQ_TEMPHIGH.
	PMU_MISC1_CLR_IRQ_TEMPHIGH = 0x20000000
	// Position of IRQ_ANA_BO field.
	PMU_MISC1_CLR_IRQ_ANA_BO_Pos = 0x1e
	// Bit mask of IRQ_ANA_BO field.
	PMU_MISC1_CLR_IRQ_ANA_BO_Msk = 0x40000000
	// Bit IRQ_ANA_BO.
	PMU_MISC1_CLR_IRQ_ANA_BO = 0x40000000
	// Position of IRQ_DIG_BO field.
	PMU_MISC1_CLR_IRQ_DIG_BO_Pos = 0x1f
	// Bit mask of IRQ_DIG_BO field.
	PMU_MISC1_CLR_IRQ_DIG_BO_Msk = 0x80000000
	// Bit IRQ_DIG_BO.
	PMU_MISC1_CLR_IRQ_DIG_BO = 0x80000000

	// MISC1_TOG: Miscellaneous Register 1
	// Position of LVDS1_CLK_SEL field.
	PMU_MISC1_TOG_LVDS1_CLK_SEL_Pos = 0x0
	// Bit mask of LVDS1_CLK_SEL field.
	PMU_MISC1_TOG_LVDS1_CLK_SEL_Msk = 0x1f
	// Arm PLL
	PMU_MISC1_TOG_LVDS1_CLK_SEL_ARM_PLL = 0x0
	// System PLL
	PMU_MISC1_TOG_LVDS1_CLK_SEL_SYS_PLL = 0x1
	// ref_pfd4_clk == pll2_pfd0_clk
	PMU_MISC1_TOG_LVDS1_CLK_SEL_PFD4 = 0x2
	// ref_pfd5_clk == pll2_pfd1_clk
	PMU_MISC1_TOG_LVDS1_CLK_SEL_PFD5 = 0x3
	// ref_pfd6_clk == pll2_pfd2_clk
	PMU_MISC1_TOG_LVDS1_CLK_SEL_PFD6 = 0x4
	// ref_pfd7_clk == pll2_pfd3_clk
	PMU_MISC1_TOG_LVDS1_CLK_SEL_PFD7 = 0x5
	// Audio PLL
	PMU_MISC1_TOG_LVDS1_CLK_SEL_AUDIO_PLL = 0x6
	// Video PLL
	PMU_MISC1_TOG_LVDS1_CLK_SEL_VIDEO_PLL = 0x7
	// ethernet ref clock (ENET_PLL)
	PMU_MISC1_TOG_LVDS1_CLK_SEL_ETHERNET_REF = 0x9
	// USB1 PLL clock
	PMU_MISC1_TOG_LVDS1_CLK_SEL_USB1_PLL = 0xc
	// USB2 PLL clock
	PMU_MISC1_TOG_LVDS1_CLK_SEL_USB2_PLL = 0xd
	// ref_pfd0_clk == pll3_pfd0_clk
	PMU_MISC1_TOG_LVDS1_CLK_SEL_PFD0 = 0xe
	// ref_pfd1_clk == pll3_pfd1_clk
	PMU_MISC1_TOG_LVDS1_CLK_SEL_PFD1 = 0xf
	// ref_pfd2_clk == pll3_pfd2_clk
	PMU_MISC1_TOG_LVDS1_CLK_SEL_PFD2 = 0x10
	// ref_pfd3_clk == pll3_pfd3_clk
	PMU_MISC1_TOG_LVDS1_CLK_SEL_PFD3 = 0x11
	// xtal (24M)
	PMU_MISC1_TOG_LVDS1_CLK_SEL_XTAL = 0x12
	// Position of LVDS2_CLK_SEL field.
	PMU_MISC1_TOG_LVDS2_CLK_SEL_Pos = 0x5
	// Bit mask of LVDS2_CLK_SEL field.
	PMU_MISC1_TOG_LVDS2_CLK_SEL_Msk = 0x3e0
	// Arm PLL
	PMU_MISC1_TOG_LVDS2_CLK_SEL_ARM_PLL = 0x0
	// System PLL
	PMU_MISC1_TOG_LVDS2_CLK_SEL_SYS_PLL = 0x1
	// ref_pfd4_clk == pll2_pfd0_clk
	PMU_MISC1_TOG_LVDS2_CLK_SEL_PFD4 = 0x2
	// ref_pfd5_clk == pll2_pfd1_clk
	PMU_MISC1_TOG_LVDS2_CLK_SEL_PFD5 = 0x3
	// ref_pfd6_clk == pll2_pfd2_clk
	PMU_MISC1_TOG_LVDS2_CLK_SEL_PFD6 = 0x4
	// ref_pfd7_clk == pll2_pfd3_clk
	PMU_MISC1_TOG_LVDS2_CLK_SEL_PFD7 = 0x5
	// Audio PLL
	PMU_MISC1_TOG_LVDS2_CLK_SEL_AUDIO_PLL = 0x6
	// Video PLL
	PMU_MISC1_TOG_LVDS2_CLK_SEL_VIDEO_PLL = 0x7
	// MLB PLL
	PMU_MISC1_TOG_LVDS2_CLK_SEL_MLB_PLL = 0x8
	// ethernet ref clock (ENET_PLL)
	PMU_MISC1_TOG_LVDS2_CLK_SEL_ETHERNET_REF = 0x9
	// PCIe ref clock (125M)
	PMU_MISC1_TOG_LVDS2_CLK_SEL_PCIE_REF = 0xa
	// SATA ref clock (100M)
	PMU_MISC1_TOG_LVDS2_CLK_SEL_SATA_REF = 0xb
	// USB1 PLL clock
	PMU_MISC1_TOG_LVDS2_CLK_SEL_USB1_PLL = 0xc
	// USB2 PLL clock
	PMU_MISC1_TOG_LVDS2_CLK_SEL_USB2_PLL = 0xd
	// ref_pfd0_clk == pll3_pfd0_clk
	PMU_MISC1_TOG_LVDS2_CLK_SEL_PFD0 = 0xe
	// ref_pfd1_clk == pll3_pfd1_clk
	PMU_MISC1_TOG_LVDS2_CLK_SEL_PFD1 = 0xf
	// ref_pfd2_clk == pll3_pfd2_clk
	PMU_MISC1_TOG_LVDS2_CLK_SEL_PFD2 = 0x10
	// ref_pfd3_clk == pll3_pfd3_clk
	PMU_MISC1_TOG_LVDS2_CLK_SEL_PFD3 = 0x11
	// xtal (24M)
	PMU_MISC1_TOG_LVDS2_CLK_SEL_XTAL = 0x12
	// LVDS1 (loopback)
	PMU_MISC1_TOG_LVDS2_CLK_SEL_LVDS1 = 0x13
	// LVDS2 (not useful)
	PMU_MISC1_TOG_LVDS2_CLK_SEL_LVDS2 = 0x14
	// Position of LVDSCLK1_OBEN field.
	PMU_MISC1_TOG_LVDSCLK1_OBEN_Pos = 0xa
	// Bit mask of LVDSCLK1_OBEN field.
	PMU_MISC1_TOG_LVDSCLK1_OBEN_Msk = 0x400
	// Bit LVDSCLK1_OBEN.
	PMU_MISC1_TOG_LVDSCLK1_OBEN = 0x400
	// Position of LVDSCLK2_OBEN field.
	PMU_MISC1_TOG_LVDSCLK2_OBEN_Pos = 0xb
	// Bit mask of LVDSCLK2_OBEN field.
	PMU_MISC1_TOG_LVDSCLK2_OBEN_Msk = 0x800
	// Bit LVDSCLK2_OBEN.
	PMU_MISC1_TOG_LVDSCLK2_OBEN = 0x800
	// Position of LVDSCLK1_IBEN field.
	PMU_MISC1_TOG_LVDSCLK1_IBEN_Pos = 0xc
	// Bit mask of LVDSCLK1_IBEN field.
	PMU_MISC1_TOG_LVDSCLK1_IBEN_Msk = 0x1000
	// Bit LVDSCLK1_IBEN.
	PMU_MISC1_TOG_LVDSCLK1_IBEN = 0x1000
	// Position of LVDSCLK2_IBEN field.
	PMU_MISC1_TOG_LVDSCLK2_IBEN_Pos = 0xd
	// Bit mask of LVDSCLK2_IBEN field.
	PMU_MISC1_TOG_LVDSCLK2_IBEN_Msk = 0x2000
	// Bit LVDSCLK2_IBEN.
	PMU_MISC1_TOG_LVDSCLK2_IBEN = 0x2000
	// Position of PFD_480_AUTOGATE_EN field.
	PMU_MISC1_TOG_PFD_480_AUTOGATE_EN_Pos = 0x10
	// Bit mask of PFD_480_AUTOGATE_EN field.
	PMU_MISC1_TOG_PFD_480_AUTOGATE_EN_Msk = 0x10000
	// Bit PFD_480_AUTOGATE_EN.
	PMU_MISC1_TOG_PFD_480_AUTOGATE_EN = 0x10000
	// Position of PFD_528_AUTOGATE_EN field.
	PMU_MISC1_TOG_PFD_528_AUTOGATE_EN_Pos = 0x11
	// Bit mask of PFD_528_AUTOGATE_EN field.
	PMU_MISC1_TOG_PFD_528_AUTOGATE_EN_Msk = 0x20000
	// Bit PFD_528_AUTOGATE_EN.
	PMU_MISC1_TOG_PFD_528_AUTOGATE_EN = 0x20000
	// Position of IRQ_TEMPPANIC field.
	PMU_MISC1_TOG_IRQ_TEMPPANIC_Pos = 0x1b
	// Bit mask of IRQ_TEMPPANIC field.
	PMU_MISC1_TOG_IRQ_TEMPPANIC_Msk = 0x8000000
	// Bit IRQ_TEMPPANIC.
	PMU_MISC1_TOG_IRQ_TEMPPANIC = 0x8000000
	// Position of IRQ_TEMPLOW field.
	PMU_MISC1_TOG_IRQ_TEMPLOW_Pos = 0x1c
	// Bit mask of IRQ_TEMPLOW field.
	PMU_MISC1_TOG_IRQ_TEMPLOW_Msk = 0x10000000
	// Bit IRQ_TEMPLOW.
	PMU_MISC1_TOG_IRQ_TEMPLOW = 0x10000000
	// Position of IRQ_TEMPHIGH field.
	PMU_MISC1_TOG_IRQ_TEMPHIGH_Pos = 0x1d
	// Bit mask of IRQ_TEMPHIGH field.
	PMU_MISC1_TOG_IRQ_TEMPHIGH_Msk = 0x20000000
	// Bit IRQ_TEMPHIGH.
	PMU_MISC1_TOG_IRQ_TEMPHIGH = 0x20000000
	// Position of IRQ_ANA_BO field.
	PMU_MISC1_TOG_IRQ_ANA_BO_Pos = 0x1e
	// Bit mask of IRQ_ANA_BO field.
	PMU_MISC1_TOG_IRQ_ANA_BO_Msk = 0x40000000
	// Bit IRQ_ANA_BO.
	PMU_MISC1_TOG_IRQ_ANA_BO = 0x40000000
	// Position of IRQ_DIG_BO field.
	PMU_MISC1_TOG_IRQ_DIG_BO_Pos = 0x1f
	// Bit mask of IRQ_DIG_BO field.
	PMU_MISC1_TOG_IRQ_DIG_BO_Msk = 0x80000000
	// Bit IRQ_DIG_BO.
	PMU_MISC1_TOG_IRQ_DIG_BO = 0x80000000

	// MISC2: Miscellaneous Control Register
	// Position of REG0_BO_OFFSET field.
	PMU_MISC2_REG0_BO_OFFSET_Pos = 0x0
	// Bit mask of REG0_BO_OFFSET field.
	PMU_MISC2_REG0_BO_OFFSET_Msk = 0x7
	// Brownout offset = 0.100V
	PMU_MISC2_REG0_BO_OFFSET_REG0_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	PMU_MISC2_REG0_BO_OFFSET_REG0_BO_OFFSET_7 = 0x7
	// Position of REG0_BO_STATUS field.
	PMU_MISC2_REG0_BO_STATUS_Pos = 0x3
	// Bit mask of REG0_BO_STATUS field.
	PMU_MISC2_REG0_BO_STATUS_Msk = 0x8
	// Bit REG0_BO_STATUS.
	PMU_MISC2_REG0_BO_STATUS = 0x8
	// Brownout, supply is below target minus brownout offset.
	PMU_MISC2_REG0_BO_STATUS_REG0_BO_STATUS_1 = 0x1
	// Position of REG0_ENABLE_BO field.
	PMU_MISC2_REG0_ENABLE_BO_Pos = 0x5
	// Bit mask of REG0_ENABLE_BO field.
	PMU_MISC2_REG0_ENABLE_BO_Msk = 0x20
	// Bit REG0_ENABLE_BO.
	PMU_MISC2_REG0_ENABLE_BO = 0x20
	// Position of PLL3_disable field.
	PMU_MISC2_PLL3_disable_Pos = 0x7
	// Bit mask of PLL3_disable field.
	PMU_MISC2_PLL3_disable_Msk = 0x80
	// Bit PLL3_disable.
	PMU_MISC2_PLL3_disable = 0x80
	// Position of REG1_BO_OFFSET field.
	PMU_MISC2_REG1_BO_OFFSET_Pos = 0x8
	// Bit mask of REG1_BO_OFFSET field.
	PMU_MISC2_REG1_BO_OFFSET_Msk = 0x700
	// Brownout offset = 0.100V
	PMU_MISC2_REG1_BO_OFFSET_REG1_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	PMU_MISC2_REG1_BO_OFFSET_REG1_BO_OFFSET_7 = 0x7
	// Position of REG1_BO_STATUS field.
	PMU_MISC2_REG1_BO_STATUS_Pos = 0xb
	// Bit mask of REG1_BO_STATUS field.
	PMU_MISC2_REG1_BO_STATUS_Msk = 0x800
	// Bit REG1_BO_STATUS.
	PMU_MISC2_REG1_BO_STATUS = 0x800
	// Brownout, supply is below target minus brownout offset.
	PMU_MISC2_REG1_BO_STATUS_REG1_BO_STATUS_1 = 0x1
	// Position of REG1_ENABLE_BO field.
	PMU_MISC2_REG1_ENABLE_BO_Pos = 0xd
	// Bit mask of REG1_ENABLE_BO field.
	PMU_MISC2_REG1_ENABLE_BO_Msk = 0x2000
	// Bit REG1_ENABLE_BO.
	PMU_MISC2_REG1_ENABLE_BO = 0x2000
	// Position of AUDIO_DIV_LSB field.
	PMU_MISC2_AUDIO_DIV_LSB_Pos = 0xf
	// Bit mask of AUDIO_DIV_LSB field.
	PMU_MISC2_AUDIO_DIV_LSB_Msk = 0x8000
	// Bit AUDIO_DIV_LSB.
	PMU_MISC2_AUDIO_DIV_LSB = 0x8000
	// divide by 1 (Default)
	PMU_MISC2_AUDIO_DIV_LSB_AUDIO_DIV_LSB_0 = 0x0
	// divide by 2
	PMU_MISC2_AUDIO_DIV_LSB_AUDIO_DIV_LSB_1 = 0x1
	// Position of REG2_BO_OFFSET field.
	PMU_MISC2_REG2_BO_OFFSET_Pos = 0x10
	// Bit mask of REG2_BO_OFFSET field.
	PMU_MISC2_REG2_BO_OFFSET_Msk = 0x70000
	// Brownout offset = 0.100V
	PMU_MISC2_REG2_BO_OFFSET_REG2_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	PMU_MISC2_REG2_BO_OFFSET_REG2_BO_OFFSET_7 = 0x7
	// Position of REG2_BO_STATUS field.
	PMU_MISC2_REG2_BO_STATUS_Pos = 0x13
	// Bit mask of REG2_BO_STATUS field.
	PMU_MISC2_REG2_BO_STATUS_Msk = 0x80000
	// Bit REG2_BO_STATUS.
	PMU_MISC2_REG2_BO_STATUS = 0x80000
	// Position of REG2_ENABLE_BO field.
	PMU_MISC2_REG2_ENABLE_BO_Pos = 0x15
	// Bit mask of REG2_ENABLE_BO field.
	PMU_MISC2_REG2_ENABLE_BO_Msk = 0x200000
	// Bit REG2_ENABLE_BO.
	PMU_MISC2_REG2_ENABLE_BO = 0x200000
	// Position of REG2_OK field.
	PMU_MISC2_REG2_OK_Pos = 0x16
	// Bit mask of REG2_OK field.
	PMU_MISC2_REG2_OK_Msk = 0x400000
	// Bit REG2_OK.
	PMU_MISC2_REG2_OK = 0x400000
	// Position of AUDIO_DIV_MSB field.
	PMU_MISC2_AUDIO_DIV_MSB_Pos = 0x17
	// Bit mask of AUDIO_DIV_MSB field.
	PMU_MISC2_AUDIO_DIV_MSB_Msk = 0x800000
	// Bit AUDIO_DIV_MSB.
	PMU_MISC2_AUDIO_DIV_MSB = 0x800000
	// divide by 1 (Default)
	PMU_MISC2_AUDIO_DIV_MSB_AUDIO_DIV_MSB_0 = 0x0
	// divide by 2
	PMU_MISC2_AUDIO_DIV_MSB_AUDIO_DIV_MSB_1 = 0x1
	// Position of REG0_STEP_TIME field.
	PMU_MISC2_REG0_STEP_TIME_Pos = 0x18
	// Bit mask of REG0_STEP_TIME field.
	PMU_MISC2_REG0_STEP_TIME_Msk = 0x3000000
	// 64
	PMU_MISC2_REG0_STEP_TIME_64_CLOCKS = 0x0
	// 128
	PMU_MISC2_REG0_STEP_TIME_128_CLOCKS = 0x1
	// 256
	PMU_MISC2_REG0_STEP_TIME_256_CLOCKS = 0x2
	// 512
	PMU_MISC2_REG0_STEP_TIME_512_CLOCKS = 0x3
	// Position of REG1_STEP_TIME field.
	PMU_MISC2_REG1_STEP_TIME_Pos = 0x1a
	// Bit mask of REG1_STEP_TIME field.
	PMU_MISC2_REG1_STEP_TIME_Msk = 0xc000000
	// 64
	PMU_MISC2_REG1_STEP_TIME_64_CLOCKS = 0x0
	// 128
	PMU_MISC2_REG1_STEP_TIME_128_CLOCKS = 0x1
	// 256
	PMU_MISC2_REG1_STEP_TIME_256_CLOCKS = 0x2
	// 512
	PMU_MISC2_REG1_STEP_TIME_512_CLOCKS = 0x3
	// Position of REG2_STEP_TIME field.
	PMU_MISC2_REG2_STEP_TIME_Pos = 0x1c
	// Bit mask of REG2_STEP_TIME field.
	PMU_MISC2_REG2_STEP_TIME_Msk = 0x30000000
	// 64
	PMU_MISC2_REG2_STEP_TIME_64_CLOCKS = 0x0
	// 128
	PMU_MISC2_REG2_STEP_TIME_128_CLOCKS = 0x1
	// 256
	PMU_MISC2_REG2_STEP_TIME_256_CLOCKS = 0x2
	// 512
	PMU_MISC2_REG2_STEP_TIME_512_CLOCKS = 0x3
	// Position of VIDEO_DIV field.
	PMU_MISC2_VIDEO_DIV_Pos = 0x1e
	// Bit mask of VIDEO_DIV field.
	PMU_MISC2_VIDEO_DIV_Msk = 0xc0000000
	// divide by 1 (Default)
	PMU_MISC2_VIDEO_DIV_VIDEO_DIV_0 = 0x0
	// divide by 2
	PMU_MISC2_VIDEO_DIV_VIDEO_DIV_1 = 0x1
	// divide by 1
	PMU_MISC2_VIDEO_DIV_VIDEO_DIV_2 = 0x2
	// divide by 4
	PMU_MISC2_VIDEO_DIV_VIDEO_DIV_3 = 0x3

	// MISC2_SET: Miscellaneous Control Register
	// Position of REG0_BO_OFFSET field.
	PMU_MISC2_SET_REG0_BO_OFFSET_Pos = 0x0
	// Bit mask of REG0_BO_OFFSET field.
	PMU_MISC2_SET_REG0_BO_OFFSET_Msk = 0x7
	// Brownout offset = 0.100V
	PMU_MISC2_SET_REG0_BO_OFFSET_REG0_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	PMU_MISC2_SET_REG0_BO_OFFSET_REG0_BO_OFFSET_7 = 0x7
	// Position of REG0_BO_STATUS field.
	PMU_MISC2_SET_REG0_BO_STATUS_Pos = 0x3
	// Bit mask of REG0_BO_STATUS field.
	PMU_MISC2_SET_REG0_BO_STATUS_Msk = 0x8
	// Bit REG0_BO_STATUS.
	PMU_MISC2_SET_REG0_BO_STATUS = 0x8
	// Brownout, supply is below target minus brownout offset.
	PMU_MISC2_SET_REG0_BO_STATUS_REG0_BO_STATUS_1 = 0x1
	// Position of REG0_ENABLE_BO field.
	PMU_MISC2_SET_REG0_ENABLE_BO_Pos = 0x5
	// Bit mask of REG0_ENABLE_BO field.
	PMU_MISC2_SET_REG0_ENABLE_BO_Msk = 0x20
	// Bit REG0_ENABLE_BO.
	PMU_MISC2_SET_REG0_ENABLE_BO = 0x20
	// Position of PLL3_disable field.
	PMU_MISC2_SET_PLL3_disable_Pos = 0x7
	// Bit mask of PLL3_disable field.
	PMU_MISC2_SET_PLL3_disable_Msk = 0x80
	// Bit PLL3_disable.
	PMU_MISC2_SET_PLL3_disable = 0x80
	// Position of REG1_BO_OFFSET field.
	PMU_MISC2_SET_REG1_BO_OFFSET_Pos = 0x8
	// Bit mask of REG1_BO_OFFSET field.
	PMU_MISC2_SET_REG1_BO_OFFSET_Msk = 0x700
	// Brownout offset = 0.100V
	PMU_MISC2_SET_REG1_BO_OFFSET_REG1_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	PMU_MISC2_SET_REG1_BO_OFFSET_REG1_BO_OFFSET_7 = 0x7
	// Position of REG1_BO_STATUS field.
	PMU_MISC2_SET_REG1_BO_STATUS_Pos = 0xb
	// Bit mask of REG1_BO_STATUS field.
	PMU_MISC2_SET_REG1_BO_STATUS_Msk = 0x800
	// Bit REG1_BO_STATUS.
	PMU_MISC2_SET_REG1_BO_STATUS = 0x800
	// Brownout, supply is below target minus brownout offset.
	PMU_MISC2_SET_REG1_BO_STATUS_REG1_BO_STATUS_1 = 0x1
	// Position of REG1_ENABLE_BO field.
	PMU_MISC2_SET_REG1_ENABLE_BO_Pos = 0xd
	// Bit mask of REG1_ENABLE_BO field.
	PMU_MISC2_SET_REG1_ENABLE_BO_Msk = 0x2000
	// Bit REG1_ENABLE_BO.
	PMU_MISC2_SET_REG1_ENABLE_BO = 0x2000
	// Position of AUDIO_DIV_LSB field.
	PMU_MISC2_SET_AUDIO_DIV_LSB_Pos = 0xf
	// Bit mask of AUDIO_DIV_LSB field.
	PMU_MISC2_SET_AUDIO_DIV_LSB_Msk = 0x8000
	// Bit AUDIO_DIV_LSB.
	PMU_MISC2_SET_AUDIO_DIV_LSB = 0x8000
	// divide by 1 (Default)
	PMU_MISC2_SET_AUDIO_DIV_LSB_AUDIO_DIV_LSB_0 = 0x0
	// divide by 2
	PMU_MISC2_SET_AUDIO_DIV_LSB_AUDIO_DIV_LSB_1 = 0x1
	// Position of REG2_BO_OFFSET field.
	PMU_MISC2_SET_REG2_BO_OFFSET_Pos = 0x10
	// Bit mask of REG2_BO_OFFSET field.
	PMU_MISC2_SET_REG2_BO_OFFSET_Msk = 0x70000
	// Brownout offset = 0.100V
	PMU_MISC2_SET_REG2_BO_OFFSET_REG2_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	PMU_MISC2_SET_REG2_BO_OFFSET_REG2_BO_OFFSET_7 = 0x7
	// Position of REG2_BO_STATUS field.
	PMU_MISC2_SET_REG2_BO_STATUS_Pos = 0x13
	// Bit mask of REG2_BO_STATUS field.
	PMU_MISC2_SET_REG2_BO_STATUS_Msk = 0x80000
	// Bit REG2_BO_STATUS.
	PMU_MISC2_SET_REG2_BO_STATUS = 0x80000
	// Position of REG2_ENABLE_BO field.
	PMU_MISC2_SET_REG2_ENABLE_BO_Pos = 0x15
	// Bit mask of REG2_ENABLE_BO field.
	PMU_MISC2_SET_REG2_ENABLE_BO_Msk = 0x200000
	// Bit REG2_ENABLE_BO.
	PMU_MISC2_SET_REG2_ENABLE_BO = 0x200000
	// Position of REG2_OK field.
	PMU_MISC2_SET_REG2_OK_Pos = 0x16
	// Bit mask of REG2_OK field.
	PMU_MISC2_SET_REG2_OK_Msk = 0x400000
	// Bit REG2_OK.
	PMU_MISC2_SET_REG2_OK = 0x400000
	// Position of AUDIO_DIV_MSB field.
	PMU_MISC2_SET_AUDIO_DIV_MSB_Pos = 0x17
	// Bit mask of AUDIO_DIV_MSB field.
	PMU_MISC2_SET_AUDIO_DIV_MSB_Msk = 0x800000
	// Bit AUDIO_DIV_MSB.
	PMU_MISC2_SET_AUDIO_DIV_MSB = 0x800000
	// divide by 1 (Default)
	PMU_MISC2_SET_AUDIO_DIV_MSB_AUDIO_DIV_MSB_0 = 0x0
	// divide by 2
	PMU_MISC2_SET_AUDIO_DIV_MSB_AUDIO_DIV_MSB_1 = 0x1
	// Position of REG0_STEP_TIME field.
	PMU_MISC2_SET_REG0_STEP_TIME_Pos = 0x18
	// Bit mask of REG0_STEP_TIME field.
	PMU_MISC2_SET_REG0_STEP_TIME_Msk = 0x3000000
	// 64
	PMU_MISC2_SET_REG0_STEP_TIME_64_CLOCKS = 0x0
	// 128
	PMU_MISC2_SET_REG0_STEP_TIME_128_CLOCKS = 0x1
	// 256
	PMU_MISC2_SET_REG0_STEP_TIME_256_CLOCKS = 0x2
	// 512
	PMU_MISC2_SET_REG0_STEP_TIME_512_CLOCKS = 0x3
	// Position of REG1_STEP_TIME field.
	PMU_MISC2_SET_REG1_STEP_TIME_Pos = 0x1a
	// Bit mask of REG1_STEP_TIME field.
	PMU_MISC2_SET_REG1_STEP_TIME_Msk = 0xc000000
	// 64
	PMU_MISC2_SET_REG1_STEP_TIME_64_CLOCKS = 0x0
	// 128
	PMU_MISC2_SET_REG1_STEP_TIME_128_CLOCKS = 0x1
	// 256
	PMU_MISC2_SET_REG1_STEP_TIME_256_CLOCKS = 0x2
	// 512
	PMU_MISC2_SET_REG1_STEP_TIME_512_CLOCKS = 0x3
	// Position of REG2_STEP_TIME field.
	PMU_MISC2_SET_REG2_STEP_TIME_Pos = 0x1c
	// Bit mask of REG2_STEP_TIME field.
	PMU_MISC2_SET_REG2_STEP_TIME_Msk = 0x30000000
	// 64
	PMU_MISC2_SET_REG2_STEP_TIME_64_CLOCKS = 0x0
	// 128
	PMU_MISC2_SET_REG2_STEP_TIME_128_CLOCKS = 0x1
	// 256
	PMU_MISC2_SET_REG2_STEP_TIME_256_CLOCKS = 0x2
	// 512
	PMU_MISC2_SET_REG2_STEP_TIME_512_CLOCKS = 0x3
	// Position of VIDEO_DIV field.
	PMU_MISC2_SET_VIDEO_DIV_Pos = 0x1e
	// Bit mask of VIDEO_DIV field.
	PMU_MISC2_SET_VIDEO_DIV_Msk = 0xc0000000
	// divide by 1 (Default)
	PMU_MISC2_SET_VIDEO_DIV_VIDEO_DIV_0 = 0x0
	// divide by 2
	PMU_MISC2_SET_VIDEO_DIV_VIDEO_DIV_1 = 0x1
	// divide by 1
	PMU_MISC2_SET_VIDEO_DIV_VIDEO_DIV_2 = 0x2
	// divide by 4
	PMU_MISC2_SET_VIDEO_DIV_VIDEO_DIV_3 = 0x3

	// MISC2_CLR: Miscellaneous Control Register
	// Position of REG0_BO_OFFSET field.
	PMU_MISC2_CLR_REG0_BO_OFFSET_Pos = 0x0
	// Bit mask of REG0_BO_OFFSET field.
	PMU_MISC2_CLR_REG0_BO_OFFSET_Msk = 0x7
	// Brownout offset = 0.100V
	PMU_MISC2_CLR_REG0_BO_OFFSET_REG0_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	PMU_MISC2_CLR_REG0_BO_OFFSET_REG0_BO_OFFSET_7 = 0x7
	// Position of REG0_BO_STATUS field.
	PMU_MISC2_CLR_REG0_BO_STATUS_Pos = 0x3
	// Bit mask of REG0_BO_STATUS field.
	PMU_MISC2_CLR_REG0_BO_STATUS_Msk = 0x8
	// Bit REG0_BO_STATUS.
	PMU_MISC2_CLR_REG0_BO_STATUS = 0x8
	// Brownout, supply is below target minus brownout offset.
	PMU_MISC2_CLR_REG0_BO_STATUS_REG0_BO_STATUS_1 = 0x1
	// Position of REG0_ENABLE_BO field.
	PMU_MISC2_CLR_REG0_ENABLE_BO_Pos = 0x5
	// Bit mask of REG0_ENABLE_BO field.
	PMU_MISC2_CLR_REG0_ENABLE_BO_Msk = 0x20
	// Bit REG0_ENABLE_BO.
	PMU_MISC2_CLR_REG0_ENABLE_BO = 0x20
	// Position of PLL3_disable field.
	PMU_MISC2_CLR_PLL3_disable_Pos = 0x7
	// Bit mask of PLL3_disable field.
	PMU_MISC2_CLR_PLL3_disable_Msk = 0x80
	// Bit PLL3_disable.
	PMU_MISC2_CLR_PLL3_disable = 0x80
	// Position of REG1_BO_OFFSET field.
	PMU_MISC2_CLR_REG1_BO_OFFSET_Pos = 0x8
	// Bit mask of REG1_BO_OFFSET field.
	PMU_MISC2_CLR_REG1_BO_OFFSET_Msk = 0x700
	// Brownout offset = 0.100V
	PMU_MISC2_CLR_REG1_BO_OFFSET_REG1_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	PMU_MISC2_CLR_REG1_BO_OFFSET_REG1_BO_OFFSET_7 = 0x7
	// Position of REG1_BO_STATUS field.
	PMU_MISC2_CLR_REG1_BO_STATUS_Pos = 0xb
	// Bit mask of REG1_BO_STATUS field.
	PMU_MISC2_CLR_REG1_BO_STATUS_Msk = 0x800
	// Bit REG1_BO_STATUS.
	PMU_MISC2_CLR_REG1_BO_STATUS = 0x800
	// Brownout, supply is below target minus brownout offset.
	PMU_MISC2_CLR_REG1_BO_STATUS_REG1_BO_STATUS_1 = 0x1
	// Position of REG1_ENABLE_BO field.
	PMU_MISC2_CLR_REG1_ENABLE_BO_Pos = 0xd
	// Bit mask of REG1_ENABLE_BO field.
	PMU_MISC2_CLR_REG1_ENABLE_BO_Msk = 0x2000
	// Bit REG1_ENABLE_BO.
	PMU_MISC2_CLR_REG1_ENABLE_BO = 0x2000
	// Position of AUDIO_DIV_LSB field.
	PMU_MISC2_CLR_AUDIO_DIV_LSB_Pos = 0xf
	// Bit mask of AUDIO_DIV_LSB field.
	PMU_MISC2_CLR_AUDIO_DIV_LSB_Msk = 0x8000
	// Bit AUDIO_DIV_LSB.
	PMU_MISC2_CLR_AUDIO_DIV_LSB = 0x8000
	// divide by 1 (Default)
	PMU_MISC2_CLR_AUDIO_DIV_LSB_AUDIO_DIV_LSB_0 = 0x0
	// divide by 2
	PMU_MISC2_CLR_AUDIO_DIV_LSB_AUDIO_DIV_LSB_1 = 0x1
	// Position of REG2_BO_OFFSET field.
	PMU_MISC2_CLR_REG2_BO_OFFSET_Pos = 0x10
	// Bit mask of REG2_BO_OFFSET field.
	PMU_MISC2_CLR_REG2_BO_OFFSET_Msk = 0x70000
	// Brownout offset = 0.100V
	PMU_MISC2_CLR_REG2_BO_OFFSET_REG2_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	PMU_MISC2_CLR_REG2_BO_OFFSET_REG2_BO_OFFSET_7 = 0x7
	// Position of REG2_BO_STATUS field.
	PMU_MISC2_CLR_REG2_BO_STATUS_Pos = 0x13
	// Bit mask of REG2_BO_STATUS field.
	PMU_MISC2_CLR_REG2_BO_STATUS_Msk = 0x80000
	// Bit REG2_BO_STATUS.
	PMU_MISC2_CLR_REG2_BO_STATUS = 0x80000
	// Position of REG2_ENABLE_BO field.
	PMU_MISC2_CLR_REG2_ENABLE_BO_Pos = 0x15
	// Bit mask of REG2_ENABLE_BO field.
	PMU_MISC2_CLR_REG2_ENABLE_BO_Msk = 0x200000
	// Bit REG2_ENABLE_BO.
	PMU_MISC2_CLR_REG2_ENABLE_BO = 0x200000
	// Position of REG2_OK field.
	PMU_MISC2_CLR_REG2_OK_Pos = 0x16
	// Bit mask of REG2_OK field.
	PMU_MISC2_CLR_REG2_OK_Msk = 0x400000
	// Bit REG2_OK.
	PMU_MISC2_CLR_REG2_OK = 0x400000
	// Position of AUDIO_DIV_MSB field.
	PMU_MISC2_CLR_AUDIO_DIV_MSB_Pos = 0x17
	// Bit mask of AUDIO_DIV_MSB field.
	PMU_MISC2_CLR_AUDIO_DIV_MSB_Msk = 0x800000
	// Bit AUDIO_DIV_MSB.
	PMU_MISC2_CLR_AUDIO_DIV_MSB = 0x800000
	// divide by 1 (Default)
	PMU_MISC2_CLR_AUDIO_DIV_MSB_AUDIO_DIV_MSB_0 = 0x0
	// divide by 2
	PMU_MISC2_CLR_AUDIO_DIV_MSB_AUDIO_DIV_MSB_1 = 0x1
	// Position of REG0_STEP_TIME field.
	PMU_MISC2_CLR_REG0_STEP_TIME_Pos = 0x18
	// Bit mask of REG0_STEP_TIME field.
	PMU_MISC2_CLR_REG0_STEP_TIME_Msk = 0x3000000
	// 64
	PMU_MISC2_CLR_REG0_STEP_TIME_64_CLOCKS = 0x0
	// 128
	PMU_MISC2_CLR_REG0_STEP_TIME_128_CLOCKS = 0x1
	// 256
	PMU_MISC2_CLR_REG0_STEP_TIME_256_CLOCKS = 0x2
	// 512
	PMU_MISC2_CLR_REG0_STEP_TIME_512_CLOCKS = 0x3
	// Position of REG1_STEP_TIME field.
	PMU_MISC2_CLR_REG1_STEP_TIME_Pos = 0x1a
	// Bit mask of REG1_STEP_TIME field.
	PMU_MISC2_CLR_REG1_STEP_TIME_Msk = 0xc000000
	// 64
	PMU_MISC2_CLR_REG1_STEP_TIME_64_CLOCKS = 0x0
	// 128
	PMU_MISC2_CLR_REG1_STEP_TIME_128_CLOCKS = 0x1
	// 256
	PMU_MISC2_CLR_REG1_STEP_TIME_256_CLOCKS = 0x2
	// 512
	PMU_MISC2_CLR_REG1_STEP_TIME_512_CLOCKS = 0x3
	// Position of REG2_STEP_TIME field.
	PMU_MISC2_CLR_REG2_STEP_TIME_Pos = 0x1c
	// Bit mask of REG2_STEP_TIME field.
	PMU_MISC2_CLR_REG2_STEP_TIME_Msk = 0x30000000
	// 64
	PMU_MISC2_CLR_REG2_STEP_TIME_64_CLOCKS = 0x0
	// 128
	PMU_MISC2_CLR_REG2_STEP_TIME_128_CLOCKS = 0x1
	// 256
	PMU_MISC2_CLR_REG2_STEP_TIME_256_CLOCKS = 0x2
	// 512
	PMU_MISC2_CLR_REG2_STEP_TIME_512_CLOCKS = 0x3
	// Position of VIDEO_DIV field.
	PMU_MISC2_CLR_VIDEO_DIV_Pos = 0x1e
	// Bit mask of VIDEO_DIV field.
	PMU_MISC2_CLR_VIDEO_DIV_Msk = 0xc0000000
	// divide by 1 (Default)
	PMU_MISC2_CLR_VIDEO_DIV_VIDEO_DIV_0 = 0x0
	// divide by 2
	PMU_MISC2_CLR_VIDEO_DIV_VIDEO_DIV_1 = 0x1
	// divide by 1
	PMU_MISC2_CLR_VIDEO_DIV_VIDEO_DIV_2 = 0x2
	// divide by 4
	PMU_MISC2_CLR_VIDEO_DIV_VIDEO_DIV_3 = 0x3

	// MISC2_TOG: Miscellaneous Control Register
	// Position of REG0_BO_OFFSET field.
	PMU_MISC2_TOG_REG0_BO_OFFSET_Pos = 0x0
	// Bit mask of REG0_BO_OFFSET field.
	PMU_MISC2_TOG_REG0_BO_OFFSET_Msk = 0x7
	// Brownout offset = 0.100V
	PMU_MISC2_TOG_REG0_BO_OFFSET_REG0_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	PMU_MISC2_TOG_REG0_BO_OFFSET_REG0_BO_OFFSET_7 = 0x7
	// Position of REG0_BO_STATUS field.
	PMU_MISC2_TOG_REG0_BO_STATUS_Pos = 0x3
	// Bit mask of REG0_BO_STATUS field.
	PMU_MISC2_TOG_REG0_BO_STATUS_Msk = 0x8
	// Bit REG0_BO_STATUS.
	PMU_MISC2_TOG_REG0_BO_STATUS = 0x8
	// Brownout, supply is below target minus brownout offset.
	PMU_MISC2_TOG_REG0_BO_STATUS_REG0_BO_STATUS_1 = 0x1
	// Position of REG0_ENABLE_BO field.
	PMU_MISC2_TOG_REG0_ENABLE_BO_Pos = 0x5
	// Bit mask of REG0_ENABLE_BO field.
	PMU_MISC2_TOG_REG0_ENABLE_BO_Msk = 0x20
	// Bit REG0_ENABLE_BO.
	PMU_MISC2_TOG_REG0_ENABLE_BO = 0x20
	// Position of PLL3_disable field.
	PMU_MISC2_TOG_PLL3_disable_Pos = 0x7
	// Bit mask of PLL3_disable field.
	PMU_MISC2_TOG_PLL3_disable_Msk = 0x80
	// Bit PLL3_disable.
	PMU_MISC2_TOG_PLL3_disable = 0x80
	// Position of REG1_BO_OFFSET field.
	PMU_MISC2_TOG_REG1_BO_OFFSET_Pos = 0x8
	// Bit mask of REG1_BO_OFFSET field.
	PMU_MISC2_TOG_REG1_BO_OFFSET_Msk = 0x700
	// Brownout offset = 0.100V
	PMU_MISC2_TOG_REG1_BO_OFFSET_REG1_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	PMU_MISC2_TOG_REG1_BO_OFFSET_REG1_BO_OFFSET_7 = 0x7
	// Position of REG1_BO_STATUS field.
	PMU_MISC2_TOG_REG1_BO_STATUS_Pos = 0xb
	// Bit mask of REG1_BO_STATUS field.
	PMU_MISC2_TOG_REG1_BO_STATUS_Msk = 0x800
	// Bit REG1_BO_STATUS.
	PMU_MISC2_TOG_REG1_BO_STATUS = 0x800
	// Brownout, supply is below target minus brownout offset.
	PMU_MISC2_TOG_REG1_BO_STATUS_REG1_BO_STATUS_1 = 0x1
	// Position of REG1_ENABLE_BO field.
	PMU_MISC2_TOG_REG1_ENABLE_BO_Pos = 0xd
	// Bit mask of REG1_ENABLE_BO field.
	PMU_MISC2_TOG_REG1_ENABLE_BO_Msk = 0x2000
	// Bit REG1_ENABLE_BO.
	PMU_MISC2_TOG_REG1_ENABLE_BO = 0x2000
	// Position of AUDIO_DIV_LSB field.
	PMU_MISC2_TOG_AUDIO_DIV_LSB_Pos = 0xf
	// Bit mask of AUDIO_DIV_LSB field.
	PMU_MISC2_TOG_AUDIO_DIV_LSB_Msk = 0x8000
	// Bit AUDIO_DIV_LSB.
	PMU_MISC2_TOG_AUDIO_DIV_LSB = 0x8000
	// divide by 1 (Default)
	PMU_MISC2_TOG_AUDIO_DIV_LSB_AUDIO_DIV_LSB_0 = 0x0
	// divide by 2
	PMU_MISC2_TOG_AUDIO_DIV_LSB_AUDIO_DIV_LSB_1 = 0x1
	// Position of REG2_BO_OFFSET field.
	PMU_MISC2_TOG_REG2_BO_OFFSET_Pos = 0x10
	// Bit mask of REG2_BO_OFFSET field.
	PMU_MISC2_TOG_REG2_BO_OFFSET_Msk = 0x70000
	// Brownout offset = 0.100V
	PMU_MISC2_TOG_REG2_BO_OFFSET_REG2_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	PMU_MISC2_TOG_REG2_BO_OFFSET_REG2_BO_OFFSET_7 = 0x7
	// Position of REG2_BO_STATUS field.
	PMU_MISC2_TOG_REG2_BO_STATUS_Pos = 0x13
	// Bit mask of REG2_BO_STATUS field.
	PMU_MISC2_TOG_REG2_BO_STATUS_Msk = 0x80000
	// Bit REG2_BO_STATUS.
	PMU_MISC2_TOG_REG2_BO_STATUS = 0x80000
	// Position of REG2_ENABLE_BO field.
	PMU_MISC2_TOG_REG2_ENABLE_BO_Pos = 0x15
	// Bit mask of REG2_ENABLE_BO field.
	PMU_MISC2_TOG_REG2_ENABLE_BO_Msk = 0x200000
	// Bit REG2_ENABLE_BO.
	PMU_MISC2_TOG_REG2_ENABLE_BO = 0x200000
	// Position of REG2_OK field.
	PMU_MISC2_TOG_REG2_OK_Pos = 0x16
	// Bit mask of REG2_OK field.
	PMU_MISC2_TOG_REG2_OK_Msk = 0x400000
	// Bit REG2_OK.
	PMU_MISC2_TOG_REG2_OK = 0x400000
	// Position of AUDIO_DIV_MSB field.
	PMU_MISC2_TOG_AUDIO_DIV_MSB_Pos = 0x17
	// Bit mask of AUDIO_DIV_MSB field.
	PMU_MISC2_TOG_AUDIO_DIV_MSB_Msk = 0x800000
	// Bit AUDIO_DIV_MSB.
	PMU_MISC2_TOG_AUDIO_DIV_MSB = 0x800000
	// divide by 1 (Default)
	PMU_MISC2_TOG_AUDIO_DIV_MSB_AUDIO_DIV_MSB_0 = 0x0
	// divide by 2
	PMU_MISC2_TOG_AUDIO_DIV_MSB_AUDIO_DIV_MSB_1 = 0x1
	// Position of REG0_STEP_TIME field.
	PMU_MISC2_TOG_REG0_STEP_TIME_Pos = 0x18
	// Bit mask of REG0_STEP_TIME field.
	PMU_MISC2_TOG_REG0_STEP_TIME_Msk = 0x3000000
	// 64
	PMU_MISC2_TOG_REG0_STEP_TIME_64_CLOCKS = 0x0
	// 128
	PMU_MISC2_TOG_REG0_STEP_TIME_128_CLOCKS = 0x1
	// 256
	PMU_MISC2_TOG_REG0_STEP_TIME_256_CLOCKS = 0x2
	// 512
	PMU_MISC2_TOG_REG0_STEP_TIME_512_CLOCKS = 0x3
	// Position of REG1_STEP_TIME field.
	PMU_MISC2_TOG_REG1_STEP_TIME_Pos = 0x1a
	// Bit mask of REG1_STEP_TIME field.
	PMU_MISC2_TOG_REG1_STEP_TIME_Msk = 0xc000000
	// 64
	PMU_MISC2_TOG_REG1_STEP_TIME_64_CLOCKS = 0x0
	// 128
	PMU_MISC2_TOG_REG1_STEP_TIME_128_CLOCKS = 0x1
	// 256
	PMU_MISC2_TOG_REG1_STEP_TIME_256_CLOCKS = 0x2
	// 512
	PMU_MISC2_TOG_REG1_STEP_TIME_512_CLOCKS = 0x3
	// Position of REG2_STEP_TIME field.
	PMU_MISC2_TOG_REG2_STEP_TIME_Pos = 0x1c
	// Bit mask of REG2_STEP_TIME field.
	PMU_MISC2_TOG_REG2_STEP_TIME_Msk = 0x30000000
	// 64
	PMU_MISC2_TOG_REG2_STEP_TIME_64_CLOCKS = 0x0
	// 128
	PMU_MISC2_TOG_REG2_STEP_TIME_128_CLOCKS = 0x1
	// 256
	PMU_MISC2_TOG_REG2_STEP_TIME_256_CLOCKS = 0x2
	// 512
	PMU_MISC2_TOG_REG2_STEP_TIME_512_CLOCKS = 0x3
	// Position of VIDEO_DIV field.
	PMU_MISC2_TOG_VIDEO_DIV_Pos = 0x1e
	// Bit mask of VIDEO_DIV field.
	PMU_MISC2_TOG_VIDEO_DIV_Msk = 0xc0000000
	// divide by 1 (Default)
	PMU_MISC2_TOG_VIDEO_DIV_VIDEO_DIV_0 = 0x0
	// divide by 2
	PMU_MISC2_TOG_VIDEO_DIV_VIDEO_DIV_1 = 0x1
	// divide by 1
	PMU_MISC2_TOG_VIDEO_DIV_VIDEO_DIV_2 = 0x2
	// divide by 4
	PMU_MISC2_TOG_VIDEO_DIV_VIDEO_DIV_3 = 0x3
)

// Bitfields for TEMPMON: Temperature Monitor
const (
	// TEMPSENSE0: Tempsensor Control Register 0
	// Position of POWER_DOWN field.
	TEMPMON_TEMPSENSE0_POWER_DOWN_Pos = 0x0
	// Bit mask of POWER_DOWN field.
	TEMPMON_TEMPSENSE0_POWER_DOWN_Msk = 0x1
	// Bit POWER_DOWN.
	TEMPMON_TEMPSENSE0_POWER_DOWN = 0x1
	// Enable power to the temperature sensor.
	TEMPMON_TEMPSENSE0_POWER_DOWN_POWER_UP = 0x0
	// Power down the temperature sensor.
	TEMPMON_TEMPSENSE0_POWER_DOWN_POWER_DOWN = 0x1
	// Position of MEASURE_TEMP field.
	TEMPMON_TEMPSENSE0_MEASURE_TEMP_Pos = 0x1
	// Bit mask of MEASURE_TEMP field.
	TEMPMON_TEMPSENSE0_MEASURE_TEMP_Msk = 0x2
	// Bit MEASURE_TEMP.
	TEMPMON_TEMPSENSE0_MEASURE_TEMP = 0x2
	// Do not start the measurement process.
	TEMPMON_TEMPSENSE0_MEASURE_TEMP_STOP = 0x0
	// Start the measurement process.
	TEMPMON_TEMPSENSE0_MEASURE_TEMP_START = 0x1
	// Position of FINISHED field.
	TEMPMON_TEMPSENSE0_FINISHED_Pos = 0x2
	// Bit mask of FINISHED field.
	TEMPMON_TEMPSENSE0_FINISHED_Msk = 0x4
	// Bit FINISHED.
	TEMPMON_TEMPSENSE0_FINISHED = 0x4
	// Last measurement is not ready yet.
	TEMPMON_TEMPSENSE0_FINISHED_INVALID = 0x0
	// Last measurement is valid.
	TEMPMON_TEMPSENSE0_FINISHED_VALID = 0x1
	// Position of TEMP_CNT field.
	TEMPMON_TEMPSENSE0_TEMP_CNT_Pos = 0x8
	// Bit mask of TEMP_CNT field.
	TEMPMON_TEMPSENSE0_TEMP_CNT_Msk = 0xfff00
	// Position of ALARM_VALUE field.
	TEMPMON_TEMPSENSE0_ALARM_VALUE_Pos = 0x14
	// Bit mask of ALARM_VALUE field.
	TEMPMON_TEMPSENSE0_ALARM_VALUE_Msk = 0xfff00000

	// TEMPSENSE0_SET: Tempsensor Control Register 0
	// Position of POWER_DOWN field.
	TEMPMON_TEMPSENSE0_SET_POWER_DOWN_Pos = 0x0
	// Bit mask of POWER_DOWN field.
	TEMPMON_TEMPSENSE0_SET_POWER_DOWN_Msk = 0x1
	// Bit POWER_DOWN.
	TEMPMON_TEMPSENSE0_SET_POWER_DOWN = 0x1
	// Enable power to the temperature sensor.
	TEMPMON_TEMPSENSE0_SET_POWER_DOWN_POWER_UP = 0x0
	// Power down the temperature sensor.
	TEMPMON_TEMPSENSE0_SET_POWER_DOWN_POWER_DOWN = 0x1
	// Position of MEASURE_TEMP field.
	TEMPMON_TEMPSENSE0_SET_MEASURE_TEMP_Pos = 0x1
	// Bit mask of MEASURE_TEMP field.
	TEMPMON_TEMPSENSE0_SET_MEASURE_TEMP_Msk = 0x2
	// Bit MEASURE_TEMP.
	TEMPMON_TEMPSENSE0_SET_MEASURE_TEMP = 0x2
	// Do not start the measurement process.
	TEMPMON_TEMPSENSE0_SET_MEASURE_TEMP_STOP = 0x0
	// Start the measurement process.
	TEMPMON_TEMPSENSE0_SET_MEASURE_TEMP_START = 0x1
	// Position of FINISHED field.
	TEMPMON_TEMPSENSE0_SET_FINISHED_Pos = 0x2
	// Bit mask of FINISHED field.
	TEMPMON_TEMPSENSE0_SET_FINISHED_Msk = 0x4
	// Bit FINISHED.
	TEMPMON_TEMPSENSE0_SET_FINISHED = 0x4
	// Last measurement is not ready yet.
	TEMPMON_TEMPSENSE0_SET_FINISHED_INVALID = 0x0
	// Last measurement is valid.
	TEMPMON_TEMPSENSE0_SET_FINISHED_VALID = 0x1
	// Position of TEMP_CNT field.
	TEMPMON_TEMPSENSE0_SET_TEMP_CNT_Pos = 0x8
	// Bit mask of TEMP_CNT field.
	TEMPMON_TEMPSENSE0_SET_TEMP_CNT_Msk = 0xfff00
	// Position of ALARM_VALUE field.
	TEMPMON_TEMPSENSE0_SET_ALARM_VALUE_Pos = 0x14
	// Bit mask of ALARM_VALUE field.
	TEMPMON_TEMPSENSE0_SET_ALARM_VALUE_Msk = 0xfff00000

	// TEMPSENSE0_CLR: Tempsensor Control Register 0
	// Position of POWER_DOWN field.
	TEMPMON_TEMPSENSE0_CLR_POWER_DOWN_Pos = 0x0
	// Bit mask of POWER_DOWN field.
	TEMPMON_TEMPSENSE0_CLR_POWER_DOWN_Msk = 0x1
	// Bit POWER_DOWN.
	TEMPMON_TEMPSENSE0_CLR_POWER_DOWN = 0x1
	// Enable power to the temperature sensor.
	TEMPMON_TEMPSENSE0_CLR_POWER_DOWN_POWER_UP = 0x0
	// Power down the temperature sensor.
	TEMPMON_TEMPSENSE0_CLR_POWER_DOWN_POWER_DOWN = 0x1
	// Position of MEASURE_TEMP field.
	TEMPMON_TEMPSENSE0_CLR_MEASURE_TEMP_Pos = 0x1
	// Bit mask of MEASURE_TEMP field.
	TEMPMON_TEMPSENSE0_CLR_MEASURE_TEMP_Msk = 0x2
	// Bit MEASURE_TEMP.
	TEMPMON_TEMPSENSE0_CLR_MEASURE_TEMP = 0x2
	// Do not start the measurement process.
	TEMPMON_TEMPSENSE0_CLR_MEASURE_TEMP_STOP = 0x0
	// Start the measurement process.
	TEMPMON_TEMPSENSE0_CLR_MEASURE_TEMP_START = 0x1
	// Position of FINISHED field.
	TEMPMON_TEMPSENSE0_CLR_FINISHED_Pos = 0x2
	// Bit mask of FINISHED field.
	TEMPMON_TEMPSENSE0_CLR_FINISHED_Msk = 0x4
	// Bit FINISHED.
	TEMPMON_TEMPSENSE0_CLR_FINISHED = 0x4
	// Last measurement is not ready yet.
	TEMPMON_TEMPSENSE0_CLR_FINISHED_INVALID = 0x0
	// Last measurement is valid.
	TEMPMON_TEMPSENSE0_CLR_FINISHED_VALID = 0x1
	// Position of TEMP_CNT field.
	TEMPMON_TEMPSENSE0_CLR_TEMP_CNT_Pos = 0x8
	// Bit mask of TEMP_CNT field.
	TEMPMON_TEMPSENSE0_CLR_TEMP_CNT_Msk = 0xfff00
	// Position of ALARM_VALUE field.
	TEMPMON_TEMPSENSE0_CLR_ALARM_VALUE_Pos = 0x14
	// Bit mask of ALARM_VALUE field.
	TEMPMON_TEMPSENSE0_CLR_ALARM_VALUE_Msk = 0xfff00000

	// TEMPSENSE0_TOG: Tempsensor Control Register 0
	// Position of POWER_DOWN field.
	TEMPMON_TEMPSENSE0_TOG_POWER_DOWN_Pos = 0x0
	// Bit mask of POWER_DOWN field.
	TEMPMON_TEMPSENSE0_TOG_POWER_DOWN_Msk = 0x1
	// Bit POWER_DOWN.
	TEMPMON_TEMPSENSE0_TOG_POWER_DOWN = 0x1
	// Enable power to the temperature sensor.
	TEMPMON_TEMPSENSE0_TOG_POWER_DOWN_POWER_UP = 0x0
	// Power down the temperature sensor.
	TEMPMON_TEMPSENSE0_TOG_POWER_DOWN_POWER_DOWN = 0x1
	// Position of MEASURE_TEMP field.
	TEMPMON_TEMPSENSE0_TOG_MEASURE_TEMP_Pos = 0x1
	// Bit mask of MEASURE_TEMP field.
	TEMPMON_TEMPSENSE0_TOG_MEASURE_TEMP_Msk = 0x2
	// Bit MEASURE_TEMP.
	TEMPMON_TEMPSENSE0_TOG_MEASURE_TEMP = 0x2
	// Do not start the measurement process.
	TEMPMON_TEMPSENSE0_TOG_MEASURE_TEMP_STOP = 0x0
	// Start the measurement process.
	TEMPMON_TEMPSENSE0_TOG_MEASURE_TEMP_START = 0x1
	// Position of FINISHED field.
	TEMPMON_TEMPSENSE0_TOG_FINISHED_Pos = 0x2
	// Bit mask of FINISHED field.
	TEMPMON_TEMPSENSE0_TOG_FINISHED_Msk = 0x4
	// Bit FINISHED.
	TEMPMON_TEMPSENSE0_TOG_FINISHED = 0x4
	// Last measurement is not ready yet.
	TEMPMON_TEMPSENSE0_TOG_FINISHED_INVALID = 0x0
	// Last measurement is valid.
	TEMPMON_TEMPSENSE0_TOG_FINISHED_VALID = 0x1
	// Position of TEMP_CNT field.
	TEMPMON_TEMPSENSE0_TOG_TEMP_CNT_Pos = 0x8
	// Bit mask of TEMP_CNT field.
	TEMPMON_TEMPSENSE0_TOG_TEMP_CNT_Msk = 0xfff00
	// Position of ALARM_VALUE field.
	TEMPMON_TEMPSENSE0_TOG_ALARM_VALUE_Pos = 0x14
	// Bit mask of ALARM_VALUE field.
	TEMPMON_TEMPSENSE0_TOG_ALARM_VALUE_Msk = 0xfff00000

	// TEMPSENSE1: Tempsensor Control Register 1
	// Position of MEASURE_FREQ field.
	TEMPMON_TEMPSENSE1_MEASURE_FREQ_Pos = 0x0
	// Bit mask of MEASURE_FREQ field.
	TEMPMON_TEMPSENSE1_MEASURE_FREQ_Msk = 0xffff

	// TEMPSENSE1_SET: Tempsensor Control Register 1
	// Position of MEASURE_FREQ field.
	TEMPMON_TEMPSENSE1_SET_MEASURE_FREQ_Pos = 0x0
	// Bit mask of MEASURE_FREQ field.
	TEMPMON_TEMPSENSE1_SET_MEASURE_FREQ_Msk = 0xffff

	// TEMPSENSE1_CLR: Tempsensor Control Register 1
	// Position of MEASURE_FREQ field.
	TEMPMON_TEMPSENSE1_CLR_MEASURE_FREQ_Pos = 0x0
	// Bit mask of MEASURE_FREQ field.
	TEMPMON_TEMPSENSE1_CLR_MEASURE_FREQ_Msk = 0xffff

	// TEMPSENSE1_TOG: Tempsensor Control Register 1
	// Position of MEASURE_FREQ field.
	TEMPMON_TEMPSENSE1_TOG_MEASURE_FREQ_Pos = 0x0
	// Bit mask of MEASURE_FREQ field.
	TEMPMON_TEMPSENSE1_TOG_MEASURE_FREQ_Msk = 0xffff

	// TEMPSENSE2: Tempsensor Control Register 2
	// Position of LOW_ALARM_VALUE field.
	TEMPMON_TEMPSENSE2_LOW_ALARM_VALUE_Pos = 0x0
	// Bit mask of LOW_ALARM_VALUE field.
	TEMPMON_TEMPSENSE2_LOW_ALARM_VALUE_Msk = 0xfff
	// Position of PANIC_ALARM_VALUE field.
	TEMPMON_TEMPSENSE2_PANIC_ALARM_VALUE_Pos = 0x10
	// Bit mask of PANIC_ALARM_VALUE field.
	TEMPMON_TEMPSENSE2_PANIC_ALARM_VALUE_Msk = 0xfff0000

	// TEMPSENSE2_SET: Tempsensor Control Register 2
	// Position of LOW_ALARM_VALUE field.
	TEMPMON_TEMPSENSE2_SET_LOW_ALARM_VALUE_Pos = 0x0
	// Bit mask of LOW_ALARM_VALUE field.
	TEMPMON_TEMPSENSE2_SET_LOW_ALARM_VALUE_Msk = 0xfff
	// Position of PANIC_ALARM_VALUE field.
	TEMPMON_TEMPSENSE2_SET_PANIC_ALARM_VALUE_Pos = 0x10
	// Bit mask of PANIC_ALARM_VALUE field.
	TEMPMON_TEMPSENSE2_SET_PANIC_ALARM_VALUE_Msk = 0xfff0000

	// TEMPSENSE2_CLR: Tempsensor Control Register 2
	// Position of LOW_ALARM_VALUE field.
	TEMPMON_TEMPSENSE2_CLR_LOW_ALARM_VALUE_Pos = 0x0
	// Bit mask of LOW_ALARM_VALUE field.
	TEMPMON_TEMPSENSE2_CLR_LOW_ALARM_VALUE_Msk = 0xfff
	// Position of PANIC_ALARM_VALUE field.
	TEMPMON_TEMPSENSE2_CLR_PANIC_ALARM_VALUE_Pos = 0x10
	// Bit mask of PANIC_ALARM_VALUE field.
	TEMPMON_TEMPSENSE2_CLR_PANIC_ALARM_VALUE_Msk = 0xfff0000

	// TEMPSENSE2_TOG: Tempsensor Control Register 2
	// Position of LOW_ALARM_VALUE field.
	TEMPMON_TEMPSENSE2_TOG_LOW_ALARM_VALUE_Pos = 0x0
	// Bit mask of LOW_ALARM_VALUE field.
	TEMPMON_TEMPSENSE2_TOG_LOW_ALARM_VALUE_Msk = 0xfff
	// Position of PANIC_ALARM_VALUE field.
	TEMPMON_TEMPSENSE2_TOG_PANIC_ALARM_VALUE_Pos = 0x10
	// Bit mask of PANIC_ALARM_VALUE field.
	TEMPMON_TEMPSENSE2_TOG_PANIC_ALARM_VALUE_Msk = 0xfff0000
)

// Bitfields for USB_ANALOG: USB Analog
const (
	// USB1_VBUS_DETECT: USB VBUS Detect Register
	// Position of VBUSVALID_THRESH field.
	USB_ANALOG_USB1_VBUS_DETECT_VBUSVALID_THRESH_Pos = 0x0
	// Bit mask of VBUSVALID_THRESH field.
	USB_ANALOG_USB1_VBUS_DETECT_VBUSVALID_THRESH_Msk = 0x7
	// 4.0V
	USB_ANALOG_USB1_VBUS_DETECT_VBUSVALID_THRESH_4V0 = 0x0
	// 4.1V
	USB_ANALOG_USB1_VBUS_DETECT_VBUSVALID_THRESH_4V1 = 0x1
	// 4.2V
	USB_ANALOG_USB1_VBUS_DETECT_VBUSVALID_THRESH_4V2 = 0x2
	// 4.3V
	USB_ANALOG_USB1_VBUS_DETECT_VBUSVALID_THRESH_4V3 = 0x3
	// 4.4V (default)
	USB_ANALOG_USB1_VBUS_DETECT_VBUSVALID_THRESH_4V4 = 0x4
	// 4.5V
	USB_ANALOG_USB1_VBUS_DETECT_VBUSVALID_THRESH_4V5 = 0x5
	// 4.6V
	USB_ANALOG_USB1_VBUS_DETECT_VBUSVALID_THRESH_4V6 = 0x6
	// 4.7V
	USB_ANALOG_USB1_VBUS_DETECT_VBUSVALID_THRESH_4V7 = 0x7
	// Position of VBUSVALID_PWRUP_CMPS field.
	USB_ANALOG_USB1_VBUS_DETECT_VBUSVALID_PWRUP_CMPS_Pos = 0x14
	// Bit mask of VBUSVALID_PWRUP_CMPS field.
	USB_ANALOG_USB1_VBUS_DETECT_VBUSVALID_PWRUP_CMPS_Msk = 0x100000
	// Bit VBUSVALID_PWRUP_CMPS.
	USB_ANALOG_USB1_VBUS_DETECT_VBUSVALID_PWRUP_CMPS = 0x100000
	// Position of DISCHARGE_VBUS field.
	USB_ANALOG_USB1_VBUS_DETECT_DISCHARGE_VBUS_Pos = 0x1a
	// Bit mask of DISCHARGE_VBUS field.
	USB_ANALOG_USB1_VBUS_DETECT_DISCHARGE_VBUS_Msk = 0x4000000
	// Bit DISCHARGE_VBUS.
	USB_ANALOG_USB1_VBUS_DETECT_DISCHARGE_VBUS = 0x4000000
	// Position of CHARGE_VBUS field.
	USB_ANALOG_USB1_VBUS_DETECT_CHARGE_VBUS_Pos = 0x1b
	// Bit mask of CHARGE_VBUS field.
	USB_ANALOG_USB1_VBUS_DETECT_CHARGE_VBUS_Msk = 0x8000000
	// Bit CHARGE_VBUS.
	USB_ANALOG_USB1_VBUS_DETECT_CHARGE_VBUS = 0x8000000

	// USB1_VBUS_DETECT_SET: USB VBUS Detect Register
	// Position of VBUSVALID_THRESH field.
	USB_ANALOG_USB1_VBUS_DETECT_SET_VBUSVALID_THRESH_Pos = 0x0
	// Bit mask of VBUSVALID_THRESH field.
	USB_ANALOG_USB1_VBUS_DETECT_SET_VBUSVALID_THRESH_Msk = 0x7
	// 4.0V
	USB_ANALOG_USB1_VBUS_DETECT_SET_VBUSVALID_THRESH_4V0 = 0x0
	// 4.1V
	USB_ANALOG_USB1_VBUS_DETECT_SET_VBUSVALID_THRESH_4V1 = 0x1
	// 4.2V
	USB_ANALOG_USB1_VBUS_DETECT_SET_VBUSVALID_THRESH_4V2 = 0x2
	// 4.3V
	USB_ANALOG_USB1_VBUS_DETECT_SET_VBUSVALID_THRESH_4V3 = 0x3
	// 4.4V (default)
	USB_ANALOG_USB1_VBUS_DETECT_SET_VBUSVALID_THRESH_4V4 = 0x4
	// 4.5V
	USB_ANALOG_USB1_VBUS_DETECT_SET_VBUSVALID_THRESH_4V5 = 0x5
	// 4.6V
	USB_ANALOG_USB1_VBUS_DETECT_SET_VBUSVALID_THRESH_4V6 = 0x6
	// 4.7V
	USB_ANALOG_USB1_VBUS_DETECT_SET_VBUSVALID_THRESH_4V7 = 0x7
	// Position of VBUSVALID_PWRUP_CMPS field.
	USB_ANALOG_USB1_VBUS_DETECT_SET_VBUSVALID_PWRUP_CMPS_Pos = 0x14
	// Bit mask of VBUSVALID_PWRUP_CMPS field.
	USB_ANALOG_USB1_VBUS_DETECT_SET_VBUSVALID_PWRUP_CMPS_Msk = 0x100000
	// Bit VBUSVALID_PWRUP_CMPS.
	USB_ANALOG_USB1_VBUS_DETECT_SET_VBUSVALID_PWRUP_CMPS = 0x100000
	// Position of DISCHARGE_VBUS field.
	USB_ANALOG_USB1_VBUS_DETECT_SET_DISCHARGE_VBUS_Pos = 0x1a
	// Bit mask of DISCHARGE_VBUS field.
	USB_ANALOG_USB1_VBUS_DETECT_SET_DISCHARGE_VBUS_Msk = 0x4000000
	// Bit DISCHARGE_VBUS.
	USB_ANALOG_USB1_VBUS_DETECT_SET_DISCHARGE_VBUS = 0x4000000
	// Position of CHARGE_VBUS field.
	USB_ANALOG_USB1_VBUS_DETECT_SET_CHARGE_VBUS_Pos = 0x1b
	// Bit mask of CHARGE_VBUS field.
	USB_ANALOG_USB1_VBUS_DETECT_SET_CHARGE_VBUS_Msk = 0x8000000
	// Bit CHARGE_VBUS.
	USB_ANALOG_USB1_VBUS_DETECT_SET_CHARGE_VBUS = 0x8000000

	// USB1_VBUS_DETECT_CLR: USB VBUS Detect Register
	// Position of VBUSVALID_THRESH field.
	USB_ANALOG_USB1_VBUS_DETECT_CLR_VBUSVALID_THRESH_Pos = 0x0
	// Bit mask of VBUSVALID_THRESH field.
	USB_ANALOG_USB1_VBUS_DETECT_CLR_VBUSVALID_THRESH_Msk = 0x7
	// 4.0V
	USB_ANALOG_USB1_VBUS_DETECT_CLR_VBUSVALID_THRESH_4V0 = 0x0
	// 4.1V
	USB_ANALOG_USB1_VBUS_DETECT_CLR_VBUSVALID_THRESH_4V1 = 0x1
	// 4.2V
	USB_ANALOG_USB1_VBUS_DETECT_CLR_VBUSVALID_THRESH_4V2 = 0x2
	// 4.3V
	USB_ANALOG_USB1_VBUS_DETECT_CLR_VBUSVALID_THRESH_4V3 = 0x3
	// 4.4V (default)
	USB_ANALOG_USB1_VBUS_DETECT_CLR_VBUSVALID_THRESH_4V4 = 0x4
	// 4.5V
	USB_ANALOG_USB1_VBUS_DETECT_CLR_VBUSVALID_THRESH_4V5 = 0x5
	// 4.6V
	USB_ANALOG_USB1_VBUS_DETECT_CLR_VBUSVALID_THRESH_4V6 = 0x6
	// 4.7V
	USB_ANALOG_USB1_VBUS_DETECT_CLR_VBUSVALID_THRESH_4V7 = 0x7
	// Position of VBUSVALID_PWRUP_CMPS field.
	USB_ANALOG_USB1_VBUS_DETECT_CLR_VBUSVALID_PWRUP_CMPS_Pos = 0x14
	// Bit mask of VBUSVALID_PWRUP_CMPS field.
	USB_ANALOG_USB1_VBUS_DETECT_CLR_VBUSVALID_PWRUP_CMPS_Msk = 0x100000
	// Bit VBUSVALID_PWRUP_CMPS.
	USB_ANALOG_USB1_VBUS_DETECT_CLR_VBUSVALID_PWRUP_CMPS = 0x100000
	// Position of DISCHARGE_VBUS field.
	USB_ANALOG_USB1_VBUS_DETECT_CLR_DISCHARGE_VBUS_Pos = 0x1a
	// Bit mask of DISCHARGE_VBUS field.
	USB_ANALOG_USB1_VBUS_DETECT_CLR_DISCHARGE_VBUS_Msk = 0x4000000
	// Bit DISCHARGE_VBUS.
	USB_ANALOG_USB1_VBUS_DETECT_CLR_DISCHARGE_VBUS = 0x4000000
	// Position of CHARGE_VBUS field.
	USB_ANALOG_USB1_VBUS_DETECT_CLR_CHARGE_VBUS_Pos = 0x1b
	// Bit mask of CHARGE_VBUS field.
	USB_ANALOG_USB1_VBUS_DETECT_CLR_CHARGE_VBUS_Msk = 0x8000000
	// Bit CHARGE_VBUS.
	USB_ANALOG_USB1_VBUS_DETECT_CLR_CHARGE_VBUS = 0x8000000

	// USB1_VBUS_DETECT_TOG: USB VBUS Detect Register
	// Position of VBUSVALID_THRESH field.
	USB_ANALOG_USB1_VBUS_DETECT_TOG_VBUSVALID_THRESH_Pos = 0x0
	// Bit mask of VBUSVALID_THRESH field.
	USB_ANALOG_USB1_VBUS_DETECT_TOG_VBUSVALID_THRESH_Msk = 0x7
	// 4.0V
	USB_ANALOG_USB1_VBUS_DETECT_TOG_VBUSVALID_THRESH_4V0 = 0x0
	// 4.1V
	USB_ANALOG_USB1_VBUS_DETECT_TOG_VBUSVALID_THRESH_4V1 = 0x1
	// 4.2V
	USB_ANALOG_USB1_VBUS_DETECT_TOG_VBUSVALID_THRESH_4V2 = 0x2
	// 4.3V
	USB_ANALOG_USB1_VBUS_DETECT_TOG_VBUSVALID_THRESH_4V3 = 0x3
	// 4.4V (default)
	USB_ANALOG_USB1_VBUS_DETECT_TOG_VBUSVALID_THRESH_4V4 = 0x4
	// 4.5V
	USB_ANALOG_USB1_VBUS_DETECT_TOG_VBUSVALID_THRESH_4V5 = 0x5
	// 4.6V
	USB_ANALOG_USB1_VBUS_DETECT_TOG_VBUSVALID_THRESH_4V6 = 0x6
	// 4.7V
	USB_ANALOG_USB1_VBUS_DETECT_TOG_VBUSVALID_THRESH_4V7 = 0x7
	// Position of VBUSVALID_PWRUP_CMPS field.
	USB_ANALOG_USB1_VBUS_DETECT_TOG_VBUSVALID_PWRUP_CMPS_Pos = 0x14
	// Bit mask of VBUSVALID_PWRUP_CMPS field.
	USB_ANALOG_USB1_VBUS_DETECT_TOG_VBUSVALID_PWRUP_CMPS_Msk = 0x100000
	// Bit VBUSVALID_PWRUP_CMPS.
	USB_ANALOG_USB1_VBUS_DETECT_TOG_VBUSVALID_PWRUP_CMPS = 0x100000
	// Position of DISCHARGE_VBUS field.
	USB_ANALOG_USB1_VBUS_DETECT_TOG_DISCHARGE_VBUS_Pos = 0x1a
	// Bit mask of DISCHARGE_VBUS field.
	USB_ANALOG_USB1_VBUS_DETECT_TOG_DISCHARGE_VBUS_Msk = 0x4000000
	// Bit DISCHARGE_VBUS.
	USB_ANALOG_USB1_VBUS_DETECT_TOG_DISCHARGE_VBUS = 0x4000000
	// Position of CHARGE_VBUS field.
	USB_ANALOG_USB1_VBUS_DETECT_TOG_CHARGE_VBUS_Pos = 0x1b
	// Bit mask of CHARGE_VBUS field.
	USB_ANALOG_USB1_VBUS_DETECT_TOG_CHARGE_VBUS_Msk = 0x8000000
	// Bit CHARGE_VBUS.
	USB_ANALOG_USB1_VBUS_DETECT_TOG_CHARGE_VBUS = 0x8000000

	// USB1_CHRG_DETECT: USB Charger Detect Register
	// Position of CHK_CONTACT field.
	USB_ANALOG_USB1_CHRG_DETECT_CHK_CONTACT_Pos = 0x12
	// Bit mask of CHK_CONTACT field.
	USB_ANALOG_USB1_CHRG_DETECT_CHK_CONTACT_Msk = 0x40000
	// Bit CHK_CONTACT.
	USB_ANALOG_USB1_CHRG_DETECT_CHK_CONTACT = 0x40000
	// Do not check the contact of USB plug.
	USB_ANALOG_USB1_CHRG_DETECT_CHK_CONTACT_NO_CHECK = 0x0
	// Check whether the USB plug has been in contact with each other
	USB_ANALOG_USB1_CHRG_DETECT_CHK_CONTACT_CHECK = 0x1
	// Position of CHK_CHRG_B field.
	USB_ANALOG_USB1_CHRG_DETECT_CHK_CHRG_B_Pos = 0x13
	// Bit mask of CHK_CHRG_B field.
	USB_ANALOG_USB1_CHRG_DETECT_CHK_CHRG_B_Msk = 0x80000
	// Bit CHK_CHRG_B.
	USB_ANALOG_USB1_CHRG_DETECT_CHK_CHRG_B = 0x80000
	// Check whether a charger (either a dedicated charger or a host charger) is connected to USB port.
	USB_ANALOG_USB1_CHRG_DETECT_CHK_CHRG_B_CHECK = 0x0
	// Do not check whether a charger is connected to the USB port.
	USB_ANALOG_USB1_CHRG_DETECT_CHK_CHRG_B_NO_CHECK = 0x1
	// Position of EN_B field.
	USB_ANALOG_USB1_CHRG_DETECT_EN_B_Pos = 0x14
	// Bit mask of EN_B field.
	USB_ANALOG_USB1_CHRG_DETECT_EN_B_Msk = 0x100000
	// Bit EN_B.
	USB_ANALOG_USB1_CHRG_DETECT_EN_B = 0x100000
	// Enable the charger detector.
	USB_ANALOG_USB1_CHRG_DETECT_EN_B_ENABLE = 0x0
	// Disable the charger detector.
	USB_ANALOG_USB1_CHRG_DETECT_EN_B_DISABLE = 0x1

	// USB1_CHRG_DETECT_SET: USB Charger Detect Register
	// Position of CHK_CONTACT field.
	USB_ANALOG_USB1_CHRG_DETECT_SET_CHK_CONTACT_Pos = 0x12
	// Bit mask of CHK_CONTACT field.
	USB_ANALOG_USB1_CHRG_DETECT_SET_CHK_CONTACT_Msk = 0x40000
	// Bit CHK_CONTACT.
	USB_ANALOG_USB1_CHRG_DETECT_SET_CHK_CONTACT = 0x40000
	// Do not check the contact of USB plug.
	USB_ANALOG_USB1_CHRG_DETECT_SET_CHK_CONTACT_NO_CHECK = 0x0
	// Check whether the USB plug has been in contact with each other
	USB_ANALOG_USB1_CHRG_DETECT_SET_CHK_CONTACT_CHECK = 0x1
	// Position of CHK_CHRG_B field.
	USB_ANALOG_USB1_CHRG_DETECT_SET_CHK_CHRG_B_Pos = 0x13
	// Bit mask of CHK_CHRG_B field.
	USB_ANALOG_USB1_CHRG_DETECT_SET_CHK_CHRG_B_Msk = 0x80000
	// Bit CHK_CHRG_B.
	USB_ANALOG_USB1_CHRG_DETECT_SET_CHK_CHRG_B = 0x80000
	// Check whether a charger (either a dedicated charger or a host charger) is connected to USB port.
	USB_ANALOG_USB1_CHRG_DETECT_SET_CHK_CHRG_B_CHECK = 0x0
	// Do not check whether a charger is connected to the USB port.
	USB_ANALOG_USB1_CHRG_DETECT_SET_CHK_CHRG_B_NO_CHECK = 0x1
	// Position of EN_B field.
	USB_ANALOG_USB1_CHRG_DETECT_SET_EN_B_Pos = 0x14
	// Bit mask of EN_B field.
	USB_ANALOG_USB1_CHRG_DETECT_SET_EN_B_Msk = 0x100000
	// Bit EN_B.
	USB_ANALOG_USB1_CHRG_DETECT_SET_EN_B = 0x100000
	// Enable the charger detector.
	USB_ANALOG_USB1_CHRG_DETECT_SET_EN_B_ENABLE = 0x0
	// Disable the charger detector.
	USB_ANALOG_USB1_CHRG_DETECT_SET_EN_B_DISABLE = 0x1

	// USB1_CHRG_DETECT_CLR: USB Charger Detect Register
	// Position of CHK_CONTACT field.
	USB_ANALOG_USB1_CHRG_DETECT_CLR_CHK_CONTACT_Pos = 0x12
	// Bit mask of CHK_CONTACT field.
	USB_ANALOG_USB1_CHRG_DETECT_CLR_CHK_CONTACT_Msk = 0x40000
	// Bit CHK_CONTACT.
	USB_ANALOG_USB1_CHRG_DETECT_CLR_CHK_CONTACT = 0x40000
	// Do not check the contact of USB plug.
	USB_ANALOG_USB1_CHRG_DETECT_CLR_CHK_CONTACT_NO_CHECK = 0x0
	// Check whether the USB plug has been in contact with each other
	USB_ANALOG_USB1_CHRG_DETECT_CLR_CHK_CONTACT_CHECK = 0x1
	// Position of CHK_CHRG_B field.
	USB_ANALOG_USB1_CHRG_DETECT_CLR_CHK_CHRG_B_Pos = 0x13
	// Bit mask of CHK_CHRG_B field.
	USB_ANALOG_USB1_CHRG_DETECT_CLR_CHK_CHRG_B_Msk = 0x80000
	// Bit CHK_CHRG_B.
	USB_ANALOG_USB1_CHRG_DETECT_CLR_CHK_CHRG_B = 0x80000
	// Check whether a charger (either a dedicated charger or a host charger) is connected to USB port.
	USB_ANALOG_USB1_CHRG_DETECT_CLR_CHK_CHRG_B_CHECK = 0x0
	// Do not check whether a charger is connected to the USB port.
	USB_ANALOG_USB1_CHRG_DETECT_CLR_CHK_CHRG_B_NO_CHECK = 0x1
	// Position of EN_B field.
	USB_ANALOG_USB1_CHRG_DETECT_CLR_EN_B_Pos = 0x14
	// Bit mask of EN_B field.
	USB_ANALOG_USB1_CHRG_DETECT_CLR_EN_B_Msk = 0x100000
	// Bit EN_B.
	USB_ANALOG_USB1_CHRG_DETECT_CLR_EN_B = 0x100000
	// Enable the charger detector.
	USB_ANALOG_USB1_CHRG_DETECT_CLR_EN_B_ENABLE = 0x0
	// Disable the charger detector.
	USB_ANALOG_USB1_CHRG_DETECT_CLR_EN_B_DISABLE = 0x1

	// USB1_CHRG_DETECT_TOG: USB Charger Detect Register
	// Position of CHK_CONTACT field.
	USB_ANALOG_USB1_CHRG_DETECT_TOG_CHK_CONTACT_Pos = 0x12
	// Bit mask of CHK_CONTACT field.
	USB_ANALOG_USB1_CHRG_DETECT_TOG_CHK_CONTACT_Msk = 0x40000
	// Bit CHK_CONTACT.
	USB_ANALOG_USB1_CHRG_DETECT_TOG_CHK_CONTACT = 0x40000
	// Do not check the contact of USB plug.
	USB_ANALOG_USB1_CHRG_DETECT_TOG_CHK_CONTACT_NO_CHECK = 0x0
	// Check whether the USB plug has been in contact with each other
	USB_ANALOG_USB1_CHRG_DETECT_TOG_CHK_CONTACT_CHECK = 0x1
	// Position of CHK_CHRG_B field.
	USB_ANALOG_USB1_CHRG_DETECT_TOG_CHK_CHRG_B_Pos = 0x13
	// Bit mask of CHK_CHRG_B field.
	USB_ANALOG_USB1_CHRG_DETECT_TOG_CHK_CHRG_B_Msk = 0x80000
	// Bit CHK_CHRG_B.
	USB_ANALOG_USB1_CHRG_DETECT_TOG_CHK_CHRG_B = 0x80000
	// Check whether a charger (either a dedicated charger or a host charger) is connected to USB port.
	USB_ANALOG_USB1_CHRG_DETECT_TOG_CHK_CHRG_B_CHECK = 0x0
	// Do not check whether a charger is connected to the USB port.
	USB_ANALOG_USB1_CHRG_DETECT_TOG_CHK_CHRG_B_NO_CHECK = 0x1
	// Position of EN_B field.
	USB_ANALOG_USB1_CHRG_DETECT_TOG_EN_B_Pos = 0x14
	// Bit mask of EN_B field.
	USB_ANALOG_USB1_CHRG_DETECT_TOG_EN_B_Msk = 0x100000
	// Bit EN_B.
	USB_ANALOG_USB1_CHRG_DETECT_TOG_EN_B = 0x100000
	// Enable the charger detector.
	USB_ANALOG_USB1_CHRG_DETECT_TOG_EN_B_ENABLE = 0x0
	// Disable the charger detector.
	USB_ANALOG_USB1_CHRG_DETECT_TOG_EN_B_DISABLE = 0x1

	// USB1_VBUS_DETECT_STAT: USB VBUS Detect Status Register
	// Position of SESSEND field.
	USB_ANALOG_USB1_VBUS_DETECT_STAT_SESSEND_Pos = 0x0
	// Bit mask of SESSEND field.
	USB_ANALOG_USB1_VBUS_DETECT_STAT_SESSEND_Msk = 0x1
	// Bit SESSEND.
	USB_ANALOG_USB1_VBUS_DETECT_STAT_SESSEND = 0x1
	// Position of BVALID field.
	USB_ANALOG_USB1_VBUS_DETECT_STAT_BVALID_Pos = 0x1
	// Bit mask of BVALID field.
	USB_ANALOG_USB1_VBUS_DETECT_STAT_BVALID_Msk = 0x2
	// Bit BVALID.
	USB_ANALOG_USB1_VBUS_DETECT_STAT_BVALID = 0x2
	// Position of AVALID field.
	USB_ANALOG_USB1_VBUS_DETECT_STAT_AVALID_Pos = 0x2
	// Bit mask of AVALID field.
	USB_ANALOG_USB1_VBUS_DETECT_STAT_AVALID_Msk = 0x4
	// Bit AVALID.
	USB_ANALOG_USB1_VBUS_DETECT_STAT_AVALID = 0x4
	// Position of VBUS_VALID field.
	USB_ANALOG_USB1_VBUS_DETECT_STAT_VBUS_VALID_Pos = 0x3
	// Bit mask of VBUS_VALID field.
	USB_ANALOG_USB1_VBUS_DETECT_STAT_VBUS_VALID_Msk = 0x8
	// Bit VBUS_VALID.
	USB_ANALOG_USB1_VBUS_DETECT_STAT_VBUS_VALID = 0x8

	// USB1_CHRG_DETECT_STAT: USB Charger Detect Status Register
	// Position of PLUG_CONTACT field.
	USB_ANALOG_USB1_CHRG_DETECT_STAT_PLUG_CONTACT_Pos = 0x0
	// Bit mask of PLUG_CONTACT field.
	USB_ANALOG_USB1_CHRG_DETECT_STAT_PLUG_CONTACT_Msk = 0x1
	// Bit PLUG_CONTACT.
	USB_ANALOG_USB1_CHRG_DETECT_STAT_PLUG_CONTACT = 0x1
	// The USB plug has not made contact.
	USB_ANALOG_USB1_CHRG_DETECT_STAT_PLUG_CONTACT_NO_CONTACT = 0x0
	// The USB plug has made good contact.
	USB_ANALOG_USB1_CHRG_DETECT_STAT_PLUG_CONTACT_GOOD_CONTACT = 0x1
	// Position of CHRG_DETECTED field.
	USB_ANALOG_USB1_CHRG_DETECT_STAT_CHRG_DETECTED_Pos = 0x1
	// Bit mask of CHRG_DETECTED field.
	USB_ANALOG_USB1_CHRG_DETECT_STAT_CHRG_DETECTED_Msk = 0x2
	// Bit CHRG_DETECTED.
	USB_ANALOG_USB1_CHRG_DETECT_STAT_CHRG_DETECTED = 0x2
	// The USB port is not connected to a charger.
	USB_ANALOG_USB1_CHRG_DETECT_STAT_CHRG_DETECTED_CHARGER_NOT_PRESENT = 0x0
	// A charger (either a dedicated charger or a host charger) is connected to the USB port.
	USB_ANALOG_USB1_CHRG_DETECT_STAT_CHRG_DETECTED_CHARGER_PRESENT = 0x1
	// Position of DM_STATE field.
	USB_ANALOG_USB1_CHRG_DETECT_STAT_DM_STATE_Pos = 0x2
	// Bit mask of DM_STATE field.
	USB_ANALOG_USB1_CHRG_DETECT_STAT_DM_STATE_Msk = 0x4
	// Bit DM_STATE.
	USB_ANALOG_USB1_CHRG_DETECT_STAT_DM_STATE = 0x4
	// Position of DP_STATE field.
	USB_ANALOG_USB1_CHRG_DETECT_STAT_DP_STATE_Pos = 0x3
	// Bit mask of DP_STATE field.
	USB_ANALOG_USB1_CHRG_DETECT_STAT_DP_STATE_Msk = 0x8
	// Bit DP_STATE.
	USB_ANALOG_USB1_CHRG_DETECT_STAT_DP_STATE = 0x8

	// USB1_MISC: USB Misc Register
	// Position of HS_USE_EXTERNAL_R field.
	USB_ANALOG_USB1_MISC_HS_USE_EXTERNAL_R_Pos = 0x0
	// Bit mask of HS_USE_EXTERNAL_R field.
	USB_ANALOG_USB1_MISC_HS_USE_EXTERNAL_R_Msk = 0x1
	// Bit HS_USE_EXTERNAL_R.
	USB_ANALOG_USB1_MISC_HS_USE_EXTERNAL_R = 0x1
	// Position of EN_DEGLITCH field.
	USB_ANALOG_USB1_MISC_EN_DEGLITCH_Pos = 0x1
	// Bit mask of EN_DEGLITCH field.
	USB_ANALOG_USB1_MISC_EN_DEGLITCH_Msk = 0x2
	// Bit EN_DEGLITCH.
	USB_ANALOG_USB1_MISC_EN_DEGLITCH = 0x2
	// Position of EN_CLK_UTMI field.
	USB_ANALOG_USB1_MISC_EN_CLK_UTMI_Pos = 0x1e
	// Bit mask of EN_CLK_UTMI field.
	USB_ANALOG_USB1_MISC_EN_CLK_UTMI_Msk = 0x40000000
	// Bit EN_CLK_UTMI.
	USB_ANALOG_USB1_MISC_EN_CLK_UTMI = 0x40000000

	// USB1_MISC_SET: USB Misc Register
	// Position of HS_USE_EXTERNAL_R field.
	USB_ANALOG_USB1_MISC_SET_HS_USE_EXTERNAL_R_Pos = 0x0
	// Bit mask of HS_USE_EXTERNAL_R field.
	USB_ANALOG_USB1_MISC_SET_HS_USE_EXTERNAL_R_Msk = 0x1
	// Bit HS_USE_EXTERNAL_R.
	USB_ANALOG_USB1_MISC_SET_HS_USE_EXTERNAL_R = 0x1
	// Position of EN_DEGLITCH field.
	USB_ANALOG_USB1_MISC_SET_EN_DEGLITCH_Pos = 0x1
	// Bit mask of EN_DEGLITCH field.
	USB_ANALOG_USB1_MISC_SET_EN_DEGLITCH_Msk = 0x2
	// Bit EN_DEGLITCH.
	USB_ANALOG_USB1_MISC_SET_EN_DEGLITCH = 0x2
	// Position of EN_CLK_UTMI field.
	USB_ANALOG_USB1_MISC_SET_EN_CLK_UTMI_Pos = 0x1e
	// Bit mask of EN_CLK_UTMI field.
	USB_ANALOG_USB1_MISC_SET_EN_CLK_UTMI_Msk = 0x40000000
	// Bit EN_CLK_UTMI.
	USB_ANALOG_USB1_MISC_SET_EN_CLK_UTMI = 0x40000000

	// USB1_MISC_CLR: USB Misc Register
	// Position of HS_USE_EXTERNAL_R field.
	USB_ANALOG_USB1_MISC_CLR_HS_USE_EXTERNAL_R_Pos = 0x0
	// Bit mask of HS_USE_EXTERNAL_R field.
	USB_ANALOG_USB1_MISC_CLR_HS_USE_EXTERNAL_R_Msk = 0x1
	// Bit HS_USE_EXTERNAL_R.
	USB_ANALOG_USB1_MISC_CLR_HS_USE_EXTERNAL_R = 0x1
	// Position of EN_DEGLITCH field.
	USB_ANALOG_USB1_MISC_CLR_EN_DEGLITCH_Pos = 0x1
	// Bit mask of EN_DEGLITCH field.
	USB_ANALOG_USB1_MISC_CLR_EN_DEGLITCH_Msk = 0x2
	// Bit EN_DEGLITCH.
	USB_ANALOG_USB1_MISC_CLR_EN_DEGLITCH = 0x2
	// Position of EN_CLK_UTMI field.
	USB_ANALOG_USB1_MISC_CLR_EN_CLK_UTMI_Pos = 0x1e
	// Bit mask of EN_CLK_UTMI field.
	USB_ANALOG_USB1_MISC_CLR_EN_CLK_UTMI_Msk = 0x40000000
	// Bit EN_CLK_UTMI.
	USB_ANALOG_USB1_MISC_CLR_EN_CLK_UTMI = 0x40000000

	// USB1_MISC_TOG: USB Misc Register
	// Position of HS_USE_EXTERNAL_R field.
	USB_ANALOG_USB1_MISC_TOG_HS_USE_EXTERNAL_R_Pos = 0x0
	// Bit mask of HS_USE_EXTERNAL_R field.
	USB_ANALOG_USB1_MISC_TOG_HS_USE_EXTERNAL_R_Msk = 0x1
	// Bit HS_USE_EXTERNAL_R.
	USB_ANALOG_USB1_MISC_TOG_HS_USE_EXTERNAL_R = 0x1
	// Position of EN_DEGLITCH field.
	USB_ANALOG_USB1_MISC_TOG_EN_DEGLITCH_Pos = 0x1
	// Bit mask of EN_DEGLITCH field.
	USB_ANALOG_USB1_MISC_TOG_EN_DEGLITCH_Msk = 0x2
	// Bit EN_DEGLITCH.
	USB_ANALOG_USB1_MISC_TOG_EN_DEGLITCH = 0x2
	// Position of EN_CLK_UTMI field.
	USB_ANALOG_USB1_MISC_TOG_EN_CLK_UTMI_Pos = 0x1e
	// Bit mask of EN_CLK_UTMI field.
	USB_ANALOG_USB1_MISC_TOG_EN_CLK_UTMI_Msk = 0x40000000
	// Bit EN_CLK_UTMI.
	USB_ANALOG_USB1_MISC_TOG_EN_CLK_UTMI = 0x40000000

	// USB2_VBUS_DETECT: USB VBUS Detect Register
	// Position of VBUSVALID_THRESH field.
	USB_ANALOG_USB2_VBUS_DETECT_VBUSVALID_THRESH_Pos = 0x0
	// Bit mask of VBUSVALID_THRESH field.
	USB_ANALOG_USB2_VBUS_DETECT_VBUSVALID_THRESH_Msk = 0x7
	// 4.0V
	USB_ANALOG_USB2_VBUS_DETECT_VBUSVALID_THRESH_4V0 = 0x0
	// 4.1V
	USB_ANALOG_USB2_VBUS_DETECT_VBUSVALID_THRESH_4V1 = 0x1
	// 4.2V
	USB_ANALOG_USB2_VBUS_DETECT_VBUSVALID_THRESH_4V2 = 0x2
	// 4.3V
	USB_ANALOG_USB2_VBUS_DETECT_VBUSVALID_THRESH_4V3 = 0x3
	// 4.4V (default)
	USB_ANALOG_USB2_VBUS_DETECT_VBUSVALID_THRESH_4V4 = 0x4
	// 4.5V
	USB_ANALOG_USB2_VBUS_DETECT_VBUSVALID_THRESH_4V5 = 0x5
	// 4.6V
	USB_ANALOG_USB2_VBUS_DETECT_VBUSVALID_THRESH_4V6 = 0x6
	// 4.7V
	USB_ANALOG_USB2_VBUS_DETECT_VBUSVALID_THRESH_4V7 = 0x7
	// Position of VBUSVALID_PWRUP_CMPS field.
	USB_ANALOG_USB2_VBUS_DETECT_VBUSVALID_PWRUP_CMPS_Pos = 0x14
	// Bit mask of VBUSVALID_PWRUP_CMPS field.
	USB_ANALOG_USB2_VBUS_DETECT_VBUSVALID_PWRUP_CMPS_Msk = 0x100000
	// Bit VBUSVALID_PWRUP_CMPS.
	USB_ANALOG_USB2_VBUS_DETECT_VBUSVALID_PWRUP_CMPS = 0x100000
	// Position of DISCHARGE_VBUS field.
	USB_ANALOG_USB2_VBUS_DETECT_DISCHARGE_VBUS_Pos = 0x1a
	// Bit mask of DISCHARGE_VBUS field.
	USB_ANALOG_USB2_VBUS_DETECT_DISCHARGE_VBUS_Msk = 0x4000000
	// Bit DISCHARGE_VBUS.
	USB_ANALOG_USB2_VBUS_DETECT_DISCHARGE_VBUS = 0x4000000
	// Position of CHARGE_VBUS field.
	USB_ANALOG_USB2_VBUS_DETECT_CHARGE_VBUS_Pos = 0x1b
	// Bit mask of CHARGE_VBUS field.
	USB_ANALOG_USB2_VBUS_DETECT_CHARGE_VBUS_Msk = 0x8000000
	// Bit CHARGE_VBUS.
	USB_ANALOG_USB2_VBUS_DETECT_CHARGE_VBUS = 0x8000000

	// USB2_VBUS_DETECT_SET: USB VBUS Detect Register
	// Position of VBUSVALID_THRESH field.
	USB_ANALOG_USB2_VBUS_DETECT_SET_VBUSVALID_THRESH_Pos = 0x0
	// Bit mask of VBUSVALID_THRESH field.
	USB_ANALOG_USB2_VBUS_DETECT_SET_VBUSVALID_THRESH_Msk = 0x7
	// 4.0V
	USB_ANALOG_USB2_VBUS_DETECT_SET_VBUSVALID_THRESH_4V0 = 0x0
	// 4.1V
	USB_ANALOG_USB2_VBUS_DETECT_SET_VBUSVALID_THRESH_4V1 = 0x1
	// 4.2V
	USB_ANALOG_USB2_VBUS_DETECT_SET_VBUSVALID_THRESH_4V2 = 0x2
	// 4.3V
	USB_ANALOG_USB2_VBUS_DETECT_SET_VBUSVALID_THRESH_4V3 = 0x3
	// 4.4V (default)
	USB_ANALOG_USB2_VBUS_DETECT_SET_VBUSVALID_THRESH_4V4 = 0x4
	// 4.5V
	USB_ANALOG_USB2_VBUS_DETECT_SET_VBUSVALID_THRESH_4V5 = 0x5
	// 4.6V
	USB_ANALOG_USB2_VBUS_DETECT_SET_VBUSVALID_THRESH_4V6 = 0x6
	// 4.7V
	USB_ANALOG_USB2_VBUS_DETECT_SET_VBUSVALID_THRESH_4V7 = 0x7
	// Position of VBUSVALID_PWRUP_CMPS field.
	USB_ANALOG_USB2_VBUS_DETECT_SET_VBUSVALID_PWRUP_CMPS_Pos = 0x14
	// Bit mask of VBUSVALID_PWRUP_CMPS field.
	USB_ANALOG_USB2_VBUS_DETECT_SET_VBUSVALID_PWRUP_CMPS_Msk = 0x100000
	// Bit VBUSVALID_PWRUP_CMPS.
	USB_ANALOG_USB2_VBUS_DETECT_SET_VBUSVALID_PWRUP_CMPS = 0x100000
	// Position of DISCHARGE_VBUS field.
	USB_ANALOG_USB2_VBUS_DETECT_SET_DISCHARGE_VBUS_Pos = 0x1a
	// Bit mask of DISCHARGE_VBUS field.
	USB_ANALOG_USB2_VBUS_DETECT_SET_DISCHARGE_VBUS_Msk = 0x4000000
	// Bit DISCHARGE_VBUS.
	USB_ANALOG_USB2_VBUS_DETECT_SET_DISCHARGE_VBUS = 0x4000000
	// Position of CHARGE_VBUS field.
	USB_ANALOG_USB2_VBUS_DETECT_SET_CHARGE_VBUS_Pos = 0x1b
	// Bit mask of CHARGE_VBUS field.
	USB_ANALOG_USB2_VBUS_DETECT_SET_CHARGE_VBUS_Msk = 0x8000000
	// Bit CHARGE_VBUS.
	USB_ANALOG_USB2_VBUS_DETECT_SET_CHARGE_VBUS = 0x8000000

	// USB2_VBUS_DETECT_CLR: USB VBUS Detect Register
	// Position of VBUSVALID_THRESH field.
	USB_ANALOG_USB2_VBUS_DETECT_CLR_VBUSVALID_THRESH_Pos = 0x0
	// Bit mask of VBUSVALID_THRESH field.
	USB_ANALOG_USB2_VBUS_DETECT_CLR_VBUSVALID_THRESH_Msk = 0x7
	// 4.0V
	USB_ANALOG_USB2_VBUS_DETECT_CLR_VBUSVALID_THRESH_4V0 = 0x0
	// 4.1V
	USB_ANALOG_USB2_VBUS_DETECT_CLR_VBUSVALID_THRESH_4V1 = 0x1
	// 4.2V
	USB_ANALOG_USB2_VBUS_DETECT_CLR_VBUSVALID_THRESH_4V2 = 0x2
	// 4.3V
	USB_ANALOG_USB2_VBUS_DETECT_CLR_VBUSVALID_THRESH_4V3 = 0x3
	// 4.4V (default)
	USB_ANALOG_USB2_VBUS_DETECT_CLR_VBUSVALID_THRESH_4V4 = 0x4
	// 4.5V
	USB_ANALOG_USB2_VBUS_DETECT_CLR_VBUSVALID_THRESH_4V5 = 0x5
	// 4.6V
	USB_ANALOG_USB2_VBUS_DETECT_CLR_VBUSVALID_THRESH_4V6 = 0x6
	// 4.7V
	USB_ANALOG_USB2_VBUS_DETECT_CLR_VBUSVALID_THRESH_4V7 = 0x7
	// Position of VBUSVALID_PWRUP_CMPS field.
	USB_ANALOG_USB2_VBUS_DETECT_CLR_VBUSVALID_PWRUP_CMPS_Pos = 0x14
	// Bit mask of VBUSVALID_PWRUP_CMPS field.
	USB_ANALOG_USB2_VBUS_DETECT_CLR_VBUSVALID_PWRUP_CMPS_Msk = 0x100000
	// Bit VBUSVALID_PWRUP_CMPS.
	USB_ANALOG_USB2_VBUS_DETECT_CLR_VBUSVALID_PWRUP_CMPS = 0x100000
	// Position of DISCHARGE_VBUS field.
	USB_ANALOG_USB2_VBUS_DETECT_CLR_DISCHARGE_VBUS_Pos = 0x1a
	// Bit mask of DISCHARGE_VBUS field.
	USB_ANALOG_USB2_VBUS_DETECT_CLR_DISCHARGE_VBUS_Msk = 0x4000000
	// Bit DISCHARGE_VBUS.
	USB_ANALOG_USB2_VBUS_DETECT_CLR_DISCHARGE_VBUS = 0x4000000
	// Position of CHARGE_VBUS field.
	USB_ANALOG_USB2_VBUS_DETECT_CLR_CHARGE_VBUS_Pos = 0x1b
	// Bit mask of CHARGE_VBUS field.
	USB_ANALOG_USB2_VBUS_DETECT_CLR_CHARGE_VBUS_Msk = 0x8000000
	// Bit CHARGE_VBUS.
	USB_ANALOG_USB2_VBUS_DETECT_CLR_CHARGE_VBUS = 0x8000000

	// USB2_VBUS_DETECT_TOG: USB VBUS Detect Register
	// Position of VBUSVALID_THRESH field.
	USB_ANALOG_USB2_VBUS_DETECT_TOG_VBUSVALID_THRESH_Pos = 0x0
	// Bit mask of VBUSVALID_THRESH field.
	USB_ANALOG_USB2_VBUS_DETECT_TOG_VBUSVALID_THRESH_Msk = 0x7
	// 4.0V
	USB_ANALOG_USB2_VBUS_DETECT_TOG_VBUSVALID_THRESH_4V0 = 0x0
	// 4.1V
	USB_ANALOG_USB2_VBUS_DETECT_TOG_VBUSVALID_THRESH_4V1 = 0x1
	// 4.2V
	USB_ANALOG_USB2_VBUS_DETECT_TOG_VBUSVALID_THRESH_4V2 = 0x2
	// 4.3V
	USB_ANALOG_USB2_VBUS_DETECT_TOG_VBUSVALID_THRESH_4V3 = 0x3
	// 4.4V (default)
	USB_ANALOG_USB2_VBUS_DETECT_TOG_VBUSVALID_THRESH_4V4 = 0x4
	// 4.5V
	USB_ANALOG_USB2_VBUS_DETECT_TOG_VBUSVALID_THRESH_4V5 = 0x5
	// 4.6V
	USB_ANALOG_USB2_VBUS_DETECT_TOG_VBUSVALID_THRESH_4V6 = 0x6
	// 4.7V
	USB_ANALOG_USB2_VBUS_DETECT_TOG_VBUSVALID_THRESH_4V7 = 0x7
	// Position of VBUSVALID_PWRUP_CMPS field.
	USB_ANALOG_USB2_VBUS_DETECT_TOG_VBUSVALID_PWRUP_CMPS_Pos = 0x14
	// Bit mask of VBUSVALID_PWRUP_CMPS field.
	USB_ANALOG_USB2_VBUS_DETECT_TOG_VBUSVALID_PWRUP_CMPS_Msk = 0x100000
	// Bit VBUSVALID_PWRUP_CMPS.
	USB_ANALOG_USB2_VBUS_DETECT_TOG_VBUSVALID_PWRUP_CMPS = 0x100000
	// Position of DISCHARGE_VBUS field.
	USB_ANALOG_USB2_VBUS_DETECT_TOG_DISCHARGE_VBUS_Pos = 0x1a
	// Bit mask of DISCHARGE_VBUS field.
	USB_ANALOG_USB2_VBUS_DETECT_TOG_DISCHARGE_VBUS_Msk = 0x4000000
	// Bit DISCHARGE_VBUS.
	USB_ANALOG_USB2_VBUS_DETECT_TOG_DISCHARGE_VBUS = 0x4000000
	// Position of CHARGE_VBUS field.
	USB_ANALOG_USB2_VBUS_DETECT_TOG_CHARGE_VBUS_Pos = 0x1b
	// Bit mask of CHARGE_VBUS field.
	USB_ANALOG_USB2_VBUS_DETECT_TOG_CHARGE_VBUS_Msk = 0x8000000
	// Bit CHARGE_VBUS.
	USB_ANALOG_USB2_VBUS_DETECT_TOG_CHARGE_VBUS = 0x8000000

	// USB2_CHRG_DETECT: USB Charger Detect Register
	// Position of CHK_CONTACT field.
	USB_ANALOG_USB2_CHRG_DETECT_CHK_CONTACT_Pos = 0x12
	// Bit mask of CHK_CONTACT field.
	USB_ANALOG_USB2_CHRG_DETECT_CHK_CONTACT_Msk = 0x40000
	// Bit CHK_CONTACT.
	USB_ANALOG_USB2_CHRG_DETECT_CHK_CONTACT = 0x40000
	// Do not check the contact of USB plug.
	USB_ANALOG_USB2_CHRG_DETECT_CHK_CONTACT_NO_CHECK = 0x0
	// Check whether the USB plug has been in contact with each other
	USB_ANALOG_USB2_CHRG_DETECT_CHK_CONTACT_CHECK = 0x1
	// Position of CHK_CHRG_B field.
	USB_ANALOG_USB2_CHRG_DETECT_CHK_CHRG_B_Pos = 0x13
	// Bit mask of CHK_CHRG_B field.
	USB_ANALOG_USB2_CHRG_DETECT_CHK_CHRG_B_Msk = 0x80000
	// Bit CHK_CHRG_B.
	USB_ANALOG_USB2_CHRG_DETECT_CHK_CHRG_B = 0x80000
	// Check whether a charger (either a dedicated charger or a host charger) is connected to USB port.
	USB_ANALOG_USB2_CHRG_DETECT_CHK_CHRG_B_CHECK = 0x0
	// Do not check whether a charger is connected to the USB port.
	USB_ANALOG_USB2_CHRG_DETECT_CHK_CHRG_B_NO_CHECK = 0x1
	// Position of EN_B field.
	USB_ANALOG_USB2_CHRG_DETECT_EN_B_Pos = 0x14
	// Bit mask of EN_B field.
	USB_ANALOG_USB2_CHRG_DETECT_EN_B_Msk = 0x100000
	// Bit EN_B.
	USB_ANALOG_USB2_CHRG_DETECT_EN_B = 0x100000
	// Enable the charger detector.
	USB_ANALOG_USB2_CHRG_DETECT_EN_B_ENABLE = 0x0
	// Disable the charger detector.
	USB_ANALOG_USB2_CHRG_DETECT_EN_B_DISABLE = 0x1

	// USB2_CHRG_DETECT_SET: USB Charger Detect Register
	// Position of CHK_CONTACT field.
	USB_ANALOG_USB2_CHRG_DETECT_SET_CHK_CONTACT_Pos = 0x12
	// Bit mask of CHK_CONTACT field.
	USB_ANALOG_USB2_CHRG_DETECT_SET_CHK_CONTACT_Msk = 0x40000
	// Bit CHK_CONTACT.
	USB_ANALOG_USB2_CHRG_DETECT_SET_CHK_CONTACT = 0x40000
	// Do not check the contact of USB plug.
	USB_ANALOG_USB2_CHRG_DETECT_SET_CHK_CONTACT_NO_CHECK = 0x0
	// Check whether the USB plug has been in contact with each other
	USB_ANALOG_USB2_CHRG_DETECT_SET_CHK_CONTACT_CHECK = 0x1
	// Position of CHK_CHRG_B field.
	USB_ANALOG_USB2_CHRG_DETECT_SET_CHK_CHRG_B_Pos = 0x13
	// Bit mask of CHK_CHRG_B field.
	USB_ANALOG_USB2_CHRG_DETECT_SET_CHK_CHRG_B_Msk = 0x80000
	// Bit CHK_CHRG_B.
	USB_ANALOG_USB2_CHRG_DETECT_SET_CHK_CHRG_B = 0x80000
	// Check whether a charger (either a dedicated charger or a host charger) is connected to USB port.
	USB_ANALOG_USB2_CHRG_DETECT_SET_CHK_CHRG_B_CHECK = 0x0
	// Do not check whether a charger is connected to the USB port.
	USB_ANALOG_USB2_CHRG_DETECT_SET_CHK_CHRG_B_NO_CHECK = 0x1
	// Position of EN_B field.
	USB_ANALOG_USB2_CHRG_DETECT_SET_EN_B_Pos = 0x14
	// Bit mask of EN_B field.
	USB_ANALOG_USB2_CHRG_DETECT_SET_EN_B_Msk = 0x100000
	// Bit EN_B.
	USB_ANALOG_USB2_CHRG_DETECT_SET_EN_B = 0x100000
	// Enable the charger detector.
	USB_ANALOG_USB2_CHRG_DETECT_SET_EN_B_ENABLE = 0x0
	// Disable the charger detector.
	USB_ANALOG_USB2_CHRG_DETECT_SET_EN_B_DISABLE = 0x1

	// USB2_CHRG_DETECT_CLR: USB Charger Detect Register
	// Position of CHK_CONTACT field.
	USB_ANALOG_USB2_CHRG_DETECT_CLR_CHK_CONTACT_Pos = 0x12
	// Bit mask of CHK_CONTACT field.
	USB_ANALOG_USB2_CHRG_DETECT_CLR_CHK_CONTACT_Msk = 0x40000
	// Bit CHK_CONTACT.
	USB_ANALOG_USB2_CHRG_DETECT_CLR_CHK_CONTACT = 0x40000
	// Do not check the contact of USB plug.
	USB_ANALOG_USB2_CHRG_DETECT_CLR_CHK_CONTACT_NO_CHECK = 0x0
	// Check whether the USB plug has been in contact with each other
	USB_ANALOG_USB2_CHRG_DETECT_CLR_CHK_CONTACT_CHECK = 0x1
	// Position of CHK_CHRG_B field.
	USB_ANALOG_USB2_CHRG_DETECT_CLR_CHK_CHRG_B_Pos = 0x13
	// Bit mask of CHK_CHRG_B field.
	USB_ANALOG_USB2_CHRG_DETECT_CLR_CHK_CHRG_B_Msk = 0x80000
	// Bit CHK_CHRG_B.
	USB_ANALOG_USB2_CHRG_DETECT_CLR_CHK_CHRG_B = 0x80000
	// Check whether a charger (either a dedicated charger or a host charger) is connected to USB port.
	USB_ANALOG_USB2_CHRG_DETECT_CLR_CHK_CHRG_B_CHECK = 0x0
	// Do not check whether a charger is connected to the USB port.
	USB_ANALOG_USB2_CHRG_DETECT_CLR_CHK_CHRG_B_NO_CHECK = 0x1
	// Position of EN_B field.
	USB_ANALOG_USB2_CHRG_DETECT_CLR_EN_B_Pos = 0x14
	// Bit mask of EN_B field.
	USB_ANALOG_USB2_CHRG_DETECT_CLR_EN_B_Msk = 0x100000
	// Bit EN_B.
	USB_ANALOG_USB2_CHRG_DETECT_CLR_EN_B = 0x100000
	// Enable the charger detector.
	USB_ANALOG_USB2_CHRG_DETECT_CLR_EN_B_ENABLE = 0x0
	// Disable the charger detector.
	USB_ANALOG_USB2_CHRG_DETECT_CLR_EN_B_DISABLE = 0x1

	// USB2_CHRG_DETECT_TOG: USB Charger Detect Register
	// Position of CHK_CONTACT field.
	USB_ANALOG_USB2_CHRG_DETECT_TOG_CHK_CONTACT_Pos = 0x12
	// Bit mask of CHK_CONTACT field.
	USB_ANALOG_USB2_CHRG_DETECT_TOG_CHK_CONTACT_Msk = 0x40000
	// Bit CHK_CONTACT.
	USB_ANALOG_USB2_CHRG_DETECT_TOG_CHK_CONTACT = 0x40000
	// Do not check the contact of USB plug.
	USB_ANALOG_USB2_CHRG_DETECT_TOG_CHK_CONTACT_NO_CHECK = 0x0
	// Check whether the USB plug has been in contact with each other
	USB_ANALOG_USB2_CHRG_DETECT_TOG_CHK_CONTACT_CHECK = 0x1
	// Position of CHK_CHRG_B field.
	USB_ANALOG_USB2_CHRG_DETECT_TOG_CHK_CHRG_B_Pos = 0x13
	// Bit mask of CHK_CHRG_B field.
	USB_ANALOG_USB2_CHRG_DETECT_TOG_CHK_CHRG_B_Msk = 0x80000
	// Bit CHK_CHRG_B.
	USB_ANALOG_USB2_CHRG_DETECT_TOG_CHK_CHRG_B = 0x80000
	// Check whether a charger (either a dedicated charger or a host charger) is connected to USB port.
	USB_ANALOG_USB2_CHRG_DETECT_TOG_CHK_CHRG_B_CHECK = 0x0
	// Do not check whether a charger is connected to the USB port.
	USB_ANALOG_USB2_CHRG_DETECT_TOG_CHK_CHRG_B_NO_CHECK = 0x1
	// Position of EN_B field.
	USB_ANALOG_USB2_CHRG_DETECT_TOG_EN_B_Pos = 0x14
	// Bit mask of EN_B field.
	USB_ANALOG_USB2_CHRG_DETECT_TOG_EN_B_Msk = 0x100000
	// Bit EN_B.
	USB_ANALOG_USB2_CHRG_DETECT_TOG_EN_B = 0x100000
	// Enable the charger detector.
	USB_ANALOG_USB2_CHRG_DETECT_TOG_EN_B_ENABLE = 0x0
	// Disable the charger detector.
	USB_ANALOG_USB2_CHRG_DETECT_TOG_EN_B_DISABLE = 0x1

	// USB2_VBUS_DETECT_STAT: USB VBUS Detect Status Register
	// Position of SESSEND field.
	USB_ANALOG_USB2_VBUS_DETECT_STAT_SESSEND_Pos = 0x0
	// Bit mask of SESSEND field.
	USB_ANALOG_USB2_VBUS_DETECT_STAT_SESSEND_Msk = 0x1
	// Bit SESSEND.
	USB_ANALOG_USB2_VBUS_DETECT_STAT_SESSEND = 0x1
	// Position of BVALID field.
	USB_ANALOG_USB2_VBUS_DETECT_STAT_BVALID_Pos = 0x1
	// Bit mask of BVALID field.
	USB_ANALOG_USB2_VBUS_DETECT_STAT_BVALID_Msk = 0x2
	// Bit BVALID.
	USB_ANALOG_USB2_VBUS_DETECT_STAT_BVALID = 0x2
	// Position of AVALID field.
	USB_ANALOG_USB2_VBUS_DETECT_STAT_AVALID_Pos = 0x2
	// Bit mask of AVALID field.
	USB_ANALOG_USB2_VBUS_DETECT_STAT_AVALID_Msk = 0x4
	// Bit AVALID.
	USB_ANALOG_USB2_VBUS_DETECT_STAT_AVALID = 0x4
	// Position of VBUS_VALID field.
	USB_ANALOG_USB2_VBUS_DETECT_STAT_VBUS_VALID_Pos = 0x3
	// Bit mask of VBUS_VALID field.
	USB_ANALOG_USB2_VBUS_DETECT_STAT_VBUS_VALID_Msk = 0x8
	// Bit VBUS_VALID.
	USB_ANALOG_USB2_VBUS_DETECT_STAT_VBUS_VALID = 0x8

	// USB2_CHRG_DETECT_STAT: USB Charger Detect Status Register
	// Position of PLUG_CONTACT field.
	USB_ANALOG_USB2_CHRG_DETECT_STAT_PLUG_CONTACT_Pos = 0x0
	// Bit mask of PLUG_CONTACT field.
	USB_ANALOG_USB2_CHRG_DETECT_STAT_PLUG_CONTACT_Msk = 0x1
	// Bit PLUG_CONTACT.
	USB_ANALOG_USB2_CHRG_DETECT_STAT_PLUG_CONTACT = 0x1
	// The USB plug has not made contact.
	USB_ANALOG_USB2_CHRG_DETECT_STAT_PLUG_CONTACT_NO_CONTACT = 0x0
	// The USB plug has made good contact.
	USB_ANALOG_USB2_CHRG_DETECT_STAT_PLUG_CONTACT_GOOD_CONTACT = 0x1
	// Position of CHRG_DETECTED field.
	USB_ANALOG_USB2_CHRG_DETECT_STAT_CHRG_DETECTED_Pos = 0x1
	// Bit mask of CHRG_DETECTED field.
	USB_ANALOG_USB2_CHRG_DETECT_STAT_CHRG_DETECTED_Msk = 0x2
	// Bit CHRG_DETECTED.
	USB_ANALOG_USB2_CHRG_DETECT_STAT_CHRG_DETECTED = 0x2
	// The USB port is not connected to a charger.
	USB_ANALOG_USB2_CHRG_DETECT_STAT_CHRG_DETECTED_CHARGER_NOT_PRESENT = 0x0
	// A charger (either a dedicated charger or a host charger) is connected to the USB port.
	USB_ANALOG_USB2_CHRG_DETECT_STAT_CHRG_DETECTED_CHARGER_PRESENT = 0x1
	// Position of DM_STATE field.
	USB_ANALOG_USB2_CHRG_DETECT_STAT_DM_STATE_Pos = 0x2
	// Bit mask of DM_STATE field.
	USB_ANALOG_USB2_CHRG_DETECT_STAT_DM_STATE_Msk = 0x4
	// Bit DM_STATE.
	USB_ANALOG_USB2_CHRG_DETECT_STAT_DM_STATE = 0x4
	// Position of DP_STATE field.
	USB_ANALOG_USB2_CHRG_DETECT_STAT_DP_STATE_Pos = 0x3
	// Bit mask of DP_STATE field.
	USB_ANALOG_USB2_CHRG_DETECT_STAT_DP_STATE_Msk = 0x8
	// Bit DP_STATE.
	USB_ANALOG_USB2_CHRG_DETECT_STAT_DP_STATE = 0x8

	// USB2_MISC: USB Misc Register
	// Position of HS_USE_EXTERNAL_R field.
	USB_ANALOG_USB2_MISC_HS_USE_EXTERNAL_R_Pos = 0x0
	// Bit mask of HS_USE_EXTERNAL_R field.
	USB_ANALOG_USB2_MISC_HS_USE_EXTERNAL_R_Msk = 0x1
	// Bit HS_USE_EXTERNAL_R.
	USB_ANALOG_USB2_MISC_HS_USE_EXTERNAL_R = 0x1
	// Position of EN_DEGLITCH field.
	USB_ANALOG_USB2_MISC_EN_DEGLITCH_Pos = 0x1
	// Bit mask of EN_DEGLITCH field.
	USB_ANALOG_USB2_MISC_EN_DEGLITCH_Msk = 0x2
	// Bit EN_DEGLITCH.
	USB_ANALOG_USB2_MISC_EN_DEGLITCH = 0x2
	// Position of EN_CLK_UTMI field.
	USB_ANALOG_USB2_MISC_EN_CLK_UTMI_Pos = 0x1e
	// Bit mask of EN_CLK_UTMI field.
	USB_ANALOG_USB2_MISC_EN_CLK_UTMI_Msk = 0x40000000
	// Bit EN_CLK_UTMI.
	USB_ANALOG_USB2_MISC_EN_CLK_UTMI = 0x40000000

	// USB2_MISC_SET: USB Misc Register
	// Position of HS_USE_EXTERNAL_R field.
	USB_ANALOG_USB2_MISC_SET_HS_USE_EXTERNAL_R_Pos = 0x0
	// Bit mask of HS_USE_EXTERNAL_R field.
	USB_ANALOG_USB2_MISC_SET_HS_USE_EXTERNAL_R_Msk = 0x1
	// Bit HS_USE_EXTERNAL_R.
	USB_ANALOG_USB2_MISC_SET_HS_USE_EXTERNAL_R = 0x1
	// Position of EN_DEGLITCH field.
	USB_ANALOG_USB2_MISC_SET_EN_DEGLITCH_Pos = 0x1
	// Bit mask of EN_DEGLITCH field.
	USB_ANALOG_USB2_MISC_SET_EN_DEGLITCH_Msk = 0x2
	// Bit EN_DEGLITCH.
	USB_ANALOG_USB2_MISC_SET_EN_DEGLITCH = 0x2
	// Position of EN_CLK_UTMI field.
	USB_ANALOG_USB2_MISC_SET_EN_CLK_UTMI_Pos = 0x1e
	// Bit mask of EN_CLK_UTMI field.
	USB_ANALOG_USB2_MISC_SET_EN_CLK_UTMI_Msk = 0x40000000
	// Bit EN_CLK_UTMI.
	USB_ANALOG_USB2_MISC_SET_EN_CLK_UTMI = 0x40000000

	// USB2_MISC_CLR: USB Misc Register
	// Position of HS_USE_EXTERNAL_R field.
	USB_ANALOG_USB2_MISC_CLR_HS_USE_EXTERNAL_R_Pos = 0x0
	// Bit mask of HS_USE_EXTERNAL_R field.
	USB_ANALOG_USB2_MISC_CLR_HS_USE_EXTERNAL_R_Msk = 0x1
	// Bit HS_USE_EXTERNAL_R.
	USB_ANALOG_USB2_MISC_CLR_HS_USE_EXTERNAL_R = 0x1
	// Position of EN_DEGLITCH field.
	USB_ANALOG_USB2_MISC_CLR_EN_DEGLITCH_Pos = 0x1
	// Bit mask of EN_DEGLITCH field.
	USB_ANALOG_USB2_MISC_CLR_EN_DEGLITCH_Msk = 0x2
	// Bit EN_DEGLITCH.
	USB_ANALOG_USB2_MISC_CLR_EN_DEGLITCH = 0x2
	// Position of EN_CLK_UTMI field.
	USB_ANALOG_USB2_MISC_CLR_EN_CLK_UTMI_Pos = 0x1e
	// Bit mask of EN_CLK_UTMI field.
	USB_ANALOG_USB2_MISC_CLR_EN_CLK_UTMI_Msk = 0x40000000
	// Bit EN_CLK_UTMI.
	USB_ANALOG_USB2_MISC_CLR_EN_CLK_UTMI = 0x40000000

	// USB2_MISC_TOG: USB Misc Register
	// Position of HS_USE_EXTERNAL_R field.
	USB_ANALOG_USB2_MISC_TOG_HS_USE_EXTERNAL_R_Pos = 0x0
	// Bit mask of HS_USE_EXTERNAL_R field.
	USB_ANALOG_USB2_MISC_TOG_HS_USE_EXTERNAL_R_Msk = 0x1
	// Bit HS_USE_EXTERNAL_R.
	USB_ANALOG_USB2_MISC_TOG_HS_USE_EXTERNAL_R = 0x1
	// Position of EN_DEGLITCH field.
	USB_ANALOG_USB2_MISC_TOG_EN_DEGLITCH_Pos = 0x1
	// Bit mask of EN_DEGLITCH field.
	USB_ANALOG_USB2_MISC_TOG_EN_DEGLITCH_Msk = 0x2
	// Bit EN_DEGLITCH.
	USB_ANALOG_USB2_MISC_TOG_EN_DEGLITCH = 0x2
	// Position of EN_CLK_UTMI field.
	USB_ANALOG_USB2_MISC_TOG_EN_CLK_UTMI_Pos = 0x1e
	// Bit mask of EN_CLK_UTMI field.
	USB_ANALOG_USB2_MISC_TOG_EN_CLK_UTMI_Msk = 0x40000000
	// Bit EN_CLK_UTMI.
	USB_ANALOG_USB2_MISC_TOG_EN_CLK_UTMI = 0x40000000

	// DIGPROG: Chip Silicon Version
	// Position of SILICON_REVISION field.
	USB_ANALOG_DIGPROG_SILICON_REVISION_Pos = 0x0
	// Bit mask of SILICON_REVISION field.
	USB_ANALOG_DIGPROG_SILICON_REVISION_Msk = 0xffffffff
	// Silicon revision 1.0
	USB_ANALOG_DIGPROG_SILICON_REVISION_SILICON_REVISION_7077888 = 0x6c0000
)

// Bitfields for XTALOSC24M: XTALOSC24M
const (
	// MISC0: Miscellaneous Register 0
	// Position of REFTOP_PWD field.
	XTALOSC24M_MISC0_REFTOP_PWD_Pos = 0x0
	// Bit mask of REFTOP_PWD field.
	XTALOSC24M_MISC0_REFTOP_PWD_Msk = 0x1
	// Bit REFTOP_PWD.
	XTALOSC24M_MISC0_REFTOP_PWD = 0x1
	// Position of REFTOP_SELFBIASOFF field.
	XTALOSC24M_MISC0_REFTOP_SELFBIASOFF_Pos = 0x3
	// Bit mask of REFTOP_SELFBIASOFF field.
	XTALOSC24M_MISC0_REFTOP_SELFBIASOFF_Msk = 0x8
	// Bit REFTOP_SELFBIASOFF.
	XTALOSC24M_MISC0_REFTOP_SELFBIASOFF = 0x8
	// Uses coarse bias currents for startup
	XTALOSC24M_MISC0_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_0 = 0x0
	// Uses bandgap-based bias currents for best performance.
	XTALOSC24M_MISC0_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_1 = 0x1
	// Position of REFTOP_VBGADJ field.
	XTALOSC24M_MISC0_REFTOP_VBGADJ_Pos = 0x4
	// Bit mask of REFTOP_VBGADJ field.
	XTALOSC24M_MISC0_REFTOP_VBGADJ_Msk = 0x70
	// Nominal VBG
	XTALOSC24M_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_0 = 0x0
	// VBG+0.78%
	XTALOSC24M_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_1 = 0x1
	// VBG+1.56%
	XTALOSC24M_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_2 = 0x2
	// VBG+2.34%
	XTALOSC24M_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_3 = 0x3
	// VBG-0.78%
	XTALOSC24M_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_4 = 0x4
	// VBG-1.56%
	XTALOSC24M_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_5 = 0x5
	// VBG-2.34%
	XTALOSC24M_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_6 = 0x6
	// VBG-3.12%
	XTALOSC24M_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_7 = 0x7
	// Position of REFTOP_VBGUP field.
	XTALOSC24M_MISC0_REFTOP_VBGUP_Pos = 0x7
	// Bit mask of REFTOP_VBGUP field.
	XTALOSC24M_MISC0_REFTOP_VBGUP_Msk = 0x80
	// Bit REFTOP_VBGUP.
	XTALOSC24M_MISC0_REFTOP_VBGUP = 0x80
	// Position of STOP_MODE_CONFIG field.
	XTALOSC24M_MISC0_STOP_MODE_CONFIG_Pos = 0xa
	// Bit mask of STOP_MODE_CONFIG field.
	XTALOSC24M_MISC0_STOP_MODE_CONFIG_Msk = 0xc00
	// All analog except rtc powered down on stop mode assertion. XtalOsc=on, RCOsc=off;
	XTALOSC24M_MISC0_STOP_MODE_CONFIG_STOP_MODE_CONFIG_0 = 0x0
	// Certain analog functions such as certain regulators left up. XtalOsc=on, RCOsc=off;
	XTALOSC24M_MISC0_STOP_MODE_CONFIG_STOP_MODE_CONFIG_1 = 0x1
	// XtalOsc=off, RCOsc=on, Old BG=on, New BG=off.
	XTALOSC24M_MISC0_STOP_MODE_CONFIG_STOP_MODE_CONFIG_2 = 0x2
	// XtalOsc=off, RCOsc=on, Old BG=off, New BG=on.
	XTALOSC24M_MISC0_STOP_MODE_CONFIG_STOP_MODE_CONFIG_3 = 0x3
	// Position of DISCON_HIGH_SNVS field.
	XTALOSC24M_MISC0_DISCON_HIGH_SNVS_Pos = 0xc
	// Bit mask of DISCON_HIGH_SNVS field.
	XTALOSC24M_MISC0_DISCON_HIGH_SNVS_Msk = 0x1000
	// Bit DISCON_HIGH_SNVS.
	XTALOSC24M_MISC0_DISCON_HIGH_SNVS = 0x1000
	// Turn on the switch
	XTALOSC24M_MISC0_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_0 = 0x0
	// Turn off the switch
	XTALOSC24M_MISC0_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_1 = 0x1
	// Position of OSC_I field.
	XTALOSC24M_MISC0_OSC_I_Pos = 0xd
	// Bit mask of OSC_I field.
	XTALOSC24M_MISC0_OSC_I_Msk = 0x6000
	// Nominal
	XTALOSC24M_MISC0_OSC_I_NOMINAL = 0x0
	// Decrease current by 12.5%
	XTALOSC24M_MISC0_OSC_I_MINUS_12_5_PERCENT = 0x1
	// Decrease current by 25.0%
	XTALOSC24M_MISC0_OSC_I_MINUS_25_PERCENT = 0x2
	// Decrease current by 37.5%
	XTALOSC24M_MISC0_OSC_I_MINUS_37_5_PERCENT = 0x3
	// Position of OSC_XTALOK field.
	XTALOSC24M_MISC0_OSC_XTALOK_Pos = 0xf
	// Bit mask of OSC_XTALOK field.
	XTALOSC24M_MISC0_OSC_XTALOK_Msk = 0x8000
	// Bit OSC_XTALOK.
	XTALOSC24M_MISC0_OSC_XTALOK = 0x8000
	// Position of OSC_XTALOK_EN field.
	XTALOSC24M_MISC0_OSC_XTALOK_EN_Pos = 0x10
	// Bit mask of OSC_XTALOK_EN field.
	XTALOSC24M_MISC0_OSC_XTALOK_EN_Msk = 0x10000
	// Bit OSC_XTALOK_EN.
	XTALOSC24M_MISC0_OSC_XTALOK_EN = 0x10000
	// Position of CLKGATE_CTRL field.
	XTALOSC24M_MISC0_CLKGATE_CTRL_Pos = 0x19
	// Bit mask of CLKGATE_CTRL field.
	XTALOSC24M_MISC0_CLKGATE_CTRL_Msk = 0x2000000
	// Bit CLKGATE_CTRL.
	XTALOSC24M_MISC0_CLKGATE_CTRL = 0x2000000
	// Allow the logic to automatically gate the clock when the XTAL is powered down.
	XTALOSC24M_MISC0_CLKGATE_CTRL_ALLOW_AUTO_GATE = 0x0
	// Prevent the logic from ever gating off the clock.
	XTALOSC24M_MISC0_CLKGATE_CTRL_NO_AUTO_GATE = 0x1
	// Position of CLKGATE_DELAY field.
	XTALOSC24M_MISC0_CLKGATE_DELAY_Pos = 0x1a
	// Bit mask of CLKGATE_DELAY field.
	XTALOSC24M_MISC0_CLKGATE_DELAY_Msk = 0x1c000000
	// 0.5ms
	XTALOSC24M_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_0 = 0x0
	// 1.0ms
	XTALOSC24M_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_1 = 0x1
	// 2.0ms
	XTALOSC24M_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_2 = 0x2
	// 3.0ms
	XTALOSC24M_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_3 = 0x3
	// 4.0ms
	XTALOSC24M_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_4 = 0x4
	// 5.0ms
	XTALOSC24M_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_5 = 0x5
	// 6.0ms
	XTALOSC24M_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_6 = 0x6
	// 7.0ms
	XTALOSC24M_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_7 = 0x7
	// Position of RTC_XTAL_SOURCE field.
	XTALOSC24M_MISC0_RTC_XTAL_SOURCE_Pos = 0x1d
	// Bit mask of RTC_XTAL_SOURCE field.
	XTALOSC24M_MISC0_RTC_XTAL_SOURCE_Msk = 0x20000000
	// Bit RTC_XTAL_SOURCE.
	XTALOSC24M_MISC0_RTC_XTAL_SOURCE = 0x20000000
	// Internal ring oscillator
	XTALOSC24M_MISC0_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_0 = 0x0
	// RTC_XTAL
	XTALOSC24M_MISC0_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_1 = 0x1
	// Position of XTAL_24M_PWD field.
	XTALOSC24M_MISC0_XTAL_24M_PWD_Pos = 0x1e
	// Bit mask of XTAL_24M_PWD field.
	XTALOSC24M_MISC0_XTAL_24M_PWD_Msk = 0x40000000
	// Bit XTAL_24M_PWD.
	XTALOSC24M_MISC0_XTAL_24M_PWD = 0x40000000
	// Position of VID_PLL_PREDIV field.
	XTALOSC24M_MISC0_VID_PLL_PREDIV_Pos = 0x1f
	// Bit mask of VID_PLL_PREDIV field.
	XTALOSC24M_MISC0_VID_PLL_PREDIV_Msk = 0x80000000
	// Bit VID_PLL_PREDIV.
	XTALOSC24M_MISC0_VID_PLL_PREDIV = 0x80000000
	// Divide by 1
	XTALOSC24M_MISC0_VID_PLL_PREDIV_VID_PLL_PREDIV_0 = 0x0
	// Divide by 2
	XTALOSC24M_MISC0_VID_PLL_PREDIV_VID_PLL_PREDIV_1 = 0x1

	// MISC0_SET: Miscellaneous Register 0
	// Position of REFTOP_PWD field.
	XTALOSC24M_MISC0_SET_REFTOP_PWD_Pos = 0x0
	// Bit mask of REFTOP_PWD field.
	XTALOSC24M_MISC0_SET_REFTOP_PWD_Msk = 0x1
	// Bit REFTOP_PWD.
	XTALOSC24M_MISC0_SET_REFTOP_PWD = 0x1
	// Position of REFTOP_SELFBIASOFF field.
	XTALOSC24M_MISC0_SET_REFTOP_SELFBIASOFF_Pos = 0x3
	// Bit mask of REFTOP_SELFBIASOFF field.
	XTALOSC24M_MISC0_SET_REFTOP_SELFBIASOFF_Msk = 0x8
	// Bit REFTOP_SELFBIASOFF.
	XTALOSC24M_MISC0_SET_REFTOP_SELFBIASOFF = 0x8
	// Uses coarse bias currents for startup
	XTALOSC24M_MISC0_SET_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_0 = 0x0
	// Uses bandgap-based bias currents for best performance.
	XTALOSC24M_MISC0_SET_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_1 = 0x1
	// Position of REFTOP_VBGADJ field.
	XTALOSC24M_MISC0_SET_REFTOP_VBGADJ_Pos = 0x4
	// Bit mask of REFTOP_VBGADJ field.
	XTALOSC24M_MISC0_SET_REFTOP_VBGADJ_Msk = 0x70
	// Nominal VBG
	XTALOSC24M_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_0 = 0x0
	// VBG+0.78%
	XTALOSC24M_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_1 = 0x1
	// VBG+1.56%
	XTALOSC24M_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_2 = 0x2
	// VBG+2.34%
	XTALOSC24M_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_3 = 0x3
	// VBG-0.78%
	XTALOSC24M_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_4 = 0x4
	// VBG-1.56%
	XTALOSC24M_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_5 = 0x5
	// VBG-2.34%
	XTALOSC24M_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_6 = 0x6
	// VBG-3.12%
	XTALOSC24M_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_7 = 0x7
	// Position of REFTOP_VBGUP field.
	XTALOSC24M_MISC0_SET_REFTOP_VBGUP_Pos = 0x7
	// Bit mask of REFTOP_VBGUP field.
	XTALOSC24M_MISC0_SET_REFTOP_VBGUP_Msk = 0x80
	// Bit REFTOP_VBGUP.
	XTALOSC24M_MISC0_SET_REFTOP_VBGUP = 0x80
	// Position of STOP_MODE_CONFIG field.
	XTALOSC24M_MISC0_SET_STOP_MODE_CONFIG_Pos = 0xa
	// Bit mask of STOP_MODE_CONFIG field.
	XTALOSC24M_MISC0_SET_STOP_MODE_CONFIG_Msk = 0xc00
	// All analog except rtc powered down on stop mode assertion. XtalOsc=on, RCOsc=off;
	XTALOSC24M_MISC0_SET_STOP_MODE_CONFIG_STOP_MODE_CONFIG_0 = 0x0
	// Certain analog functions such as certain regulators left up. XtalOsc=on, RCOsc=off;
	XTALOSC24M_MISC0_SET_STOP_MODE_CONFIG_STOP_MODE_CONFIG_1 = 0x1
	// XtalOsc=off, RCOsc=on, Old BG=on, New BG=off.
	XTALOSC24M_MISC0_SET_STOP_MODE_CONFIG_STOP_MODE_CONFIG_2 = 0x2
	// XtalOsc=off, RCOsc=on, Old BG=off, New BG=on.
	XTALOSC24M_MISC0_SET_STOP_MODE_CONFIG_STOP_MODE_CONFIG_3 = 0x3
	// Position of DISCON_HIGH_SNVS field.
	XTALOSC24M_MISC0_SET_DISCON_HIGH_SNVS_Pos = 0xc
	// Bit mask of DISCON_HIGH_SNVS field.
	XTALOSC24M_MISC0_SET_DISCON_HIGH_SNVS_Msk = 0x1000
	// Bit DISCON_HIGH_SNVS.
	XTALOSC24M_MISC0_SET_DISCON_HIGH_SNVS = 0x1000
	// Turn on the switch
	XTALOSC24M_MISC0_SET_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_0 = 0x0
	// Turn off the switch
	XTALOSC24M_MISC0_SET_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_1 = 0x1
	// Position of OSC_I field.
	XTALOSC24M_MISC0_SET_OSC_I_Pos = 0xd
	// Bit mask of OSC_I field.
	XTALOSC24M_MISC0_SET_OSC_I_Msk = 0x6000
	// Nominal
	XTALOSC24M_MISC0_SET_OSC_I_NOMINAL = 0x0
	// Decrease current by 12.5%
	XTALOSC24M_MISC0_SET_OSC_I_MINUS_12_5_PERCENT = 0x1
	// Decrease current by 25.0%
	XTALOSC24M_MISC0_SET_OSC_I_MINUS_25_PERCENT = 0x2
	// Decrease current by 37.5%
	XTALOSC24M_MISC0_SET_OSC_I_MINUS_37_5_PERCENT = 0x3
	// Position of OSC_XTALOK field.
	XTALOSC24M_MISC0_SET_OSC_XTALOK_Pos = 0xf
	// Bit mask of OSC_XTALOK field.
	XTALOSC24M_MISC0_SET_OSC_XTALOK_Msk = 0x8000
	// Bit OSC_XTALOK.
	XTALOSC24M_MISC0_SET_OSC_XTALOK = 0x8000
	// Position of OSC_XTALOK_EN field.
	XTALOSC24M_MISC0_SET_OSC_XTALOK_EN_Pos = 0x10
	// Bit mask of OSC_XTALOK_EN field.
	XTALOSC24M_MISC0_SET_OSC_XTALOK_EN_Msk = 0x10000
	// Bit OSC_XTALOK_EN.
	XTALOSC24M_MISC0_SET_OSC_XTALOK_EN = 0x10000
	// Position of CLKGATE_CTRL field.
	XTALOSC24M_MISC0_SET_CLKGATE_CTRL_Pos = 0x19
	// Bit mask of CLKGATE_CTRL field.
	XTALOSC24M_MISC0_SET_CLKGATE_CTRL_Msk = 0x2000000
	// Bit CLKGATE_CTRL.
	XTALOSC24M_MISC0_SET_CLKGATE_CTRL = 0x2000000
	// Allow the logic to automatically gate the clock when the XTAL is powered down.
	XTALOSC24M_MISC0_SET_CLKGATE_CTRL_ALLOW_AUTO_GATE = 0x0
	// Prevent the logic from ever gating off the clock.
	XTALOSC24M_MISC0_SET_CLKGATE_CTRL_NO_AUTO_GATE = 0x1
	// Position of CLKGATE_DELAY field.
	XTALOSC24M_MISC0_SET_CLKGATE_DELAY_Pos = 0x1a
	// Bit mask of CLKGATE_DELAY field.
	XTALOSC24M_MISC0_SET_CLKGATE_DELAY_Msk = 0x1c000000
	// 0.5ms
	XTALOSC24M_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_0 = 0x0
	// 1.0ms
	XTALOSC24M_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_1 = 0x1
	// 2.0ms
	XTALOSC24M_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_2 = 0x2
	// 3.0ms
	XTALOSC24M_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_3 = 0x3
	// 4.0ms
	XTALOSC24M_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_4 = 0x4
	// 5.0ms
	XTALOSC24M_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_5 = 0x5
	// 6.0ms
	XTALOSC24M_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_6 = 0x6
	// 7.0ms
	XTALOSC24M_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_7 = 0x7
	// Position of RTC_XTAL_SOURCE field.
	XTALOSC24M_MISC0_SET_RTC_XTAL_SOURCE_Pos = 0x1d
	// Bit mask of RTC_XTAL_SOURCE field.
	XTALOSC24M_MISC0_SET_RTC_XTAL_SOURCE_Msk = 0x20000000
	// Bit RTC_XTAL_SOURCE.
	XTALOSC24M_MISC0_SET_RTC_XTAL_SOURCE = 0x20000000
	// Internal ring oscillator
	XTALOSC24M_MISC0_SET_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_0 = 0x0
	// RTC_XTAL
	XTALOSC24M_MISC0_SET_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_1 = 0x1
	// Position of XTAL_24M_PWD field.
	XTALOSC24M_MISC0_SET_XTAL_24M_PWD_Pos = 0x1e
	// Bit mask of XTAL_24M_PWD field.
	XTALOSC24M_MISC0_SET_XTAL_24M_PWD_Msk = 0x40000000
	// Bit XTAL_24M_PWD.
	XTALOSC24M_MISC0_SET_XTAL_24M_PWD = 0x40000000
	// Position of VID_PLL_PREDIV field.
	XTALOSC24M_MISC0_SET_VID_PLL_PREDIV_Pos = 0x1f
	// Bit mask of VID_PLL_PREDIV field.
	XTALOSC24M_MISC0_SET_VID_PLL_PREDIV_Msk = 0x80000000
	// Bit VID_PLL_PREDIV.
	XTALOSC24M_MISC0_SET_VID_PLL_PREDIV = 0x80000000
	// Divide by 1
	XTALOSC24M_MISC0_SET_VID_PLL_PREDIV_VID_PLL_PREDIV_0 = 0x0
	// Divide by 2
	XTALOSC24M_MISC0_SET_VID_PLL_PREDIV_VID_PLL_PREDIV_1 = 0x1

	// MISC0_CLR: Miscellaneous Register 0
	// Position of REFTOP_PWD field.
	XTALOSC24M_MISC0_CLR_REFTOP_PWD_Pos = 0x0
	// Bit mask of REFTOP_PWD field.
	XTALOSC24M_MISC0_CLR_REFTOP_PWD_Msk = 0x1
	// Bit REFTOP_PWD.
	XTALOSC24M_MISC0_CLR_REFTOP_PWD = 0x1
	// Position of REFTOP_SELFBIASOFF field.
	XTALOSC24M_MISC0_CLR_REFTOP_SELFBIASOFF_Pos = 0x3
	// Bit mask of REFTOP_SELFBIASOFF field.
	XTALOSC24M_MISC0_CLR_REFTOP_SELFBIASOFF_Msk = 0x8
	// Bit REFTOP_SELFBIASOFF.
	XTALOSC24M_MISC0_CLR_REFTOP_SELFBIASOFF = 0x8
	// Uses coarse bias currents for startup
	XTALOSC24M_MISC0_CLR_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_0 = 0x0
	// Uses bandgap-based bias currents for best performance.
	XTALOSC24M_MISC0_CLR_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_1 = 0x1
	// Position of REFTOP_VBGADJ field.
	XTALOSC24M_MISC0_CLR_REFTOP_VBGADJ_Pos = 0x4
	// Bit mask of REFTOP_VBGADJ field.
	XTALOSC24M_MISC0_CLR_REFTOP_VBGADJ_Msk = 0x70
	// Nominal VBG
	XTALOSC24M_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_0 = 0x0
	// VBG+0.78%
	XTALOSC24M_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_1 = 0x1
	// VBG+1.56%
	XTALOSC24M_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_2 = 0x2
	// VBG+2.34%
	XTALOSC24M_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_3 = 0x3
	// VBG-0.78%
	XTALOSC24M_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_4 = 0x4
	// VBG-1.56%
	XTALOSC24M_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_5 = 0x5
	// VBG-2.34%
	XTALOSC24M_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_6 = 0x6
	// VBG-3.12%
	XTALOSC24M_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_7 = 0x7
	// Position of REFTOP_VBGUP field.
	XTALOSC24M_MISC0_CLR_REFTOP_VBGUP_Pos = 0x7
	// Bit mask of REFTOP_VBGUP field.
	XTALOSC24M_MISC0_CLR_REFTOP_VBGUP_Msk = 0x80
	// Bit REFTOP_VBGUP.
	XTALOSC24M_MISC0_CLR_REFTOP_VBGUP = 0x80
	// Position of STOP_MODE_CONFIG field.
	XTALOSC24M_MISC0_CLR_STOP_MODE_CONFIG_Pos = 0xa
	// Bit mask of STOP_MODE_CONFIG field.
	XTALOSC24M_MISC0_CLR_STOP_MODE_CONFIG_Msk = 0xc00
	// All analog except rtc powered down on stop mode assertion. XtalOsc=on, RCOsc=off;
	XTALOSC24M_MISC0_CLR_STOP_MODE_CONFIG_STOP_MODE_CONFIG_0 = 0x0
	// Certain analog functions such as certain regulators left up. XtalOsc=on, RCOsc=off;
	XTALOSC24M_MISC0_CLR_STOP_MODE_CONFIG_STOP_MODE_CONFIG_1 = 0x1
	// XtalOsc=off, RCOsc=on, Old BG=on, New BG=off.
	XTALOSC24M_MISC0_CLR_STOP_MODE_CONFIG_STOP_MODE_CONFIG_2 = 0x2
	// XtalOsc=off, RCOsc=on, Old BG=off, New BG=on.
	XTALOSC24M_MISC0_CLR_STOP_MODE_CONFIG_STOP_MODE_CONFIG_3 = 0x3
	// Position of DISCON_HIGH_SNVS field.
	XTALOSC24M_MISC0_CLR_DISCON_HIGH_SNVS_Pos = 0xc
	// Bit mask of DISCON_HIGH_SNVS field.
	XTALOSC24M_MISC0_CLR_DISCON_HIGH_SNVS_Msk = 0x1000
	// Bit DISCON_HIGH_SNVS.
	XTALOSC24M_MISC0_CLR_DISCON_HIGH_SNVS = 0x1000
	// Turn on the switch
	XTALOSC24M_MISC0_CLR_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_0 = 0x0
	// Turn off the switch
	XTALOSC24M_MISC0_CLR_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_1 = 0x1
	// Position of OSC_I field.
	XTALOSC24M_MISC0_CLR_OSC_I_Pos = 0xd
	// Bit mask of OSC_I field.
	XTALOSC24M_MISC0_CLR_OSC_I_Msk = 0x6000
	// Nominal
	XTALOSC24M_MISC0_CLR_OSC_I_NOMINAL = 0x0
	// Decrease current by 12.5%
	XTALOSC24M_MISC0_CLR_OSC_I_MINUS_12_5_PERCENT = 0x1
	// Decrease current by 25.0%
	XTALOSC24M_MISC0_CLR_OSC_I_MINUS_25_PERCENT = 0x2
	// Decrease current by 37.5%
	XTALOSC24M_MISC0_CLR_OSC_I_MINUS_37_5_PERCENT = 0x3
	// Position of OSC_XTALOK field.
	XTALOSC24M_MISC0_CLR_OSC_XTALOK_Pos = 0xf
	// Bit mask of OSC_XTALOK field.
	XTALOSC24M_MISC0_CLR_OSC_XTALOK_Msk = 0x8000
	// Bit OSC_XTALOK.
	XTALOSC24M_MISC0_CLR_OSC_XTALOK = 0x8000
	// Position of OSC_XTALOK_EN field.
	XTALOSC24M_MISC0_CLR_OSC_XTALOK_EN_Pos = 0x10
	// Bit mask of OSC_XTALOK_EN field.
	XTALOSC24M_MISC0_CLR_OSC_XTALOK_EN_Msk = 0x10000
	// Bit OSC_XTALOK_EN.
	XTALOSC24M_MISC0_CLR_OSC_XTALOK_EN = 0x10000
	// Position of CLKGATE_CTRL field.
	XTALOSC24M_MISC0_CLR_CLKGATE_CTRL_Pos = 0x19
	// Bit mask of CLKGATE_CTRL field.
	XTALOSC24M_MISC0_CLR_CLKGATE_CTRL_Msk = 0x2000000
	// Bit CLKGATE_CTRL.
	XTALOSC24M_MISC0_CLR_CLKGATE_CTRL = 0x2000000
	// Allow the logic to automatically gate the clock when the XTAL is powered down.
	XTALOSC24M_MISC0_CLR_CLKGATE_CTRL_ALLOW_AUTO_GATE = 0x0
	// Prevent the logic from ever gating off the clock.
	XTALOSC24M_MISC0_CLR_CLKGATE_CTRL_NO_AUTO_GATE = 0x1
	// Position of CLKGATE_DELAY field.
	XTALOSC24M_MISC0_CLR_CLKGATE_DELAY_Pos = 0x1a
	// Bit mask of CLKGATE_DELAY field.
	XTALOSC24M_MISC0_CLR_CLKGATE_DELAY_Msk = 0x1c000000
	// 0.5ms
	XTALOSC24M_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_0 = 0x0
	// 1.0ms
	XTALOSC24M_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_1 = 0x1
	// 2.0ms
	XTALOSC24M_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_2 = 0x2
	// 3.0ms
	XTALOSC24M_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_3 = 0x3
	// 4.0ms
	XTALOSC24M_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_4 = 0x4
	// 5.0ms
	XTALOSC24M_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_5 = 0x5
	// 6.0ms
	XTALOSC24M_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_6 = 0x6
	// 7.0ms
	XTALOSC24M_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_7 = 0x7
	// Position of RTC_XTAL_SOURCE field.
	XTALOSC24M_MISC0_CLR_RTC_XTAL_SOURCE_Pos = 0x1d
	// Bit mask of RTC_XTAL_SOURCE field.
	XTALOSC24M_MISC0_CLR_RTC_XTAL_SOURCE_Msk = 0x20000000
	// Bit RTC_XTAL_SOURCE.
	XTALOSC24M_MISC0_CLR_RTC_XTAL_SOURCE = 0x20000000
	// Internal ring oscillator
	XTALOSC24M_MISC0_CLR_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_0 = 0x0
	// RTC_XTAL
	XTALOSC24M_MISC0_CLR_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_1 = 0x1
	// Position of XTAL_24M_PWD field.
	XTALOSC24M_MISC0_CLR_XTAL_24M_PWD_Pos = 0x1e
	// Bit mask of XTAL_24M_PWD field.
	XTALOSC24M_MISC0_CLR_XTAL_24M_PWD_Msk = 0x40000000
	// Bit XTAL_24M_PWD.
	XTALOSC24M_MISC0_CLR_XTAL_24M_PWD = 0x40000000
	// Position of VID_PLL_PREDIV field.
	XTALOSC24M_MISC0_CLR_VID_PLL_PREDIV_Pos = 0x1f
	// Bit mask of VID_PLL_PREDIV field.
	XTALOSC24M_MISC0_CLR_VID_PLL_PREDIV_Msk = 0x80000000
	// Bit VID_PLL_PREDIV.
	XTALOSC24M_MISC0_CLR_VID_PLL_PREDIV = 0x80000000
	// Divide by 1
	XTALOSC24M_MISC0_CLR_VID_PLL_PREDIV_VID_PLL_PREDIV_0 = 0x0
	// Divide by 2
	XTALOSC24M_MISC0_CLR_VID_PLL_PREDIV_VID_PLL_PREDIV_1 = 0x1

	// MISC0_TOG: Miscellaneous Register 0
	// Position of REFTOP_PWD field.
	XTALOSC24M_MISC0_TOG_REFTOP_PWD_Pos = 0x0
	// Bit mask of REFTOP_PWD field.
	XTALOSC24M_MISC0_TOG_REFTOP_PWD_Msk = 0x1
	// Bit REFTOP_PWD.
	XTALOSC24M_MISC0_TOG_REFTOP_PWD = 0x1
	// Position of REFTOP_SELFBIASOFF field.
	XTALOSC24M_MISC0_TOG_REFTOP_SELFBIASOFF_Pos = 0x3
	// Bit mask of REFTOP_SELFBIASOFF field.
	XTALOSC24M_MISC0_TOG_REFTOP_SELFBIASOFF_Msk = 0x8
	// Bit REFTOP_SELFBIASOFF.
	XTALOSC24M_MISC0_TOG_REFTOP_SELFBIASOFF = 0x8
	// Uses coarse bias currents for startup
	XTALOSC24M_MISC0_TOG_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_0 = 0x0
	// Uses bandgap-based bias currents for best performance.
	XTALOSC24M_MISC0_TOG_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_1 = 0x1
	// Position of REFTOP_VBGADJ field.
	XTALOSC24M_MISC0_TOG_REFTOP_VBGADJ_Pos = 0x4
	// Bit mask of REFTOP_VBGADJ field.
	XTALOSC24M_MISC0_TOG_REFTOP_VBGADJ_Msk = 0x70
	// Nominal VBG
	XTALOSC24M_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_0 = 0x0
	// VBG+0.78%
	XTALOSC24M_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_1 = 0x1
	// VBG+1.56%
	XTALOSC24M_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_2 = 0x2
	// VBG+2.34%
	XTALOSC24M_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_3 = 0x3
	// VBG-0.78%
	XTALOSC24M_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_4 = 0x4
	// VBG-1.56%
	XTALOSC24M_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_5 = 0x5
	// VBG-2.34%
	XTALOSC24M_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_6 = 0x6
	// VBG-3.12%
	XTALOSC24M_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_7 = 0x7
	// Position of REFTOP_VBGUP field.
	XTALOSC24M_MISC0_TOG_REFTOP_VBGUP_Pos = 0x7
	// Bit mask of REFTOP_VBGUP field.
	XTALOSC24M_MISC0_TOG_REFTOP_VBGUP_Msk = 0x80
	// Bit REFTOP_VBGUP.
	XTALOSC24M_MISC0_TOG_REFTOP_VBGUP = 0x80
	// Position of STOP_MODE_CONFIG field.
	XTALOSC24M_MISC0_TOG_STOP_MODE_CONFIG_Pos = 0xa
	// Bit mask of STOP_MODE_CONFIG field.
	XTALOSC24M_MISC0_TOG_STOP_MODE_CONFIG_Msk = 0xc00
	// All analog except rtc powered down on stop mode assertion. XtalOsc=on, RCOsc=off;
	XTALOSC24M_MISC0_TOG_STOP_MODE_CONFIG_STOP_MODE_CONFIG_0 = 0x0
	// Certain analog functions such as certain regulators left up. XtalOsc=on, RCOsc=off;
	XTALOSC24M_MISC0_TOG_STOP_MODE_CONFIG_STOP_MODE_CONFIG_1 = 0x1
	// XtalOsc=off, RCOsc=on, Old BG=on, New BG=off.
	XTALOSC24M_MISC0_TOG_STOP_MODE_CONFIG_STOP_MODE_CONFIG_2 = 0x2
	// XtalOsc=off, RCOsc=on, Old BG=off, New BG=on.
	XTALOSC24M_MISC0_TOG_STOP_MODE_CONFIG_STOP_MODE_CONFIG_3 = 0x3
	// Position of DISCON_HIGH_SNVS field.
	XTALOSC24M_MISC0_TOG_DISCON_HIGH_SNVS_Pos = 0xc
	// Bit mask of DISCON_HIGH_SNVS field.
	XTALOSC24M_MISC0_TOG_DISCON_HIGH_SNVS_Msk = 0x1000
	// Bit DISCON_HIGH_SNVS.
	XTALOSC24M_MISC0_TOG_DISCON_HIGH_SNVS = 0x1000
	// Turn on the switch
	XTALOSC24M_MISC0_TOG_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_0 = 0x0
	// Turn off the switch
	XTALOSC24M_MISC0_TOG_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_1 = 0x1
	// Position of OSC_I field.
	XTALOSC24M_MISC0_TOG_OSC_I_Pos = 0xd
	// Bit mask of OSC_I field.
	XTALOSC24M_MISC0_TOG_OSC_I_Msk = 0x6000
	// Nominal
	XTALOSC24M_MISC0_TOG_OSC_I_NOMINAL = 0x0
	// Decrease current by 12.5%
	XTALOSC24M_MISC0_TOG_OSC_I_MINUS_12_5_PERCENT = 0x1
	// Decrease current by 25.0%
	XTALOSC24M_MISC0_TOG_OSC_I_MINUS_25_PERCENT = 0x2
	// Decrease current by 37.5%
	XTALOSC24M_MISC0_TOG_OSC_I_MINUS_37_5_PERCENT = 0x3
	// Position of OSC_XTALOK field.
	XTALOSC24M_MISC0_TOG_OSC_XTALOK_Pos = 0xf
	// Bit mask of OSC_XTALOK field.
	XTALOSC24M_MISC0_TOG_OSC_XTALOK_Msk = 0x8000
	// Bit OSC_XTALOK.
	XTALOSC24M_MISC0_TOG_OSC_XTALOK = 0x8000
	// Position of OSC_XTALOK_EN field.
	XTALOSC24M_MISC0_TOG_OSC_XTALOK_EN_Pos = 0x10
	// Bit mask of OSC_XTALOK_EN field.
	XTALOSC24M_MISC0_TOG_OSC_XTALOK_EN_Msk = 0x10000
	// Bit OSC_XTALOK_EN.
	XTALOSC24M_MISC0_TOG_OSC_XTALOK_EN = 0x10000
	// Position of CLKGATE_CTRL field.
	XTALOSC24M_MISC0_TOG_CLKGATE_CTRL_Pos = 0x19
	// Bit mask of CLKGATE_CTRL field.
	XTALOSC24M_MISC0_TOG_CLKGATE_CTRL_Msk = 0x2000000
	// Bit CLKGATE_CTRL.
	XTALOSC24M_MISC0_TOG_CLKGATE_CTRL = 0x2000000
	// Allow the logic to automatically gate the clock when the XTAL is powered down.
	XTALOSC24M_MISC0_TOG_CLKGATE_CTRL_ALLOW_AUTO_GATE = 0x0
	// Prevent the logic from ever gating off the clock.
	XTALOSC24M_MISC0_TOG_CLKGATE_CTRL_NO_AUTO_GATE = 0x1
	// Position of CLKGATE_DELAY field.
	XTALOSC24M_MISC0_TOG_CLKGATE_DELAY_Pos = 0x1a
	// Bit mask of CLKGATE_DELAY field.
	XTALOSC24M_MISC0_TOG_CLKGATE_DELAY_Msk = 0x1c000000
	// 0.5ms
	XTALOSC24M_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_0 = 0x0
	// 1.0ms
	XTALOSC24M_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_1 = 0x1
	// 2.0ms
	XTALOSC24M_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_2 = 0x2
	// 3.0ms
	XTALOSC24M_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_3 = 0x3
	// 4.0ms
	XTALOSC24M_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_4 = 0x4
	// 5.0ms
	XTALOSC24M_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_5 = 0x5
	// 6.0ms
	XTALOSC24M_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_6 = 0x6
	// 7.0ms
	XTALOSC24M_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_7 = 0x7
	// Position of RTC_XTAL_SOURCE field.
	XTALOSC24M_MISC0_TOG_RTC_XTAL_SOURCE_Pos = 0x1d
	// Bit mask of RTC_XTAL_SOURCE field.
	XTALOSC24M_MISC0_TOG_RTC_XTAL_SOURCE_Msk = 0x20000000
	// Bit RTC_XTAL_SOURCE.
	XTALOSC24M_MISC0_TOG_RTC_XTAL_SOURCE = 0x20000000
	// Internal ring oscillator
	XTALOSC24M_MISC0_TOG_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_0 = 0x0
	// RTC_XTAL
	XTALOSC24M_MISC0_TOG_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_1 = 0x1
	// Position of XTAL_24M_PWD field.
	XTALOSC24M_MISC0_TOG_XTAL_24M_PWD_Pos = 0x1e
	// Bit mask of XTAL_24M_PWD field.
	XTALOSC24M_MISC0_TOG_XTAL_24M_PWD_Msk = 0x40000000
	// Bit XTAL_24M_PWD.
	XTALOSC24M_MISC0_TOG_XTAL_24M_PWD = 0x40000000
	// Position of VID_PLL_PREDIV field.
	XTALOSC24M_MISC0_TOG_VID_PLL_PREDIV_Pos = 0x1f
	// Bit mask of VID_PLL_PREDIV field.
	XTALOSC24M_MISC0_TOG_VID_PLL_PREDIV_Msk = 0x80000000
	// Bit VID_PLL_PREDIV.
	XTALOSC24M_MISC0_TOG_VID_PLL_PREDIV = 0x80000000
	// Divide by 1
	XTALOSC24M_MISC0_TOG_VID_PLL_PREDIV_VID_PLL_PREDIV_0 = 0x0
	// Divide by 2
	XTALOSC24M_MISC0_TOG_VID_PLL_PREDIV_VID_PLL_PREDIV_1 = 0x1

	// LOWPWR_CTRL: XTAL OSC (LP) Control Register
	// Position of RC_OSC_EN field.
	XTALOSC24M_LOWPWR_CTRL_RC_OSC_EN_Pos = 0x0
	// Bit mask of RC_OSC_EN field.
	XTALOSC24M_LOWPWR_CTRL_RC_OSC_EN_Msk = 0x1
	// Bit RC_OSC_EN.
	XTALOSC24M_LOWPWR_CTRL_RC_OSC_EN = 0x1
	// Use XTAL OSC to source the 24MHz clock
	XTALOSC24M_LOWPWR_CTRL_RC_OSC_EN_RC_OSC_EN_0 = 0x0
	// Use RC OSC
	XTALOSC24M_LOWPWR_CTRL_RC_OSC_EN_RC_OSC_EN_1 = 0x1
	// Position of OSC_SEL field.
	XTALOSC24M_LOWPWR_CTRL_OSC_SEL_Pos = 0x4
	// Bit mask of OSC_SEL field.
	XTALOSC24M_LOWPWR_CTRL_OSC_SEL_Msk = 0x10
	// Bit OSC_SEL.
	XTALOSC24M_LOWPWR_CTRL_OSC_SEL = 0x10
	// XTAL OSC
	XTALOSC24M_LOWPWR_CTRL_OSC_SEL_OSC_SEL_0 = 0x0
	// RC OSC
	XTALOSC24M_LOWPWR_CTRL_OSC_SEL_OSC_SEL_1 = 0x1
	// Position of LPBG_SEL field.
	XTALOSC24M_LOWPWR_CTRL_LPBG_SEL_Pos = 0x5
	// Bit mask of LPBG_SEL field.
	XTALOSC24M_LOWPWR_CTRL_LPBG_SEL_Msk = 0x20
	// Bit LPBG_SEL.
	XTALOSC24M_LOWPWR_CTRL_LPBG_SEL = 0x20
	// Normal power bandgap
	XTALOSC24M_LOWPWR_CTRL_LPBG_SEL_LPBG_SEL_0 = 0x0
	// Low power bandgap
	XTALOSC24M_LOWPWR_CTRL_LPBG_SEL_LPBG_SEL_1 = 0x1
	// Position of LPBG_TEST field.
	XTALOSC24M_LOWPWR_CTRL_LPBG_TEST_Pos = 0x6
	// Bit mask of LPBG_TEST field.
	XTALOSC24M_LOWPWR_CTRL_LPBG_TEST_Msk = 0x40
	// Bit LPBG_TEST.
	XTALOSC24M_LOWPWR_CTRL_LPBG_TEST = 0x40
	// Position of REFTOP_IBIAS_OFF field.
	XTALOSC24M_LOWPWR_CTRL_REFTOP_IBIAS_OFF_Pos = 0x7
	// Bit mask of REFTOP_IBIAS_OFF field.
	XTALOSC24M_LOWPWR_CTRL_REFTOP_IBIAS_OFF_Msk = 0x80
	// Bit REFTOP_IBIAS_OFF.
	XTALOSC24M_LOWPWR_CTRL_REFTOP_IBIAS_OFF = 0x80
	// Position of L1_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_L1_PWRGATE_Pos = 0x8
	// Bit mask of L1_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_L1_PWRGATE_Msk = 0x100
	// Bit L1_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_L1_PWRGATE = 0x100
	// Position of L2_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_L2_PWRGATE_Pos = 0x9
	// Bit mask of L2_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_L2_PWRGATE_Msk = 0x200
	// Bit L2_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_L2_PWRGATE = 0x200
	// Position of CPU_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_CPU_PWRGATE_Pos = 0xa
	// Bit mask of CPU_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_CPU_PWRGATE_Msk = 0x400
	// Bit CPU_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_CPU_PWRGATE = 0x400
	// Position of DISPLAY_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_DISPLAY_PWRGATE_Pos = 0xb
	// Bit mask of DISPLAY_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_DISPLAY_PWRGATE_Msk = 0x800
	// Bit DISPLAY_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_DISPLAY_PWRGATE = 0x800
	// Position of RCOSC_CG_OVERRIDE field.
	XTALOSC24M_LOWPWR_CTRL_RCOSC_CG_OVERRIDE_Pos = 0xd
	// Bit mask of RCOSC_CG_OVERRIDE field.
	XTALOSC24M_LOWPWR_CTRL_RCOSC_CG_OVERRIDE_Msk = 0x2000
	// Bit RCOSC_CG_OVERRIDE.
	XTALOSC24M_LOWPWR_CTRL_RCOSC_CG_OVERRIDE = 0x2000
	// Position of XTALOSC_PWRUP_DELAY field.
	XTALOSC24M_LOWPWR_CTRL_XTALOSC_PWRUP_DELAY_Pos = 0xe
	// Bit mask of XTALOSC_PWRUP_DELAY field.
	XTALOSC24M_LOWPWR_CTRL_XTALOSC_PWRUP_DELAY_Msk = 0xc000
	// 0.25ms
	XTALOSC24M_LOWPWR_CTRL_XTALOSC_PWRUP_DELAY_XTALOSC_PWRUP_DELAY_0 = 0x0
	// 0.5ms
	XTALOSC24M_LOWPWR_CTRL_XTALOSC_PWRUP_DELAY_XTALOSC_PWRUP_DELAY_1 = 0x1
	// 1ms
	XTALOSC24M_LOWPWR_CTRL_XTALOSC_PWRUP_DELAY_XTALOSC_PWRUP_DELAY_2 = 0x2
	// 2ms
	XTALOSC24M_LOWPWR_CTRL_XTALOSC_PWRUP_DELAY_XTALOSC_PWRUP_DELAY_3 = 0x3
	// Position of XTALOSC_PWRUP_STAT field.
	XTALOSC24M_LOWPWR_CTRL_XTALOSC_PWRUP_STAT_Pos = 0x10
	// Bit mask of XTALOSC_PWRUP_STAT field.
	XTALOSC24M_LOWPWR_CTRL_XTALOSC_PWRUP_STAT_Msk = 0x10000
	// Bit XTALOSC_PWRUP_STAT.
	XTALOSC24M_LOWPWR_CTRL_XTALOSC_PWRUP_STAT = 0x10000
	// Not stable
	XTALOSC24M_LOWPWR_CTRL_XTALOSC_PWRUP_STAT_XTALOSC_PWRUP_STAT_0 = 0x0
	// Stable and ready to use
	XTALOSC24M_LOWPWR_CTRL_XTALOSC_PWRUP_STAT_XTALOSC_PWRUP_STAT_1 = 0x1
	// Position of MIX_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_MIX_PWRGATE_Pos = 0x11
	// Bit mask of MIX_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_MIX_PWRGATE_Msk = 0x20000
	// Bit MIX_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_MIX_PWRGATE = 0x20000
	// Position of GPU_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_GPU_PWRGATE_Pos = 0x12
	// Bit mask of GPU_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_GPU_PWRGATE_Msk = 0x40000
	// Bit GPU_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_GPU_PWRGATE = 0x40000

	// LOWPWR_CTRL_SET: XTAL OSC (LP) Control Register
	// Position of RC_OSC_EN field.
	XTALOSC24M_LOWPWR_CTRL_SET_RC_OSC_EN_Pos = 0x0
	// Bit mask of RC_OSC_EN field.
	XTALOSC24M_LOWPWR_CTRL_SET_RC_OSC_EN_Msk = 0x1
	// Bit RC_OSC_EN.
	XTALOSC24M_LOWPWR_CTRL_SET_RC_OSC_EN = 0x1
	// Use XTAL OSC to source the 24MHz clock
	XTALOSC24M_LOWPWR_CTRL_SET_RC_OSC_EN_RC_OSC_EN_0 = 0x0
	// Use RC OSC
	XTALOSC24M_LOWPWR_CTRL_SET_RC_OSC_EN_RC_OSC_EN_1 = 0x1
	// Position of OSC_SEL field.
	XTALOSC24M_LOWPWR_CTRL_SET_OSC_SEL_Pos = 0x4
	// Bit mask of OSC_SEL field.
	XTALOSC24M_LOWPWR_CTRL_SET_OSC_SEL_Msk = 0x10
	// Bit OSC_SEL.
	XTALOSC24M_LOWPWR_CTRL_SET_OSC_SEL = 0x10
	// XTAL OSC
	XTALOSC24M_LOWPWR_CTRL_SET_OSC_SEL_OSC_SEL_0 = 0x0
	// RC OSC
	XTALOSC24M_LOWPWR_CTRL_SET_OSC_SEL_OSC_SEL_1 = 0x1
	// Position of LPBG_SEL field.
	XTALOSC24M_LOWPWR_CTRL_SET_LPBG_SEL_Pos = 0x5
	// Bit mask of LPBG_SEL field.
	XTALOSC24M_LOWPWR_CTRL_SET_LPBG_SEL_Msk = 0x20
	// Bit LPBG_SEL.
	XTALOSC24M_LOWPWR_CTRL_SET_LPBG_SEL = 0x20
	// Normal power bandgap
	XTALOSC24M_LOWPWR_CTRL_SET_LPBG_SEL_LPBG_SEL_0 = 0x0
	// Low power bandgap
	XTALOSC24M_LOWPWR_CTRL_SET_LPBG_SEL_LPBG_SEL_1 = 0x1
	// Position of LPBG_TEST field.
	XTALOSC24M_LOWPWR_CTRL_SET_LPBG_TEST_Pos = 0x6
	// Bit mask of LPBG_TEST field.
	XTALOSC24M_LOWPWR_CTRL_SET_LPBG_TEST_Msk = 0x40
	// Bit LPBG_TEST.
	XTALOSC24M_LOWPWR_CTRL_SET_LPBG_TEST = 0x40
	// Position of REFTOP_IBIAS_OFF field.
	XTALOSC24M_LOWPWR_CTRL_SET_REFTOP_IBIAS_OFF_Pos = 0x7
	// Bit mask of REFTOP_IBIAS_OFF field.
	XTALOSC24M_LOWPWR_CTRL_SET_REFTOP_IBIAS_OFF_Msk = 0x80
	// Bit REFTOP_IBIAS_OFF.
	XTALOSC24M_LOWPWR_CTRL_SET_REFTOP_IBIAS_OFF = 0x80
	// Position of L1_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_SET_L1_PWRGATE_Pos = 0x8
	// Bit mask of L1_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_SET_L1_PWRGATE_Msk = 0x100
	// Bit L1_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_SET_L1_PWRGATE = 0x100
	// Position of L2_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_SET_L2_PWRGATE_Pos = 0x9
	// Bit mask of L2_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_SET_L2_PWRGATE_Msk = 0x200
	// Bit L2_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_SET_L2_PWRGATE = 0x200
	// Position of CPU_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_SET_CPU_PWRGATE_Pos = 0xa
	// Bit mask of CPU_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_SET_CPU_PWRGATE_Msk = 0x400
	// Bit CPU_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_SET_CPU_PWRGATE = 0x400
	// Position of DISPLAY_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_SET_DISPLAY_PWRGATE_Pos = 0xb
	// Bit mask of DISPLAY_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_SET_DISPLAY_PWRGATE_Msk = 0x800
	// Bit DISPLAY_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_SET_DISPLAY_PWRGATE = 0x800
	// Position of RCOSC_CG_OVERRIDE field.
	XTALOSC24M_LOWPWR_CTRL_SET_RCOSC_CG_OVERRIDE_Pos = 0xd
	// Bit mask of RCOSC_CG_OVERRIDE field.
	XTALOSC24M_LOWPWR_CTRL_SET_RCOSC_CG_OVERRIDE_Msk = 0x2000
	// Bit RCOSC_CG_OVERRIDE.
	XTALOSC24M_LOWPWR_CTRL_SET_RCOSC_CG_OVERRIDE = 0x2000
	// Position of XTALOSC_PWRUP_DELAY field.
	XTALOSC24M_LOWPWR_CTRL_SET_XTALOSC_PWRUP_DELAY_Pos = 0xe
	// Bit mask of XTALOSC_PWRUP_DELAY field.
	XTALOSC24M_LOWPWR_CTRL_SET_XTALOSC_PWRUP_DELAY_Msk = 0xc000
	// 0.25ms
	XTALOSC24M_LOWPWR_CTRL_SET_XTALOSC_PWRUP_DELAY_XTALOSC_PWRUP_DELAY_0 = 0x0
	// 0.5ms
	XTALOSC24M_LOWPWR_CTRL_SET_XTALOSC_PWRUP_DELAY_XTALOSC_PWRUP_DELAY_1 = 0x1
	// 1ms
	XTALOSC24M_LOWPWR_CTRL_SET_XTALOSC_PWRUP_DELAY_XTALOSC_PWRUP_DELAY_2 = 0x2
	// 2ms
	XTALOSC24M_LOWPWR_CTRL_SET_XTALOSC_PWRUP_DELAY_XTALOSC_PWRUP_DELAY_3 = 0x3
	// Position of XTALOSC_PWRUP_STAT field.
	XTALOSC24M_LOWPWR_CTRL_SET_XTALOSC_PWRUP_STAT_Pos = 0x10
	// Bit mask of XTALOSC_PWRUP_STAT field.
	XTALOSC24M_LOWPWR_CTRL_SET_XTALOSC_PWRUP_STAT_Msk = 0x10000
	// Bit XTALOSC_PWRUP_STAT.
	XTALOSC24M_LOWPWR_CTRL_SET_XTALOSC_PWRUP_STAT = 0x10000
	// Not stable
	XTALOSC24M_LOWPWR_CTRL_SET_XTALOSC_PWRUP_STAT_XTALOSC_PWRUP_STAT_0 = 0x0
	// Stable and ready to use
	XTALOSC24M_LOWPWR_CTRL_SET_XTALOSC_PWRUP_STAT_XTALOSC_PWRUP_STAT_1 = 0x1
	// Position of MIX_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_SET_MIX_PWRGATE_Pos = 0x11
	// Bit mask of MIX_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_SET_MIX_PWRGATE_Msk = 0x20000
	// Bit MIX_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_SET_MIX_PWRGATE = 0x20000
	// Position of GPU_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_SET_GPU_PWRGATE_Pos = 0x12
	// Bit mask of GPU_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_SET_GPU_PWRGATE_Msk = 0x40000
	// Bit GPU_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_SET_GPU_PWRGATE = 0x40000

	// LOWPWR_CTRL_CLR: XTAL OSC (LP) Control Register
	// Position of RC_OSC_EN field.
	XTALOSC24M_LOWPWR_CTRL_CLR_RC_OSC_EN_Pos = 0x0
	// Bit mask of RC_OSC_EN field.
	XTALOSC24M_LOWPWR_CTRL_CLR_RC_OSC_EN_Msk = 0x1
	// Bit RC_OSC_EN.
	XTALOSC24M_LOWPWR_CTRL_CLR_RC_OSC_EN = 0x1
	// Use XTAL OSC to source the 24MHz clock
	XTALOSC24M_LOWPWR_CTRL_CLR_RC_OSC_EN_RC_OSC_EN_0 = 0x0
	// Use RC OSC
	XTALOSC24M_LOWPWR_CTRL_CLR_RC_OSC_EN_RC_OSC_EN_1 = 0x1
	// Position of OSC_SEL field.
	XTALOSC24M_LOWPWR_CTRL_CLR_OSC_SEL_Pos = 0x4
	// Bit mask of OSC_SEL field.
	XTALOSC24M_LOWPWR_CTRL_CLR_OSC_SEL_Msk = 0x10
	// Bit OSC_SEL.
	XTALOSC24M_LOWPWR_CTRL_CLR_OSC_SEL = 0x10
	// XTAL OSC
	XTALOSC24M_LOWPWR_CTRL_CLR_OSC_SEL_OSC_SEL_0 = 0x0
	// RC OSC
	XTALOSC24M_LOWPWR_CTRL_CLR_OSC_SEL_OSC_SEL_1 = 0x1
	// Position of LPBG_SEL field.
	XTALOSC24M_LOWPWR_CTRL_CLR_LPBG_SEL_Pos = 0x5
	// Bit mask of LPBG_SEL field.
	XTALOSC24M_LOWPWR_CTRL_CLR_LPBG_SEL_Msk = 0x20
	// Bit LPBG_SEL.
	XTALOSC24M_LOWPWR_CTRL_CLR_LPBG_SEL = 0x20
	// Normal power bandgap
	XTALOSC24M_LOWPWR_CTRL_CLR_LPBG_SEL_LPBG_SEL_0 = 0x0
	// Low power bandgap
	XTALOSC24M_LOWPWR_CTRL_CLR_LPBG_SEL_LPBG_SEL_1 = 0x1
	// Position of LPBG_TEST field.
	XTALOSC24M_LOWPWR_CTRL_CLR_LPBG_TEST_Pos = 0x6
	// Bit mask of LPBG_TEST field.
	XTALOSC24M_LOWPWR_CTRL_CLR_LPBG_TEST_Msk = 0x40
	// Bit LPBG_TEST.
	XTALOSC24M_LOWPWR_CTRL_CLR_LPBG_TEST = 0x40
	// Position of REFTOP_IBIAS_OFF field.
	XTALOSC24M_LOWPWR_CTRL_CLR_REFTOP_IBIAS_OFF_Pos = 0x7
	// Bit mask of REFTOP_IBIAS_OFF field.
	XTALOSC24M_LOWPWR_CTRL_CLR_REFTOP_IBIAS_OFF_Msk = 0x80
	// Bit REFTOP_IBIAS_OFF.
	XTALOSC24M_LOWPWR_CTRL_CLR_REFTOP_IBIAS_OFF = 0x80
	// Position of L1_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_CLR_L1_PWRGATE_Pos = 0x8
	// Bit mask of L1_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_CLR_L1_PWRGATE_Msk = 0x100
	// Bit L1_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_CLR_L1_PWRGATE = 0x100
	// Position of L2_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_CLR_L2_PWRGATE_Pos = 0x9
	// Bit mask of L2_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_CLR_L2_PWRGATE_Msk = 0x200
	// Bit L2_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_CLR_L2_PWRGATE = 0x200
	// Position of CPU_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_CLR_CPU_PWRGATE_Pos = 0xa
	// Bit mask of CPU_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_CLR_CPU_PWRGATE_Msk = 0x400
	// Bit CPU_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_CLR_CPU_PWRGATE = 0x400
	// Position of DISPLAY_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_CLR_DISPLAY_PWRGATE_Pos = 0xb
	// Bit mask of DISPLAY_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_CLR_DISPLAY_PWRGATE_Msk = 0x800
	// Bit DISPLAY_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_CLR_DISPLAY_PWRGATE = 0x800
	// Position of RCOSC_CG_OVERRIDE field.
	XTALOSC24M_LOWPWR_CTRL_CLR_RCOSC_CG_OVERRIDE_Pos = 0xd
	// Bit mask of RCOSC_CG_OVERRIDE field.
	XTALOSC24M_LOWPWR_CTRL_CLR_RCOSC_CG_OVERRIDE_Msk = 0x2000
	// Bit RCOSC_CG_OVERRIDE.
	XTALOSC24M_LOWPWR_CTRL_CLR_RCOSC_CG_OVERRIDE = 0x2000
	// Position of XTALOSC_PWRUP_DELAY field.
	XTALOSC24M_LOWPWR_CTRL_CLR_XTALOSC_PWRUP_DELAY_Pos = 0xe
	// Bit mask of XTALOSC_PWRUP_DELAY field.
	XTALOSC24M_LOWPWR_CTRL_CLR_XTALOSC_PWRUP_DELAY_Msk = 0xc000
	// 0.25ms
	XTALOSC24M_LOWPWR_CTRL_CLR_XTALOSC_PWRUP_DELAY_XTALOSC_PWRUP_DELAY_0 = 0x0
	// 0.5ms
	XTALOSC24M_LOWPWR_CTRL_CLR_XTALOSC_PWRUP_DELAY_XTALOSC_PWRUP_DELAY_1 = 0x1
	// 1ms
	XTALOSC24M_LOWPWR_CTRL_CLR_XTALOSC_PWRUP_DELAY_XTALOSC_PWRUP_DELAY_2 = 0x2
	// 2ms
	XTALOSC24M_LOWPWR_CTRL_CLR_XTALOSC_PWRUP_DELAY_XTALOSC_PWRUP_DELAY_3 = 0x3
	// Position of XTALOSC_PWRUP_STAT field.
	XTALOSC24M_LOWPWR_CTRL_CLR_XTALOSC_PWRUP_STAT_Pos = 0x10
	// Bit mask of XTALOSC_PWRUP_STAT field.
	XTALOSC24M_LOWPWR_CTRL_CLR_XTALOSC_PWRUP_STAT_Msk = 0x10000
	// Bit XTALOSC_PWRUP_STAT.
	XTALOSC24M_LOWPWR_CTRL_CLR_XTALOSC_PWRUP_STAT = 0x10000
	// Not stable
	XTALOSC24M_LOWPWR_CTRL_CLR_XTALOSC_PWRUP_STAT_XTALOSC_PWRUP_STAT_0 = 0x0
	// Stable and ready to use
	XTALOSC24M_LOWPWR_CTRL_CLR_XTALOSC_PWRUP_STAT_XTALOSC_PWRUP_STAT_1 = 0x1
	// Position of MIX_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_CLR_MIX_PWRGATE_Pos = 0x11
	// Bit mask of MIX_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_CLR_MIX_PWRGATE_Msk = 0x20000
	// Bit MIX_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_CLR_MIX_PWRGATE = 0x20000
	// Position of GPU_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_CLR_GPU_PWRGATE_Pos = 0x12
	// Bit mask of GPU_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_CLR_GPU_PWRGATE_Msk = 0x40000
	// Bit GPU_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_CLR_GPU_PWRGATE = 0x40000

	// LOWPWR_CTRL_TOG: XTAL OSC (LP) Control Register
	// Position of RC_OSC_EN field.
	XTALOSC24M_LOWPWR_CTRL_TOG_RC_OSC_EN_Pos = 0x0
	// Bit mask of RC_OSC_EN field.
	XTALOSC24M_LOWPWR_CTRL_TOG_RC_OSC_EN_Msk = 0x1
	// Bit RC_OSC_EN.
	XTALOSC24M_LOWPWR_CTRL_TOG_RC_OSC_EN = 0x1
	// Use XTAL OSC to source the 24MHz clock
	XTALOSC24M_LOWPWR_CTRL_TOG_RC_OSC_EN_RC_OSC_EN_0 = 0x0
	// Use RC OSC
	XTALOSC24M_LOWPWR_CTRL_TOG_RC_OSC_EN_RC_OSC_EN_1 = 0x1
	// Position of OSC_SEL field.
	XTALOSC24M_LOWPWR_CTRL_TOG_OSC_SEL_Pos = 0x4
	// Bit mask of OSC_SEL field.
	XTALOSC24M_LOWPWR_CTRL_TOG_OSC_SEL_Msk = 0x10
	// Bit OSC_SEL.
	XTALOSC24M_LOWPWR_CTRL_TOG_OSC_SEL = 0x10
	// XTAL OSC
	XTALOSC24M_LOWPWR_CTRL_TOG_OSC_SEL_OSC_SEL_0 = 0x0
	// RC OSC
	XTALOSC24M_LOWPWR_CTRL_TOG_OSC_SEL_OSC_SEL_1 = 0x1
	// Position of LPBG_SEL field.
	XTALOSC24M_LOWPWR_CTRL_TOG_LPBG_SEL_Pos = 0x5
	// Bit mask of LPBG_SEL field.
	XTALOSC24M_LOWPWR_CTRL_TOG_LPBG_SEL_Msk = 0x20
	// Bit LPBG_SEL.
	XTALOSC24M_LOWPWR_CTRL_TOG_LPBG_SEL = 0x20
	// Normal power bandgap
	XTALOSC24M_LOWPWR_CTRL_TOG_LPBG_SEL_LPBG_SEL_0 = 0x0
	// Low power bandgap
	XTALOSC24M_LOWPWR_CTRL_TOG_LPBG_SEL_LPBG_SEL_1 = 0x1
	// Position of LPBG_TEST field.
	XTALOSC24M_LOWPWR_CTRL_TOG_LPBG_TEST_Pos = 0x6
	// Bit mask of LPBG_TEST field.
	XTALOSC24M_LOWPWR_CTRL_TOG_LPBG_TEST_Msk = 0x40
	// Bit LPBG_TEST.
	XTALOSC24M_LOWPWR_CTRL_TOG_LPBG_TEST = 0x40
	// Position of REFTOP_IBIAS_OFF field.
	XTALOSC24M_LOWPWR_CTRL_TOG_REFTOP_IBIAS_OFF_Pos = 0x7
	// Bit mask of REFTOP_IBIAS_OFF field.
	XTALOSC24M_LOWPWR_CTRL_TOG_REFTOP_IBIAS_OFF_Msk = 0x80
	// Bit REFTOP_IBIAS_OFF.
	XTALOSC24M_LOWPWR_CTRL_TOG_REFTOP_IBIAS_OFF = 0x80
	// Position of L1_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_TOG_L1_PWRGATE_Pos = 0x8
	// Bit mask of L1_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_TOG_L1_PWRGATE_Msk = 0x100
	// Bit L1_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_TOG_L1_PWRGATE = 0x100
	// Position of L2_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_TOG_L2_PWRGATE_Pos = 0x9
	// Bit mask of L2_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_TOG_L2_PWRGATE_Msk = 0x200
	// Bit L2_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_TOG_L2_PWRGATE = 0x200
	// Position of CPU_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_TOG_CPU_PWRGATE_Pos = 0xa
	// Bit mask of CPU_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_TOG_CPU_PWRGATE_Msk = 0x400
	// Bit CPU_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_TOG_CPU_PWRGATE = 0x400
	// Position of DISPLAY_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_TOG_DISPLAY_PWRGATE_Pos = 0xb
	// Bit mask of DISPLAY_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_TOG_DISPLAY_PWRGATE_Msk = 0x800
	// Bit DISPLAY_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_TOG_DISPLAY_PWRGATE = 0x800
	// Position of RCOSC_CG_OVERRIDE field.
	XTALOSC24M_LOWPWR_CTRL_TOG_RCOSC_CG_OVERRIDE_Pos = 0xd
	// Bit mask of RCOSC_CG_OVERRIDE field.
	XTALOSC24M_LOWPWR_CTRL_TOG_RCOSC_CG_OVERRIDE_Msk = 0x2000
	// Bit RCOSC_CG_OVERRIDE.
	XTALOSC24M_LOWPWR_CTRL_TOG_RCOSC_CG_OVERRIDE = 0x2000
	// Position of XTALOSC_PWRUP_DELAY field.
	XTALOSC24M_LOWPWR_CTRL_TOG_XTALOSC_PWRUP_DELAY_Pos = 0xe
	// Bit mask of XTALOSC_PWRUP_DELAY field.
	XTALOSC24M_LOWPWR_CTRL_TOG_XTALOSC_PWRUP_DELAY_Msk = 0xc000
	// 0.25ms
	XTALOSC24M_LOWPWR_CTRL_TOG_XTALOSC_PWRUP_DELAY_XTALOSC_PWRUP_DELAY_0 = 0x0
	// 0.5ms
	XTALOSC24M_LOWPWR_CTRL_TOG_XTALOSC_PWRUP_DELAY_XTALOSC_PWRUP_DELAY_1 = 0x1
	// 1ms
	XTALOSC24M_LOWPWR_CTRL_TOG_XTALOSC_PWRUP_DELAY_XTALOSC_PWRUP_DELAY_2 = 0x2
	// 2ms
	XTALOSC24M_LOWPWR_CTRL_TOG_XTALOSC_PWRUP_DELAY_XTALOSC_PWRUP_DELAY_3 = 0x3
	// Position of XTALOSC_PWRUP_STAT field.
	XTALOSC24M_LOWPWR_CTRL_TOG_XTALOSC_PWRUP_STAT_Pos = 0x10
	// Bit mask of XTALOSC_PWRUP_STAT field.
	XTALOSC24M_LOWPWR_CTRL_TOG_XTALOSC_PWRUP_STAT_Msk = 0x10000
	// Bit XTALOSC_PWRUP_STAT.
	XTALOSC24M_LOWPWR_CTRL_TOG_XTALOSC_PWRUP_STAT = 0x10000
	// Not stable
	XTALOSC24M_LOWPWR_CTRL_TOG_XTALOSC_PWRUP_STAT_XTALOSC_PWRUP_STAT_0 = 0x0
	// Stable and ready to use
	XTALOSC24M_LOWPWR_CTRL_TOG_XTALOSC_PWRUP_STAT_XTALOSC_PWRUP_STAT_1 = 0x1
	// Position of MIX_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_TOG_MIX_PWRGATE_Pos = 0x11
	// Bit mask of MIX_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_TOG_MIX_PWRGATE_Msk = 0x20000
	// Bit MIX_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_TOG_MIX_PWRGATE = 0x20000
	// Position of GPU_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_TOG_GPU_PWRGATE_Pos = 0x12
	// Bit mask of GPU_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_TOG_GPU_PWRGATE_Msk = 0x40000
	// Bit GPU_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_TOG_GPU_PWRGATE = 0x40000

	// OSC_CONFIG0: XTAL OSC Configuration 0 Register
	// Position of START field.
	XTALOSC24M_OSC_CONFIG0_START_Pos = 0x0
	// Bit mask of START field.
	XTALOSC24M_OSC_CONFIG0_START_Msk = 0x1
	// Bit START.
	XTALOSC24M_OSC_CONFIG0_START = 0x1
	// Position of ENABLE field.
	XTALOSC24M_OSC_CONFIG0_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	XTALOSC24M_OSC_CONFIG0_ENABLE_Msk = 0x2
	// Bit ENABLE.
	XTALOSC24M_OSC_CONFIG0_ENABLE = 0x2
	// Position of BYPASS field.
	XTALOSC24M_OSC_CONFIG0_BYPASS_Pos = 0x2
	// Bit mask of BYPASS field.
	XTALOSC24M_OSC_CONFIG0_BYPASS_Msk = 0x4
	// Bit BYPASS.
	XTALOSC24M_OSC_CONFIG0_BYPASS = 0x4
	// Position of INVERT field.
	XTALOSC24M_OSC_CONFIG0_INVERT_Pos = 0x3
	// Bit mask of INVERT field.
	XTALOSC24M_OSC_CONFIG0_INVERT_Msk = 0x8
	// Bit INVERT.
	XTALOSC24M_OSC_CONFIG0_INVERT = 0x8
	// Position of RC_OSC_PROG field.
	XTALOSC24M_OSC_CONFIG0_RC_OSC_PROG_Pos = 0x4
	// Bit mask of RC_OSC_PROG field.
	XTALOSC24M_OSC_CONFIG0_RC_OSC_PROG_Msk = 0xff0
	// Position of HYST_PLUS field.
	XTALOSC24M_OSC_CONFIG0_HYST_PLUS_Pos = 0xc
	// Bit mask of HYST_PLUS field.
	XTALOSC24M_OSC_CONFIG0_HYST_PLUS_Msk = 0xf000
	// Position of HYST_MINUS field.
	XTALOSC24M_OSC_CONFIG0_HYST_MINUS_Pos = 0x10
	// Bit mask of HYST_MINUS field.
	XTALOSC24M_OSC_CONFIG0_HYST_MINUS_Msk = 0xf0000
	// Position of RC_OSC_PROG_CUR field.
	XTALOSC24M_OSC_CONFIG0_RC_OSC_PROG_CUR_Pos = 0x18
	// Bit mask of RC_OSC_PROG_CUR field.
	XTALOSC24M_OSC_CONFIG0_RC_OSC_PROG_CUR_Msk = 0xff000000

	// OSC_CONFIG0_SET: XTAL OSC Configuration 0 Register
	// Position of START field.
	XTALOSC24M_OSC_CONFIG0_SET_START_Pos = 0x0
	// Bit mask of START field.
	XTALOSC24M_OSC_CONFIG0_SET_START_Msk = 0x1
	// Bit START.
	XTALOSC24M_OSC_CONFIG0_SET_START = 0x1
	// Position of ENABLE field.
	XTALOSC24M_OSC_CONFIG0_SET_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	XTALOSC24M_OSC_CONFIG0_SET_ENABLE_Msk = 0x2
	// Bit ENABLE.
	XTALOSC24M_OSC_CONFIG0_SET_ENABLE = 0x2
	// Position of BYPASS field.
	XTALOSC24M_OSC_CONFIG0_SET_BYPASS_Pos = 0x2
	// Bit mask of BYPASS field.
	XTALOSC24M_OSC_CONFIG0_SET_BYPASS_Msk = 0x4
	// Bit BYPASS.
	XTALOSC24M_OSC_CONFIG0_SET_BYPASS = 0x4
	// Position of INVERT field.
	XTALOSC24M_OSC_CONFIG0_SET_INVERT_Pos = 0x3
	// Bit mask of INVERT field.
	XTALOSC24M_OSC_CONFIG0_SET_INVERT_Msk = 0x8
	// Bit INVERT.
	XTALOSC24M_OSC_CONFIG0_SET_INVERT = 0x8
	// Position of RC_OSC_PROG field.
	XTALOSC24M_OSC_CONFIG0_SET_RC_OSC_PROG_Pos = 0x4
	// Bit mask of RC_OSC_PROG field.
	XTALOSC24M_OSC_CONFIG0_SET_RC_OSC_PROG_Msk = 0xff0
	// Position of HYST_PLUS field.
	XTALOSC24M_OSC_CONFIG0_SET_HYST_PLUS_Pos = 0xc
	// Bit mask of HYST_PLUS field.
	XTALOSC24M_OSC_CONFIG0_SET_HYST_PLUS_Msk = 0xf000
	// Position of HYST_MINUS field.
	XTALOSC24M_OSC_CONFIG0_SET_HYST_MINUS_Pos = 0x10
	// Bit mask of HYST_MINUS field.
	XTALOSC24M_OSC_CONFIG0_SET_HYST_MINUS_Msk = 0xf0000
	// Position of RC_OSC_PROG_CUR field.
	XTALOSC24M_OSC_CONFIG0_SET_RC_OSC_PROG_CUR_Pos = 0x18
	// Bit mask of RC_OSC_PROG_CUR field.
	XTALOSC24M_OSC_CONFIG0_SET_RC_OSC_PROG_CUR_Msk = 0xff000000

	// OSC_CONFIG0_CLR: XTAL OSC Configuration 0 Register
	// Position of START field.
	XTALOSC24M_OSC_CONFIG0_CLR_START_Pos = 0x0
	// Bit mask of START field.
	XTALOSC24M_OSC_CONFIG0_CLR_START_Msk = 0x1
	// Bit START.
	XTALOSC24M_OSC_CONFIG0_CLR_START = 0x1
	// Position of ENABLE field.
	XTALOSC24M_OSC_CONFIG0_CLR_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	XTALOSC24M_OSC_CONFIG0_CLR_ENABLE_Msk = 0x2
	// Bit ENABLE.
	XTALOSC24M_OSC_CONFIG0_CLR_ENABLE = 0x2
	// Position of BYPASS field.
	XTALOSC24M_OSC_CONFIG0_CLR_BYPASS_Pos = 0x2
	// Bit mask of BYPASS field.
	XTALOSC24M_OSC_CONFIG0_CLR_BYPASS_Msk = 0x4
	// Bit BYPASS.
	XTALOSC24M_OSC_CONFIG0_CLR_BYPASS = 0x4
	// Position of INVERT field.
	XTALOSC24M_OSC_CONFIG0_CLR_INVERT_Pos = 0x3
	// Bit mask of INVERT field.
	XTALOSC24M_OSC_CONFIG0_CLR_INVERT_Msk = 0x8
	// Bit INVERT.
	XTALOSC24M_OSC_CONFIG0_CLR_INVERT = 0x8
	// Position of RC_OSC_PROG field.
	XTALOSC24M_OSC_CONFIG0_CLR_RC_OSC_PROG_Pos = 0x4
	// Bit mask of RC_OSC_PROG field.
	XTALOSC24M_OSC_CONFIG0_CLR_RC_OSC_PROG_Msk = 0xff0
	// Position of HYST_PLUS field.
	XTALOSC24M_OSC_CONFIG0_CLR_HYST_PLUS_Pos = 0xc
	// Bit mask of HYST_PLUS field.
	XTALOSC24M_OSC_CONFIG0_CLR_HYST_PLUS_Msk = 0xf000
	// Position of HYST_MINUS field.
	XTALOSC24M_OSC_CONFIG0_CLR_HYST_MINUS_Pos = 0x10
	// Bit mask of HYST_MINUS field.
	XTALOSC24M_OSC_CONFIG0_CLR_HYST_MINUS_Msk = 0xf0000
	// Position of RC_OSC_PROG_CUR field.
	XTALOSC24M_OSC_CONFIG0_CLR_RC_OSC_PROG_CUR_Pos = 0x18
	// Bit mask of RC_OSC_PROG_CUR field.
	XTALOSC24M_OSC_CONFIG0_CLR_RC_OSC_PROG_CUR_Msk = 0xff000000

	// OSC_CONFIG0_TOG: XTAL OSC Configuration 0 Register
	// Position of START field.
	XTALOSC24M_OSC_CONFIG0_TOG_START_Pos = 0x0
	// Bit mask of START field.
	XTALOSC24M_OSC_CONFIG0_TOG_START_Msk = 0x1
	// Bit START.
	XTALOSC24M_OSC_CONFIG0_TOG_START = 0x1
	// Position of ENABLE field.
	XTALOSC24M_OSC_CONFIG0_TOG_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	XTALOSC24M_OSC_CONFIG0_TOG_ENABLE_Msk = 0x2
	// Bit ENABLE.
	XTALOSC24M_OSC_CONFIG0_TOG_ENABLE = 0x2
	// Position of BYPASS field.
	XTALOSC24M_OSC_CONFIG0_TOG_BYPASS_Pos = 0x2
	// Bit mask of BYPASS field.
	XTALOSC24M_OSC_CONFIG0_TOG_BYPASS_Msk = 0x4
	// Bit BYPASS.
	XTALOSC24M_OSC_CONFIG0_TOG_BYPASS = 0x4
	// Position of INVERT field.
	XTALOSC24M_OSC_CONFIG0_TOG_INVERT_Pos = 0x3
	// Bit mask of INVERT field.
	XTALOSC24M_OSC_CONFIG0_TOG_INVERT_Msk = 0x8
	// Bit INVERT.
	XTALOSC24M_OSC_CONFIG0_TOG_INVERT = 0x8
	// Position of RC_OSC_PROG field.
	XTALOSC24M_OSC_CONFIG0_TOG_RC_OSC_PROG_Pos = 0x4
	// Bit mask of RC_OSC_PROG field.
	XTALOSC24M_OSC_CONFIG0_TOG_RC_OSC_PROG_Msk = 0xff0
	// Position of HYST_PLUS field.
	XTALOSC24M_OSC_CONFIG0_TOG_HYST_PLUS_Pos = 0xc
	// Bit mask of HYST_PLUS field.
	XTALOSC24M_OSC_CONFIG0_TOG_HYST_PLUS_Msk = 0xf000
	// Position of HYST_MINUS field.
	XTALOSC24M_OSC_CONFIG0_TOG_HYST_MINUS_Pos = 0x10
	// Bit mask of HYST_MINUS field.
	XTALOSC24M_OSC_CONFIG0_TOG_HYST_MINUS_Msk = 0xf0000
	// Position of RC_OSC_PROG_CUR field.
	XTALOSC24M_OSC_CONFIG0_TOG_RC_OSC_PROG_CUR_Pos = 0x18
	// Bit mask of RC_OSC_PROG_CUR field.
	XTALOSC24M_OSC_CONFIG0_TOG_RC_OSC_PROG_CUR_Msk = 0xff000000

	// OSC_CONFIG1: XTAL OSC Configuration 1 Register
	// Position of COUNT_RC_TRG field.
	XTALOSC24M_OSC_CONFIG1_COUNT_RC_TRG_Pos = 0x0
	// Bit mask of COUNT_RC_TRG field.
	XTALOSC24M_OSC_CONFIG1_COUNT_RC_TRG_Msk = 0xfff
	// Position of COUNT_RC_CUR field.
	XTALOSC24M_OSC_CONFIG1_COUNT_RC_CUR_Pos = 0x14
	// Bit mask of COUNT_RC_CUR field.
	XTALOSC24M_OSC_CONFIG1_COUNT_RC_CUR_Msk = 0xfff00000

	// OSC_CONFIG1_SET: XTAL OSC Configuration 1 Register
	// Position of COUNT_RC_TRG field.
	XTALOSC24M_OSC_CONFIG1_SET_COUNT_RC_TRG_Pos = 0x0
	// Bit mask of COUNT_RC_TRG field.
	XTALOSC24M_OSC_CONFIG1_SET_COUNT_RC_TRG_Msk = 0xfff
	// Position of COUNT_RC_CUR field.
	XTALOSC24M_OSC_CONFIG1_SET_COUNT_RC_CUR_Pos = 0x14
	// Bit mask of COUNT_RC_CUR field.
	XTALOSC24M_OSC_CONFIG1_SET_COUNT_RC_CUR_Msk = 0xfff00000

	// OSC_CONFIG1_CLR: XTAL OSC Configuration 1 Register
	// Position of COUNT_RC_TRG field.
	XTALOSC24M_OSC_CONFIG1_CLR_COUNT_RC_TRG_Pos = 0x0
	// Bit mask of COUNT_RC_TRG field.
	XTALOSC24M_OSC_CONFIG1_CLR_COUNT_RC_TRG_Msk = 0xfff
	// Position of COUNT_RC_CUR field.
	XTALOSC24M_OSC_CONFIG1_CLR_COUNT_RC_CUR_Pos = 0x14
	// Bit mask of COUNT_RC_CUR field.
	XTALOSC24M_OSC_CONFIG1_CLR_COUNT_RC_CUR_Msk = 0xfff00000

	// OSC_CONFIG1_TOG: XTAL OSC Configuration 1 Register
	// Position of COUNT_RC_TRG field.
	XTALOSC24M_OSC_CONFIG1_TOG_COUNT_RC_TRG_Pos = 0x0
	// Bit mask of COUNT_RC_TRG field.
	XTALOSC24M_OSC_CONFIG1_TOG_COUNT_RC_TRG_Msk = 0xfff
	// Position of COUNT_RC_CUR field.
	XTALOSC24M_OSC_CONFIG1_TOG_COUNT_RC_CUR_Pos = 0x14
	// Bit mask of COUNT_RC_CUR field.
	XTALOSC24M_OSC_CONFIG1_TOG_COUNT_RC_CUR_Msk = 0xfff00000

	// OSC_CONFIG2: XTAL OSC Configuration 2 Register
	// Position of COUNT_1M_TRG field.
	XTALOSC24M_OSC_CONFIG2_COUNT_1M_TRG_Pos = 0x0
	// Bit mask of COUNT_1M_TRG field.
	XTALOSC24M_OSC_CONFIG2_COUNT_1M_TRG_Msk = 0xfff
	// Position of ENABLE_1M field.
	XTALOSC24M_OSC_CONFIG2_ENABLE_1M_Pos = 0x10
	// Bit mask of ENABLE_1M field.
	XTALOSC24M_OSC_CONFIG2_ENABLE_1M_Msk = 0x10000
	// Bit ENABLE_1M.
	XTALOSC24M_OSC_CONFIG2_ENABLE_1M = 0x10000
	// Position of MUX_1M field.
	XTALOSC24M_OSC_CONFIG2_MUX_1M_Pos = 0x11
	// Bit mask of MUX_1M field.
	XTALOSC24M_OSC_CONFIG2_MUX_1M_Msk = 0x20000
	// Bit MUX_1M.
	XTALOSC24M_OSC_CONFIG2_MUX_1M = 0x20000
	// Position of CLK_1M_ERR_FL field.
	XTALOSC24M_OSC_CONFIG2_CLK_1M_ERR_FL_Pos = 0x1f
	// Bit mask of CLK_1M_ERR_FL field.
	XTALOSC24M_OSC_CONFIG2_CLK_1M_ERR_FL_Msk = 0x80000000
	// Bit CLK_1M_ERR_FL.
	XTALOSC24M_OSC_CONFIG2_CLK_1M_ERR_FL = 0x80000000

	// OSC_CONFIG2_SET: XTAL OSC Configuration 2 Register
	// Position of COUNT_1M_TRG field.
	XTALOSC24M_OSC_CONFIG2_SET_COUNT_1M_TRG_Pos = 0x0
	// Bit mask of COUNT_1M_TRG field.
	XTALOSC24M_OSC_CONFIG2_SET_COUNT_1M_TRG_Msk = 0xfff
	// Position of ENABLE_1M field.
	XTALOSC24M_OSC_CONFIG2_SET_ENABLE_1M_Pos = 0x10
	// Bit mask of ENABLE_1M field.
	XTALOSC24M_OSC_CONFIG2_SET_ENABLE_1M_Msk = 0x10000
	// Bit ENABLE_1M.
	XTALOSC24M_OSC_CONFIG2_SET_ENABLE_1M = 0x10000
	// Position of MUX_1M field.
	XTALOSC24M_OSC_CONFIG2_SET_MUX_1M_Pos = 0x11
	// Bit mask of MUX_1M field.
	XTALOSC24M_OSC_CONFIG2_SET_MUX_1M_Msk = 0x20000
	// Bit MUX_1M.
	XTALOSC24M_OSC_CONFIG2_SET_MUX_1M = 0x20000
	// Position of CLK_1M_ERR_FL field.
	XTALOSC24M_OSC_CONFIG2_SET_CLK_1M_ERR_FL_Pos = 0x1f
	// Bit mask of CLK_1M_ERR_FL field.
	XTALOSC24M_OSC_CONFIG2_SET_CLK_1M_ERR_FL_Msk = 0x80000000
	// Bit CLK_1M_ERR_FL.
	XTALOSC24M_OSC_CONFIG2_SET_CLK_1M_ERR_FL = 0x80000000

	// OSC_CONFIG2_CLR: XTAL OSC Configuration 2 Register
	// Position of COUNT_1M_TRG field.
	XTALOSC24M_OSC_CONFIG2_CLR_COUNT_1M_TRG_Pos = 0x0
	// Bit mask of COUNT_1M_TRG field.
	XTALOSC24M_OSC_CONFIG2_CLR_COUNT_1M_TRG_Msk = 0xfff
	// Position of ENABLE_1M field.
	XTALOSC24M_OSC_CONFIG2_CLR_ENABLE_1M_Pos = 0x10
	// Bit mask of ENABLE_1M field.
	XTALOSC24M_OSC_CONFIG2_CLR_ENABLE_1M_Msk = 0x10000
	// Bit ENABLE_1M.
	XTALOSC24M_OSC_CONFIG2_CLR_ENABLE_1M = 0x10000
	// Position of MUX_1M field.
	XTALOSC24M_OSC_CONFIG2_CLR_MUX_1M_Pos = 0x11
	// Bit mask of MUX_1M field.
	XTALOSC24M_OSC_CONFIG2_CLR_MUX_1M_Msk = 0x20000
	// Bit MUX_1M.
	XTALOSC24M_OSC_CONFIG2_CLR_MUX_1M = 0x20000
	// Position of CLK_1M_ERR_FL field.
	XTALOSC24M_OSC_CONFIG2_CLR_CLK_1M_ERR_FL_Pos = 0x1f
	// Bit mask of CLK_1M_ERR_FL field.
	XTALOSC24M_OSC_CONFIG2_CLR_CLK_1M_ERR_FL_Msk = 0x80000000
	// Bit CLK_1M_ERR_FL.
	XTALOSC24M_OSC_CONFIG2_CLR_CLK_1M_ERR_FL = 0x80000000

	// OSC_CONFIG2_TOG: XTAL OSC Configuration 2 Register
	// Position of COUNT_1M_TRG field.
	XTALOSC24M_OSC_CONFIG2_TOG_COUNT_1M_TRG_Pos = 0x0
	// Bit mask of COUNT_1M_TRG field.
	XTALOSC24M_OSC_CONFIG2_TOG_COUNT_1M_TRG_Msk = 0xfff
	// Position of ENABLE_1M field.
	XTALOSC24M_OSC_CONFIG2_TOG_ENABLE_1M_Pos = 0x10
	// Bit mask of ENABLE_1M field.
	XTALOSC24M_OSC_CONFIG2_TOG_ENABLE_1M_Msk = 0x10000
	// Bit ENABLE_1M.
	XTALOSC24M_OSC_CONFIG2_TOG_ENABLE_1M = 0x10000
	// Position of MUX_1M field.
	XTALOSC24M_OSC_CONFIG2_TOG_MUX_1M_Pos = 0x11
	// Bit mask of MUX_1M field.
	XTALOSC24M_OSC_CONFIG2_TOG_MUX_1M_Msk = 0x20000
	// Bit MUX_1M.
	XTALOSC24M_OSC_CONFIG2_TOG_MUX_1M = 0x20000
	// Position of CLK_1M_ERR_FL field.
	XTALOSC24M_OSC_CONFIG2_TOG_CLK_1M_ERR_FL_Pos = 0x1f
	// Bit mask of CLK_1M_ERR_FL field.
	XTALOSC24M_OSC_CONFIG2_TOG_CLK_1M_ERR_FL_Msk = 0x80000000
	// Bit CLK_1M_ERR_FL.
	XTALOSC24M_OSC_CONFIG2_TOG_CLK_1M_ERR_FL = 0x80000000
)

// Bitfields for USBPHY1: USBPHY Register Reference Index
const (
	// PWD: USB PHY Power-Down Register
	// Position of RSVD0 field.
	USBPHY_PWD_RSVD0_Pos = 0x0
	// Bit mask of RSVD0 field.
	USBPHY_PWD_RSVD0_Msk = 0x3ff
	// Position of TXPWDFS field.
	USBPHY_PWD_TXPWDFS_Pos = 0xa
	// Bit mask of TXPWDFS field.
	USBPHY_PWD_TXPWDFS_Msk = 0x400
	// Bit TXPWDFS.
	USBPHY_PWD_TXPWDFS = 0x400
	// Position of TXPWDIBIAS field.
	USBPHY_PWD_TXPWDIBIAS_Pos = 0xb
	// Bit mask of TXPWDIBIAS field.
	USBPHY_PWD_TXPWDIBIAS_Msk = 0x800
	// Bit TXPWDIBIAS.
	USBPHY_PWD_TXPWDIBIAS = 0x800
	// Position of TXPWDV2I field.
	USBPHY_PWD_TXPWDV2I_Pos = 0xc
	// Bit mask of TXPWDV2I field.
	USBPHY_PWD_TXPWDV2I_Msk = 0x1000
	// Bit TXPWDV2I.
	USBPHY_PWD_TXPWDV2I = 0x1000
	// Position of RSVD1 field.
	USBPHY_PWD_RSVD1_Pos = 0xd
	// Bit mask of RSVD1 field.
	USBPHY_PWD_RSVD1_Msk = 0x1e000
	// Position of RXPWDENV field.
	USBPHY_PWD_RXPWDENV_Pos = 0x11
	// Bit mask of RXPWDENV field.
	USBPHY_PWD_RXPWDENV_Msk = 0x20000
	// Bit RXPWDENV.
	USBPHY_PWD_RXPWDENV = 0x20000
	// Position of RXPWD1PT1 field.
	USBPHY_PWD_RXPWD1PT1_Pos = 0x12
	// Bit mask of RXPWD1PT1 field.
	USBPHY_PWD_RXPWD1PT1_Msk = 0x40000
	// Bit RXPWD1PT1.
	USBPHY_PWD_RXPWD1PT1 = 0x40000
	// Position of RXPWDDIFF field.
	USBPHY_PWD_RXPWDDIFF_Pos = 0x13
	// Bit mask of RXPWDDIFF field.
	USBPHY_PWD_RXPWDDIFF_Msk = 0x80000
	// Bit RXPWDDIFF.
	USBPHY_PWD_RXPWDDIFF = 0x80000
	// Position of RXPWDRX field.
	USBPHY_PWD_RXPWDRX_Pos = 0x14
	// Bit mask of RXPWDRX field.
	USBPHY_PWD_RXPWDRX_Msk = 0x100000
	// Bit RXPWDRX.
	USBPHY_PWD_RXPWDRX = 0x100000
	// Position of RSVD2 field.
	USBPHY_PWD_RSVD2_Pos = 0x15
	// Bit mask of RSVD2 field.
	USBPHY_PWD_RSVD2_Msk = 0xffe00000

	// PWD_SET: USB PHY Power-Down Register
	// Position of RSVD0 field.
	USBPHY_PWD_SET_RSVD0_Pos = 0x0
	// Bit mask of RSVD0 field.
	USBPHY_PWD_SET_RSVD0_Msk = 0x3ff
	// Position of TXPWDFS field.
	USBPHY_PWD_SET_TXPWDFS_Pos = 0xa
	// Bit mask of TXPWDFS field.
	USBPHY_PWD_SET_TXPWDFS_Msk = 0x400
	// Bit TXPWDFS.
	USBPHY_PWD_SET_TXPWDFS = 0x400
	// Position of TXPWDIBIAS field.
	USBPHY_PWD_SET_TXPWDIBIAS_Pos = 0xb
	// Bit mask of TXPWDIBIAS field.
	USBPHY_PWD_SET_TXPWDIBIAS_Msk = 0x800
	// Bit TXPWDIBIAS.
	USBPHY_PWD_SET_TXPWDIBIAS = 0x800
	// Position of TXPWDV2I field.
	USBPHY_PWD_SET_TXPWDV2I_Pos = 0xc
	// Bit mask of TXPWDV2I field.
	USBPHY_PWD_SET_TXPWDV2I_Msk = 0x1000
	// Bit TXPWDV2I.
	USBPHY_PWD_SET_TXPWDV2I = 0x1000
	// Position of RSVD1 field.
	USBPHY_PWD_SET_RSVD1_Pos = 0xd
	// Bit mask of RSVD1 field.
	USBPHY_PWD_SET_RSVD1_Msk = 0x1e000
	// Position of RXPWDENV field.
	USBPHY_PWD_SET_RXPWDENV_Pos = 0x11
	// Bit mask of RXPWDENV field.
	USBPHY_PWD_SET_RXPWDENV_Msk = 0x20000
	// Bit RXPWDENV.
	USBPHY_PWD_SET_RXPWDENV = 0x20000
	// Position of RXPWD1PT1 field.
	USBPHY_PWD_SET_RXPWD1PT1_Pos = 0x12
	// Bit mask of RXPWD1PT1 field.
	USBPHY_PWD_SET_RXPWD1PT1_Msk = 0x40000
	// Bit RXPWD1PT1.
	USBPHY_PWD_SET_RXPWD1PT1 = 0x40000
	// Position of RXPWDDIFF field.
	USBPHY_PWD_SET_RXPWDDIFF_Pos = 0x13
	// Bit mask of RXPWDDIFF field.
	USBPHY_PWD_SET_RXPWDDIFF_Msk = 0x80000
	// Bit RXPWDDIFF.
	USBPHY_PWD_SET_RXPWDDIFF = 0x80000
	// Position of RXPWDRX field.
	USBPHY_PWD_SET_RXPWDRX_Pos = 0x14
	// Bit mask of RXPWDRX field.
	USBPHY_PWD_SET_RXPWDRX_Msk = 0x100000
	// Bit RXPWDRX.
	USBPHY_PWD_SET_RXPWDRX = 0x100000
	// Position of RSVD2 field.
	USBPHY_PWD_SET_RSVD2_Pos = 0x15
	// Bit mask of RSVD2 field.
	USBPHY_PWD_SET_RSVD2_Msk = 0xffe00000

	// PWD_CLR: USB PHY Power-Down Register
	// Position of RSVD0 field.
	USBPHY_PWD_CLR_RSVD0_Pos = 0x0
	// Bit mask of RSVD0 field.
	USBPHY_PWD_CLR_RSVD0_Msk = 0x3ff
	// Position of TXPWDFS field.
	USBPHY_PWD_CLR_TXPWDFS_Pos = 0xa
	// Bit mask of TXPWDFS field.
	USBPHY_PWD_CLR_TXPWDFS_Msk = 0x400
	// Bit TXPWDFS.
	USBPHY_PWD_CLR_TXPWDFS = 0x400
	// Position of TXPWDIBIAS field.
	USBPHY_PWD_CLR_TXPWDIBIAS_Pos = 0xb
	// Bit mask of TXPWDIBIAS field.
	USBPHY_PWD_CLR_TXPWDIBIAS_Msk = 0x800
	// Bit TXPWDIBIAS.
	USBPHY_PWD_CLR_TXPWDIBIAS = 0x800
	// Position of TXPWDV2I field.
	USBPHY_PWD_CLR_TXPWDV2I_Pos = 0xc
	// Bit mask of TXPWDV2I field.
	USBPHY_PWD_CLR_TXPWDV2I_Msk = 0x1000
	// Bit TXPWDV2I.
	USBPHY_PWD_CLR_TXPWDV2I = 0x1000
	// Position of RSVD1 field.
	USBPHY_PWD_CLR_RSVD1_Pos = 0xd
	// Bit mask of RSVD1 field.
	USBPHY_PWD_CLR_RSVD1_Msk = 0x1e000
	// Position of RXPWDENV field.
	USBPHY_PWD_CLR_RXPWDENV_Pos = 0x11
	// Bit mask of RXPWDENV field.
	USBPHY_PWD_CLR_RXPWDENV_Msk = 0x20000
	// Bit RXPWDENV.
	USBPHY_PWD_CLR_RXPWDENV = 0x20000
	// Position of RXPWD1PT1 field.
	USBPHY_PWD_CLR_RXPWD1PT1_Pos = 0x12
	// Bit mask of RXPWD1PT1 field.
	USBPHY_PWD_CLR_RXPWD1PT1_Msk = 0x40000
	// Bit RXPWD1PT1.
	USBPHY_PWD_CLR_RXPWD1PT1 = 0x40000
	// Position of RXPWDDIFF field.
	USBPHY_PWD_CLR_RXPWDDIFF_Pos = 0x13
	// Bit mask of RXPWDDIFF field.
	USBPHY_PWD_CLR_RXPWDDIFF_Msk = 0x80000
	// Bit RXPWDDIFF.
	USBPHY_PWD_CLR_RXPWDDIFF = 0x80000
	// Position of RXPWDRX field.
	USBPHY_PWD_CLR_RXPWDRX_Pos = 0x14
	// Bit mask of RXPWDRX field.
	USBPHY_PWD_CLR_RXPWDRX_Msk = 0x100000
	// Bit RXPWDRX.
	USBPHY_PWD_CLR_RXPWDRX = 0x100000
	// Position of RSVD2 field.
	USBPHY_PWD_CLR_RSVD2_Pos = 0x15
	// Bit mask of RSVD2 field.
	USBPHY_PWD_CLR_RSVD2_Msk = 0xffe00000

	// PWD_TOG: USB PHY Power-Down Register
	// Position of RSVD0 field.
	USBPHY_PWD_TOG_RSVD0_Pos = 0x0
	// Bit mask of RSVD0 field.
	USBPHY_PWD_TOG_RSVD0_Msk = 0x3ff
	// Position of TXPWDFS field.
	USBPHY_PWD_TOG_TXPWDFS_Pos = 0xa
	// Bit mask of TXPWDFS field.
	USBPHY_PWD_TOG_TXPWDFS_Msk = 0x400
	// Bit TXPWDFS.
	USBPHY_PWD_TOG_TXPWDFS = 0x400
	// Position of TXPWDIBIAS field.
	USBPHY_PWD_TOG_TXPWDIBIAS_Pos = 0xb
	// Bit mask of TXPWDIBIAS field.
	USBPHY_PWD_TOG_TXPWDIBIAS_Msk = 0x800
	// Bit TXPWDIBIAS.
	USBPHY_PWD_TOG_TXPWDIBIAS = 0x800
	// Position of TXPWDV2I field.
	USBPHY_PWD_TOG_TXPWDV2I_Pos = 0xc
	// Bit mask of TXPWDV2I field.
	USBPHY_PWD_TOG_TXPWDV2I_Msk = 0x1000
	// Bit TXPWDV2I.
	USBPHY_PWD_TOG_TXPWDV2I = 0x1000
	// Position of RSVD1 field.
	USBPHY_PWD_TOG_RSVD1_Pos = 0xd
	// Bit mask of RSVD1 field.
	USBPHY_PWD_TOG_RSVD1_Msk = 0x1e000
	// Position of RXPWDENV field.
	USBPHY_PWD_TOG_RXPWDENV_Pos = 0x11
	// Bit mask of RXPWDENV field.
	USBPHY_PWD_TOG_RXPWDENV_Msk = 0x20000
	// Bit RXPWDENV.
	USBPHY_PWD_TOG_RXPWDENV = 0x20000
	// Position of RXPWD1PT1 field.
	USBPHY_PWD_TOG_RXPWD1PT1_Pos = 0x12
	// Bit mask of RXPWD1PT1 field.
	USBPHY_PWD_TOG_RXPWD1PT1_Msk = 0x40000
	// Bit RXPWD1PT1.
	USBPHY_PWD_TOG_RXPWD1PT1 = 0x40000
	// Position of RXPWDDIFF field.
	USBPHY_PWD_TOG_RXPWDDIFF_Pos = 0x13
	// Bit mask of RXPWDDIFF field.
	USBPHY_PWD_TOG_RXPWDDIFF_Msk = 0x80000
	// Bit RXPWDDIFF.
	USBPHY_PWD_TOG_RXPWDDIFF = 0x80000
	// Position of RXPWDRX field.
	USBPHY_PWD_TOG_RXPWDRX_Pos = 0x14
	// Bit mask of RXPWDRX field.
	USBPHY_PWD_TOG_RXPWDRX_Msk = 0x100000
	// Bit RXPWDRX.
	USBPHY_PWD_TOG_RXPWDRX = 0x100000
	// Position of RSVD2 field.
	USBPHY_PWD_TOG_RSVD2_Pos = 0x15
	// Bit mask of RSVD2 field.
	USBPHY_PWD_TOG_RSVD2_Msk = 0xffe00000

	// TX: USB PHY Transmitter Control Register
	// Position of D_CAL field.
	USBPHY_TX_D_CAL_Pos = 0x0
	// Bit mask of D_CAL field.
	USBPHY_TX_D_CAL_Msk = 0xf
	// Position of RSVD0 field.
	USBPHY_TX_RSVD0_Pos = 0x4
	// Bit mask of RSVD0 field.
	USBPHY_TX_RSVD0_Msk = 0xf0
	// Position of TXCAL45DN field.
	USBPHY_TX_TXCAL45DN_Pos = 0x8
	// Bit mask of TXCAL45DN field.
	USBPHY_TX_TXCAL45DN_Msk = 0xf00
	// Position of RSVD1 field.
	USBPHY_TX_RSVD1_Pos = 0xc
	// Bit mask of RSVD1 field.
	USBPHY_TX_RSVD1_Msk = 0xf000
	// Position of TXCAL45DP field.
	USBPHY_TX_TXCAL45DP_Pos = 0x10
	// Bit mask of TXCAL45DP field.
	USBPHY_TX_TXCAL45DP_Msk = 0xf0000
	// Position of RSVD2 field.
	USBPHY_TX_RSVD2_Pos = 0x14
	// Bit mask of RSVD2 field.
	USBPHY_TX_RSVD2_Msk = 0x3f00000
	// Position of USBPHY_TX_EDGECTRL field.
	USBPHY_TX_USBPHY_TX_EDGECTRL_Pos = 0x1a
	// Bit mask of USBPHY_TX_EDGECTRL field.
	USBPHY_TX_USBPHY_TX_EDGECTRL_Msk = 0x1c000000
	// Position of RSVD5 field.
	USBPHY_TX_RSVD5_Pos = 0x1d
	// Bit mask of RSVD5 field.
	USBPHY_TX_RSVD5_Msk = 0xe0000000

	// TX_SET: USB PHY Transmitter Control Register
	// Position of D_CAL field.
	USBPHY_TX_SET_D_CAL_Pos = 0x0
	// Bit mask of D_CAL field.
	USBPHY_TX_SET_D_CAL_Msk = 0xf
	// Position of RSVD0 field.
	USBPHY_TX_SET_RSVD0_Pos = 0x4
	// Bit mask of RSVD0 field.
	USBPHY_TX_SET_RSVD0_Msk = 0xf0
	// Position of TXCAL45DN field.
	USBPHY_TX_SET_TXCAL45DN_Pos = 0x8
	// Bit mask of TXCAL45DN field.
	USBPHY_TX_SET_TXCAL45DN_Msk = 0xf00
	// Position of RSVD1 field.
	USBPHY_TX_SET_RSVD1_Pos = 0xc
	// Bit mask of RSVD1 field.
	USBPHY_TX_SET_RSVD1_Msk = 0xf000
	// Position of TXCAL45DP field.
	USBPHY_TX_SET_TXCAL45DP_Pos = 0x10
	// Bit mask of TXCAL45DP field.
	USBPHY_TX_SET_TXCAL45DP_Msk = 0xf0000
	// Position of RSVD2 field.
	USBPHY_TX_SET_RSVD2_Pos = 0x14
	// Bit mask of RSVD2 field.
	USBPHY_TX_SET_RSVD2_Msk = 0x3f00000
	// Position of USBPHY_TX_EDGECTRL field.
	USBPHY_TX_SET_USBPHY_TX_EDGECTRL_Pos = 0x1a
	// Bit mask of USBPHY_TX_EDGECTRL field.
	USBPHY_TX_SET_USBPHY_TX_EDGECTRL_Msk = 0x1c000000
	// Position of RSVD5 field.
	USBPHY_TX_SET_RSVD5_Pos = 0x1d
	// Bit mask of RSVD5 field.
	USBPHY_TX_SET_RSVD5_Msk = 0xe0000000

	// TX_CLR: USB PHY Transmitter Control Register
	// Position of D_CAL field.
	USBPHY_TX_CLR_D_CAL_Pos = 0x0
	// Bit mask of D_CAL field.
	USBPHY_TX_CLR_D_CAL_Msk = 0xf
	// Position of RSVD0 field.
	USBPHY_TX_CLR_RSVD0_Pos = 0x4
	// Bit mask of RSVD0 field.
	USBPHY_TX_CLR_RSVD0_Msk = 0xf0
	// Position of TXCAL45DN field.
	USBPHY_TX_CLR_TXCAL45DN_Pos = 0x8
	// Bit mask of TXCAL45DN field.
	USBPHY_TX_CLR_TXCAL45DN_Msk = 0xf00
	// Position of RSVD1 field.
	USBPHY_TX_CLR_RSVD1_Pos = 0xc
	// Bit mask of RSVD1 field.
	USBPHY_TX_CLR_RSVD1_Msk = 0xf000
	// Position of TXCAL45DP field.
	USBPHY_TX_CLR_TXCAL45DP_Pos = 0x10
	// Bit mask of TXCAL45DP field.
	USBPHY_TX_CLR_TXCAL45DP_Msk = 0xf0000
	// Position of RSVD2 field.
	USBPHY_TX_CLR_RSVD2_Pos = 0x14
	// Bit mask of RSVD2 field.
	USBPHY_TX_CLR_RSVD2_Msk = 0x3f00000
	// Position of USBPHY_TX_EDGECTRL field.
	USBPHY_TX_CLR_USBPHY_TX_EDGECTRL_Pos = 0x1a
	// Bit mask of USBPHY_TX_EDGECTRL field.
	USBPHY_TX_CLR_USBPHY_TX_EDGECTRL_Msk = 0x1c000000
	// Position of RSVD5 field.
	USBPHY_TX_CLR_RSVD5_Pos = 0x1d
	// Bit mask of RSVD5 field.
	USBPHY_TX_CLR_RSVD5_Msk = 0xe0000000

	// TX_TOG: USB PHY Transmitter Control Register
	// Position of D_CAL field.
	USBPHY_TX_TOG_D_CAL_Pos = 0x0
	// Bit mask of D_CAL field.
	USBPHY_TX_TOG_D_CAL_Msk = 0xf
	// Position of RSVD0 field.
	USBPHY_TX_TOG_RSVD0_Pos = 0x4
	// Bit mask of RSVD0 field.
	USBPHY_TX_TOG_RSVD0_Msk = 0xf0
	// Position of TXCAL45DN field.
	USBPHY_TX_TOG_TXCAL45DN_Pos = 0x8
	// Bit mask of TXCAL45DN field.
	USBPHY_TX_TOG_TXCAL45DN_Msk = 0xf00
	// Position of RSVD1 field.
	USBPHY_TX_TOG_RSVD1_Pos = 0xc
	// Bit mask of RSVD1 field.
	USBPHY_TX_TOG_RSVD1_Msk = 0xf000
	// Position of TXCAL45DP field.
	USBPHY_TX_TOG_TXCAL45DP_Pos = 0x10
	// Bit mask of TXCAL45DP field.
	USBPHY_TX_TOG_TXCAL45DP_Msk = 0xf0000
	// Position of RSVD2 field.
	USBPHY_TX_TOG_RSVD2_Pos = 0x14
	// Bit mask of RSVD2 field.
	USBPHY_TX_TOG_RSVD2_Msk = 0x3f00000
	// Position of USBPHY_TX_EDGECTRL field.
	USBPHY_TX_TOG_USBPHY_TX_EDGECTRL_Pos = 0x1a
	// Bit mask of USBPHY_TX_EDGECTRL field.
	USBPHY_TX_TOG_USBPHY_TX_EDGECTRL_Msk = 0x1c000000
	// Position of RSVD5 field.
	USBPHY_TX_TOG_RSVD5_Pos = 0x1d
	// Bit mask of RSVD5 field.
	USBPHY_TX_TOG_RSVD5_Msk = 0xe0000000

	// RX: USB PHY Receiver Control Register
	// Position of ENVADJ field.
	USBPHY_RX_ENVADJ_Pos = 0x0
	// Bit mask of ENVADJ field.
	USBPHY_RX_ENVADJ_Msk = 0x7
	// Position of RSVD0 field.
	USBPHY_RX_RSVD0_Pos = 0x3
	// Bit mask of RSVD0 field.
	USBPHY_RX_RSVD0_Msk = 0x8
	// Bit RSVD0.
	USBPHY_RX_RSVD0 = 0x8
	// Position of DISCONADJ field.
	USBPHY_RX_DISCONADJ_Pos = 0x4
	// Bit mask of DISCONADJ field.
	USBPHY_RX_DISCONADJ_Msk = 0x70
	// Position of RSVD1 field.
	USBPHY_RX_RSVD1_Pos = 0x7
	// Bit mask of RSVD1 field.
	USBPHY_RX_RSVD1_Msk = 0x3fff80
	// Position of RXDBYPASS field.
	USBPHY_RX_RXDBYPASS_Pos = 0x16
	// Bit mask of RXDBYPASS field.
	USBPHY_RX_RXDBYPASS_Msk = 0x400000
	// Bit RXDBYPASS.
	USBPHY_RX_RXDBYPASS = 0x400000
	// Position of RSVD2 field.
	USBPHY_RX_RSVD2_Pos = 0x17
	// Bit mask of RSVD2 field.
	USBPHY_RX_RSVD2_Msk = 0xff800000

	// RX_SET: USB PHY Receiver Control Register
	// Position of ENVADJ field.
	USBPHY_RX_SET_ENVADJ_Pos = 0x0
	// Bit mask of ENVADJ field.
	USBPHY_RX_SET_ENVADJ_Msk = 0x7
	// Position of RSVD0 field.
	USBPHY_RX_SET_RSVD0_Pos = 0x3
	// Bit mask of RSVD0 field.
	USBPHY_RX_SET_RSVD0_Msk = 0x8
	// Bit RSVD0.
	USBPHY_RX_SET_RSVD0 = 0x8
	// Position of DISCONADJ field.
	USBPHY_RX_SET_DISCONADJ_Pos = 0x4
	// Bit mask of DISCONADJ field.
	USBPHY_RX_SET_DISCONADJ_Msk = 0x70
	// Position of RSVD1 field.
	USBPHY_RX_SET_RSVD1_Pos = 0x7
	// Bit mask of RSVD1 field.
	USBPHY_RX_SET_RSVD1_Msk = 0x3fff80
	// Position of RXDBYPASS field.
	USBPHY_RX_SET_RXDBYPASS_Pos = 0x16
	// Bit mask of RXDBYPASS field.
	USBPHY_RX_SET_RXDBYPASS_Msk = 0x400000
	// Bit RXDBYPASS.
	USBPHY_RX_SET_RXDBYPASS = 0x400000
	// Position of RSVD2 field.
	USBPHY_RX_SET_RSVD2_Pos = 0x17
	// Bit mask of RSVD2 field.
	USBPHY_RX_SET_RSVD2_Msk = 0xff800000

	// RX_CLR: USB PHY Receiver Control Register
	// Position of ENVADJ field.
	USBPHY_RX_CLR_ENVADJ_Pos = 0x0
	// Bit mask of ENVADJ field.
	USBPHY_RX_CLR_ENVADJ_Msk = 0x7
	// Position of RSVD0 field.
	USBPHY_RX_CLR_RSVD0_Pos = 0x3
	// Bit mask of RSVD0 field.
	USBPHY_RX_CLR_RSVD0_Msk = 0x8
	// Bit RSVD0.
	USBPHY_RX_CLR_RSVD0 = 0x8
	// Position of DISCONADJ field.
	USBPHY_RX_CLR_DISCONADJ_Pos = 0x4
	// Bit mask of DISCONADJ field.
	USBPHY_RX_CLR_DISCONADJ_Msk = 0x70
	// Position of RSVD1 field.
	USBPHY_RX_CLR_RSVD1_Pos = 0x7
	// Bit mask of RSVD1 field.
	USBPHY_RX_CLR_RSVD1_Msk = 0x3fff80
	// Position of RXDBYPASS field.
	USBPHY_RX_CLR_RXDBYPASS_Pos = 0x16
	// Bit mask of RXDBYPASS field.
	USBPHY_RX_CLR_RXDBYPASS_Msk = 0x400000
	// Bit RXDBYPASS.
	USBPHY_RX_CLR_RXDBYPASS = 0x400000
	// Position of RSVD2 field.
	USBPHY_RX_CLR_RSVD2_Pos = 0x17
	// Bit mask of RSVD2 field.
	USBPHY_RX_CLR_RSVD2_Msk = 0xff800000

	// RX_TOG: USB PHY Receiver Control Register
	// Position of ENVADJ field.
	USBPHY_RX_TOG_ENVADJ_Pos = 0x0
	// Bit mask of ENVADJ field.
	USBPHY_RX_TOG_ENVADJ_Msk = 0x7
	// Position of RSVD0 field.
	USBPHY_RX_TOG_RSVD0_Pos = 0x3
	// Bit mask of RSVD0 field.
	USBPHY_RX_TOG_RSVD0_Msk = 0x8
	// Bit RSVD0.
	USBPHY_RX_TOG_RSVD0 = 0x8
	// Position of DISCONADJ field.
	USBPHY_RX_TOG_DISCONADJ_Pos = 0x4
	// Bit mask of DISCONADJ field.
	USBPHY_RX_TOG_DISCONADJ_Msk = 0x70
	// Position of RSVD1 field.
	USBPHY_RX_TOG_RSVD1_Pos = 0x7
	// Bit mask of RSVD1 field.
	USBPHY_RX_TOG_RSVD1_Msk = 0x3fff80
	// Position of RXDBYPASS field.
	USBPHY_RX_TOG_RXDBYPASS_Pos = 0x16
	// Bit mask of RXDBYPASS field.
	USBPHY_RX_TOG_RXDBYPASS_Msk = 0x400000
	// Bit RXDBYPASS.
	USBPHY_RX_TOG_RXDBYPASS = 0x400000
	// Position of RSVD2 field.
	USBPHY_RX_TOG_RSVD2_Pos = 0x17
	// Bit mask of RSVD2 field.
	USBPHY_RX_TOG_RSVD2_Msk = 0xff800000

	// CTRL: USB PHY General Control Register
	// Position of ENOTG_ID_CHG_IRQ field.
	USBPHY_CTRL_ENOTG_ID_CHG_IRQ_Pos = 0x0
	// Bit mask of ENOTG_ID_CHG_IRQ field.
	USBPHY_CTRL_ENOTG_ID_CHG_IRQ_Msk = 0x1
	// Bit ENOTG_ID_CHG_IRQ.
	USBPHY_CTRL_ENOTG_ID_CHG_IRQ = 0x1
	// Position of ENHOSTDISCONDETECT field.
	USBPHY_CTRL_ENHOSTDISCONDETECT_Pos = 0x1
	// Bit mask of ENHOSTDISCONDETECT field.
	USBPHY_CTRL_ENHOSTDISCONDETECT_Msk = 0x2
	// Bit ENHOSTDISCONDETECT.
	USBPHY_CTRL_ENHOSTDISCONDETECT = 0x2
	// Position of ENIRQHOSTDISCON field.
	USBPHY_CTRL_ENIRQHOSTDISCON_Pos = 0x2
	// Bit mask of ENIRQHOSTDISCON field.
	USBPHY_CTRL_ENIRQHOSTDISCON_Msk = 0x4
	// Bit ENIRQHOSTDISCON.
	USBPHY_CTRL_ENIRQHOSTDISCON = 0x4
	// Position of HOSTDISCONDETECT_IRQ field.
	USBPHY_CTRL_HOSTDISCONDETECT_IRQ_Pos = 0x3
	// Bit mask of HOSTDISCONDETECT_IRQ field.
	USBPHY_CTRL_HOSTDISCONDETECT_IRQ_Msk = 0x8
	// Bit HOSTDISCONDETECT_IRQ.
	USBPHY_CTRL_HOSTDISCONDETECT_IRQ = 0x8
	// Position of ENDEVPLUGINDETECT field.
	USBPHY_CTRL_ENDEVPLUGINDETECT_Pos = 0x4
	// Bit mask of ENDEVPLUGINDETECT field.
	USBPHY_CTRL_ENDEVPLUGINDETECT_Msk = 0x10
	// Bit ENDEVPLUGINDETECT.
	USBPHY_CTRL_ENDEVPLUGINDETECT = 0x10
	// Position of DEVPLUGIN_POLARITY field.
	USBPHY_CTRL_DEVPLUGIN_POLARITY_Pos = 0x5
	// Bit mask of DEVPLUGIN_POLARITY field.
	USBPHY_CTRL_DEVPLUGIN_POLARITY_Msk = 0x20
	// Bit DEVPLUGIN_POLARITY.
	USBPHY_CTRL_DEVPLUGIN_POLARITY = 0x20
	// Position of OTG_ID_CHG_IRQ field.
	USBPHY_CTRL_OTG_ID_CHG_IRQ_Pos = 0x6
	// Bit mask of OTG_ID_CHG_IRQ field.
	USBPHY_CTRL_OTG_ID_CHG_IRQ_Msk = 0x40
	// Bit OTG_ID_CHG_IRQ.
	USBPHY_CTRL_OTG_ID_CHG_IRQ = 0x40
	// Position of ENOTGIDDETECT field.
	USBPHY_CTRL_ENOTGIDDETECT_Pos = 0x7
	// Bit mask of ENOTGIDDETECT field.
	USBPHY_CTRL_ENOTGIDDETECT_Msk = 0x80
	// Bit ENOTGIDDETECT.
	USBPHY_CTRL_ENOTGIDDETECT = 0x80
	// Position of RESUMEIRQSTICKY field.
	USBPHY_CTRL_RESUMEIRQSTICKY_Pos = 0x8
	// Bit mask of RESUMEIRQSTICKY field.
	USBPHY_CTRL_RESUMEIRQSTICKY_Msk = 0x100
	// Bit RESUMEIRQSTICKY.
	USBPHY_CTRL_RESUMEIRQSTICKY = 0x100
	// Position of ENIRQRESUMEDETECT field.
	USBPHY_CTRL_ENIRQRESUMEDETECT_Pos = 0x9
	// Bit mask of ENIRQRESUMEDETECT field.
	USBPHY_CTRL_ENIRQRESUMEDETECT_Msk = 0x200
	// Bit ENIRQRESUMEDETECT.
	USBPHY_CTRL_ENIRQRESUMEDETECT = 0x200
	// Position of RESUME_IRQ field.
	USBPHY_CTRL_RESUME_IRQ_Pos = 0xa
	// Bit mask of RESUME_IRQ field.
	USBPHY_CTRL_RESUME_IRQ_Msk = 0x400
	// Bit RESUME_IRQ.
	USBPHY_CTRL_RESUME_IRQ = 0x400
	// Position of ENIRQDEVPLUGIN field.
	USBPHY_CTRL_ENIRQDEVPLUGIN_Pos = 0xb
	// Bit mask of ENIRQDEVPLUGIN field.
	USBPHY_CTRL_ENIRQDEVPLUGIN_Msk = 0x800
	// Bit ENIRQDEVPLUGIN.
	USBPHY_CTRL_ENIRQDEVPLUGIN = 0x800
	// Position of DEVPLUGIN_IRQ field.
	USBPHY_CTRL_DEVPLUGIN_IRQ_Pos = 0xc
	// Bit mask of DEVPLUGIN_IRQ field.
	USBPHY_CTRL_DEVPLUGIN_IRQ_Msk = 0x1000
	// Bit DEVPLUGIN_IRQ.
	USBPHY_CTRL_DEVPLUGIN_IRQ = 0x1000
	// Position of DATA_ON_LRADC field.
	USBPHY_CTRL_DATA_ON_LRADC_Pos = 0xd
	// Bit mask of DATA_ON_LRADC field.
	USBPHY_CTRL_DATA_ON_LRADC_Msk = 0x2000
	// Bit DATA_ON_LRADC.
	USBPHY_CTRL_DATA_ON_LRADC = 0x2000
	// Position of ENUTMILEVEL2 field.
	USBPHY_CTRL_ENUTMILEVEL2_Pos = 0xe
	// Bit mask of ENUTMILEVEL2 field.
	USBPHY_CTRL_ENUTMILEVEL2_Msk = 0x4000
	// Bit ENUTMILEVEL2.
	USBPHY_CTRL_ENUTMILEVEL2 = 0x4000
	// Position of ENUTMILEVEL3 field.
	USBPHY_CTRL_ENUTMILEVEL3_Pos = 0xf
	// Bit mask of ENUTMILEVEL3 field.
	USBPHY_CTRL_ENUTMILEVEL3_Msk = 0x8000
	// Bit ENUTMILEVEL3.
	USBPHY_CTRL_ENUTMILEVEL3 = 0x8000
	// Position of ENIRQWAKEUP field.
	USBPHY_CTRL_ENIRQWAKEUP_Pos = 0x10
	// Bit mask of ENIRQWAKEUP field.
	USBPHY_CTRL_ENIRQWAKEUP_Msk = 0x10000
	// Bit ENIRQWAKEUP.
	USBPHY_CTRL_ENIRQWAKEUP = 0x10000
	// Position of WAKEUP_IRQ field.
	USBPHY_CTRL_WAKEUP_IRQ_Pos = 0x11
	// Bit mask of WAKEUP_IRQ field.
	USBPHY_CTRL_WAKEUP_IRQ_Msk = 0x20000
	// Bit WAKEUP_IRQ.
	USBPHY_CTRL_WAKEUP_IRQ = 0x20000
	// Position of ENAUTO_PWRON_PLL field.
	USBPHY_CTRL_ENAUTO_PWRON_PLL_Pos = 0x12
	// Bit mask of ENAUTO_PWRON_PLL field.
	USBPHY_CTRL_ENAUTO_PWRON_PLL_Msk = 0x40000
	// Bit ENAUTO_PWRON_PLL.
	USBPHY_CTRL_ENAUTO_PWRON_PLL = 0x40000
	// Position of ENAUTOCLR_CLKGATE field.
	USBPHY_CTRL_ENAUTOCLR_CLKGATE_Pos = 0x13
	// Bit mask of ENAUTOCLR_CLKGATE field.
	USBPHY_CTRL_ENAUTOCLR_CLKGATE_Msk = 0x80000
	// Bit ENAUTOCLR_CLKGATE.
	USBPHY_CTRL_ENAUTOCLR_CLKGATE = 0x80000
	// Position of ENAUTOCLR_PHY_PWD field.
	USBPHY_CTRL_ENAUTOCLR_PHY_PWD_Pos = 0x14
	// Bit mask of ENAUTOCLR_PHY_PWD field.
	USBPHY_CTRL_ENAUTOCLR_PHY_PWD_Msk = 0x100000
	// Bit ENAUTOCLR_PHY_PWD.
	USBPHY_CTRL_ENAUTOCLR_PHY_PWD = 0x100000
	// Position of ENDPDMCHG_WKUP field.
	USBPHY_CTRL_ENDPDMCHG_WKUP_Pos = 0x15
	// Bit mask of ENDPDMCHG_WKUP field.
	USBPHY_CTRL_ENDPDMCHG_WKUP_Msk = 0x200000
	// Bit ENDPDMCHG_WKUP.
	USBPHY_CTRL_ENDPDMCHG_WKUP = 0x200000
	// Position of ENIDCHG_WKUP field.
	USBPHY_CTRL_ENIDCHG_WKUP_Pos = 0x16
	// Bit mask of ENIDCHG_WKUP field.
	USBPHY_CTRL_ENIDCHG_WKUP_Msk = 0x400000
	// Bit ENIDCHG_WKUP.
	USBPHY_CTRL_ENIDCHG_WKUP = 0x400000
	// Position of ENVBUSCHG_WKUP field.
	USBPHY_CTRL_ENVBUSCHG_WKUP_Pos = 0x17
	// Bit mask of ENVBUSCHG_WKUP field.
	USBPHY_CTRL_ENVBUSCHG_WKUP_Msk = 0x800000
	// Bit ENVBUSCHG_WKUP.
	USBPHY_CTRL_ENVBUSCHG_WKUP = 0x800000
	// Position of FSDLL_RST_EN field.
	USBPHY_CTRL_FSDLL_RST_EN_Pos = 0x18
	// Bit mask of FSDLL_RST_EN field.
	USBPHY_CTRL_FSDLL_RST_EN_Msk = 0x1000000
	// Bit FSDLL_RST_EN.
	USBPHY_CTRL_FSDLL_RST_EN = 0x1000000
	// Position of RSVD1 field.
	USBPHY_CTRL_RSVD1_Pos = 0x19
	// Bit mask of RSVD1 field.
	USBPHY_CTRL_RSVD1_Msk = 0x6000000
	// Position of OTG_ID_VALUE field.
	USBPHY_CTRL_OTG_ID_VALUE_Pos = 0x1b
	// Bit mask of OTG_ID_VALUE field.
	USBPHY_CTRL_OTG_ID_VALUE_Msk = 0x8000000
	// Bit OTG_ID_VALUE.
	USBPHY_CTRL_OTG_ID_VALUE = 0x8000000
	// Position of HOST_FORCE_LS_SE0 field.
	USBPHY_CTRL_HOST_FORCE_LS_SE0_Pos = 0x1c
	// Bit mask of HOST_FORCE_LS_SE0 field.
	USBPHY_CTRL_HOST_FORCE_LS_SE0_Msk = 0x10000000
	// Bit HOST_FORCE_LS_SE0.
	USBPHY_CTRL_HOST_FORCE_LS_SE0 = 0x10000000
	// Position of UTMI_SUSPENDM field.
	USBPHY_CTRL_UTMI_SUSPENDM_Pos = 0x1d
	// Bit mask of UTMI_SUSPENDM field.
	USBPHY_CTRL_UTMI_SUSPENDM_Msk = 0x20000000
	// Bit UTMI_SUSPENDM.
	USBPHY_CTRL_UTMI_SUSPENDM = 0x20000000
	// Position of CLKGATE field.
	USBPHY_CTRL_CLKGATE_Pos = 0x1e
	// Bit mask of CLKGATE field.
	USBPHY_CTRL_CLKGATE_Msk = 0x40000000
	// Bit CLKGATE.
	USBPHY_CTRL_CLKGATE = 0x40000000
	// Position of SFTRST field.
	USBPHY_CTRL_SFTRST_Pos = 0x1f
	// Bit mask of SFTRST field.
	USBPHY_CTRL_SFTRST_Msk = 0x80000000
	// Bit SFTRST.
	USBPHY_CTRL_SFTRST = 0x80000000

	// CTRL_SET: USB PHY General Control Register
	// Position of ENOTG_ID_CHG_IRQ field.
	USBPHY_CTRL_SET_ENOTG_ID_CHG_IRQ_Pos = 0x0
	// Bit mask of ENOTG_ID_CHG_IRQ field.
	USBPHY_CTRL_SET_ENOTG_ID_CHG_IRQ_Msk = 0x1
	// Bit ENOTG_ID_CHG_IRQ.
	USBPHY_CTRL_SET_ENOTG_ID_CHG_IRQ = 0x1
	// Position of ENHOSTDISCONDETECT field.
	USBPHY_CTRL_SET_ENHOSTDISCONDETECT_Pos = 0x1
	// Bit mask of ENHOSTDISCONDETECT field.
	USBPHY_CTRL_SET_ENHOSTDISCONDETECT_Msk = 0x2
	// Bit ENHOSTDISCONDETECT.
	USBPHY_CTRL_SET_ENHOSTDISCONDETECT = 0x2
	// Position of ENIRQHOSTDISCON field.
	USBPHY_CTRL_SET_ENIRQHOSTDISCON_Pos = 0x2
	// Bit mask of ENIRQHOSTDISCON field.
	USBPHY_CTRL_SET_ENIRQHOSTDISCON_Msk = 0x4
	// Bit ENIRQHOSTDISCON.
	USBPHY_CTRL_SET_ENIRQHOSTDISCON = 0x4
	// Position of HOSTDISCONDETECT_IRQ field.
	USBPHY_CTRL_SET_HOSTDISCONDETECT_IRQ_Pos = 0x3
	// Bit mask of HOSTDISCONDETECT_IRQ field.
	USBPHY_CTRL_SET_HOSTDISCONDETECT_IRQ_Msk = 0x8
	// Bit HOSTDISCONDETECT_IRQ.
	USBPHY_CTRL_SET_HOSTDISCONDETECT_IRQ = 0x8
	// Position of ENDEVPLUGINDETECT field.
	USBPHY_CTRL_SET_ENDEVPLUGINDETECT_Pos = 0x4
	// Bit mask of ENDEVPLUGINDETECT field.
	USBPHY_CTRL_SET_ENDEVPLUGINDETECT_Msk = 0x10
	// Bit ENDEVPLUGINDETECT.
	USBPHY_CTRL_SET_ENDEVPLUGINDETECT = 0x10
	// Position of DEVPLUGIN_POLARITY field.
	USBPHY_CTRL_SET_DEVPLUGIN_POLARITY_Pos = 0x5
	// Bit mask of DEVPLUGIN_POLARITY field.
	USBPHY_CTRL_SET_DEVPLUGIN_POLARITY_Msk = 0x20
	// Bit DEVPLUGIN_POLARITY.
	USBPHY_CTRL_SET_DEVPLUGIN_POLARITY = 0x20
	// Position of OTG_ID_CHG_IRQ field.
	USBPHY_CTRL_SET_OTG_ID_CHG_IRQ_Pos = 0x6
	// Bit mask of OTG_ID_CHG_IRQ field.
	USBPHY_CTRL_SET_OTG_ID_CHG_IRQ_Msk = 0x40
	// Bit OTG_ID_CHG_IRQ.
	USBPHY_CTRL_SET_OTG_ID_CHG_IRQ = 0x40
	// Position of ENOTGIDDETECT field.
	USBPHY_CTRL_SET_ENOTGIDDETECT_Pos = 0x7
	// Bit mask of ENOTGIDDETECT field.
	USBPHY_CTRL_SET_ENOTGIDDETECT_Msk = 0x80
	// Bit ENOTGIDDETECT.
	USBPHY_CTRL_SET_ENOTGIDDETECT = 0x80
	// Position of RESUMEIRQSTICKY field.
	USBPHY_CTRL_SET_RESUMEIRQSTICKY_Pos = 0x8
	// Bit mask of RESUMEIRQSTICKY field.
	USBPHY_CTRL_SET_RESUMEIRQSTICKY_Msk = 0x100
	// Bit RESUMEIRQSTICKY.
	USBPHY_CTRL_SET_RESUMEIRQSTICKY = 0x100
	// Position of ENIRQRESUMEDETECT field.
	USBPHY_CTRL_SET_ENIRQRESUMEDETECT_Pos = 0x9
	// Bit mask of ENIRQRESUMEDETECT field.
	USBPHY_CTRL_SET_ENIRQRESUMEDETECT_Msk = 0x200
	// Bit ENIRQRESUMEDETECT.
	USBPHY_CTRL_SET_ENIRQRESUMEDETECT = 0x200
	// Position of RESUME_IRQ field.
	USBPHY_CTRL_SET_RESUME_IRQ_Pos = 0xa
	// Bit mask of RESUME_IRQ field.
	USBPHY_CTRL_SET_RESUME_IRQ_Msk = 0x400
	// Bit RESUME_IRQ.
	USBPHY_CTRL_SET_RESUME_IRQ = 0x400
	// Position of ENIRQDEVPLUGIN field.
	USBPHY_CTRL_SET_ENIRQDEVPLUGIN_Pos = 0xb
	// Bit mask of ENIRQDEVPLUGIN field.
	USBPHY_CTRL_SET_ENIRQDEVPLUGIN_Msk = 0x800
	// Bit ENIRQDEVPLUGIN.
	USBPHY_CTRL_SET_ENIRQDEVPLUGIN = 0x800
	// Position of DEVPLUGIN_IRQ field.
	USBPHY_CTRL_SET_DEVPLUGIN_IRQ_Pos = 0xc
	// Bit mask of DEVPLUGIN_IRQ field.
	USBPHY_CTRL_SET_DEVPLUGIN_IRQ_Msk = 0x1000
	// Bit DEVPLUGIN_IRQ.
	USBPHY_CTRL_SET_DEVPLUGIN_IRQ = 0x1000
	// Position of DATA_ON_LRADC field.
	USBPHY_CTRL_SET_DATA_ON_LRADC_Pos = 0xd
	// Bit mask of DATA_ON_LRADC field.
	USBPHY_CTRL_SET_DATA_ON_LRADC_Msk = 0x2000
	// Bit DATA_ON_LRADC.
	USBPHY_CTRL_SET_DATA_ON_LRADC = 0x2000
	// Position of ENUTMILEVEL2 field.
	USBPHY_CTRL_SET_ENUTMILEVEL2_Pos = 0xe
	// Bit mask of ENUTMILEVEL2 field.
	USBPHY_CTRL_SET_ENUTMILEVEL2_Msk = 0x4000
	// Bit ENUTMILEVEL2.
	USBPHY_CTRL_SET_ENUTMILEVEL2 = 0x4000
	// Position of ENUTMILEVEL3 field.
	USBPHY_CTRL_SET_ENUTMILEVEL3_Pos = 0xf
	// Bit mask of ENUTMILEVEL3 field.
	USBPHY_CTRL_SET_ENUTMILEVEL3_Msk = 0x8000
	// Bit ENUTMILEVEL3.
	USBPHY_CTRL_SET_ENUTMILEVEL3 = 0x8000
	// Position of ENIRQWAKEUP field.
	USBPHY_CTRL_SET_ENIRQWAKEUP_Pos = 0x10
	// Bit mask of ENIRQWAKEUP field.
	USBPHY_CTRL_SET_ENIRQWAKEUP_Msk = 0x10000
	// Bit ENIRQWAKEUP.
	USBPHY_CTRL_SET_ENIRQWAKEUP = 0x10000
	// Position of WAKEUP_IRQ field.
	USBPHY_CTRL_SET_WAKEUP_IRQ_Pos = 0x11
	// Bit mask of WAKEUP_IRQ field.
	USBPHY_CTRL_SET_WAKEUP_IRQ_Msk = 0x20000
	// Bit WAKEUP_IRQ.
	USBPHY_CTRL_SET_WAKEUP_IRQ = 0x20000
	// Position of ENAUTO_PWRON_PLL field.
	USBPHY_CTRL_SET_ENAUTO_PWRON_PLL_Pos = 0x12
	// Bit mask of ENAUTO_PWRON_PLL field.
	USBPHY_CTRL_SET_ENAUTO_PWRON_PLL_Msk = 0x40000
	// Bit ENAUTO_PWRON_PLL.
	USBPHY_CTRL_SET_ENAUTO_PWRON_PLL = 0x40000
	// Position of ENAUTOCLR_CLKGATE field.
	USBPHY_CTRL_SET_ENAUTOCLR_CLKGATE_Pos = 0x13
	// Bit mask of ENAUTOCLR_CLKGATE field.
	USBPHY_CTRL_SET_ENAUTOCLR_CLKGATE_Msk = 0x80000
	// Bit ENAUTOCLR_CLKGATE.
	USBPHY_CTRL_SET_ENAUTOCLR_CLKGATE = 0x80000
	// Position of ENAUTOCLR_PHY_PWD field.
	USBPHY_CTRL_SET_ENAUTOCLR_PHY_PWD_Pos = 0x14
	// Bit mask of ENAUTOCLR_PHY_PWD field.
	USBPHY_CTRL_SET_ENAUTOCLR_PHY_PWD_Msk = 0x100000
	// Bit ENAUTOCLR_PHY_PWD.
	USBPHY_CTRL_SET_ENAUTOCLR_PHY_PWD = 0x100000
	// Position of ENDPDMCHG_WKUP field.
	USBPHY_CTRL_SET_ENDPDMCHG_WKUP_Pos = 0x15
	// Bit mask of ENDPDMCHG_WKUP field.
	USBPHY_CTRL_SET_ENDPDMCHG_WKUP_Msk = 0x200000
	// Bit ENDPDMCHG_WKUP.
	USBPHY_CTRL_SET_ENDPDMCHG_WKUP = 0x200000
	// Position of ENIDCHG_WKUP field.
	USBPHY_CTRL_SET_ENIDCHG_WKUP_Pos = 0x16
	// Bit mask of ENIDCHG_WKUP field.
	USBPHY_CTRL_SET_ENIDCHG_WKUP_Msk = 0x400000
	// Bit ENIDCHG_WKUP.
	USBPHY_CTRL_SET_ENIDCHG_WKUP = 0x400000
	// Position of ENVBUSCHG_WKUP field.
	USBPHY_CTRL_SET_ENVBUSCHG_WKUP_Pos = 0x17
	// Bit mask of ENVBUSCHG_WKUP field.
	USBPHY_CTRL_SET_ENVBUSCHG_WKUP_Msk = 0x800000
	// Bit ENVBUSCHG_WKUP.
	USBPHY_CTRL_SET_ENVBUSCHG_WKUP = 0x800000
	// Position of FSDLL_RST_EN field.
	USBPHY_CTRL_SET_FSDLL_RST_EN_Pos = 0x18
	// Bit mask of FSDLL_RST_EN field.
	USBPHY_CTRL_SET_FSDLL_RST_EN_Msk = 0x1000000
	// Bit FSDLL_RST_EN.
	USBPHY_CTRL_SET_FSDLL_RST_EN = 0x1000000
	// Position of RSVD1 field.
	USBPHY_CTRL_SET_RSVD1_Pos = 0x19
	// Bit mask of RSVD1 field.
	USBPHY_CTRL_SET_RSVD1_Msk = 0x6000000
	// Position of OTG_ID_VALUE field.
	USBPHY_CTRL_SET_OTG_ID_VALUE_Pos = 0x1b
	// Bit mask of OTG_ID_VALUE field.
	USBPHY_CTRL_SET_OTG_ID_VALUE_Msk = 0x8000000
	// Bit OTG_ID_VALUE.
	USBPHY_CTRL_SET_OTG_ID_VALUE = 0x8000000
	// Position of HOST_FORCE_LS_SE0 field.
	USBPHY_CTRL_SET_HOST_FORCE_LS_SE0_Pos = 0x1c
	// Bit mask of HOST_FORCE_LS_SE0 field.
	USBPHY_CTRL_SET_HOST_FORCE_LS_SE0_Msk = 0x10000000
	// Bit HOST_FORCE_LS_SE0.
	USBPHY_CTRL_SET_HOST_FORCE_LS_SE0 = 0x10000000
	// Position of UTMI_SUSPENDM field.
	USBPHY_CTRL_SET_UTMI_SUSPENDM_Pos = 0x1d
	// Bit mask of UTMI_SUSPENDM field.
	USBPHY_CTRL_SET_UTMI_SUSPENDM_Msk = 0x20000000
	// Bit UTMI_SUSPENDM.
	USBPHY_CTRL_SET_UTMI_SUSPENDM = 0x20000000
	// Position of CLKGATE field.
	USBPHY_CTRL_SET_CLKGATE_Pos = 0x1e
	// Bit mask of CLKGATE field.
	USBPHY_CTRL_SET_CLKGATE_Msk = 0x40000000
	// Bit CLKGATE.
	USBPHY_CTRL_SET_CLKGATE = 0x40000000
	// Position of SFTRST field.
	USBPHY_CTRL_SET_SFTRST_Pos = 0x1f
	// Bit mask of SFTRST field.
	USBPHY_CTRL_SET_SFTRST_Msk = 0x80000000
	// Bit SFTRST.
	USBPHY_CTRL_SET_SFTRST = 0x80000000

	// CTRL_CLR: USB PHY General Control Register
	// Position of ENOTG_ID_CHG_IRQ field.
	USBPHY_CTRL_CLR_ENOTG_ID_CHG_IRQ_Pos = 0x0
	// Bit mask of ENOTG_ID_CHG_IRQ field.
	USBPHY_CTRL_CLR_ENOTG_ID_CHG_IRQ_Msk = 0x1
	// Bit ENOTG_ID_CHG_IRQ.
	USBPHY_CTRL_CLR_ENOTG_ID_CHG_IRQ = 0x1
	// Position of ENHOSTDISCONDETECT field.
	USBPHY_CTRL_CLR_ENHOSTDISCONDETECT_Pos = 0x1
	// Bit mask of ENHOSTDISCONDETECT field.
	USBPHY_CTRL_CLR_ENHOSTDISCONDETECT_Msk = 0x2
	// Bit ENHOSTDISCONDETECT.
	USBPHY_CTRL_CLR_ENHOSTDISCONDETECT = 0x2
	// Position of ENIRQHOSTDISCON field.
	USBPHY_CTRL_CLR_ENIRQHOSTDISCON_Pos = 0x2
	// Bit mask of ENIRQHOSTDISCON field.
	USBPHY_CTRL_CLR_ENIRQHOSTDISCON_Msk = 0x4
	// Bit ENIRQHOSTDISCON.
	USBPHY_CTRL_CLR_ENIRQHOSTDISCON = 0x4
	// Position of HOSTDISCONDETECT_IRQ field.
	USBPHY_CTRL_CLR_HOSTDISCONDETECT_IRQ_Pos = 0x3
	// Bit mask of HOSTDISCONDETECT_IRQ field.
	USBPHY_CTRL_CLR_HOSTDISCONDETECT_IRQ_Msk = 0x8
	// Bit HOSTDISCONDETECT_IRQ.
	USBPHY_CTRL_CLR_HOSTDISCONDETECT_IRQ = 0x8
	// Position of ENDEVPLUGINDETECT field.
	USBPHY_CTRL_CLR_ENDEVPLUGINDETECT_Pos = 0x4
	// Bit mask of ENDEVPLUGINDETECT field.
	USBPHY_CTRL_CLR_ENDEVPLUGINDETECT_Msk = 0x10
	// Bit ENDEVPLUGINDETECT.
	USBPHY_CTRL_CLR_ENDEVPLUGINDETECT = 0x10
	// Position of DEVPLUGIN_POLARITY field.
	USBPHY_CTRL_CLR_DEVPLUGIN_POLARITY_Pos = 0x5
	// Bit mask of DEVPLUGIN_POLARITY field.
	USBPHY_CTRL_CLR_DEVPLUGIN_POLARITY_Msk = 0x20
	// Bit DEVPLUGIN_POLARITY.
	USBPHY_CTRL_CLR_DEVPLUGIN_POLARITY = 0x20
	// Position of OTG_ID_CHG_IRQ field.
	USBPHY_CTRL_CLR_OTG_ID_CHG_IRQ_Pos = 0x6
	// Bit mask of OTG_ID_CHG_IRQ field.
	USBPHY_CTRL_CLR_OTG_ID_CHG_IRQ_Msk = 0x40
	// Bit OTG_ID_CHG_IRQ.
	USBPHY_CTRL_CLR_OTG_ID_CHG_IRQ = 0x40
	// Position of ENOTGIDDETECT field.
	USBPHY_CTRL_CLR_ENOTGIDDETECT_Pos = 0x7
	// Bit mask of ENOTGIDDETECT field.
	USBPHY_CTRL_CLR_ENOTGIDDETECT_Msk = 0x80
	// Bit ENOTGIDDETECT.
	USBPHY_CTRL_CLR_ENOTGIDDETECT = 0x80
	// Position of RESUMEIRQSTICKY field.
	USBPHY_CTRL_CLR_RESUMEIRQSTICKY_Pos = 0x8
	// Bit mask of RESUMEIRQSTICKY field.
	USBPHY_CTRL_CLR_RESUMEIRQSTICKY_Msk = 0x100
	// Bit RESUMEIRQSTICKY.
	USBPHY_CTRL_CLR_RESUMEIRQSTICKY = 0x100
	// Position of ENIRQRESUMEDETECT field.
	USBPHY_CTRL_CLR_ENIRQRESUMEDETECT_Pos = 0x9
	// Bit mask of ENIRQRESUMEDETECT field.
	USBPHY_CTRL_CLR_ENIRQRESUMEDETECT_Msk = 0x200
	// Bit ENIRQRESUMEDETECT.
	USBPHY_CTRL_CLR_ENIRQRESUMEDETECT = 0x200
	// Position of RESUME_IRQ field.
	USBPHY_CTRL_CLR_RESUME_IRQ_Pos = 0xa
	// Bit mask of RESUME_IRQ field.
	USBPHY_CTRL_CLR_RESUME_IRQ_Msk = 0x400
	// Bit RESUME_IRQ.
	USBPHY_CTRL_CLR_RESUME_IRQ = 0x400
	// Position of ENIRQDEVPLUGIN field.
	USBPHY_CTRL_CLR_ENIRQDEVPLUGIN_Pos = 0xb
	// Bit mask of ENIRQDEVPLUGIN field.
	USBPHY_CTRL_CLR_ENIRQDEVPLUGIN_Msk = 0x800
	// Bit ENIRQDEVPLUGIN.
	USBPHY_CTRL_CLR_ENIRQDEVPLUGIN = 0x800
	// Position of DEVPLUGIN_IRQ field.
	USBPHY_CTRL_CLR_DEVPLUGIN_IRQ_Pos = 0xc
	// Bit mask of DEVPLUGIN_IRQ field.
	USBPHY_CTRL_CLR_DEVPLUGIN_IRQ_Msk = 0x1000
	// Bit DEVPLUGIN_IRQ.
	USBPHY_CTRL_CLR_DEVPLUGIN_IRQ = 0x1000
	// Position of DATA_ON_LRADC field.
	USBPHY_CTRL_CLR_DATA_ON_LRADC_Pos = 0xd
	// Bit mask of DATA_ON_LRADC field.
	USBPHY_CTRL_CLR_DATA_ON_LRADC_Msk = 0x2000
	// Bit DATA_ON_LRADC.
	USBPHY_CTRL_CLR_DATA_ON_LRADC = 0x2000
	// Position of ENUTMILEVEL2 field.
	USBPHY_CTRL_CLR_ENUTMILEVEL2_Pos = 0xe
	// Bit mask of ENUTMILEVEL2 field.
	USBPHY_CTRL_CLR_ENUTMILEVEL2_Msk = 0x4000
	// Bit ENUTMILEVEL2.
	USBPHY_CTRL_CLR_ENUTMILEVEL2 = 0x4000
	// Position of ENUTMILEVEL3 field.
	USBPHY_CTRL_CLR_ENUTMILEVEL3_Pos = 0xf
	// Bit mask of ENUTMILEVEL3 field.
	USBPHY_CTRL_CLR_ENUTMILEVEL3_Msk = 0x8000
	// Bit ENUTMILEVEL3.
	USBPHY_CTRL_CLR_ENUTMILEVEL3 = 0x8000
	// Position of ENIRQWAKEUP field.
	USBPHY_CTRL_CLR_ENIRQWAKEUP_Pos = 0x10
	// Bit mask of ENIRQWAKEUP field.
	USBPHY_CTRL_CLR_ENIRQWAKEUP_Msk = 0x10000
	// Bit ENIRQWAKEUP.
	USBPHY_CTRL_CLR_ENIRQWAKEUP = 0x10000
	// Position of WAKEUP_IRQ field.
	USBPHY_CTRL_CLR_WAKEUP_IRQ_Pos = 0x11
	// Bit mask of WAKEUP_IRQ field.
	USBPHY_CTRL_CLR_WAKEUP_IRQ_Msk = 0x20000
	// Bit WAKEUP_IRQ.
	USBPHY_CTRL_CLR_WAKEUP_IRQ = 0x20000
	// Position of ENAUTO_PWRON_PLL field.
	USBPHY_CTRL_CLR_ENAUTO_PWRON_PLL_Pos = 0x12
	// Bit mask of ENAUTO_PWRON_PLL field.
	USBPHY_CTRL_CLR_ENAUTO_PWRON_PLL_Msk = 0x40000
	// Bit ENAUTO_PWRON_PLL.
	USBPHY_CTRL_CLR_ENAUTO_PWRON_PLL = 0x40000
	// Position of ENAUTOCLR_CLKGATE field.
	USBPHY_CTRL_CLR_ENAUTOCLR_CLKGATE_Pos = 0x13
	// Bit mask of ENAUTOCLR_CLKGATE field.
	USBPHY_CTRL_CLR_ENAUTOCLR_CLKGATE_Msk = 0x80000
	// Bit ENAUTOCLR_CLKGATE.
	USBPHY_CTRL_CLR_ENAUTOCLR_CLKGATE = 0x80000
	// Position of ENAUTOCLR_PHY_PWD field.
	USBPHY_CTRL_CLR_ENAUTOCLR_PHY_PWD_Pos = 0x14
	// Bit mask of ENAUTOCLR_PHY_PWD field.
	USBPHY_CTRL_CLR_ENAUTOCLR_PHY_PWD_Msk = 0x100000
	// Bit ENAUTOCLR_PHY_PWD.
	USBPHY_CTRL_CLR_ENAUTOCLR_PHY_PWD = 0x100000
	// Position of ENDPDMCHG_WKUP field.
	USBPHY_CTRL_CLR_ENDPDMCHG_WKUP_Pos = 0x15
	// Bit mask of ENDPDMCHG_WKUP field.
	USBPHY_CTRL_CLR_ENDPDMCHG_WKUP_Msk = 0x200000
	// Bit ENDPDMCHG_WKUP.
	USBPHY_CTRL_CLR_ENDPDMCHG_WKUP = 0x200000
	// Position of ENIDCHG_WKUP field.
	USBPHY_CTRL_CLR_ENIDCHG_WKUP_Pos = 0x16
	// Bit mask of ENIDCHG_WKUP field.
	USBPHY_CTRL_CLR_ENIDCHG_WKUP_Msk = 0x400000
	// Bit ENIDCHG_WKUP.
	USBPHY_CTRL_CLR_ENIDCHG_WKUP = 0x400000
	// Position of ENVBUSCHG_WKUP field.
	USBPHY_CTRL_CLR_ENVBUSCHG_WKUP_Pos = 0x17
	// Bit mask of ENVBUSCHG_WKUP field.
	USBPHY_CTRL_CLR_ENVBUSCHG_WKUP_Msk = 0x800000
	// Bit ENVBUSCHG_WKUP.
	USBPHY_CTRL_CLR_ENVBUSCHG_WKUP = 0x800000
	// Position of FSDLL_RST_EN field.
	USBPHY_CTRL_CLR_FSDLL_RST_EN_Pos = 0x18
	// Bit mask of FSDLL_RST_EN field.
	USBPHY_CTRL_CLR_FSDLL_RST_EN_Msk = 0x1000000
	// Bit FSDLL_RST_EN.
	USBPHY_CTRL_CLR_FSDLL_RST_EN = 0x1000000
	// Position of RSVD1 field.
	USBPHY_CTRL_CLR_RSVD1_Pos = 0x19
	// Bit mask of RSVD1 field.
	USBPHY_CTRL_CLR_RSVD1_Msk = 0x6000000
	// Position of OTG_ID_VALUE field.
	USBPHY_CTRL_CLR_OTG_ID_VALUE_Pos = 0x1b
	// Bit mask of OTG_ID_VALUE field.
	USBPHY_CTRL_CLR_OTG_ID_VALUE_Msk = 0x8000000
	// Bit OTG_ID_VALUE.
	USBPHY_CTRL_CLR_OTG_ID_VALUE = 0x8000000
	// Position of HOST_FORCE_LS_SE0 field.
	USBPHY_CTRL_CLR_HOST_FORCE_LS_SE0_Pos = 0x1c
	// Bit mask of HOST_FORCE_LS_SE0 field.
	USBPHY_CTRL_CLR_HOST_FORCE_LS_SE0_Msk = 0x10000000
	// Bit HOST_FORCE_LS_SE0.
	USBPHY_CTRL_CLR_HOST_FORCE_LS_SE0 = 0x10000000
	// Position of UTMI_SUSPENDM field.
	USBPHY_CTRL_CLR_UTMI_SUSPENDM_Pos = 0x1d
	// Bit mask of UTMI_SUSPENDM field.
	USBPHY_CTRL_CLR_UTMI_SUSPENDM_Msk = 0x20000000
	// Bit UTMI_SUSPENDM.
	USBPHY_CTRL_CLR_UTMI_SUSPENDM = 0x20000000
	// Position of CLKGATE field.
	USBPHY_CTRL_CLR_CLKGATE_Pos = 0x1e
	// Bit mask of CLKGATE field.
	USBPHY_CTRL_CLR_CLKGATE_Msk = 0x40000000
	// Bit CLKGATE.
	USBPHY_CTRL_CLR_CLKGATE = 0x40000000
	// Position of SFTRST field.
	USBPHY_CTRL_CLR_SFTRST_Pos = 0x1f
	// Bit mask of SFTRST field.
	USBPHY_CTRL_CLR_SFTRST_Msk = 0x80000000
	// Bit SFTRST.
	USBPHY_CTRL_CLR_SFTRST = 0x80000000

	// CTRL_TOG: USB PHY General Control Register
	// Position of ENOTG_ID_CHG_IRQ field.
	USBPHY_CTRL_TOG_ENOTG_ID_CHG_IRQ_Pos = 0x0
	// Bit mask of ENOTG_ID_CHG_IRQ field.
	USBPHY_CTRL_TOG_ENOTG_ID_CHG_IRQ_Msk = 0x1
	// Bit ENOTG_ID_CHG_IRQ.
	USBPHY_CTRL_TOG_ENOTG_ID_CHG_IRQ = 0x1
	// Position of ENHOSTDISCONDETECT field.
	USBPHY_CTRL_TOG_ENHOSTDISCONDETECT_Pos = 0x1
	// Bit mask of ENHOSTDISCONDETECT field.
	USBPHY_CTRL_TOG_ENHOSTDISCONDETECT_Msk = 0x2
	// Bit ENHOSTDISCONDETECT.
	USBPHY_CTRL_TOG_ENHOSTDISCONDETECT = 0x2
	// Position of ENIRQHOSTDISCON field.
	USBPHY_CTRL_TOG_ENIRQHOSTDISCON_Pos = 0x2
	// Bit mask of ENIRQHOSTDISCON field.
	USBPHY_CTRL_TOG_ENIRQHOSTDISCON_Msk = 0x4
	// Bit ENIRQHOSTDISCON.
	USBPHY_CTRL_TOG_ENIRQHOSTDISCON = 0x4
	// Position of HOSTDISCONDETECT_IRQ field.
	USBPHY_CTRL_TOG_HOSTDISCONDETECT_IRQ_Pos = 0x3
	// Bit mask of HOSTDISCONDETECT_IRQ field.
	USBPHY_CTRL_TOG_HOSTDISCONDETECT_IRQ_Msk = 0x8
	// Bit HOSTDISCONDETECT_IRQ.
	USBPHY_CTRL_TOG_HOSTDISCONDETECT_IRQ = 0x8
	// Position of ENDEVPLUGINDETECT field.
	USBPHY_CTRL_TOG_ENDEVPLUGINDETECT_Pos = 0x4
	// Bit mask of ENDEVPLUGINDETECT field.
	USBPHY_CTRL_TOG_ENDEVPLUGINDETECT_Msk = 0x10
	// Bit ENDEVPLUGINDETECT.
	USBPHY_CTRL_TOG_ENDEVPLUGINDETECT = 0x10
	// Position of DEVPLUGIN_POLARITY field.
	USBPHY_CTRL_TOG_DEVPLUGIN_POLARITY_Pos = 0x5
	// Bit mask of DEVPLUGIN_POLARITY field.
	USBPHY_CTRL_TOG_DEVPLUGIN_POLARITY_Msk = 0x20
	// Bit DEVPLUGIN_POLARITY.
	USBPHY_CTRL_TOG_DEVPLUGIN_POLARITY = 0x20
	// Position of OTG_ID_CHG_IRQ field.
	USBPHY_CTRL_TOG_OTG_ID_CHG_IRQ_Pos = 0x6
	// Bit mask of OTG_ID_CHG_IRQ field.
	USBPHY_CTRL_TOG_OTG_ID_CHG_IRQ_Msk = 0x40
	// Bit OTG_ID_CHG_IRQ.
	USBPHY_CTRL_TOG_OTG_ID_CHG_IRQ = 0x40
	// Position of ENOTGIDDETECT field.
	USBPHY_CTRL_TOG_ENOTGIDDETECT_Pos = 0x7
	// Bit mask of ENOTGIDDETECT field.
	USBPHY_CTRL_TOG_ENOTGIDDETECT_Msk = 0x80
	// Bit ENOTGIDDETECT.
	USBPHY_CTRL_TOG_ENOTGIDDETECT = 0x80
	// Position of RESUMEIRQSTICKY field.
	USBPHY_CTRL_TOG_RESUMEIRQSTICKY_Pos = 0x8
	// Bit mask of RESUMEIRQSTICKY field.
	USBPHY_CTRL_TOG_RESUMEIRQSTICKY_Msk = 0x100
	// Bit RESUMEIRQSTICKY.
	USBPHY_CTRL_TOG_RESUMEIRQSTICKY = 0x100
	// Position of ENIRQRESUMEDETECT field.
	USBPHY_CTRL_TOG_ENIRQRESUMEDETECT_Pos = 0x9
	// Bit mask of ENIRQRESUMEDETECT field.
	USBPHY_CTRL_TOG_ENIRQRESUMEDETECT_Msk = 0x200
	// Bit ENIRQRESUMEDETECT.
	USBPHY_CTRL_TOG_ENIRQRESUMEDETECT = 0x200
	// Position of RESUME_IRQ field.
	USBPHY_CTRL_TOG_RESUME_IRQ_Pos = 0xa
	// Bit mask of RESUME_IRQ field.
	USBPHY_CTRL_TOG_RESUME_IRQ_Msk = 0x400
	// Bit RESUME_IRQ.
	USBPHY_CTRL_TOG_RESUME_IRQ = 0x400
	// Position of ENIRQDEVPLUGIN field.
	USBPHY_CTRL_TOG_ENIRQDEVPLUGIN_Pos = 0xb
	// Bit mask of ENIRQDEVPLUGIN field.
	USBPHY_CTRL_TOG_ENIRQDEVPLUGIN_Msk = 0x800
	// Bit ENIRQDEVPLUGIN.
	USBPHY_CTRL_TOG_ENIRQDEVPLUGIN = 0x800
	// Position of DEVPLUGIN_IRQ field.
	USBPHY_CTRL_TOG_DEVPLUGIN_IRQ_Pos = 0xc
	// Bit mask of DEVPLUGIN_IRQ field.
	USBPHY_CTRL_TOG_DEVPLUGIN_IRQ_Msk = 0x1000
	// Bit DEVPLUGIN_IRQ.
	USBPHY_CTRL_TOG_DEVPLUGIN_IRQ = 0x1000
	// Position of DATA_ON_LRADC field.
	USBPHY_CTRL_TOG_DATA_ON_LRADC_Pos = 0xd
	// Bit mask of DATA_ON_LRADC field.
	USBPHY_CTRL_TOG_DATA_ON_LRADC_Msk = 0x2000
	// Bit DATA_ON_LRADC.
	USBPHY_CTRL_TOG_DATA_ON_LRADC = 0x2000
	// Position of ENUTMILEVEL2 field.
	USBPHY_CTRL_TOG_ENUTMILEVEL2_Pos = 0xe
	// Bit mask of ENUTMILEVEL2 field.
	USBPHY_CTRL_TOG_ENUTMILEVEL2_Msk = 0x4000
	// Bit ENUTMILEVEL2.
	USBPHY_CTRL_TOG_ENUTMILEVEL2 = 0x4000
	// Position of ENUTMILEVEL3 field.
	USBPHY_CTRL_TOG_ENUTMILEVEL3_Pos = 0xf
	// Bit mask of ENUTMILEVEL3 field.
	USBPHY_CTRL_TOG_ENUTMILEVEL3_Msk = 0x8000
	// Bit ENUTMILEVEL3.
	USBPHY_CTRL_TOG_ENUTMILEVEL3 = 0x8000
	// Position of ENIRQWAKEUP field.
	USBPHY_CTRL_TOG_ENIRQWAKEUP_Pos = 0x10
	// Bit mask of ENIRQWAKEUP field.
	USBPHY_CTRL_TOG_ENIRQWAKEUP_Msk = 0x10000
	// Bit ENIRQWAKEUP.
	USBPHY_CTRL_TOG_ENIRQWAKEUP = 0x10000
	// Position of WAKEUP_IRQ field.
	USBPHY_CTRL_TOG_WAKEUP_IRQ_Pos = 0x11
	// Bit mask of WAKEUP_IRQ field.
	USBPHY_CTRL_TOG_WAKEUP_IRQ_Msk = 0x20000
	// Bit WAKEUP_IRQ.
	USBPHY_CTRL_TOG_WAKEUP_IRQ = 0x20000
	// Position of ENAUTO_PWRON_PLL field.
	USBPHY_CTRL_TOG_ENAUTO_PWRON_PLL_Pos = 0x12
	// Bit mask of ENAUTO_PWRON_PLL field.
	USBPHY_CTRL_TOG_ENAUTO_PWRON_PLL_Msk = 0x40000
	// Bit ENAUTO_PWRON_PLL.
	USBPHY_CTRL_TOG_ENAUTO_PWRON_PLL = 0x40000
	// Position of ENAUTOCLR_CLKGATE field.
	USBPHY_CTRL_TOG_ENAUTOCLR_CLKGATE_Pos = 0x13
	// Bit mask of ENAUTOCLR_CLKGATE field.
	USBPHY_CTRL_TOG_ENAUTOCLR_CLKGATE_Msk = 0x80000
	// Bit ENAUTOCLR_CLKGATE.
	USBPHY_CTRL_TOG_ENAUTOCLR_CLKGATE = 0x80000
	// Position of ENAUTOCLR_PHY_PWD field.
	USBPHY_CTRL_TOG_ENAUTOCLR_PHY_PWD_Pos = 0x14
	// Bit mask of ENAUTOCLR_PHY_PWD field.
	USBPHY_CTRL_TOG_ENAUTOCLR_PHY_PWD_Msk = 0x100000
	// Bit ENAUTOCLR_PHY_PWD.
	USBPHY_CTRL_TOG_ENAUTOCLR_PHY_PWD = 0x100000
	// Position of ENDPDMCHG_WKUP field.
	USBPHY_CTRL_TOG_ENDPDMCHG_WKUP_Pos = 0x15
	// Bit mask of ENDPDMCHG_WKUP field.
	USBPHY_CTRL_TOG_ENDPDMCHG_WKUP_Msk = 0x200000
	// Bit ENDPDMCHG_WKUP.
	USBPHY_CTRL_TOG_ENDPDMCHG_WKUP = 0x200000
	// Position of ENIDCHG_WKUP field.
	USBPHY_CTRL_TOG_ENIDCHG_WKUP_Pos = 0x16
	// Bit mask of ENIDCHG_WKUP field.
	USBPHY_CTRL_TOG_ENIDCHG_WKUP_Msk = 0x400000
	// Bit ENIDCHG_WKUP.
	USBPHY_CTRL_TOG_ENIDCHG_WKUP = 0x400000
	// Position of ENVBUSCHG_WKUP field.
	USBPHY_CTRL_TOG_ENVBUSCHG_WKUP_Pos = 0x17
	// Bit mask of ENVBUSCHG_WKUP field.
	USBPHY_CTRL_TOG_ENVBUSCHG_WKUP_Msk = 0x800000
	// Bit ENVBUSCHG_WKUP.
	USBPHY_CTRL_TOG_ENVBUSCHG_WKUP = 0x800000
	// Position of FSDLL_RST_EN field.
	USBPHY_CTRL_TOG_FSDLL_RST_EN_Pos = 0x18
	// Bit mask of FSDLL_RST_EN field.
	USBPHY_CTRL_TOG_FSDLL_RST_EN_Msk = 0x1000000
	// Bit FSDLL_RST_EN.
	USBPHY_CTRL_TOG_FSDLL_RST_EN = 0x1000000
	// Position of RSVD1 field.
	USBPHY_CTRL_TOG_RSVD1_Pos = 0x19
	// Bit mask of RSVD1 field.
	USBPHY_CTRL_TOG_RSVD1_Msk = 0x6000000
	// Position of OTG_ID_VALUE field.
	USBPHY_CTRL_TOG_OTG_ID_VALUE_Pos = 0x1b
	// Bit mask of OTG_ID_VALUE field.
	USBPHY_CTRL_TOG_OTG_ID_VALUE_Msk = 0x8000000
	// Bit OTG_ID_VALUE.
	USBPHY_CTRL_TOG_OTG_ID_VALUE = 0x8000000
	// Position of HOST_FORCE_LS_SE0 field.
	USBPHY_CTRL_TOG_HOST_FORCE_LS_SE0_Pos = 0x1c
	// Bit mask of HOST_FORCE_LS_SE0 field.
	USBPHY_CTRL_TOG_HOST_FORCE_LS_SE0_Msk = 0x10000000
	// Bit HOST_FORCE_LS_SE0.
	USBPHY_CTRL_TOG_HOST_FORCE_LS_SE0 = 0x10000000
	// Position of UTMI_SUSPENDM field.
	USBPHY_CTRL_TOG_UTMI_SUSPENDM_Pos = 0x1d
	// Bit mask of UTMI_SUSPENDM field.
	USBPHY_CTRL_TOG_UTMI_SUSPENDM_Msk = 0x20000000
	// Bit UTMI_SUSPENDM.
	USBPHY_CTRL_TOG_UTMI_SUSPENDM = 0x20000000
	// Position of CLKGATE field.
	USBPHY_CTRL_TOG_CLKGATE_Pos = 0x1e
	// Bit mask of CLKGATE field.
	USBPHY_CTRL_TOG_CLKGATE_Msk = 0x40000000
	// Bit CLKGATE.
	USBPHY_CTRL_TOG_CLKGATE = 0x40000000
	// Position of SFTRST field.
	USBPHY_CTRL_TOG_SFTRST_Pos = 0x1f
	// Bit mask of SFTRST field.
	USBPHY_CTRL_TOG_SFTRST_Msk = 0x80000000
	// Bit SFTRST.
	USBPHY_CTRL_TOG_SFTRST = 0x80000000

	// STATUS: USB PHY Status Register
	// Position of RSVD0 field.
	USBPHY_STATUS_RSVD0_Pos = 0x0
	// Bit mask of RSVD0 field.
	USBPHY_STATUS_RSVD0_Msk = 0x7
	// Position of HOSTDISCONDETECT_STATUS field.
	USBPHY_STATUS_HOSTDISCONDETECT_STATUS_Pos = 0x3
	// Bit mask of HOSTDISCONDETECT_STATUS field.
	USBPHY_STATUS_HOSTDISCONDETECT_STATUS_Msk = 0x8
	// Bit HOSTDISCONDETECT_STATUS.
	USBPHY_STATUS_HOSTDISCONDETECT_STATUS = 0x8
	// Position of RSVD1 field.
	USBPHY_STATUS_RSVD1_Pos = 0x4
	// Bit mask of RSVD1 field.
	USBPHY_STATUS_RSVD1_Msk = 0x30
	// Position of DEVPLUGIN_STATUS field.
	USBPHY_STATUS_DEVPLUGIN_STATUS_Pos = 0x6
	// Bit mask of DEVPLUGIN_STATUS field.
	USBPHY_STATUS_DEVPLUGIN_STATUS_Msk = 0x40
	// Bit DEVPLUGIN_STATUS.
	USBPHY_STATUS_DEVPLUGIN_STATUS = 0x40
	// Position of RSVD2 field.
	USBPHY_STATUS_RSVD2_Pos = 0x7
	// Bit mask of RSVD2 field.
	USBPHY_STATUS_RSVD2_Msk = 0x80
	// Bit RSVD2.
	USBPHY_STATUS_RSVD2 = 0x80
	// Position of OTGID_STATUS field.
	USBPHY_STATUS_OTGID_STATUS_Pos = 0x8
	// Bit mask of OTGID_STATUS field.
	USBPHY_STATUS_OTGID_STATUS_Msk = 0x100
	// Bit OTGID_STATUS.
	USBPHY_STATUS_OTGID_STATUS = 0x100
	// Position of RSVD3 field.
	USBPHY_STATUS_RSVD3_Pos = 0x9
	// Bit mask of RSVD3 field.
	USBPHY_STATUS_RSVD3_Msk = 0x200
	// Bit RSVD3.
	USBPHY_STATUS_RSVD3 = 0x200
	// Position of RESUME_STATUS field.
	USBPHY_STATUS_RESUME_STATUS_Pos = 0xa
	// Bit mask of RESUME_STATUS field.
	USBPHY_STATUS_RESUME_STATUS_Msk = 0x400
	// Bit RESUME_STATUS.
	USBPHY_STATUS_RESUME_STATUS = 0x400
	// Position of RSVD4 field.
	USBPHY_STATUS_RSVD4_Pos = 0xb
	// Bit mask of RSVD4 field.
	USBPHY_STATUS_RSVD4_Msk = 0xfffff800

	// DEBUG: USB PHY Debug Register
	// Position of OTGIDPIOLOCK field.
	USBPHY_DEBUG_OTGIDPIOLOCK_Pos = 0x0
	// Bit mask of OTGIDPIOLOCK field.
	USBPHY_DEBUG_OTGIDPIOLOCK_Msk = 0x1
	// Bit OTGIDPIOLOCK.
	USBPHY_DEBUG_OTGIDPIOLOCK = 0x1
	// Position of DEBUG_INTERFACE_HOLD field.
	USBPHY_DEBUG_DEBUG_INTERFACE_HOLD_Pos = 0x1
	// Bit mask of DEBUG_INTERFACE_HOLD field.
	USBPHY_DEBUG_DEBUG_INTERFACE_HOLD_Msk = 0x2
	// Bit DEBUG_INTERFACE_HOLD.
	USBPHY_DEBUG_DEBUG_INTERFACE_HOLD = 0x2
	// Position of HSTPULLDOWN field.
	USBPHY_DEBUG_HSTPULLDOWN_Pos = 0x2
	// Bit mask of HSTPULLDOWN field.
	USBPHY_DEBUG_HSTPULLDOWN_Msk = 0xc
	// Position of ENHSTPULLDOWN field.
	USBPHY_DEBUG_ENHSTPULLDOWN_Pos = 0x4
	// Bit mask of ENHSTPULLDOWN field.
	USBPHY_DEBUG_ENHSTPULLDOWN_Msk = 0x30
	// Position of RSVD0 field.
	USBPHY_DEBUG_RSVD0_Pos = 0x6
	// Bit mask of RSVD0 field.
	USBPHY_DEBUG_RSVD0_Msk = 0xc0
	// Position of TX2RXCOUNT field.
	USBPHY_DEBUG_TX2RXCOUNT_Pos = 0x8
	// Bit mask of TX2RXCOUNT field.
	USBPHY_DEBUG_TX2RXCOUNT_Msk = 0xf00
	// Position of ENTX2RXCOUNT field.
	USBPHY_DEBUG_ENTX2RXCOUNT_Pos = 0xc
	// Bit mask of ENTX2RXCOUNT field.
	USBPHY_DEBUG_ENTX2RXCOUNT_Msk = 0x1000
	// Bit ENTX2RXCOUNT.
	USBPHY_DEBUG_ENTX2RXCOUNT = 0x1000
	// Position of RSVD1 field.
	USBPHY_DEBUG_RSVD1_Pos = 0xd
	// Bit mask of RSVD1 field.
	USBPHY_DEBUG_RSVD1_Msk = 0xe000
	// Position of SQUELCHRESETCOUNT field.
	USBPHY_DEBUG_SQUELCHRESETCOUNT_Pos = 0x10
	// Bit mask of SQUELCHRESETCOUNT field.
	USBPHY_DEBUG_SQUELCHRESETCOUNT_Msk = 0x1f0000
	// Position of RSVD2 field.
	USBPHY_DEBUG_RSVD2_Pos = 0x15
	// Bit mask of RSVD2 field.
	USBPHY_DEBUG_RSVD2_Msk = 0xe00000
	// Position of ENSQUELCHRESET field.
	USBPHY_DEBUG_ENSQUELCHRESET_Pos = 0x18
	// Bit mask of ENSQUELCHRESET field.
	USBPHY_DEBUG_ENSQUELCHRESET_Msk = 0x1000000
	// Bit ENSQUELCHRESET.
	USBPHY_DEBUG_ENSQUELCHRESET = 0x1000000
	// Position of SQUELCHRESETLENGTH field.
	USBPHY_DEBUG_SQUELCHRESETLENGTH_Pos = 0x19
	// Bit mask of SQUELCHRESETLENGTH field.
	USBPHY_DEBUG_SQUELCHRESETLENGTH_Msk = 0x1e000000
	// Position of HOST_RESUME_DEBUG field.
	USBPHY_DEBUG_HOST_RESUME_DEBUG_Pos = 0x1d
	// Bit mask of HOST_RESUME_DEBUG field.
	USBPHY_DEBUG_HOST_RESUME_DEBUG_Msk = 0x20000000
	// Bit HOST_RESUME_DEBUG.
	USBPHY_DEBUG_HOST_RESUME_DEBUG = 0x20000000
	// Position of CLKGATE field.
	USBPHY_DEBUG_CLKGATE_Pos = 0x1e
	// Bit mask of CLKGATE field.
	USBPHY_DEBUG_CLKGATE_Msk = 0x40000000
	// Bit CLKGATE.
	USBPHY_DEBUG_CLKGATE = 0x40000000
	// Position of RSVD3 field.
	USBPHY_DEBUG_RSVD3_Pos = 0x1f
	// Bit mask of RSVD3 field.
	USBPHY_DEBUG_RSVD3_Msk = 0x80000000
	// Bit RSVD3.
	USBPHY_DEBUG_RSVD3 = 0x80000000

	// DEBUG_SET: USB PHY Debug Register
	// Position of OTGIDPIOLOCK field.
	USBPHY_DEBUG_SET_OTGIDPIOLOCK_Pos = 0x0
	// Bit mask of OTGIDPIOLOCK field.
	USBPHY_DEBUG_SET_OTGIDPIOLOCK_Msk = 0x1
	// Bit OTGIDPIOLOCK.
	USBPHY_DEBUG_SET_OTGIDPIOLOCK = 0x1
	// Position of DEBUG_INTERFACE_HOLD field.
	USBPHY_DEBUG_SET_DEBUG_INTERFACE_HOLD_Pos = 0x1
	// Bit mask of DEBUG_INTERFACE_HOLD field.
	USBPHY_DEBUG_SET_DEBUG_INTERFACE_HOLD_Msk = 0x2
	// Bit DEBUG_INTERFACE_HOLD.
	USBPHY_DEBUG_SET_DEBUG_INTERFACE_HOLD = 0x2
	// Position of HSTPULLDOWN field.
	USBPHY_DEBUG_SET_HSTPULLDOWN_Pos = 0x2
	// Bit mask of HSTPULLDOWN field.
	USBPHY_DEBUG_SET_HSTPULLDOWN_Msk = 0xc
	// Position of ENHSTPULLDOWN field.
	USBPHY_DEBUG_SET_ENHSTPULLDOWN_Pos = 0x4
	// Bit mask of ENHSTPULLDOWN field.
	USBPHY_DEBUG_SET_ENHSTPULLDOWN_Msk = 0x30
	// Position of RSVD0 field.
	USBPHY_DEBUG_SET_RSVD0_Pos = 0x6
	// Bit mask of RSVD0 field.
	USBPHY_DEBUG_SET_RSVD0_Msk = 0xc0
	// Position of TX2RXCOUNT field.
	USBPHY_DEBUG_SET_TX2RXCOUNT_Pos = 0x8
	// Bit mask of TX2RXCOUNT field.
	USBPHY_DEBUG_SET_TX2RXCOUNT_Msk = 0xf00
	// Position of ENTX2RXCOUNT field.
	USBPHY_DEBUG_SET_ENTX2RXCOUNT_Pos = 0xc
	// Bit mask of ENTX2RXCOUNT field.
	USBPHY_DEBUG_SET_ENTX2RXCOUNT_Msk = 0x1000
	// Bit ENTX2RXCOUNT.
	USBPHY_DEBUG_SET_ENTX2RXCOUNT = 0x1000
	// Position of RSVD1 field.
	USBPHY_DEBUG_SET_RSVD1_Pos = 0xd
	// Bit mask of RSVD1 field.
	USBPHY_DEBUG_SET_RSVD1_Msk = 0xe000
	// Position of SQUELCHRESETCOUNT field.
	USBPHY_DEBUG_SET_SQUELCHRESETCOUNT_Pos = 0x10
	// Bit mask of SQUELCHRESETCOUNT field.
	USBPHY_DEBUG_SET_SQUELCHRESETCOUNT_Msk = 0x1f0000
	// Position of RSVD2 field.
	USBPHY_DEBUG_SET_RSVD2_Pos = 0x15
	// Bit mask of RSVD2 field.
	USBPHY_DEBUG_SET_RSVD2_Msk = 0xe00000
	// Position of ENSQUELCHRESET field.
	USBPHY_DEBUG_SET_ENSQUELCHRESET_Pos = 0x18
	// Bit mask of ENSQUELCHRESET field.
	USBPHY_DEBUG_SET_ENSQUELCHRESET_Msk = 0x1000000
	// Bit ENSQUELCHRESET.
	USBPHY_DEBUG_SET_ENSQUELCHRESET = 0x1000000
	// Position of SQUELCHRESETLENGTH field.
	USBPHY_DEBUG_SET_SQUELCHRESETLENGTH_Pos = 0x19
	// Bit mask of SQUELCHRESETLENGTH field.
	USBPHY_DEBUG_SET_SQUELCHRESETLENGTH_Msk = 0x1e000000
	// Position of HOST_RESUME_DEBUG field.
	USBPHY_DEBUG_SET_HOST_RESUME_DEBUG_Pos = 0x1d
	// Bit mask of HOST_RESUME_DEBUG field.
	USBPHY_DEBUG_SET_HOST_RESUME_DEBUG_Msk = 0x20000000
	// Bit HOST_RESUME_DEBUG.
	USBPHY_DEBUG_SET_HOST_RESUME_DEBUG = 0x20000000
	// Position of CLKGATE field.
	USBPHY_DEBUG_SET_CLKGATE_Pos = 0x1e
	// Bit mask of CLKGATE field.
	USBPHY_DEBUG_SET_CLKGATE_Msk = 0x40000000
	// Bit CLKGATE.
	USBPHY_DEBUG_SET_CLKGATE = 0x40000000
	// Position of RSVD3 field.
	USBPHY_DEBUG_SET_RSVD3_Pos = 0x1f
	// Bit mask of RSVD3 field.
	USBPHY_DEBUG_SET_RSVD3_Msk = 0x80000000
	// Bit RSVD3.
	USBPHY_DEBUG_SET_RSVD3 = 0x80000000

	// DEBUG_CLR: USB PHY Debug Register
	// Position of OTGIDPIOLOCK field.
	USBPHY_DEBUG_CLR_OTGIDPIOLOCK_Pos = 0x0
	// Bit mask of OTGIDPIOLOCK field.
	USBPHY_DEBUG_CLR_OTGIDPIOLOCK_Msk = 0x1
	// Bit OTGIDPIOLOCK.
	USBPHY_DEBUG_CLR_OTGIDPIOLOCK = 0x1
	// Position of DEBUG_INTERFACE_HOLD field.
	USBPHY_DEBUG_CLR_DEBUG_INTERFACE_HOLD_Pos = 0x1
	// Bit mask of DEBUG_INTERFACE_HOLD field.
	USBPHY_DEBUG_CLR_DEBUG_INTERFACE_HOLD_Msk = 0x2
	// Bit DEBUG_INTERFACE_HOLD.
	USBPHY_DEBUG_CLR_DEBUG_INTERFACE_HOLD = 0x2
	// Position of HSTPULLDOWN field.
	USBPHY_DEBUG_CLR_HSTPULLDOWN_Pos = 0x2
	// Bit mask of HSTPULLDOWN field.
	USBPHY_DEBUG_CLR_HSTPULLDOWN_Msk = 0xc
	// Position of ENHSTPULLDOWN field.
	USBPHY_DEBUG_CLR_ENHSTPULLDOWN_Pos = 0x4
	// Bit mask of ENHSTPULLDOWN field.
	USBPHY_DEBUG_CLR_ENHSTPULLDOWN_Msk = 0x30
	// Position of RSVD0 field.
	USBPHY_DEBUG_CLR_RSVD0_Pos = 0x6
	// Bit mask of RSVD0 field.
	USBPHY_DEBUG_CLR_RSVD0_Msk = 0xc0
	// Position of TX2RXCOUNT field.
	USBPHY_DEBUG_CLR_TX2RXCOUNT_Pos = 0x8
	// Bit mask of TX2RXCOUNT field.
	USBPHY_DEBUG_CLR_TX2RXCOUNT_Msk = 0xf00
	// Position of ENTX2RXCOUNT field.
	USBPHY_DEBUG_CLR_ENTX2RXCOUNT_Pos = 0xc
	// Bit mask of ENTX2RXCOUNT field.
	USBPHY_DEBUG_CLR_ENTX2RXCOUNT_Msk = 0x1000
	// Bit ENTX2RXCOUNT.
	USBPHY_DEBUG_CLR_ENTX2RXCOUNT = 0x1000
	// Position of RSVD1 field.
	USBPHY_DEBUG_CLR_RSVD1_Pos = 0xd
	// Bit mask of RSVD1 field.
	USBPHY_DEBUG_CLR_RSVD1_Msk = 0xe000
	// Position of SQUELCHRESETCOUNT field.
	USBPHY_DEBUG_CLR_SQUELCHRESETCOUNT_Pos = 0x10
	// Bit mask of SQUELCHRESETCOUNT field.
	USBPHY_DEBUG_CLR_SQUELCHRESETCOUNT_Msk = 0x1f0000
	// Position of RSVD2 field.
	USBPHY_DEBUG_CLR_RSVD2_Pos = 0x15
	// Bit mask of RSVD2 field.
	USBPHY_DEBUG_CLR_RSVD2_Msk = 0xe00000
	// Position of ENSQUELCHRESET field.
	USBPHY_DEBUG_CLR_ENSQUELCHRESET_Pos = 0x18
	// Bit mask of ENSQUELCHRESET field.
	USBPHY_DEBUG_CLR_ENSQUELCHRESET_Msk = 0x1000000
	// Bit ENSQUELCHRESET.
	USBPHY_DEBUG_CLR_ENSQUELCHRESET = 0x1000000
	// Position of SQUELCHRESETLENGTH field.
	USBPHY_DEBUG_CLR_SQUELCHRESETLENGTH_Pos = 0x19
	// Bit mask of SQUELCHRESETLENGTH field.
	USBPHY_DEBUG_CLR_SQUELCHRESETLENGTH_Msk = 0x1e000000
	// Position of HOST_RESUME_DEBUG field.
	USBPHY_DEBUG_CLR_HOST_RESUME_DEBUG_Pos = 0x1d
	// Bit mask of HOST_RESUME_DEBUG field.
	USBPHY_DEBUG_CLR_HOST_RESUME_DEBUG_Msk = 0x20000000
	// Bit HOST_RESUME_DEBUG.
	USBPHY_DEBUG_CLR_HOST_RESUME_DEBUG = 0x20000000
	// Position of CLKGATE field.
	USBPHY_DEBUG_CLR_CLKGATE_Pos = 0x1e
	// Bit mask of CLKGATE field.
	USBPHY_DEBUG_CLR_CLKGATE_Msk = 0x40000000
	// Bit CLKGATE.
	USBPHY_DEBUG_CLR_CLKGATE = 0x40000000
	// Position of RSVD3 field.
	USBPHY_DEBUG_CLR_RSVD3_Pos = 0x1f
	// Bit mask of RSVD3 field.
	USBPHY_DEBUG_CLR_RSVD3_Msk = 0x80000000
	// Bit RSVD3.
	USBPHY_DEBUG_CLR_RSVD3 = 0x80000000

	// DEBUG_TOG: USB PHY Debug Register
	// Position of OTGIDPIOLOCK field.
	USBPHY_DEBUG_TOG_OTGIDPIOLOCK_Pos = 0x0
	// Bit mask of OTGIDPIOLOCK field.
	USBPHY_DEBUG_TOG_OTGIDPIOLOCK_Msk = 0x1
	// Bit OTGIDPIOLOCK.
	USBPHY_DEBUG_TOG_OTGIDPIOLOCK = 0x1
	// Position of DEBUG_INTERFACE_HOLD field.
	USBPHY_DEBUG_TOG_DEBUG_INTERFACE_HOLD_Pos = 0x1
	// Bit mask of DEBUG_INTERFACE_HOLD field.
	USBPHY_DEBUG_TOG_DEBUG_INTERFACE_HOLD_Msk = 0x2
	// Bit DEBUG_INTERFACE_HOLD.
	USBPHY_DEBUG_TOG_DEBUG_INTERFACE_HOLD = 0x2
	// Position of HSTPULLDOWN field.
	USBPHY_DEBUG_TOG_HSTPULLDOWN_Pos = 0x2
	// Bit mask of HSTPULLDOWN field.
	USBPHY_DEBUG_TOG_HSTPULLDOWN_Msk = 0xc
	// Position of ENHSTPULLDOWN field.
	USBPHY_DEBUG_TOG_ENHSTPULLDOWN_Pos = 0x4
	// Bit mask of ENHSTPULLDOWN field.
	USBPHY_DEBUG_TOG_ENHSTPULLDOWN_Msk = 0x30
	// Position of RSVD0 field.
	USBPHY_DEBUG_TOG_RSVD0_Pos = 0x6
	// Bit mask of RSVD0 field.
	USBPHY_DEBUG_TOG_RSVD0_Msk = 0xc0
	// Position of TX2RXCOUNT field.
	USBPHY_DEBUG_TOG_TX2RXCOUNT_Pos = 0x8
	// Bit mask of TX2RXCOUNT field.
	USBPHY_DEBUG_TOG_TX2RXCOUNT_Msk = 0xf00
	// Position of ENTX2RXCOUNT field.
	USBPHY_DEBUG_TOG_ENTX2RXCOUNT_Pos = 0xc
	// Bit mask of ENTX2RXCOUNT field.
	USBPHY_DEBUG_TOG_ENTX2RXCOUNT_Msk = 0x1000
	// Bit ENTX2RXCOUNT.
	USBPHY_DEBUG_TOG_ENTX2RXCOUNT = 0x1000
	// Position of RSVD1 field.
	USBPHY_DEBUG_TOG_RSVD1_Pos = 0xd
	// Bit mask of RSVD1 field.
	USBPHY_DEBUG_TOG_RSVD1_Msk = 0xe000
	// Position of SQUELCHRESETCOUNT field.
	USBPHY_DEBUG_TOG_SQUELCHRESETCOUNT_Pos = 0x10
	// Bit mask of SQUELCHRESETCOUNT field.
	USBPHY_DEBUG_TOG_SQUELCHRESETCOUNT_Msk = 0x1f0000
	// Position of RSVD2 field.
	USBPHY_DEBUG_TOG_RSVD2_Pos = 0x15
	// Bit mask of RSVD2 field.
	USBPHY_DEBUG_TOG_RSVD2_Msk = 0xe00000
	// Position of ENSQUELCHRESET field.
	USBPHY_DEBUG_TOG_ENSQUELCHRESET_Pos = 0x18
	// Bit mask of ENSQUELCHRESET field.
	USBPHY_DEBUG_TOG_ENSQUELCHRESET_Msk = 0x1000000
	// Bit ENSQUELCHRESET.
	USBPHY_DEBUG_TOG_ENSQUELCHRESET = 0x1000000
	// Position of SQUELCHRESETLENGTH field.
	USBPHY_DEBUG_TOG_SQUELCHRESETLENGTH_Pos = 0x19
	// Bit mask of SQUELCHRESETLENGTH field.
	USBPHY_DEBUG_TOG_SQUELCHRESETLENGTH_Msk = 0x1e000000
	// Position of HOST_RESUME_DEBUG field.
	USBPHY_DEBUG_TOG_HOST_RESUME_DEBUG_Pos = 0x1d
	// Bit mask of HOST_RESUME_DEBUG field.
	USBPHY_DEBUG_TOG_HOST_RESUME_DEBUG_Msk = 0x20000000
	// Bit HOST_RESUME_DEBUG.
	USBPHY_DEBUG_TOG_HOST_RESUME_DEBUG = 0x20000000
	// Position of CLKGATE field.
	USBPHY_DEBUG_TOG_CLKGATE_Pos = 0x1e
	// Bit mask of CLKGATE field.
	USBPHY_DEBUG_TOG_CLKGATE_Msk = 0x40000000
	// Bit CLKGATE.
	USBPHY_DEBUG_TOG_CLKGATE = 0x40000000
	// Position of RSVD3 field.
	USBPHY_DEBUG_TOG_RSVD3_Pos = 0x1f
	// Bit mask of RSVD3 field.
	USBPHY_DEBUG_TOG_RSVD3_Msk = 0x80000000
	// Bit RSVD3.
	USBPHY_DEBUG_TOG_RSVD3 = 0x80000000

	// DEBUG0_STATUS: UTMI Debug Status Register 0
	// Position of LOOP_BACK_FAIL_COUNT field.
	USBPHY_DEBUG0_STATUS_LOOP_BACK_FAIL_COUNT_Pos = 0x0
	// Bit mask of LOOP_BACK_FAIL_COUNT field.
	USBPHY_DEBUG0_STATUS_LOOP_BACK_FAIL_COUNT_Msk = 0xffff
	// Position of UTMI_RXERROR_FAIL_COUNT field.
	USBPHY_DEBUG0_STATUS_UTMI_RXERROR_FAIL_COUNT_Pos = 0x10
	// Bit mask of UTMI_RXERROR_FAIL_COUNT field.
	USBPHY_DEBUG0_STATUS_UTMI_RXERROR_FAIL_COUNT_Msk = 0x3ff0000
	// Position of SQUELCH_COUNT field.
	USBPHY_DEBUG0_STATUS_SQUELCH_COUNT_Pos = 0x1a
	// Bit mask of SQUELCH_COUNT field.
	USBPHY_DEBUG0_STATUS_SQUELCH_COUNT_Msk = 0xfc000000

	// DEBUG1: UTMI Debug Status Register 1
	// Position of RSVD0 field.
	USBPHY_DEBUG1_RSVD0_Pos = 0x0
	// Bit mask of RSVD0 field.
	USBPHY_DEBUG1_RSVD0_Msk = 0x1fff
	// Position of ENTAILADJVD field.
	USBPHY_DEBUG1_ENTAILADJVD_Pos = 0xd
	// Bit mask of ENTAILADJVD field.
	USBPHY_DEBUG1_ENTAILADJVD_Msk = 0x6000
	// Position of RSVD1 field.
	USBPHY_DEBUG1_RSVD1_Pos = 0xf
	// Bit mask of RSVD1 field.
	USBPHY_DEBUG1_RSVD1_Msk = 0xffff8000

	// DEBUG1_SET: UTMI Debug Status Register 1
	// Position of RSVD0 field.
	USBPHY_DEBUG1_SET_RSVD0_Pos = 0x0
	// Bit mask of RSVD0 field.
	USBPHY_DEBUG1_SET_RSVD0_Msk = 0x1fff
	// Position of ENTAILADJVD field.
	USBPHY_DEBUG1_SET_ENTAILADJVD_Pos = 0xd
	// Bit mask of ENTAILADJVD field.
	USBPHY_DEBUG1_SET_ENTAILADJVD_Msk = 0x6000
	// Position of RSVD1 field.
	USBPHY_DEBUG1_SET_RSVD1_Pos = 0xf
	// Bit mask of RSVD1 field.
	USBPHY_DEBUG1_SET_RSVD1_Msk = 0xffff8000

	// DEBUG1_CLR: UTMI Debug Status Register 1
	// Position of RSVD0 field.
	USBPHY_DEBUG1_CLR_RSVD0_Pos = 0x0
	// Bit mask of RSVD0 field.
	USBPHY_DEBUG1_CLR_RSVD0_Msk = 0x1fff
	// Position of ENTAILADJVD field.
	USBPHY_DEBUG1_CLR_ENTAILADJVD_Pos = 0xd
	// Bit mask of ENTAILADJVD field.
	USBPHY_DEBUG1_CLR_ENTAILADJVD_Msk = 0x6000
	// Position of RSVD1 field.
	USBPHY_DEBUG1_CLR_RSVD1_Pos = 0xf
	// Bit mask of RSVD1 field.
	USBPHY_DEBUG1_CLR_RSVD1_Msk = 0xffff8000

	// DEBUG1_TOG: UTMI Debug Status Register 1
	// Position of RSVD0 field.
	USBPHY_DEBUG1_TOG_RSVD0_Pos = 0x0
	// Bit mask of RSVD0 field.
	USBPHY_DEBUG1_TOG_RSVD0_Msk = 0x1fff
	// Position of ENTAILADJVD field.
	USBPHY_DEBUG1_TOG_ENTAILADJVD_Pos = 0xd
	// Bit mask of ENTAILADJVD field.
	USBPHY_DEBUG1_TOG_ENTAILADJVD_Msk = 0x6000
	// Position of RSVD1 field.
	USBPHY_DEBUG1_TOG_RSVD1_Pos = 0xf
	// Bit mask of RSVD1 field.
	USBPHY_DEBUG1_TOG_RSVD1_Msk = 0xffff8000

	// VERSION: UTMI RTL Version
	// Position of STEP field.
	USBPHY_VERSION_STEP_Pos = 0x0
	// Bit mask of STEP field.
	USBPHY_VERSION_STEP_Msk = 0xffff
	// Position of MINOR field.
	USBPHY_VERSION_MINOR_Pos = 0x10
	// Bit mask of MINOR field.
	USBPHY_VERSION_MINOR_Msk = 0xff0000
	// Position of MAJOR field.
	USBPHY_VERSION_MAJOR_Pos = 0x18
	// Bit mask of MAJOR field.
	USBPHY_VERSION_MAJOR_Msk = 0xff000000
)

// Bitfields for CSU: CSU registers
const (
	// CSL0: Config security level register
	// Position of SUR_S2 field.
	CSU_CSL_SUR_S2_Pos = 0x0
	// Bit mask of SUR_S2 field.
	CSU_CSL_SUR_S2_Msk = 0x1
	// Bit SUR_S2.
	CSU_CSL_SUR_S2 = 0x1
	// The secure user read access is disabled for the second slave.
	CSU_CSL_SUR_S2_SUR_S2_0 = 0x0
	// The secure user read access is enabled for the second slave.
	CSU_CSL_SUR_S2_SUR_S2_1 = 0x1
	// Position of SSR_S2 field.
	CSU_CSL_SSR_S2_Pos = 0x1
	// Bit mask of SSR_S2 field.
	CSU_CSL_SSR_S2_Msk = 0x2
	// Bit SSR_S2.
	CSU_CSL_SSR_S2 = 0x2
	// The secure supervisor read access is disabled for the second slave.
	CSU_CSL_SSR_S2_SSR_S2_0 = 0x0
	// The secure supervisor read access is enabled for the second slave.
	CSU_CSL_SSR_S2_SSR_S2_1 = 0x1
	// Position of NUR_S2 field.
	CSU_CSL_NUR_S2_Pos = 0x2
	// Bit mask of NUR_S2 field.
	CSU_CSL_NUR_S2_Msk = 0x4
	// Bit NUR_S2.
	CSU_CSL_NUR_S2 = 0x4
	// The non-secure user read access is disabled for the second slave.
	CSU_CSL_NUR_S2_NUR_S2_0 = 0x0
	// The non-secure user read access is enabled for the second slave.
	CSU_CSL_NUR_S2_NUR_S2_1 = 0x1
	// Position of NSR_S2 field.
	CSU_CSL_NSR_S2_Pos = 0x3
	// Bit mask of NSR_S2 field.
	CSU_CSL_NSR_S2_Msk = 0x8
	// Bit NSR_S2.
	CSU_CSL_NSR_S2 = 0x8
	// The non-secure supervisor read access is disabled for the second slave.
	CSU_CSL_NSR_S2_NSR_S2_0 = 0x0
	// The non-secure supervisor read access is enabled for the second slave.
	CSU_CSL_NSR_S2_NSR_S2_1 = 0x1
	// Position of SUW_S2 field.
	CSU_CSL_SUW_S2_Pos = 0x4
	// Bit mask of SUW_S2 field.
	CSU_CSL_SUW_S2_Msk = 0x10
	// Bit SUW_S2.
	CSU_CSL_SUW_S2 = 0x10
	// The secure user write access is disabled for the second slave.
	CSU_CSL_SUW_S2_SUW_S2_0 = 0x0
	// The secure user write access is enabled for the second slave.
	CSU_CSL_SUW_S2_SUW_S2_1 = 0x1
	// Position of SSW_S2 field.
	CSU_CSL_SSW_S2_Pos = 0x5
	// Bit mask of SSW_S2 field.
	CSU_CSL_SSW_S2_Msk = 0x20
	// Bit SSW_S2.
	CSU_CSL_SSW_S2 = 0x20
	// The secure supervisor write access is disabled for the second slave.
	CSU_CSL_SSW_S2_SSW_S2_0 = 0x0
	// The secure supervisor write access is enabled for the second slave.
	CSU_CSL_SSW_S2_SSW_S2_1 = 0x1
	// Position of NUW_S2 field.
	CSU_CSL_NUW_S2_Pos = 0x6
	// Bit mask of NUW_S2 field.
	CSU_CSL_NUW_S2_Msk = 0x40
	// Bit NUW_S2.
	CSU_CSL_NUW_S2 = 0x40
	// The non-secure user write access is disabled for the second slave.
	CSU_CSL_NUW_S2_NUW_S2_0 = 0x0
	// The non-secure user write access is enabled for the second slave.
	CSU_CSL_NUW_S2_NUW_S2_1 = 0x1
	// Position of NSW_S2 field.
	CSU_CSL_NSW_S2_Pos = 0x7
	// Bit mask of NSW_S2 field.
	CSU_CSL_NSW_S2_Msk = 0x80
	// Bit NSW_S2.
	CSU_CSL_NSW_S2 = 0x80
	// The non-secure supervisor write access is disabled for the second slave.
	CSU_CSL_NSW_S2_NSW_S2_0 = 0x0
	// The non-secure supervisor write access is enabled for the second slave.
	CSU_CSL_NSW_S2_NSW_S2_1 = 0x1
	// Position of LOCK_S2 field.
	CSU_CSL_LOCK_S2_Pos = 0x8
	// Bit mask of LOCK_S2 field.
	CSU_CSL_LOCK_S2_Msk = 0x100
	// Bit LOCK_S2.
	CSU_CSL_LOCK_S2 = 0x100
	// Not locked. Bits 7-0 can be written by the software.
	CSU_CSL_LOCK_S2_LOCK_S2_0 = 0x0
	// Bits 7-0 are locked and cannot be written by the software
	CSU_CSL_LOCK_S2_LOCK_S2_1 = 0x1
	// Position of SUR_S1 field.
	CSU_CSL_SUR_S1_Pos = 0x10
	// Bit mask of SUR_S1 field.
	CSU_CSL_SUR_S1_Msk = 0x10000
	// Bit SUR_S1.
	CSU_CSL_SUR_S1 = 0x10000
	// The secure user read access is disabled for the first slave.
	CSU_CSL_SUR_S1_SUR_S1_0 = 0x0
	// The secure user read access is enabled for the first slave.
	CSU_CSL_SUR_S1_SUR_S1_1 = 0x1
	// Position of SSR_S1 field.
	CSU_CSL_SSR_S1_Pos = 0x11
	// Bit mask of SSR_S1 field.
	CSU_CSL_SSR_S1_Msk = 0x20000
	// Bit SSR_S1.
	CSU_CSL_SSR_S1 = 0x20000
	// The secure supervisor read access is disabled for the first slave.
	CSU_CSL_SSR_S1_SSR_S1_0 = 0x0
	// The secure supervisor read access is enabled for the first slave.
	CSU_CSL_SSR_S1_SSR_S1_1 = 0x1
	// Position of NUR_S1 field.
	CSU_CSL_NUR_S1_Pos = 0x12
	// Bit mask of NUR_S1 field.
	CSU_CSL_NUR_S1_Msk = 0x40000
	// Bit NUR_S1.
	CSU_CSL_NUR_S1 = 0x40000
	// The non-secure user read access is disabled for the first slave.
	CSU_CSL_NUR_S1_NUR_S1_0 = 0x0
	// The non-secure user read access is enabled for the first slave.
	CSU_CSL_NUR_S1_NUR_S1_1 = 0x1
	// Position of NSR_S1 field.
	CSU_CSL_NSR_S1_Pos = 0x13
	// Bit mask of NSR_S1 field.
	CSU_CSL_NSR_S1_Msk = 0x80000
	// Bit NSR_S1.
	CSU_CSL_NSR_S1 = 0x80000
	// The non-secure supervisor read access is disabled for the first slave.
	CSU_CSL_NSR_S1_NSR_S1_0 = 0x0
	// The non-secure supervisor read access is enabled for the first slave.
	CSU_CSL_NSR_S1_NSR_S1_1 = 0x1
	// Position of SUW_S1 field.
	CSU_CSL_SUW_S1_Pos = 0x14
	// Bit mask of SUW_S1 field.
	CSU_CSL_SUW_S1_Msk = 0x100000
	// Bit SUW_S1.
	CSU_CSL_SUW_S1 = 0x100000
	// The secure user write access is disabled for the first slave.
	CSU_CSL_SUW_S1_SUW_S1_0 = 0x0
	// The secure user write access is enabled for the first slave.
	CSU_CSL_SUW_S1_SUW_S1_1 = 0x1
	// Position of SSW_S1 field.
	CSU_CSL_SSW_S1_Pos = 0x15
	// Bit mask of SSW_S1 field.
	CSU_CSL_SSW_S1_Msk = 0x200000
	// Bit SSW_S1.
	CSU_CSL_SSW_S1 = 0x200000
	// The secure supervisor write access is disabled for the first slave.
	CSU_CSL_SSW_S1_SSW_S1_0 = 0x0
	// The secure supervisor write access is enabled for the first slave.
	CSU_CSL_SSW_S1_SSW_S1_1 = 0x1
	// Position of NUW_S1 field.
	CSU_CSL_NUW_S1_Pos = 0x16
	// Bit mask of NUW_S1 field.
	CSU_CSL_NUW_S1_Msk = 0x400000
	// Bit NUW_S1.
	CSU_CSL_NUW_S1 = 0x400000
	// The non-secure user write access is disabled for the first slave.
	CSU_CSL_NUW_S1_NUW_S1_0 = 0x0
	// The non-secure user write access is enabled for the first slave.
	CSU_CSL_NUW_S1_NUW_S1_1 = 0x1
	// Position of NSW_S1 field.
	CSU_CSL_NSW_S1_Pos = 0x17
	// Bit mask of NSW_S1 field.
	CSU_CSL_NSW_S1_Msk = 0x800000
	// Bit NSW_S1.
	CSU_CSL_NSW_S1 = 0x800000
	// The non-secure supervisor write access is disabled for the first slave.
	CSU_CSL_NSW_S1_NSW_S1_0 = 0x0
	// The non-secure supervisor write access is enabled for the first slave
	CSU_CSL_NSW_S1_NSW_S1_1 = 0x1
	// Position of LOCK_S1 field.
	CSU_CSL_LOCK_S1_Pos = 0x18
	// Bit mask of LOCK_S1 field.
	CSU_CSL_LOCK_S1_Msk = 0x1000000
	// Bit LOCK_S1.
	CSU_CSL_LOCK_S1 = 0x1000000
	// Not locked. The bits 16-23 can be written by the software.
	CSU_CSL_LOCK_S1_LOCK_S1_0 = 0x0
	// The bits 16-23 are locked and can't be written by the software.
	CSU_CSL_LOCK_S1_LOCK_S1_1 = 0x1

	// HP0: HP0 register
	// Position of HP_DMA field.
	CSU_HP0_HP_DMA_Pos = 0x2
	// Bit mask of HP_DMA field.
	CSU_HP0_HP_DMA_Msk = 0x4
	// Bit HP_DMA.
	CSU_HP0_HP_DMA = 0x4
	// The hprot1 input signal value is routed to the csu_hprot1 output for the corresponding master.
	CSU_HP0_HP_DMA_HP_DMA_0 = 0x0
	// The HP register bit is routed to the csu_hprot1 output for the corresponding master.
	CSU_HP0_HP_DMA_HP_DMA_1 = 0x1
	// Position of L_DMA field.
	CSU_HP0_L_DMA_Pos = 0x3
	// Bit mask of L_DMA field.
	CSU_HP0_L_DMA_Msk = 0x8
	// Bit L_DMA.
	CSU_HP0_L_DMA = 0x8
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_HP0_L_DMA_L_DMA_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_HP0_L_DMA_L_DMA_1 = 0x1
	// Position of HP_LCDIF field.
	CSU_HP0_HP_LCDIF_Pos = 0x4
	// Bit mask of HP_LCDIF field.
	CSU_HP0_HP_LCDIF_Msk = 0x10
	// Bit HP_LCDIF.
	CSU_HP0_HP_LCDIF = 0x10
	// The hprot1 input signal value is routed to the csu_hprot1 output for the corresponding master.
	CSU_HP0_HP_LCDIF_HP_LCDIF_0 = 0x0
	// The HP register bit is routed to the csu_hprot1 output for the corresponding master.
	CSU_HP0_HP_LCDIF_HP_LCDIF_1 = 0x1
	// Position of L_LCDIF field.
	CSU_HP0_L_LCDIF_Pos = 0x5
	// Bit mask of L_LCDIF field.
	CSU_HP0_L_LCDIF_Msk = 0x20
	// Bit L_LCDIF.
	CSU_HP0_L_LCDIF = 0x20
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_HP0_L_LCDIF_L_LCDIF_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_HP0_L_LCDIF_L_LCDIF_1 = 0x1
	// Position of HP_CSI field.
	CSU_HP0_HP_CSI_Pos = 0x6
	// Bit mask of HP_CSI field.
	CSU_HP0_HP_CSI_Msk = 0x40
	// Bit HP_CSI.
	CSU_HP0_HP_CSI = 0x40
	// The hprot1 input signal value is routed to the csu_hprot1 output for the corresponding master.
	CSU_HP0_HP_CSI_HP_CSI_0 = 0x0
	// The HP register bit is routed to the csu_hprot1 output for the corresponding master.
	CSU_HP0_HP_CSI_HP_CSI_1 = 0x1
	// Position of L_CSI field.
	CSU_HP0_L_CSI_Pos = 0x7
	// Bit mask of L_CSI field.
	CSU_HP0_L_CSI_Msk = 0x80
	// Bit L_CSI.
	CSU_HP0_L_CSI = 0x80
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_HP0_L_CSI_L_CSI_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_HP0_L_CSI_L_CSI_1 = 0x1
	// Position of HP_PXP field.
	CSU_HP0_HP_PXP_Pos = 0x8
	// Bit mask of HP_PXP field.
	CSU_HP0_HP_PXP_Msk = 0x100
	// Bit HP_PXP.
	CSU_HP0_HP_PXP = 0x100
	// The hprot1 input signal value is routed to the csu_hprot1 output for the corresponding master.
	CSU_HP0_HP_PXP_HP_PXP_0 = 0x0
	// The HP register bit is routed to the csu_hprot1 output for the corresponding master.
	CSU_HP0_HP_PXP_HP_PXP_1 = 0x1
	// Position of L_PXP field.
	CSU_HP0_L_PXP_Pos = 0x9
	// Bit mask of L_PXP field.
	CSU_HP0_L_PXP_Msk = 0x200
	// Bit L_PXP.
	CSU_HP0_L_PXP = 0x200
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_HP0_L_PXP_L_PXP_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_HP0_L_PXP_L_PXP_1 = 0x1
	// Position of HP_DCP field.
	CSU_HP0_HP_DCP_Pos = 0xa
	// Bit mask of HP_DCP field.
	CSU_HP0_HP_DCP_Msk = 0x400
	// Bit HP_DCP.
	CSU_HP0_HP_DCP = 0x400
	// The hprot1 input signal value is routed to the csu_hprot1 output for the corresponding master.
	CSU_HP0_HP_DCP_HP_DCP_0 = 0x0
	// The HP register bit is routed to the csu_hprot1 output for the corresponding master.
	CSU_HP0_HP_DCP_HP_DCP_1 = 0x1
	// Position of L_DCP field.
	CSU_HP0_L_DCP_Pos = 0xb
	// Bit mask of L_DCP field.
	CSU_HP0_L_DCP_Msk = 0x800
	// Bit L_DCP.
	CSU_HP0_L_DCP = 0x800
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_HP0_L_DCP_L_DCP_0 = 0x0
	// Lock-the adjacent (next lower) bit cannot be written by the software.
	CSU_HP0_L_DCP_L_DCP_1 = 0x1
	// Position of HP_ENET field.
	CSU_HP0_HP_ENET_Pos = 0xe
	// Bit mask of HP_ENET field.
	CSU_HP0_HP_ENET_Msk = 0x4000
	// Bit HP_ENET.
	CSU_HP0_HP_ENET = 0x4000
	// The hprot1 input signal value is routed to the csu_hprot1 output for the corresponding master.
	CSU_HP0_HP_ENET_HP_ENET_0 = 0x0
	// The HP register bit is routed to the csu_hprot1 output for the corresponding master.
	CSU_HP0_HP_ENET_HP_ENET_1 = 0x1
	// Position of L_ENET field.
	CSU_HP0_L_ENET_Pos = 0xf
	// Bit mask of L_ENET field.
	CSU_HP0_L_ENET_Msk = 0x8000
	// Bit L_ENET.
	CSU_HP0_L_ENET = 0x8000
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_HP0_L_ENET_L_ENET_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_HP0_L_ENET_L_ENET_1 = 0x1
	// Position of HP_USDHC1 field.
	CSU_HP0_HP_USDHC1_Pos = 0x10
	// Bit mask of HP_USDHC1 field.
	CSU_HP0_HP_USDHC1_Msk = 0x10000
	// Bit HP_USDHC1.
	CSU_HP0_HP_USDHC1 = 0x10000
	// The hprot1 input signal value is routed to the csu_hprot1 output for the corresponding master.
	CSU_HP0_HP_USDHC1_HP_USDHC1_0 = 0x0
	// The HP register bit is routed to the csu_hprot1 output for the corresponding master.
	CSU_HP0_HP_USDHC1_HP_USDHC1_1 = 0x1
	// Position of L_USDHC1 field.
	CSU_HP0_L_USDHC1_Pos = 0x11
	// Bit mask of L_USDHC1 field.
	CSU_HP0_L_USDHC1_Msk = 0x20000
	// Bit L_USDHC1.
	CSU_HP0_L_USDHC1 = 0x20000
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_HP0_L_USDHC1_L_USDHC1_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_HP0_L_USDHC1_L_USDHC1_1 = 0x1
	// Position of HP_USDHC2 field.
	CSU_HP0_HP_USDHC2_Pos = 0x12
	// Bit mask of HP_USDHC2 field.
	CSU_HP0_HP_USDHC2_Msk = 0x40000
	// Bit HP_USDHC2.
	CSU_HP0_HP_USDHC2 = 0x40000
	// The hprot1 input signal value is routed to the csu_hprot1 output for the corresponding master.
	CSU_HP0_HP_USDHC2_HP_USDHC2_0 = 0x0
	// The HP register bit is routed to the csu_hprot1 output for the corresponding master.
	CSU_HP0_HP_USDHC2_HP_USDHC2_1 = 0x1
	// Position of L_USDHC2 field.
	CSU_HP0_L_USDHC2_Pos = 0x13
	// Bit mask of L_USDHC2 field.
	CSU_HP0_L_USDHC2_Msk = 0x80000
	// Bit L_USDHC2.
	CSU_HP0_L_USDHC2 = 0x80000
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_HP0_L_USDHC2_L_USDHC2_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_HP0_L_USDHC2_L_USDHC2_1 = 0x1
	// Position of HP_TPSMP field.
	CSU_HP0_HP_TPSMP_Pos = 0x14
	// Bit mask of HP_TPSMP field.
	CSU_HP0_HP_TPSMP_Msk = 0x100000
	// Bit HP_TPSMP.
	CSU_HP0_HP_TPSMP = 0x100000
	// The hprot1 input signal value is routed to the csu_hprot1 output for the corresponding master.
	CSU_HP0_HP_TPSMP_HP_TPSMP_0 = 0x0
	// The HP register bit is routed to the csu_hprot1 output for the corresponding master.
	CSU_HP0_HP_TPSMP_HP_TPSMP_1 = 0x1
	// Position of L_TPSMP field.
	CSU_HP0_L_TPSMP_Pos = 0x15
	// Bit mask of L_TPSMP field.
	CSU_HP0_L_TPSMP_Msk = 0x200000
	// Bit L_TPSMP.
	CSU_HP0_L_TPSMP = 0x200000
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_HP0_L_TPSMP_L_TPSMP_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_HP0_L_TPSMP_L_TPSMP_1 = 0x1
	// Position of HP_USB field.
	CSU_HP0_HP_USB_Pos = 0x16
	// Bit mask of HP_USB field.
	CSU_HP0_HP_USB_Msk = 0x400000
	// Bit HP_USB.
	CSU_HP0_HP_USB = 0x400000
	// The hprot1 input signal value is routed to the csu_hprot1 output for the corresponding master.
	CSU_HP0_HP_USB_HP_USB_0 = 0x0
	// The HP register bit is routed to the csu_hprot1 output for the corresponding master.
	CSU_HP0_HP_USB_HP_USB_1 = 0x1
	// Position of L_USB field.
	CSU_HP0_L_USB_Pos = 0x17
	// Bit mask of L_USB field.
	CSU_HP0_L_USB_Msk = 0x800000
	// Bit L_USB.
	CSU_HP0_L_USB = 0x800000
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_HP0_L_USB_L_USB_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_HP0_L_USB_L_USB_1 = 0x1

	// SA: Secure access register
	// Position of NSA_DMA field.
	CSU_SA_NSA_DMA_Pos = 0x2
	// Bit mask of NSA_DMA field.
	CSU_SA_NSA_DMA_Msk = 0x4
	// Bit NSA_DMA.
	CSU_SA_NSA_DMA = 0x4
	// Secure access for the corresponding type-1 master
	CSU_SA_NSA_DMA_NSA_DMA_0 = 0x0
	// Non-secure access for the corresponding type-1 master
	CSU_SA_NSA_DMA_NSA_DMA_1 = 0x1
	// Position of L_DMA field.
	CSU_SA_L_DMA_Pos = 0x3
	// Bit mask of L_DMA field.
	CSU_SA_L_DMA_Msk = 0x8
	// Bit L_DMA.
	CSU_SA_L_DMA = 0x8
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_SA_L_DMA_L_DMA_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_SA_L_DMA_L_DMA_1 = 0x1
	// Position of NSA_LCDIF field.
	CSU_SA_NSA_LCDIF_Pos = 0x4
	// Bit mask of NSA_LCDIF field.
	CSU_SA_NSA_LCDIF_Msk = 0x10
	// Bit NSA_LCDIF.
	CSU_SA_NSA_LCDIF = 0x10
	// Secure access for the corresponding type-1 master
	CSU_SA_NSA_LCDIF_NSA_LCDIF_0 = 0x0
	// Non-secure access for the corresponding type-1 master
	CSU_SA_NSA_LCDIF_NSA_LCDIF_1 = 0x1
	// Position of L_LCDIF field.
	CSU_SA_L_LCDIF_Pos = 0x5
	// Bit mask of L_LCDIF field.
	CSU_SA_L_LCDIF_Msk = 0x20
	// Bit L_LCDIF.
	CSU_SA_L_LCDIF = 0x20
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_SA_L_LCDIF_L_LCDIF_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_SA_L_LCDIF_L_LCDIF_1 = 0x1
	// Position of NSA_CSI field.
	CSU_SA_NSA_CSI_Pos = 0x6
	// Bit mask of NSA_CSI field.
	CSU_SA_NSA_CSI_Msk = 0x40
	// Bit NSA_CSI.
	CSU_SA_NSA_CSI = 0x40
	// Secure access for the corresponding type-1 master
	CSU_SA_NSA_CSI_NSA_CSI_0 = 0x0
	// Non-secure access for the corresponding type-1 master
	CSU_SA_NSA_CSI_NSA_CSI_1 = 0x1
	// Position of L_CSI field.
	CSU_SA_L_CSI_Pos = 0x7
	// Bit mask of L_CSI field.
	CSU_SA_L_CSI_Msk = 0x80
	// Bit L_CSI.
	CSU_SA_L_CSI = 0x80
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_SA_L_CSI_L_CSI_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_SA_L_CSI_L_CSI_1 = 0x1
	// Position of NSA_PXP field.
	CSU_SA_NSA_PXP_Pos = 0x8
	// Bit mask of NSA_PXP field.
	CSU_SA_NSA_PXP_Msk = 0x100
	// Bit NSA_PXP.
	CSU_SA_NSA_PXP = 0x100
	// Secure access for the corresponding type-1 master
	CSU_SA_NSA_PXP_NSA_PXP_0 = 0x0
	// Non-secure access for the corresponding type-1 master
	CSU_SA_NSA_PXP_NSA_PXP_1 = 0x1
	// Position of L_PXP field.
	CSU_SA_L_PXP_Pos = 0x9
	// Bit mask of L_PXP field.
	CSU_SA_L_PXP_Msk = 0x200
	// Bit L_PXP.
	CSU_SA_L_PXP = 0x200
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_SA_L_PXP_L_PXP_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_SA_L_PXP_L_PXP_1 = 0x1
	// Position of NSA_DCP field.
	CSU_SA_NSA_DCP_Pos = 0xa
	// Bit mask of NSA_DCP field.
	CSU_SA_NSA_DCP_Msk = 0x400
	// Bit NSA_DCP.
	CSU_SA_NSA_DCP = 0x400
	// Secure access for the corresponding type-1 master
	CSU_SA_NSA_DCP_NSA_DCP_0 = 0x0
	// Non-secure access for the corresponding type-1 master
	CSU_SA_NSA_DCP_NSA_DCP_1 = 0x1
	// Position of L_DCP field.
	CSU_SA_L_DCP_Pos = 0xb
	// Bit mask of L_DCP field.
	CSU_SA_L_DCP_Msk = 0x800
	// Bit L_DCP.
	CSU_SA_L_DCP = 0x800
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_SA_L_DCP_L_DCP_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_SA_L_DCP_L_DCP_1 = 0x1
	// Position of NSA_ENET field.
	CSU_SA_NSA_ENET_Pos = 0xe
	// Bit mask of NSA_ENET field.
	CSU_SA_NSA_ENET_Msk = 0x4000
	// Bit NSA_ENET.
	CSU_SA_NSA_ENET = 0x4000
	// Secure access for the corresponding type-1 master
	CSU_SA_NSA_ENET_NSA_ENET_0 = 0x0
	// Non-secure access for the corresponding type-1 master
	CSU_SA_NSA_ENET_NSA_ENET_1 = 0x1
	// Position of L_ENET field.
	CSU_SA_L_ENET_Pos = 0xf
	// Bit mask of L_ENET field.
	CSU_SA_L_ENET_Msk = 0x8000
	// Bit L_ENET.
	CSU_SA_L_ENET = 0x8000
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_SA_L_ENET_L_ENET_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_SA_L_ENET_L_ENET_1 = 0x1
	// Position of NSA_USDHC1 field.
	CSU_SA_NSA_USDHC1_Pos = 0x10
	// Bit mask of NSA_USDHC1 field.
	CSU_SA_NSA_USDHC1_Msk = 0x10000
	// Bit NSA_USDHC1.
	CSU_SA_NSA_USDHC1 = 0x10000
	// Secure access for the corresponding type-1 master
	CSU_SA_NSA_USDHC1_NSA_USDHC1_0 = 0x0
	// Non-secure access for the corresponding type-1 master
	CSU_SA_NSA_USDHC1_NSA_USDHC1_1 = 0x1
	// Position of L_USDHC1 field.
	CSU_SA_L_USDHC1_Pos = 0x11
	// Bit mask of L_USDHC1 field.
	CSU_SA_L_USDHC1_Msk = 0x20000
	// Bit L_USDHC1.
	CSU_SA_L_USDHC1 = 0x20000
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_SA_L_USDHC1_L_USDHC1_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_SA_L_USDHC1_L_USDHC1_1 = 0x1
	// Position of NSA_USDHC2 field.
	CSU_SA_NSA_USDHC2_Pos = 0x12
	// Bit mask of NSA_USDHC2 field.
	CSU_SA_NSA_USDHC2_Msk = 0x40000
	// Bit NSA_USDHC2.
	CSU_SA_NSA_USDHC2 = 0x40000
	// Secure access for the corresponding type-1 master
	CSU_SA_NSA_USDHC2_NSA_USDHC2_0 = 0x0
	// Non-secure access for the corresponding type-1 master
	CSU_SA_NSA_USDHC2_NSA_USDHC2_1 = 0x1
	// Position of L_USDHC2 field.
	CSU_SA_L_USDHC2_Pos = 0x13
	// Bit mask of L_USDHC2 field.
	CSU_SA_L_USDHC2_Msk = 0x80000
	// Bit L_USDHC2.
	CSU_SA_L_USDHC2 = 0x80000
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_SA_L_USDHC2_L_USDHC2_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_SA_L_USDHC2_L_USDHC2_1 = 0x1
	// Position of NSA_TPSMP field.
	CSU_SA_NSA_TPSMP_Pos = 0x14
	// Bit mask of NSA_TPSMP field.
	CSU_SA_NSA_TPSMP_Msk = 0x100000
	// Bit NSA_TPSMP.
	CSU_SA_NSA_TPSMP = 0x100000
	// Secure access for the corresponding type-1 master
	CSU_SA_NSA_TPSMP_NSA_TPSMP_0 = 0x0
	// Non-secure access for the corresponding type-1 master
	CSU_SA_NSA_TPSMP_NSA_TPSMP_1 = 0x1
	// Position of L_TPSMP field.
	CSU_SA_L_TPSMP_Pos = 0x15
	// Bit mask of L_TPSMP field.
	CSU_SA_L_TPSMP_Msk = 0x200000
	// Bit L_TPSMP.
	CSU_SA_L_TPSMP = 0x200000
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_SA_L_TPSMP_L_TPSMP_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_SA_L_TPSMP_L_TPSMP_1 = 0x1
	// Position of NSA_USB field.
	CSU_SA_NSA_USB_Pos = 0x16
	// Bit mask of NSA_USB field.
	CSU_SA_NSA_USB_Msk = 0x400000
	// Bit NSA_USB.
	CSU_SA_NSA_USB = 0x400000
	// Secure access for the corresponding type-1 master
	CSU_SA_NSA_USB_NSA_USB_0 = 0x0
	// Non-secure access for the corresponding type-1 master
	CSU_SA_NSA_USB_NSA_USB_1 = 0x1
	// Position of L_USB field.
	CSU_SA_L_USB_Pos = 0x17
	// Bit mask of L_USB field.
	CSU_SA_L_USB_Msk = 0x800000
	// Bit L_USB.
	CSU_SA_L_USB = 0x800000
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_SA_L_USB_L_USB_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_SA_L_USB_L_USB_1 = 0x1

	// HPCONTROL0: HPCONTROL0 register
	// Position of HPC_DMA field.
	CSU_HPCONTROL0_HPC_DMA_Pos = 0x2
	// Bit mask of HPC_DMA field.
	CSU_HPCONTROL0_HPC_DMA_Msk = 0x4
	// Bit HPC_DMA.
	CSU_HPCONTROL0_HPC_DMA = 0x4
	// User mode for the corresponding master
	CSU_HPCONTROL0_HPC_DMA_HPC_DMA_0 = 0x0
	// Supervisor mode for the corresponding master
	CSU_HPCONTROL0_HPC_DMA_HPC_DMA_1 = 0x1
	// Position of L_DMA field.
	CSU_HPCONTROL0_L_DMA_Pos = 0x3
	// Bit mask of L_DMA field.
	CSU_HPCONTROL0_L_DMA_Msk = 0x8
	// Bit L_DMA.
	CSU_HPCONTROL0_L_DMA = 0x8
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_HPCONTROL0_L_DMA_L_DMA_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_HPCONTROL0_L_DMA_L_DMA_1 = 0x1
	// Position of HPC_LCDIF field.
	CSU_HPCONTROL0_HPC_LCDIF_Pos = 0x4
	// Bit mask of HPC_LCDIF field.
	CSU_HPCONTROL0_HPC_LCDIF_Msk = 0x10
	// Bit HPC_LCDIF.
	CSU_HPCONTROL0_HPC_LCDIF = 0x10
	// User mode for the corresponding master
	CSU_HPCONTROL0_HPC_LCDIF_HPC_LCDIF_0 = 0x0
	// Supervisor mode for the corresponding master
	CSU_HPCONTROL0_HPC_LCDIF_HPC_LCDIF_1 = 0x1
	// Position of L_LCDIF field.
	CSU_HPCONTROL0_L_LCDIF_Pos = 0x5
	// Bit mask of L_LCDIF field.
	CSU_HPCONTROL0_L_LCDIF_Msk = 0x20
	// Bit L_LCDIF.
	CSU_HPCONTROL0_L_LCDIF = 0x20
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_HPCONTROL0_L_LCDIF_L_LCDIF_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_HPCONTROL0_L_LCDIF_L_LCDIF_1 = 0x1
	// Position of HPC_CSI field.
	CSU_HPCONTROL0_HPC_CSI_Pos = 0x6
	// Bit mask of HPC_CSI field.
	CSU_HPCONTROL0_HPC_CSI_Msk = 0x40
	// Bit HPC_CSI.
	CSU_HPCONTROL0_HPC_CSI = 0x40
	// User mode for the corresponding master
	CSU_HPCONTROL0_HPC_CSI_HPC_CSI_0 = 0x0
	// Supervisor mode for the corresponding master
	CSU_HPCONTROL0_HPC_CSI_HPC_CSI_1 = 0x1
	// Position of L_CSI field.
	CSU_HPCONTROL0_L_CSI_Pos = 0x7
	// Bit mask of L_CSI field.
	CSU_HPCONTROL0_L_CSI_Msk = 0x80
	// Bit L_CSI.
	CSU_HPCONTROL0_L_CSI = 0x80
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_HPCONTROL0_L_CSI_L_CSI_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_HPCONTROL0_L_CSI_L_CSI_1 = 0x1
	// Position of HPC_PXP field.
	CSU_HPCONTROL0_HPC_PXP_Pos = 0x8
	// Bit mask of HPC_PXP field.
	CSU_HPCONTROL0_HPC_PXP_Msk = 0x100
	// Bit HPC_PXP.
	CSU_HPCONTROL0_HPC_PXP = 0x100
	// User mode for the corresponding master
	CSU_HPCONTROL0_HPC_PXP_HPC_PXP_0 = 0x0
	// Supervisor mode for the corresponding master
	CSU_HPCONTROL0_HPC_PXP_HPC_PXP_1 = 0x1
	// Position of L_PXP field.
	CSU_HPCONTROL0_L_PXP_Pos = 0x9
	// Bit mask of L_PXP field.
	CSU_HPCONTROL0_L_PXP_Msk = 0x200
	// Bit L_PXP.
	CSU_HPCONTROL0_L_PXP = 0x200
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_HPCONTROL0_L_PXP_L_PXP_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_HPCONTROL0_L_PXP_L_PXP_1 = 0x1
	// Position of HPC_DCP field.
	CSU_HPCONTROL0_HPC_DCP_Pos = 0xa
	// Bit mask of HPC_DCP field.
	CSU_HPCONTROL0_HPC_DCP_Msk = 0x400
	// Bit HPC_DCP.
	CSU_HPCONTROL0_HPC_DCP = 0x400
	// User mode for the corresponding master
	CSU_HPCONTROL0_HPC_DCP_HPC_DCP_0 = 0x0
	// Supervisor mode for the corresponding master
	CSU_HPCONTROL0_HPC_DCP_HPC_DCP_1 = 0x1
	// Position of L_DCP field.
	CSU_HPCONTROL0_L_DCP_Pos = 0xb
	// Bit mask of L_DCP field.
	CSU_HPCONTROL0_L_DCP_Msk = 0x800
	// Bit L_DCP.
	CSU_HPCONTROL0_L_DCP = 0x800
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_HPCONTROL0_L_DCP_L_DCP_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_HPCONTROL0_L_DCP_L_DCP_1 = 0x1
	// Position of HPC_ENET field.
	CSU_HPCONTROL0_HPC_ENET_Pos = 0xe
	// Bit mask of HPC_ENET field.
	CSU_HPCONTROL0_HPC_ENET_Msk = 0x4000
	// Bit HPC_ENET.
	CSU_HPCONTROL0_HPC_ENET = 0x4000
	// User mode for the corresponding master
	CSU_HPCONTROL0_HPC_ENET_HPC_ENET_0 = 0x0
	// Supervisor mode for the corresponding master
	CSU_HPCONTROL0_HPC_ENET_HPC_ENET_1 = 0x1
	// Position of L_ENET field.
	CSU_HPCONTROL0_L_ENET_Pos = 0xf
	// Bit mask of L_ENET field.
	CSU_HPCONTROL0_L_ENET_Msk = 0x8000
	// Bit L_ENET.
	CSU_HPCONTROL0_L_ENET = 0x8000
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_HPCONTROL0_L_ENET_L_ENET_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_HPCONTROL0_L_ENET_L_ENET_1 = 0x1
	// Position of HPC_USDHC1 field.
	CSU_HPCONTROL0_HPC_USDHC1_Pos = 0x10
	// Bit mask of HPC_USDHC1 field.
	CSU_HPCONTROL0_HPC_USDHC1_Msk = 0x10000
	// Bit HPC_USDHC1.
	CSU_HPCONTROL0_HPC_USDHC1 = 0x10000
	// User mode for the corresponding master
	CSU_HPCONTROL0_HPC_USDHC1_HPC_USDHC1_0 = 0x0
	// Supervisor mode for the corresponding master
	CSU_HPCONTROL0_HPC_USDHC1_HPC_USDHC1_1 = 0x1
	// Position of L_USDHC1 field.
	CSU_HPCONTROL0_L_USDHC1_Pos = 0x11
	// Bit mask of L_USDHC1 field.
	CSU_HPCONTROL0_L_USDHC1_Msk = 0x20000
	// Bit L_USDHC1.
	CSU_HPCONTROL0_L_USDHC1 = 0x20000
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_HPCONTROL0_L_USDHC1_L_USDHC1_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_HPCONTROL0_L_USDHC1_L_USDHC1_1 = 0x1
	// Position of HPC_USDHC2 field.
	CSU_HPCONTROL0_HPC_USDHC2_Pos = 0x12
	// Bit mask of HPC_USDHC2 field.
	CSU_HPCONTROL0_HPC_USDHC2_Msk = 0x40000
	// Bit HPC_USDHC2.
	CSU_HPCONTROL0_HPC_USDHC2 = 0x40000
	// User mode for the corresponding master
	CSU_HPCONTROL0_HPC_USDHC2_HPC_USDHC2_0 = 0x0
	// Supervisor mode for the corresponding master
	CSU_HPCONTROL0_HPC_USDHC2_HPC_USDHC2_1 = 0x1
	// Position of L_USDHC2 field.
	CSU_HPCONTROL0_L_USDHC2_Pos = 0x13
	// Bit mask of L_USDHC2 field.
	CSU_HPCONTROL0_L_USDHC2_Msk = 0x80000
	// Bit L_USDHC2.
	CSU_HPCONTROL0_L_USDHC2 = 0x80000
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_HPCONTROL0_L_USDHC2_L_USDHC2_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_HPCONTROL0_L_USDHC2_L_USDHC2_1 = 0x1
	// Position of HPC_TPSMP field.
	CSU_HPCONTROL0_HPC_TPSMP_Pos = 0x14
	// Bit mask of HPC_TPSMP field.
	CSU_HPCONTROL0_HPC_TPSMP_Msk = 0x100000
	// Bit HPC_TPSMP.
	CSU_HPCONTROL0_HPC_TPSMP = 0x100000
	// User mode for the corresponding master
	CSU_HPCONTROL0_HPC_TPSMP_HPC_TPSMP_0 = 0x0
	// Supervisor mode for the corresponding master
	CSU_HPCONTROL0_HPC_TPSMP_HPC_TPSMP_1 = 0x1
	// Position of L_TPSMP field.
	CSU_HPCONTROL0_L_TPSMP_Pos = 0x15
	// Bit mask of L_TPSMP field.
	CSU_HPCONTROL0_L_TPSMP_Msk = 0x200000
	// Bit L_TPSMP.
	CSU_HPCONTROL0_L_TPSMP = 0x200000
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_HPCONTROL0_L_TPSMP_L_TPSMP_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_HPCONTROL0_L_TPSMP_L_TPSMP_1 = 0x1
	// Position of HPC_USB field.
	CSU_HPCONTROL0_HPC_USB_Pos = 0x16
	// Bit mask of HPC_USB field.
	CSU_HPCONTROL0_HPC_USB_Msk = 0x400000
	// Bit HPC_USB.
	CSU_HPCONTROL0_HPC_USB = 0x400000
	// User mode for the corresponding master
	CSU_HPCONTROL0_HPC_USB_HPC_USB_0 = 0x0
	// Supervisor mode for the corresponding master
	CSU_HPCONTROL0_HPC_USB_HPC_USB_1 = 0x1
	// Position of L_USB field.
	CSU_HPCONTROL0_L_USB_Pos = 0x17
	// Bit mask of L_USB field.
	CSU_HPCONTROL0_L_USB_Msk = 0x800000
	// Bit L_USB.
	CSU_HPCONTROL0_L_USB = 0x800000
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_HPCONTROL0_L_USB_L_USB_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_HPCONTROL0_L_USB_L_USB_1 = 0x1
)

// Bitfields for TSC: Touch Screen Controller
const (
	// BASIC_SETTING: no description available
	// Position of AUTO_MEASURE field.
	TSC_BASIC_SETTING_AUTO_MEASURE_Pos = 0x0
	// Bit mask of AUTO_MEASURE field.
	TSC_BASIC_SETTING_AUTO_MEASURE_Msk = 0x1
	// Bit AUTO_MEASURE.
	TSC_BASIC_SETTING_AUTO_MEASURE = 0x1
	// Disable Auto Measure
	TSC_BASIC_SETTING_AUTO_MEASURE_AUTO_MEASURE_0 = 0x0
	// Auto Measure
	TSC_BASIC_SETTING_AUTO_MEASURE_AUTO_MEASURE_1 = 0x1
	// Position of _4_5_WIRE field.
	TSC_BASIC_SETTING__4_5_WIRE_Pos = 0x4
	// Bit mask of _4_5_WIRE field.
	TSC_BASIC_SETTING__4_5_WIRE_Msk = 0x10
	// Bit _4_5_WIRE.
	TSC_BASIC_SETTING__4_5_WIRE = 0x10
	// 4-Wire Detection Mode
	TSC_BASIC_SETTING__4_5_WIRE_4_5_WIRE_0 = 0x0
	// 5-Wire Detection Mode
	TSC_BASIC_SETTING__4_5_WIRE_4_5_WIRE_1 = 0x1
	// Position of MEASURE_DELAY_TIME field.
	TSC_BASIC_SETTING_MEASURE_DELAY_TIME_Pos = 0x8
	// Bit mask of MEASURE_DELAY_TIME field.
	TSC_BASIC_SETTING_MEASURE_DELAY_TIME_Msk = 0xffffff00

	// PRE_CHARGE_TIME: no description available
	// Position of PRE_CHARGE_TIME field.
	TSC_PRE_CHARGE_TIME_PRE_CHARGE_TIME_Pos = 0x0
	// Bit mask of PRE_CHARGE_TIME field.
	TSC_PRE_CHARGE_TIME_PRE_CHARGE_TIME_Msk = 0xffffffff

	// FLOW_CONTROL: Flow Control
	// Position of SW_RST field.
	TSC_FLOW_CONTROL_SW_RST_Pos = 0x0
	// Bit mask of SW_RST field.
	TSC_FLOW_CONTROL_SW_RST_Msk = 0x1
	// Bit SW_RST.
	TSC_FLOW_CONTROL_SW_RST = 0x1
	// Position of START_MEASURE field.
	TSC_FLOW_CONTROL_START_MEASURE_Pos = 0x4
	// Bit mask of START_MEASURE field.
	TSC_FLOW_CONTROL_START_MEASURE_Msk = 0x10
	// Bit START_MEASURE.
	TSC_FLOW_CONTROL_START_MEASURE = 0x10
	// Do not start measure for now
	TSC_FLOW_CONTROL_START_MEASURE_START_MEASURE_0 = 0x0
	// Start measure the X/Y coordinate value
	TSC_FLOW_CONTROL_START_MEASURE_START_MEASURE_1 = 0x1
	// Position of DROP_MEASURE field.
	TSC_FLOW_CONTROL_DROP_MEASURE_Pos = 0x8
	// Bit mask of DROP_MEASURE field.
	TSC_FLOW_CONTROL_DROP_MEASURE_Msk = 0x100
	// Bit DROP_MEASURE.
	TSC_FLOW_CONTROL_DROP_MEASURE = 0x100
	// Do not drop measure for now
	TSC_FLOW_CONTROL_DROP_MEASURE_DROP_MEASURE_0 = 0x0
	// Drop the measure and controller return to idle status
	TSC_FLOW_CONTROL_DROP_MEASURE_DROP_MEASURE_1 = 0x1
	// Position of START_SENSE field.
	TSC_FLOW_CONTROL_START_SENSE_Pos = 0xc
	// Bit mask of START_SENSE field.
	TSC_FLOW_CONTROL_START_SENSE_Msk = 0x1000
	// Bit START_SENSE.
	TSC_FLOW_CONTROL_START_SENSE = 0x1000
	// Stay at idle status
	TSC_FLOW_CONTROL_START_SENSE_START_SENSE_0 = 0x0
	// Start sense detection and (if auto_measure set to 1) measure after detect a touch
	TSC_FLOW_CONTROL_START_SENSE_START_SENSE_1 = 0x1
	// Position of DISABLE field.
	TSC_FLOW_CONTROL_DISABLE_Pos = 0x10
	// Bit mask of DISABLE field.
	TSC_FLOW_CONTROL_DISABLE_Msk = 0x10000
	// Bit DISABLE.
	TSC_FLOW_CONTROL_DISABLE = 0x10000
	// Leave HW state machine control
	TSC_FLOW_CONTROL_DISABLE_DISABLE_0 = 0x0
	// SW set to idle status
	TSC_FLOW_CONTROL_DISABLE_DISABLE_1 = 0x1

	// MEASEURE_VALUE: Measure Value
	// Position of Y_VALUE field.
	TSC_MEASEURE_VALUE_Y_VALUE_Pos = 0x0
	// Bit mask of Y_VALUE field.
	TSC_MEASEURE_VALUE_Y_VALUE_Msk = 0xfff
	// Position of X_VALUE field.
	TSC_MEASEURE_VALUE_X_VALUE_Pos = 0x10
	// Bit mask of X_VALUE field.
	TSC_MEASEURE_VALUE_X_VALUE_Msk = 0xfff0000

	// INT_EN: Interrupt Enable
	// Position of MEASURE_INT_EN field.
	TSC_INT_EN_MEASURE_INT_EN_Pos = 0x0
	// Bit mask of MEASURE_INT_EN field.
	TSC_INT_EN_MEASURE_INT_EN_Msk = 0x1
	// Bit MEASURE_INT_EN.
	TSC_INT_EN_MEASURE_INT_EN = 0x1
	// Disable measure interrupt
	TSC_INT_EN_MEASURE_INT_EN_MEASURE_INT_EN_0 = 0x0
	// Enable measure interrupt
	TSC_INT_EN_MEASURE_INT_EN_MEASURE_INT_EN_1 = 0x1
	// Position of DETECT_INT_EN field.
	TSC_INT_EN_DETECT_INT_EN_Pos = 0x4
	// Bit mask of DETECT_INT_EN field.
	TSC_INT_EN_DETECT_INT_EN_Msk = 0x10
	// Bit DETECT_INT_EN.
	TSC_INT_EN_DETECT_INT_EN = 0x10
	// Disable detect interrupt
	TSC_INT_EN_DETECT_INT_EN_DETECT_INT_EN_0 = 0x0
	// Enable detect interrupt
	TSC_INT_EN_DETECT_INT_EN_DETECT_INT_EN_1 = 0x1
	// Position of IDLE_SW_INT_EN field.
	TSC_INT_EN_IDLE_SW_INT_EN_Pos = 0xc
	// Bit mask of IDLE_SW_INT_EN field.
	TSC_INT_EN_IDLE_SW_INT_EN_Msk = 0x1000
	// Bit IDLE_SW_INT_EN.
	TSC_INT_EN_IDLE_SW_INT_EN = 0x1000
	// Disable idle software interrupt
	TSC_INT_EN_IDLE_SW_INT_EN_IDLE_SW_INT_EN_0 = 0x0
	// Enable idle software interrupt
	TSC_INT_EN_IDLE_SW_INT_EN_IDLE_SW_INT_EN_1 = 0x1

	// INT_SIG_EN: Interrupt Signal Enable
	// Position of MEASURE_SIG_EN field.
	TSC_INT_SIG_EN_MEASURE_SIG_EN_Pos = 0x0
	// Bit mask of MEASURE_SIG_EN field.
	TSC_INT_SIG_EN_MEASURE_SIG_EN_Msk = 0x1
	// Bit MEASURE_SIG_EN.
	TSC_INT_SIG_EN_MEASURE_SIG_EN = 0x1
	// Position of DETECT_SIG_EN field.
	TSC_INT_SIG_EN_DETECT_SIG_EN_Pos = 0x4
	// Bit mask of DETECT_SIG_EN field.
	TSC_INT_SIG_EN_DETECT_SIG_EN_Msk = 0x10
	// Bit DETECT_SIG_EN.
	TSC_INT_SIG_EN_DETECT_SIG_EN = 0x10
	// Disable detect signal
	TSC_INT_SIG_EN_DETECT_SIG_EN_DETECT_SIG_EN_0 = 0x0
	// Enable detect signal
	TSC_INT_SIG_EN_DETECT_SIG_EN_DETECT_SIG_EN_1 = 0x1
	// Position of VALID_SIG_EN field.
	TSC_INT_SIG_EN_VALID_SIG_EN_Pos = 0x8
	// Bit mask of VALID_SIG_EN field.
	TSC_INT_SIG_EN_VALID_SIG_EN_Msk = 0x100
	// Bit VALID_SIG_EN.
	TSC_INT_SIG_EN_VALID_SIG_EN = 0x100
	// Disable valid signal
	TSC_INT_SIG_EN_VALID_SIG_EN_VALID_SIG_EN_0 = 0x0
	// Enable valid signal
	TSC_INT_SIG_EN_VALID_SIG_EN_VALID_SIG_EN_1 = 0x1
	// Position of IDLE_SW_SIG_EN field.
	TSC_INT_SIG_EN_IDLE_SW_SIG_EN_Pos = 0xc
	// Bit mask of IDLE_SW_SIG_EN field.
	TSC_INT_SIG_EN_IDLE_SW_SIG_EN_Msk = 0x1000
	// Bit IDLE_SW_SIG_EN.
	TSC_INT_SIG_EN_IDLE_SW_SIG_EN = 0x1000
	// Disable idle software signal
	TSC_INT_SIG_EN_IDLE_SW_SIG_EN_IDLE_SW_SIG_EN_0 = 0x0
	// Enable idle software signal
	TSC_INT_SIG_EN_IDLE_SW_SIG_EN_IDLE_SW_SIG_EN_1 = 0x1

	// INT_STATUS: Intterrupt Status
	// Position of MEASURE field.
	TSC_INT_STATUS_MEASURE_Pos = 0x0
	// Bit mask of MEASURE field.
	TSC_INT_STATUS_MEASURE_Msk = 0x1
	// Bit MEASURE.
	TSC_INT_STATUS_MEASURE = 0x1
	// Does not exist a measure signal
	TSC_INT_STATUS_MEASURE_MEASURE_0 = 0x0
	// Exist a measure signal
	TSC_INT_STATUS_MEASURE_MEASURE_1 = 0x1
	// Position of DETECT field.
	TSC_INT_STATUS_DETECT_Pos = 0x4
	// Bit mask of DETECT field.
	TSC_INT_STATUS_DETECT_Msk = 0x10
	// Bit DETECT.
	TSC_INT_STATUS_DETECT = 0x10
	// Does not exist a detect signal
	TSC_INT_STATUS_DETECT_DETECT_0 = 0x0
	// Exist detect signal
	TSC_INT_STATUS_DETECT_DETECT_1 = 0x1
	// Position of VALID field.
	TSC_INT_STATUS_VALID_Pos = 0x8
	// Bit mask of VALID field.
	TSC_INT_STATUS_VALID_Msk = 0x100
	// Bit VALID.
	TSC_INT_STATUS_VALID = 0x100
	// There is no touch detected after measurement, indicates that the measured value is not valid
	TSC_INT_STATUS_VALID_VALID_0 = 0x0
	// There is touch detection after measurement, indicates that the measure is valid
	TSC_INT_STATUS_VALID_VALID_1 = 0x1
	// Position of IDLE_SW field.
	TSC_INT_STATUS_IDLE_SW_Pos = 0xc
	// Bit mask of IDLE_SW field.
	TSC_INT_STATUS_IDLE_SW_Msk = 0x1000
	// Bit IDLE_SW.
	TSC_INT_STATUS_IDLE_SW = 0x1000
	// Haven't return to idle status
	TSC_INT_STATUS_IDLE_SW_IDLE_SW_0 = 0x0
	// Already return to idle status
	TSC_INT_STATUS_IDLE_SW_IDLE_SW_1 = 0x1

	// DEBUG_MODE: no description available
	// Position of ADC_CONV_VALUE field.
	TSC_DEBUG_MODE_ADC_CONV_VALUE_Pos = 0x0
	// Bit mask of ADC_CONV_VALUE field.
	TSC_DEBUG_MODE_ADC_CONV_VALUE_Msk = 0xfff
	// Position of ADC_COCO field.
	TSC_DEBUG_MODE_ADC_COCO_Pos = 0xc
	// Bit mask of ADC_COCO field.
	TSC_DEBUG_MODE_ADC_COCO_Msk = 0x1000
	// Bit ADC_COCO.
	TSC_DEBUG_MODE_ADC_COCO = 0x1000
	// Position of EXT_HWTS field.
	TSC_DEBUG_MODE_EXT_HWTS_Pos = 0x10
	// Bit mask of EXT_HWTS field.
	TSC_DEBUG_MODE_EXT_HWTS_Msk = 0x1f0000
	// Position of TRIGGER field.
	TSC_DEBUG_MODE_TRIGGER_Pos = 0x18
	// Bit mask of TRIGGER field.
	TSC_DEBUG_MODE_TRIGGER_Msk = 0x1000000
	// Bit TRIGGER.
	TSC_DEBUG_MODE_TRIGGER = 0x1000000
	// No hardware trigger signal
	TSC_DEBUG_MODE_TRIGGER_TRIGGER_0 = 0x0
	// Hardware trigger signal, the signal must last at least 1 ips clock period
	TSC_DEBUG_MODE_TRIGGER_TRIGGER_1 = 0x1
	// Position of ADC_COCO_CLEAR field.
	TSC_DEBUG_MODE_ADC_COCO_CLEAR_Pos = 0x19
	// Bit mask of ADC_COCO_CLEAR field.
	TSC_DEBUG_MODE_ADC_COCO_CLEAR_Msk = 0x2000000
	// Bit ADC_COCO_CLEAR.
	TSC_DEBUG_MODE_ADC_COCO_CLEAR = 0x2000000
	// No ADC COCO clear
	TSC_DEBUG_MODE_ADC_COCO_CLEAR_ADC_COCO_CLEAR_0 = 0x0
	// Set ADC COCO clear
	TSC_DEBUG_MODE_ADC_COCO_CLEAR_ADC_COCO_CLEAR_1 = 0x1
	// Position of ADC_COCO_CLEAR_DISABLE field.
	TSC_DEBUG_MODE_ADC_COCO_CLEAR_DISABLE_Pos = 0x1a
	// Bit mask of ADC_COCO_CLEAR_DISABLE field.
	TSC_DEBUG_MODE_ADC_COCO_CLEAR_DISABLE_Msk = 0x4000000
	// Bit ADC_COCO_CLEAR_DISABLE.
	TSC_DEBUG_MODE_ADC_COCO_CLEAR_DISABLE = 0x4000000
	// Allow TSC hardware generates ADC COCO clear
	TSC_DEBUG_MODE_ADC_COCO_CLEAR_DISABLE_ADC_COCO_CLEAR_DISABLE_0 = 0x0
	// Prevent TSC from generate ADC COCO clear signal
	TSC_DEBUG_MODE_ADC_COCO_CLEAR_DISABLE_ADC_COCO_CLEAR_DISABLE_1 = 0x1
	// Position of DEBUG_EN field.
	TSC_DEBUG_MODE_DEBUG_EN_Pos = 0x1c
	// Bit mask of DEBUG_EN field.
	TSC_DEBUG_MODE_DEBUG_EN_Msk = 0x10000000
	// Bit DEBUG_EN.
	TSC_DEBUG_MODE_DEBUG_EN = 0x10000000
	// Enable debug mode
	TSC_DEBUG_MODE_DEBUG_EN_DEBUG_EN_0 = 0x0
	// Disable debug mode
	TSC_DEBUG_MODE_DEBUG_EN_DEBUG_EN_1 = 0x1

	// DEBUG_MODE2: no description available
	// Position of XPUL_PULL_DOWN field.
	TSC_DEBUG_MODE2_XPUL_PULL_DOWN_Pos = 0x0
	// Bit mask of XPUL_PULL_DOWN field.
	TSC_DEBUG_MODE2_XPUL_PULL_DOWN_Msk = 0x1
	// Bit XPUL_PULL_DOWN.
	TSC_DEBUG_MODE2_XPUL_PULL_DOWN = 0x1
	// Close the switch
	TSC_DEBUG_MODE2_XPUL_PULL_DOWN_XPUL_PULL_DOWN_0 = 0x0
	// Open up the switch
	TSC_DEBUG_MODE2_XPUL_PULL_DOWN_XPUL_PULL_DOWN_1 = 0x1
	// Position of XPUL_PULL_UP field.
	TSC_DEBUG_MODE2_XPUL_PULL_UP_Pos = 0x1
	// Bit mask of XPUL_PULL_UP field.
	TSC_DEBUG_MODE2_XPUL_PULL_UP_Msk = 0x2
	// Bit XPUL_PULL_UP.
	TSC_DEBUG_MODE2_XPUL_PULL_UP = 0x2
	// Close the switch
	TSC_DEBUG_MODE2_XPUL_PULL_UP_XPUL_PULL_UP_0 = 0x0
	// Open up the switch
	TSC_DEBUG_MODE2_XPUL_PULL_UP_XPUL_PULL_UP_1 = 0x1
	// Position of XPUL_200K_PULL_UP field.
	TSC_DEBUG_MODE2_XPUL_200K_PULL_UP_Pos = 0x2
	// Bit mask of XPUL_200K_PULL_UP field.
	TSC_DEBUG_MODE2_XPUL_200K_PULL_UP_Msk = 0x4
	// Bit XPUL_200K_PULL_UP.
	TSC_DEBUG_MODE2_XPUL_200K_PULL_UP = 0x4
	// Close the switch
	TSC_DEBUG_MODE2_XPUL_200K_PULL_UP_XPUL_200K_PULL_UP_0 = 0x0
	// Open up the switch
	TSC_DEBUG_MODE2_XPUL_200K_PULL_UP_XPUL_200K_PULL_UP_1 = 0x1
	// Position of XNUR_PULL_DOWN field.
	TSC_DEBUG_MODE2_XNUR_PULL_DOWN_Pos = 0x3
	// Bit mask of XNUR_PULL_DOWN field.
	TSC_DEBUG_MODE2_XNUR_PULL_DOWN_Msk = 0x8
	// Bit XNUR_PULL_DOWN.
	TSC_DEBUG_MODE2_XNUR_PULL_DOWN = 0x8
	// Close the switch
	TSC_DEBUG_MODE2_XNUR_PULL_DOWN_XNUR_PULL_DOWN_0 = 0x0
	// Open up the switch
	TSC_DEBUG_MODE2_XNUR_PULL_DOWN_XNUR_PULL_DOWN_1 = 0x1
	// Position of XNUR_PULL_UP field.
	TSC_DEBUG_MODE2_XNUR_PULL_UP_Pos = 0x4
	// Bit mask of XNUR_PULL_UP field.
	TSC_DEBUG_MODE2_XNUR_PULL_UP_Msk = 0x10
	// Bit XNUR_PULL_UP.
	TSC_DEBUG_MODE2_XNUR_PULL_UP = 0x10
	// Close the switch
	TSC_DEBUG_MODE2_XNUR_PULL_UP_XNUR_PULL_UP_0 = 0x0
	// Open up the switch
	TSC_DEBUG_MODE2_XNUR_PULL_UP_XNUR_PULL_UP_1 = 0x1
	// Position of XNUR_200K_PULL_UP field.
	TSC_DEBUG_MODE2_XNUR_200K_PULL_UP_Pos = 0x5
	// Bit mask of XNUR_200K_PULL_UP field.
	TSC_DEBUG_MODE2_XNUR_200K_PULL_UP_Msk = 0x20
	// Bit XNUR_200K_PULL_UP.
	TSC_DEBUG_MODE2_XNUR_200K_PULL_UP = 0x20
	// Close the switch
	TSC_DEBUG_MODE2_XNUR_200K_PULL_UP_XNUR_200K_PULL_UP_0 = 0x0
	// Open up the switch
	TSC_DEBUG_MODE2_XNUR_200K_PULL_UP_XNUR_200K_PULL_UP_1 = 0x1
	// Position of YPLL_PULL_DOWN field.
	TSC_DEBUG_MODE2_YPLL_PULL_DOWN_Pos = 0x6
	// Bit mask of YPLL_PULL_DOWN field.
	TSC_DEBUG_MODE2_YPLL_PULL_DOWN_Msk = 0x40
	// Bit YPLL_PULL_DOWN.
	TSC_DEBUG_MODE2_YPLL_PULL_DOWN = 0x40
	// Close the switch
	TSC_DEBUG_MODE2_YPLL_PULL_DOWN_YPLL_PULL_DOWN_0 = 0x0
	// Open up the switch
	TSC_DEBUG_MODE2_YPLL_PULL_DOWN_YPLL_PULL_DOWN_1 = 0x1
	// Position of YPLL_PULL_UP field.
	TSC_DEBUG_MODE2_YPLL_PULL_UP_Pos = 0x7
	// Bit mask of YPLL_PULL_UP field.
	TSC_DEBUG_MODE2_YPLL_PULL_UP_Msk = 0x80
	// Bit YPLL_PULL_UP.
	TSC_DEBUG_MODE2_YPLL_PULL_UP = 0x80
	// Close the switch
	TSC_DEBUG_MODE2_YPLL_PULL_UP_YPLL_PULL_UP_0 = 0x0
	// Open the switch
	TSC_DEBUG_MODE2_YPLL_PULL_UP_YPLL_PULL_UP_1 = 0x1
	// Position of YPLL_200K_PULL_UP field.
	TSC_DEBUG_MODE2_YPLL_200K_PULL_UP_Pos = 0x8
	// Bit mask of YPLL_200K_PULL_UP field.
	TSC_DEBUG_MODE2_YPLL_200K_PULL_UP_Msk = 0x100
	// Bit YPLL_200K_PULL_UP.
	TSC_DEBUG_MODE2_YPLL_200K_PULL_UP = 0x100
	// Close the switch
	TSC_DEBUG_MODE2_YPLL_200K_PULL_UP_YPLL_200K_PULL_UP_0 = 0x0
	// Open up the switch
	TSC_DEBUG_MODE2_YPLL_200K_PULL_UP_YPLL_200K_PULL_UP_1 = 0x1
	// Position of YNLR_PULL_DOWN field.
	TSC_DEBUG_MODE2_YNLR_PULL_DOWN_Pos = 0x9
	// Bit mask of YNLR_PULL_DOWN field.
	TSC_DEBUG_MODE2_YNLR_PULL_DOWN_Msk = 0x200
	// Bit YNLR_PULL_DOWN.
	TSC_DEBUG_MODE2_YNLR_PULL_DOWN = 0x200
	// Close the switch
	TSC_DEBUG_MODE2_YNLR_PULL_DOWN_YNLR_PULL_DOWN_0 = 0x0
	// Open up the switch
	TSC_DEBUG_MODE2_YNLR_PULL_DOWN_YNLR_PULL_DOWN_1 = 0x1
	// Position of YNLR_PULL_UP field.
	TSC_DEBUG_MODE2_YNLR_PULL_UP_Pos = 0xa
	// Bit mask of YNLR_PULL_UP field.
	TSC_DEBUG_MODE2_YNLR_PULL_UP_Msk = 0x400
	// Bit YNLR_PULL_UP.
	TSC_DEBUG_MODE2_YNLR_PULL_UP = 0x400
	// Close the switch
	TSC_DEBUG_MODE2_YNLR_PULL_UP_YNLR_PULL_UP_0 = 0x0
	// Open up the switch
	TSC_DEBUG_MODE2_YNLR_PULL_UP_YNLR_PULL_UP_1 = 0x1
	// Position of YNLR_200K_PULL_UP field.
	TSC_DEBUG_MODE2_YNLR_200K_PULL_UP_Pos = 0xb
	// Bit mask of YNLR_200K_PULL_UP field.
	TSC_DEBUG_MODE2_YNLR_200K_PULL_UP_Msk = 0x800
	// Bit YNLR_200K_PULL_UP.
	TSC_DEBUG_MODE2_YNLR_200K_PULL_UP = 0x800
	// Close the switch
	TSC_DEBUG_MODE2_YNLR_200K_PULL_UP_YNLR_200K_PULL_UP_0 = 0x0
	// Open up the switch
	TSC_DEBUG_MODE2_YNLR_200K_PULL_UP_YNLR_200K_PULL_UP_1 = 0x1
	// Position of WIPER_PULL_DOWN field.
	TSC_DEBUG_MODE2_WIPER_PULL_DOWN_Pos = 0xc
	// Bit mask of WIPER_PULL_DOWN field.
	TSC_DEBUG_MODE2_WIPER_PULL_DOWN_Msk = 0x1000
	// Bit WIPER_PULL_DOWN.
	TSC_DEBUG_MODE2_WIPER_PULL_DOWN = 0x1000
	// Close the switch
	TSC_DEBUG_MODE2_WIPER_PULL_DOWN_WIPER_PULL_DOWN_0 = 0x0
	// Open up the switch
	TSC_DEBUG_MODE2_WIPER_PULL_DOWN_WIPER_PULL_DOWN_1 = 0x1
	// Position of WIPER_PULL_UP field.
	TSC_DEBUG_MODE2_WIPER_PULL_UP_Pos = 0xd
	// Bit mask of WIPER_PULL_UP field.
	TSC_DEBUG_MODE2_WIPER_PULL_UP_Msk = 0x2000
	// Bit WIPER_PULL_UP.
	TSC_DEBUG_MODE2_WIPER_PULL_UP = 0x2000
	// Close the switch
	TSC_DEBUG_MODE2_WIPER_PULL_UP_WIPER_PULL_UP_0 = 0x0
	// Open up the switch
	TSC_DEBUG_MODE2_WIPER_PULL_UP_WIPER_PULL_UP_1 = 0x1
	// Position of WIPER_200K_PULL_UP field.
	TSC_DEBUG_MODE2_WIPER_200K_PULL_UP_Pos = 0xe
	// Bit mask of WIPER_200K_PULL_UP field.
	TSC_DEBUG_MODE2_WIPER_200K_PULL_UP_Msk = 0x4000
	// Bit WIPER_200K_PULL_UP.
	TSC_DEBUG_MODE2_WIPER_200K_PULL_UP = 0x4000
	// Close the switch
	TSC_DEBUG_MODE2_WIPER_200K_PULL_UP_WIPER_200K_PULL_UP_0 = 0x0
	// Open up the switch
	TSC_DEBUG_MODE2_WIPER_200K_PULL_UP_WIPER_200K_PULL_UP_1 = 0x1
	// Position of DETECT_FOUR_WIRE field.
	TSC_DEBUG_MODE2_DETECT_FOUR_WIRE_Pos = 0x10
	// Bit mask of DETECT_FOUR_WIRE field.
	TSC_DEBUG_MODE2_DETECT_FOUR_WIRE_Msk = 0x10000
	// Bit DETECT_FOUR_WIRE.
	TSC_DEBUG_MODE2_DETECT_FOUR_WIRE = 0x10000
	// No detect signal
	TSC_DEBUG_MODE2_DETECT_FOUR_WIRE_DETECT_FOUR_WIRE_0 = 0x0
	// Yes, there is a detect on the touch screen.
	TSC_DEBUG_MODE2_DETECT_FOUR_WIRE_DETECT_FOUR_WIRE_1 = 0x1
	// Position of DETECT_FIVE_WIRE field.
	TSC_DEBUG_MODE2_DETECT_FIVE_WIRE_Pos = 0x11
	// Bit mask of DETECT_FIVE_WIRE field.
	TSC_DEBUG_MODE2_DETECT_FIVE_WIRE_Msk = 0x20000
	// Bit DETECT_FIVE_WIRE.
	TSC_DEBUG_MODE2_DETECT_FIVE_WIRE = 0x20000
	// No detect signal
	TSC_DEBUG_MODE2_DETECT_FIVE_WIRE_DETECT_FIVE_WIRE_0 = 0x0
	// Yes, there is a detect on the touch screen.
	TSC_DEBUG_MODE2_DETECT_FIVE_WIRE_DETECT_FIVE_WIRE_1 = 0x1
	// Position of STATE_MACHINE field.
	TSC_DEBUG_MODE2_STATE_MACHINE_Pos = 0x14
	// Bit mask of STATE_MACHINE field.
	TSC_DEBUG_MODE2_STATE_MACHINE_Msk = 0x700000
	// Idle
	TSC_DEBUG_MODE2_STATE_MACHINE_STATE_MACHINE_0 = 0x0
	// Pre-charge
	TSC_DEBUG_MODE2_STATE_MACHINE_STATE_MACHINE_1 = 0x1
	// Detect
	TSC_DEBUG_MODE2_STATE_MACHINE_STATE_MACHINE_2 = 0x2
	// X-measure
	TSC_DEBUG_MODE2_STATE_MACHINE_STATE_MACHINE_3 = 0x3
	// Y-measure
	TSC_DEBUG_MODE2_STATE_MACHINE_STATE_MACHINE_4 = 0x4
	// Pre-charge
	TSC_DEBUG_MODE2_STATE_MACHINE_STATE_MACHINE_5 = 0x5
	// Detect
	TSC_DEBUG_MODE2_STATE_MACHINE_STATE_MACHINE_6 = 0x6
	// Position of INTERMEDIATE field.
	TSC_DEBUG_MODE2_INTERMEDIATE_Pos = 0x17
	// Bit mask of INTERMEDIATE field.
	TSC_DEBUG_MODE2_INTERMEDIATE_Msk = 0x800000
	// Bit INTERMEDIATE.
	TSC_DEBUG_MODE2_INTERMEDIATE = 0x800000
	// Not in intermedia
	TSC_DEBUG_MODE2_INTERMEDIATE_INTERMEDIATE_0 = 0x0
	// Intermedia
	TSC_DEBUG_MODE2_INTERMEDIATE_INTERMEDIATE_1 = 0x1
	// Position of DETECT_ENABLE_FOUR_WIRE field.
	TSC_DEBUG_MODE2_DETECT_ENABLE_FOUR_WIRE_Pos = 0x18
	// Bit mask of DETECT_ENABLE_FOUR_WIRE field.
	TSC_DEBUG_MODE2_DETECT_ENABLE_FOUR_WIRE_Msk = 0x1000000
	// Bit DETECT_ENABLE_FOUR_WIRE.
	TSC_DEBUG_MODE2_DETECT_ENABLE_FOUR_WIRE = 0x1000000
	// Do not read four wire detect value, read default value from analogue
	TSC_DEBUG_MODE2_DETECT_ENABLE_FOUR_WIRE_DETECT_ENABLE_FOUR_WIRE_0 = 0x0
	// Read four wire detect status from analogue
	TSC_DEBUG_MODE2_DETECT_ENABLE_FOUR_WIRE_DETECT_ENABLE_FOUR_WIRE_1 = 0x1
	// Position of DETECT_ENABLE_FIVE_WIRE field.
	TSC_DEBUG_MODE2_DETECT_ENABLE_FIVE_WIRE_Pos = 0x1c
	// Bit mask of DETECT_ENABLE_FIVE_WIRE field.
	TSC_DEBUG_MODE2_DETECT_ENABLE_FIVE_WIRE_Msk = 0x10000000
	// Bit DETECT_ENABLE_FIVE_WIRE.
	TSC_DEBUG_MODE2_DETECT_ENABLE_FIVE_WIRE = 0x10000000
	// Do not read five wire detect value, read default value from analogue
	TSC_DEBUG_MODE2_DETECT_ENABLE_FIVE_WIRE_DETECT_ENABLE_FIVE_WIRE_0 = 0x0
	// Read five wire detect status from analogue
	TSC_DEBUG_MODE2_DETECT_ENABLE_FIVE_WIRE_DETECT_ENABLE_FIVE_WIRE_1 = 0x1
	// Position of DE_GLITCH field.
	TSC_DEBUG_MODE2_DE_GLITCH_Pos = 0x1d
	// Bit mask of DE_GLITCH field.
	TSC_DEBUG_MODE2_DE_GLITCH_Msk = 0x60000000
	// Normal function: 0x1fff ipg clock cycles; Low power mode: 0x9 low power clock cycles
	TSC_DEBUG_MODE2_DE_GLITCH_DE_GLITCH_0 = 0x0
	// Normal function: 0xfff ipg clock cycles; Low power mode: :0x7 low power clock cycles
	TSC_DEBUG_MODE2_DE_GLITCH_DE_GLITCH_1 = 0x1
	// Normal function: 0x7ff ipg clock cycles; Low power mode:0x5 low power clock cycles
	TSC_DEBUG_MODE2_DE_GLITCH_DE_GLITCH_2 = 0x2
	// Normal function: 0x3 ipg clock cycles; Low power mode:0x3 low power clock cycles
	TSC_DEBUG_MODE2_DE_GLITCH_DE_GLITCH_3 = 0x3
)

// Bitfields for DMA0: DMA
const (
	// CR: Control Register
	// Position of EDBG field.
	DMA_CR_EDBG_Pos = 0x1
	// Bit mask of EDBG field.
	DMA_CR_EDBG_Msk = 0x2
	// Bit EDBG.
	DMA_CR_EDBG = 0x2
	// When in debug mode, the DMA continues to operate.
	DMA_CR_EDBG_EDBG_0 = 0x0
	// When in debug mode, the DMA stalls the start of a new channel. Executing channels are allowed to complete. Channel execution resumes when the system exits debug mode or the EDBG bit is cleared.
	DMA_CR_EDBG_EDBG_1 = 0x1
	// Position of ERCA field.
	DMA_CR_ERCA_Pos = 0x2
	// Bit mask of ERCA field.
	DMA_CR_ERCA_Msk = 0x4
	// Bit ERCA.
	DMA_CR_ERCA = 0x4
	// Fixed priority arbitration is used for channel selection within each group.
	DMA_CR_ERCA_ERCA_0 = 0x0
	// Round robin arbitration is used for channel selection within each group.
	DMA_CR_ERCA_ERCA_1 = 0x1
	// Position of ERGA field.
	DMA_CR_ERGA_Pos = 0x3
	// Bit mask of ERGA field.
	DMA_CR_ERGA_Msk = 0x8
	// Bit ERGA.
	DMA_CR_ERGA = 0x8
	// Fixed priority arbitration is used for selection among the groups.
	DMA_CR_ERGA_ERGA_0 = 0x0
	// Round robin arbitration is used for selection among the groups.
	DMA_CR_ERGA_ERGA_1 = 0x1
	// Position of HOE field.
	DMA_CR_HOE_Pos = 0x4
	// Bit mask of HOE field.
	DMA_CR_HOE_Msk = 0x10
	// Bit HOE.
	DMA_CR_HOE = 0x10
	// Normal operation
	DMA_CR_HOE_HOE_0 = 0x0
	// Any error causes the HALT bit to set. Subsequently, all service requests are ignored until the HALT bit is cleared.
	DMA_CR_HOE_HOE_1 = 0x1
	// Position of HALT field.
	DMA_CR_HALT_Pos = 0x5
	// Bit mask of HALT field.
	DMA_CR_HALT_Msk = 0x20
	// Bit HALT.
	DMA_CR_HALT = 0x20
	// Normal operation
	DMA_CR_HALT_HALT_0 = 0x0
	// Stall the start of any new channels. Executing channels are allowed to complete. Channel execution resumes when this bit is cleared.
	DMA_CR_HALT_HALT_1 = 0x1
	// Position of CLM field.
	DMA_CR_CLM_Pos = 0x6
	// Bit mask of CLM field.
	DMA_CR_CLM_Msk = 0x40
	// Bit CLM.
	DMA_CR_CLM = 0x40
	// A minor loop channel link made to itself goes through channel arbitration before being activated again.
	DMA_CR_CLM_CLM_0 = 0x0
	// A minor loop channel link made to itself does not go through channel arbitration before being activated again. Upon minor loop completion, the channel activates again if that channel has a minor loop channel link enabled and the link channel is itself. This effectively applies the minor loop offsets and restarts the next minor loop.
	DMA_CR_CLM_CLM_1 = 0x1
	// Position of EMLM field.
	DMA_CR_EMLM_Pos = 0x7
	// Bit mask of EMLM field.
	DMA_CR_EMLM_Msk = 0x80
	// Bit EMLM.
	DMA_CR_EMLM = 0x80
	// Disabled. TCDn.word2 is defined as a 32-bit NBYTES field.
	DMA_CR_EMLM_EMLM_0 = 0x0
	// Enabled. TCDn.word2 is redefined to include individual enable fields, an offset field, and the NBYTES field. The individual enable fields allow the minor loop offset to be applied to the source address, the destination address, or both. The NBYTES field is reduced when either offset is enabled.
	DMA_CR_EMLM_EMLM_1 = 0x1
	// Position of GRP0PRI field.
	DMA_CR_GRP0PRI_Pos = 0x8
	// Bit mask of GRP0PRI field.
	DMA_CR_GRP0PRI_Msk = 0x100
	// Bit GRP0PRI.
	DMA_CR_GRP0PRI = 0x100
	// Position of GRP1PRI field.
	DMA_CR_GRP1PRI_Pos = 0xa
	// Bit mask of GRP1PRI field.
	DMA_CR_GRP1PRI_Msk = 0x400
	// Bit GRP1PRI.
	DMA_CR_GRP1PRI = 0x400
	// Position of ECX field.
	DMA_CR_ECX_Pos = 0x10
	// Bit mask of ECX field.
	DMA_CR_ECX_Msk = 0x10000
	// Bit ECX.
	DMA_CR_ECX = 0x10000
	// Normal operation
	DMA_CR_ECX_ECX_0 = 0x0
	// Cancel the remaining data transfer in the same fashion as the CX bit. Stop the executing channel and force the minor loop to finish. The cancel takes effect after the last write of the current read/write sequence. The ECX bit clears itself after the cancel is honored. In addition to cancelling the transfer, ECX treats the cancel as an error condition, thus updating the Error Status register (DMAx_ES) and generating an optional error interrupt.
	DMA_CR_ECX_ECX_1 = 0x1
	// Position of CX field.
	DMA_CR_CX_Pos = 0x11
	// Bit mask of CX field.
	DMA_CR_CX_Msk = 0x20000
	// Bit CX.
	DMA_CR_CX = 0x20000
	// Normal operation
	DMA_CR_CX_CX_0 = 0x0
	// Cancel the remaining data transfer. Stop the executing channel and force the minor loop to finish. The cancel takes effect after the last write of the current read/write sequence. The CX bit clears itself after the cancel has been honored. This cancel retires the channel normally as if the minor loop was completed.
	DMA_CR_CX_CX_1 = 0x1
	// Position of ACTIVE field.
	DMA_CR_ACTIVE_Pos = 0x1f
	// Bit mask of ACTIVE field.
	DMA_CR_ACTIVE_Msk = 0x80000000
	// Bit ACTIVE.
	DMA_CR_ACTIVE = 0x80000000
	// eDMA is idle.
	DMA_CR_ACTIVE_ACTIVE_0 = 0x0
	// eDMA is executing a channel.
	DMA_CR_ACTIVE_ACTIVE_1 = 0x1

	// ES: Error Status Register
	// Position of DBE field.
	DMA_ES_DBE_Pos = 0x0
	// Bit mask of DBE field.
	DMA_ES_DBE_Msk = 0x1
	// Bit DBE.
	DMA_ES_DBE = 0x1
	// No destination bus error
	DMA_ES_DBE_DBE_0 = 0x0
	// The last recorded error was a bus error on a destination write
	DMA_ES_DBE_DBE_1 = 0x1
	// Position of SBE field.
	DMA_ES_SBE_Pos = 0x1
	// Bit mask of SBE field.
	DMA_ES_SBE_Msk = 0x2
	// Bit SBE.
	DMA_ES_SBE = 0x2
	// No source bus error
	DMA_ES_SBE_SBE_0 = 0x0
	// The last recorded error was a bus error on a source read
	DMA_ES_SBE_SBE_1 = 0x1
	// Position of SGE field.
	DMA_ES_SGE_Pos = 0x2
	// Bit mask of SGE field.
	DMA_ES_SGE_Msk = 0x4
	// Bit SGE.
	DMA_ES_SGE = 0x4
	// No scatter/gather configuration error
	DMA_ES_SGE_SGE_0 = 0x0
	// The last recorded error was a configuration error detected in the TCDn_DLASTSGA field. This field is checked at the beginning of a scatter/gather operation after major loop completion if TCDn_CSR[ESG] is enabled. TCDn_DLASTSGA is not on a 32 byte boundary.
	DMA_ES_SGE_SGE_1 = 0x1
	// Position of NCE field.
	DMA_ES_NCE_Pos = 0x3
	// Bit mask of NCE field.
	DMA_ES_NCE_Msk = 0x8
	// Bit NCE.
	DMA_ES_NCE = 0x8
	// No NBYTES/CITER configuration error
	DMA_ES_NCE_NCE_0 = 0x0
	// The last recorded error was a configuration error detected in the TCDn_NBYTES or TCDn_CITER fields. TCDn_NBYTES is not a multiple of TCDn_ATTR[SSIZE] and TCDn_ATTR[DSIZE], or TCDn_CITER[CITER] is equal to zero, or TCDn_CITER[ELINK] is not equal to TCDn_BITER[ELINK]
	DMA_ES_NCE_NCE_1 = 0x1
	// Position of DOE field.
	DMA_ES_DOE_Pos = 0x4
	// Bit mask of DOE field.
	DMA_ES_DOE_Msk = 0x10
	// Bit DOE.
	DMA_ES_DOE = 0x10
	// No destination offset configuration error
	DMA_ES_DOE_DOE_0 = 0x0
	// The last recorded error was a configuration error detected in the TCDn_DOFF field. TCDn_DOFF is inconsistent with TCDn_ATTR[DSIZE].
	DMA_ES_DOE_DOE_1 = 0x1
	// Position of DAE field.
	DMA_ES_DAE_Pos = 0x5
	// Bit mask of DAE field.
	DMA_ES_DAE_Msk = 0x20
	// Bit DAE.
	DMA_ES_DAE = 0x20
	// No destination address configuration error
	DMA_ES_DAE_DAE_0 = 0x0
	// The last recorded error was a configuration error detected in the TCDn_DADDR field. TCDn_DADDR is inconsistent with TCDn_ATTR[DSIZE].
	DMA_ES_DAE_DAE_1 = 0x1
	// Position of SOE field.
	DMA_ES_SOE_Pos = 0x6
	// Bit mask of SOE field.
	DMA_ES_SOE_Msk = 0x40
	// Bit SOE.
	DMA_ES_SOE = 0x40
	// No source offset configuration error
	DMA_ES_SOE_SOE_0 = 0x0
	// The last recorded error was a configuration error detected in the TCDn_SOFF field. TCDn_SOFF is inconsistent with TCDn_ATTR[SSIZE].
	DMA_ES_SOE_SOE_1 = 0x1
	// Position of SAE field.
	DMA_ES_SAE_Pos = 0x7
	// Bit mask of SAE field.
	DMA_ES_SAE_Msk = 0x80
	// Bit SAE.
	DMA_ES_SAE = 0x80
	// No source address configuration error.
	DMA_ES_SAE_SAE_0 = 0x0
	// The last recorded error was a configuration error detected in the TCDn_SADDR field. TCDn_SADDR is inconsistent with TCDn_ATTR[SSIZE].
	DMA_ES_SAE_SAE_1 = 0x1
	// Position of ERRCHN field.
	DMA_ES_ERRCHN_Pos = 0x8
	// Bit mask of ERRCHN field.
	DMA_ES_ERRCHN_Msk = 0x1f00
	// Position of CPE field.
	DMA_ES_CPE_Pos = 0xe
	// Bit mask of CPE field.
	DMA_ES_CPE_Msk = 0x4000
	// Bit CPE.
	DMA_ES_CPE = 0x4000
	// No channel priority error
	DMA_ES_CPE_CPE_0 = 0x0
	// The last recorded error was a configuration error in the channel priorities within a group. Channel priorities within a group are not unique.
	DMA_ES_CPE_CPE_1 = 0x1
	// Position of GPE field.
	DMA_ES_GPE_Pos = 0xf
	// Bit mask of GPE field.
	DMA_ES_GPE_Msk = 0x8000
	// Bit GPE.
	DMA_ES_GPE = 0x8000
	// No group priority error
	DMA_ES_GPE_GPE_0 = 0x0
	// The last recorded error was a configuration error among the group priorities. All group priorities are not unique.
	DMA_ES_GPE_GPE_1 = 0x1
	// Position of ECX field.
	DMA_ES_ECX_Pos = 0x10
	// Bit mask of ECX field.
	DMA_ES_ECX_Msk = 0x10000
	// Bit ECX.
	DMA_ES_ECX = 0x10000
	// No canceled transfers
	DMA_ES_ECX_ECX_0 = 0x0
	// The last recorded entry was a canceled transfer by the error cancel transfer input
	DMA_ES_ECX_ECX_1 = 0x1
	// Position of VLD field.
	DMA_ES_VLD_Pos = 0x1f
	// Bit mask of VLD field.
	DMA_ES_VLD_Msk = 0x80000000
	// Bit VLD.
	DMA_ES_VLD = 0x80000000
	// No ERR bits are set.
	DMA_ES_VLD_VLD_0 = 0x0
	// At least one ERR bit is set indicating a valid error exists that has not been cleared.
	DMA_ES_VLD_VLD_1 = 0x1

	// ERQ: Enable Request Register
	// Position of ERQ0 field.
	DMA_ERQ_ERQ0_Pos = 0x0
	// Bit mask of ERQ0 field.
	DMA_ERQ_ERQ0_Msk = 0x1
	// Bit ERQ0.
	DMA_ERQ_ERQ0 = 0x1
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ0_ERQ0_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ0_ERQ0_1 = 0x1
	// Position of ERQ1 field.
	DMA_ERQ_ERQ1_Pos = 0x1
	// Bit mask of ERQ1 field.
	DMA_ERQ_ERQ1_Msk = 0x2
	// Bit ERQ1.
	DMA_ERQ_ERQ1 = 0x2
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ1_ERQ1_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ1_ERQ1_1 = 0x1
	// Position of ERQ2 field.
	DMA_ERQ_ERQ2_Pos = 0x2
	// Bit mask of ERQ2 field.
	DMA_ERQ_ERQ2_Msk = 0x4
	// Bit ERQ2.
	DMA_ERQ_ERQ2 = 0x4
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ2_ERQ2_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ2_ERQ2_1 = 0x1
	// Position of ERQ3 field.
	DMA_ERQ_ERQ3_Pos = 0x3
	// Bit mask of ERQ3 field.
	DMA_ERQ_ERQ3_Msk = 0x8
	// Bit ERQ3.
	DMA_ERQ_ERQ3 = 0x8
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ3_ERQ3_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ3_ERQ3_1 = 0x1
	// Position of ERQ4 field.
	DMA_ERQ_ERQ4_Pos = 0x4
	// Bit mask of ERQ4 field.
	DMA_ERQ_ERQ4_Msk = 0x10
	// Bit ERQ4.
	DMA_ERQ_ERQ4 = 0x10
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ4_ERQ4_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ4_ERQ4_1 = 0x1
	// Position of ERQ5 field.
	DMA_ERQ_ERQ5_Pos = 0x5
	// Bit mask of ERQ5 field.
	DMA_ERQ_ERQ5_Msk = 0x20
	// Bit ERQ5.
	DMA_ERQ_ERQ5 = 0x20
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ5_ERQ5_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ5_ERQ5_1 = 0x1
	// Position of ERQ6 field.
	DMA_ERQ_ERQ6_Pos = 0x6
	// Bit mask of ERQ6 field.
	DMA_ERQ_ERQ6_Msk = 0x40
	// Bit ERQ6.
	DMA_ERQ_ERQ6 = 0x40
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ6_ERQ6_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ6_ERQ6_1 = 0x1
	// Position of ERQ7 field.
	DMA_ERQ_ERQ7_Pos = 0x7
	// Bit mask of ERQ7 field.
	DMA_ERQ_ERQ7_Msk = 0x80
	// Bit ERQ7.
	DMA_ERQ_ERQ7 = 0x80
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ7_ERQ7_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ7_ERQ7_1 = 0x1
	// Position of ERQ8 field.
	DMA_ERQ_ERQ8_Pos = 0x8
	// Bit mask of ERQ8 field.
	DMA_ERQ_ERQ8_Msk = 0x100
	// Bit ERQ8.
	DMA_ERQ_ERQ8 = 0x100
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ8_ERQ8_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ8_ERQ8_1 = 0x1
	// Position of ERQ9 field.
	DMA_ERQ_ERQ9_Pos = 0x9
	// Bit mask of ERQ9 field.
	DMA_ERQ_ERQ9_Msk = 0x200
	// Bit ERQ9.
	DMA_ERQ_ERQ9 = 0x200
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ9_ERQ9_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ9_ERQ9_1 = 0x1
	// Position of ERQ10 field.
	DMA_ERQ_ERQ10_Pos = 0xa
	// Bit mask of ERQ10 field.
	DMA_ERQ_ERQ10_Msk = 0x400
	// Bit ERQ10.
	DMA_ERQ_ERQ10 = 0x400
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ10_ERQ10_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ10_ERQ10_1 = 0x1
	// Position of ERQ11 field.
	DMA_ERQ_ERQ11_Pos = 0xb
	// Bit mask of ERQ11 field.
	DMA_ERQ_ERQ11_Msk = 0x800
	// Bit ERQ11.
	DMA_ERQ_ERQ11 = 0x800
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ11_ERQ11_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ11_ERQ11_1 = 0x1
	// Position of ERQ12 field.
	DMA_ERQ_ERQ12_Pos = 0xc
	// Bit mask of ERQ12 field.
	DMA_ERQ_ERQ12_Msk = 0x1000
	// Bit ERQ12.
	DMA_ERQ_ERQ12 = 0x1000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ12_ERQ12_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ12_ERQ12_1 = 0x1
	// Position of ERQ13 field.
	DMA_ERQ_ERQ13_Pos = 0xd
	// Bit mask of ERQ13 field.
	DMA_ERQ_ERQ13_Msk = 0x2000
	// Bit ERQ13.
	DMA_ERQ_ERQ13 = 0x2000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ13_ERQ13_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ13_ERQ13_1 = 0x1
	// Position of ERQ14 field.
	DMA_ERQ_ERQ14_Pos = 0xe
	// Bit mask of ERQ14 field.
	DMA_ERQ_ERQ14_Msk = 0x4000
	// Bit ERQ14.
	DMA_ERQ_ERQ14 = 0x4000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ14_ERQ14_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ14_ERQ14_1 = 0x1
	// Position of ERQ15 field.
	DMA_ERQ_ERQ15_Pos = 0xf
	// Bit mask of ERQ15 field.
	DMA_ERQ_ERQ15_Msk = 0x8000
	// Bit ERQ15.
	DMA_ERQ_ERQ15 = 0x8000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ15_ERQ15_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ15_ERQ15_1 = 0x1
	// Position of ERQ16 field.
	DMA_ERQ_ERQ16_Pos = 0x10
	// Bit mask of ERQ16 field.
	DMA_ERQ_ERQ16_Msk = 0x10000
	// Bit ERQ16.
	DMA_ERQ_ERQ16 = 0x10000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ16_ERQ16_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ16_ERQ16_1 = 0x1
	// Position of ERQ17 field.
	DMA_ERQ_ERQ17_Pos = 0x11
	// Bit mask of ERQ17 field.
	DMA_ERQ_ERQ17_Msk = 0x20000
	// Bit ERQ17.
	DMA_ERQ_ERQ17 = 0x20000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ17_ERQ17_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ17_ERQ17_1 = 0x1
	// Position of ERQ18 field.
	DMA_ERQ_ERQ18_Pos = 0x12
	// Bit mask of ERQ18 field.
	DMA_ERQ_ERQ18_Msk = 0x40000
	// Bit ERQ18.
	DMA_ERQ_ERQ18 = 0x40000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ18_ERQ18_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ18_ERQ18_1 = 0x1
	// Position of ERQ19 field.
	DMA_ERQ_ERQ19_Pos = 0x13
	// Bit mask of ERQ19 field.
	DMA_ERQ_ERQ19_Msk = 0x80000
	// Bit ERQ19.
	DMA_ERQ_ERQ19 = 0x80000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ19_ERQ19_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ19_ERQ19_1 = 0x1
	// Position of ERQ20 field.
	DMA_ERQ_ERQ20_Pos = 0x14
	// Bit mask of ERQ20 field.
	DMA_ERQ_ERQ20_Msk = 0x100000
	// Bit ERQ20.
	DMA_ERQ_ERQ20 = 0x100000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ20_ERQ20_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ20_ERQ20_1 = 0x1
	// Position of ERQ21 field.
	DMA_ERQ_ERQ21_Pos = 0x15
	// Bit mask of ERQ21 field.
	DMA_ERQ_ERQ21_Msk = 0x200000
	// Bit ERQ21.
	DMA_ERQ_ERQ21 = 0x200000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ21_ERQ21_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ21_ERQ21_1 = 0x1
	// Position of ERQ22 field.
	DMA_ERQ_ERQ22_Pos = 0x16
	// Bit mask of ERQ22 field.
	DMA_ERQ_ERQ22_Msk = 0x400000
	// Bit ERQ22.
	DMA_ERQ_ERQ22 = 0x400000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ22_ERQ22_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ22_ERQ22_1 = 0x1
	// Position of ERQ23 field.
	DMA_ERQ_ERQ23_Pos = 0x17
	// Bit mask of ERQ23 field.
	DMA_ERQ_ERQ23_Msk = 0x800000
	// Bit ERQ23.
	DMA_ERQ_ERQ23 = 0x800000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ23_ERQ23_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ23_ERQ23_1 = 0x1
	// Position of ERQ24 field.
	DMA_ERQ_ERQ24_Pos = 0x18
	// Bit mask of ERQ24 field.
	DMA_ERQ_ERQ24_Msk = 0x1000000
	// Bit ERQ24.
	DMA_ERQ_ERQ24 = 0x1000000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ24_ERQ24_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ24_ERQ24_1 = 0x1
	// Position of ERQ25 field.
	DMA_ERQ_ERQ25_Pos = 0x19
	// Bit mask of ERQ25 field.
	DMA_ERQ_ERQ25_Msk = 0x2000000
	// Bit ERQ25.
	DMA_ERQ_ERQ25 = 0x2000000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ25_ERQ25_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ25_ERQ25_1 = 0x1
	// Position of ERQ26 field.
	DMA_ERQ_ERQ26_Pos = 0x1a
	// Bit mask of ERQ26 field.
	DMA_ERQ_ERQ26_Msk = 0x4000000
	// Bit ERQ26.
	DMA_ERQ_ERQ26 = 0x4000000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ26_ERQ26_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ26_ERQ26_1 = 0x1
	// Position of ERQ27 field.
	DMA_ERQ_ERQ27_Pos = 0x1b
	// Bit mask of ERQ27 field.
	DMA_ERQ_ERQ27_Msk = 0x8000000
	// Bit ERQ27.
	DMA_ERQ_ERQ27 = 0x8000000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ27_ERQ27_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ27_ERQ27_1 = 0x1
	// Position of ERQ28 field.
	DMA_ERQ_ERQ28_Pos = 0x1c
	// Bit mask of ERQ28 field.
	DMA_ERQ_ERQ28_Msk = 0x10000000
	// Bit ERQ28.
	DMA_ERQ_ERQ28 = 0x10000000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ28_ERQ28_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ28_ERQ28_1 = 0x1
	// Position of ERQ29 field.
	DMA_ERQ_ERQ29_Pos = 0x1d
	// Bit mask of ERQ29 field.
	DMA_ERQ_ERQ29_Msk = 0x20000000
	// Bit ERQ29.
	DMA_ERQ_ERQ29 = 0x20000000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ29_ERQ29_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ29_ERQ29_1 = 0x1
	// Position of ERQ30 field.
	DMA_ERQ_ERQ30_Pos = 0x1e
	// Bit mask of ERQ30 field.
	DMA_ERQ_ERQ30_Msk = 0x40000000
	// Bit ERQ30.
	DMA_ERQ_ERQ30 = 0x40000000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ30_ERQ30_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ30_ERQ30_1 = 0x1
	// Position of ERQ31 field.
	DMA_ERQ_ERQ31_Pos = 0x1f
	// Bit mask of ERQ31 field.
	DMA_ERQ_ERQ31_Msk = 0x80000000
	// Bit ERQ31.
	DMA_ERQ_ERQ31 = 0x80000000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ31_ERQ31_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ31_ERQ31_1 = 0x1

	// EEI: Enable Error Interrupt Register
	// Position of EEI0 field.
	DMA_EEI_EEI0_Pos = 0x0
	// Bit mask of EEI0 field.
	DMA_EEI_EEI0_Msk = 0x1
	// Bit EEI0.
	DMA_EEI_EEI0 = 0x1
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI0_EEI0_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI0_EEI0_1 = 0x1
	// Position of EEI1 field.
	DMA_EEI_EEI1_Pos = 0x1
	// Bit mask of EEI1 field.
	DMA_EEI_EEI1_Msk = 0x2
	// Bit EEI1.
	DMA_EEI_EEI1 = 0x2
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI1_EEI1_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI1_EEI1_1 = 0x1
	// Position of EEI2 field.
	DMA_EEI_EEI2_Pos = 0x2
	// Bit mask of EEI2 field.
	DMA_EEI_EEI2_Msk = 0x4
	// Bit EEI2.
	DMA_EEI_EEI2 = 0x4
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI2_EEI2_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI2_EEI2_1 = 0x1
	// Position of EEI3 field.
	DMA_EEI_EEI3_Pos = 0x3
	// Bit mask of EEI3 field.
	DMA_EEI_EEI3_Msk = 0x8
	// Bit EEI3.
	DMA_EEI_EEI3 = 0x8
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI3_EEI3_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI3_EEI3_1 = 0x1
	// Position of EEI4 field.
	DMA_EEI_EEI4_Pos = 0x4
	// Bit mask of EEI4 field.
	DMA_EEI_EEI4_Msk = 0x10
	// Bit EEI4.
	DMA_EEI_EEI4 = 0x10
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI4_EEI4_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI4_EEI4_1 = 0x1
	// Position of EEI5 field.
	DMA_EEI_EEI5_Pos = 0x5
	// Bit mask of EEI5 field.
	DMA_EEI_EEI5_Msk = 0x20
	// Bit EEI5.
	DMA_EEI_EEI5 = 0x20
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI5_EEI5_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI5_EEI5_1 = 0x1
	// Position of EEI6 field.
	DMA_EEI_EEI6_Pos = 0x6
	// Bit mask of EEI6 field.
	DMA_EEI_EEI6_Msk = 0x40
	// Bit EEI6.
	DMA_EEI_EEI6 = 0x40
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI6_EEI6_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI6_EEI6_1 = 0x1
	// Position of EEI7 field.
	DMA_EEI_EEI7_Pos = 0x7
	// Bit mask of EEI7 field.
	DMA_EEI_EEI7_Msk = 0x80
	// Bit EEI7.
	DMA_EEI_EEI7 = 0x80
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI7_EEI7_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI7_EEI7_1 = 0x1
	// Position of EEI8 field.
	DMA_EEI_EEI8_Pos = 0x8
	// Bit mask of EEI8 field.
	DMA_EEI_EEI8_Msk = 0x100
	// Bit EEI8.
	DMA_EEI_EEI8 = 0x100
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI8_EEI8_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI8_EEI8_1 = 0x1
	// Position of EEI9 field.
	DMA_EEI_EEI9_Pos = 0x9
	// Bit mask of EEI9 field.
	DMA_EEI_EEI9_Msk = 0x200
	// Bit EEI9.
	DMA_EEI_EEI9 = 0x200
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI9_EEI9_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI9_EEI9_1 = 0x1
	// Position of EEI10 field.
	DMA_EEI_EEI10_Pos = 0xa
	// Bit mask of EEI10 field.
	DMA_EEI_EEI10_Msk = 0x400
	// Bit EEI10.
	DMA_EEI_EEI10 = 0x400
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI10_EEI10_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI10_EEI10_1 = 0x1
	// Position of EEI11 field.
	DMA_EEI_EEI11_Pos = 0xb
	// Bit mask of EEI11 field.
	DMA_EEI_EEI11_Msk = 0x800
	// Bit EEI11.
	DMA_EEI_EEI11 = 0x800
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI11_EEI11_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI11_EEI11_1 = 0x1
	// Position of EEI12 field.
	DMA_EEI_EEI12_Pos = 0xc
	// Bit mask of EEI12 field.
	DMA_EEI_EEI12_Msk = 0x1000
	// Bit EEI12.
	DMA_EEI_EEI12 = 0x1000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI12_EEI12_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI12_EEI12_1 = 0x1
	// Position of EEI13 field.
	DMA_EEI_EEI13_Pos = 0xd
	// Bit mask of EEI13 field.
	DMA_EEI_EEI13_Msk = 0x2000
	// Bit EEI13.
	DMA_EEI_EEI13 = 0x2000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI13_EEI13_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI13_EEI13_1 = 0x1
	// Position of EEI14 field.
	DMA_EEI_EEI14_Pos = 0xe
	// Bit mask of EEI14 field.
	DMA_EEI_EEI14_Msk = 0x4000
	// Bit EEI14.
	DMA_EEI_EEI14 = 0x4000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI14_EEI14_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI14_EEI14_1 = 0x1
	// Position of EEI15 field.
	DMA_EEI_EEI15_Pos = 0xf
	// Bit mask of EEI15 field.
	DMA_EEI_EEI15_Msk = 0x8000
	// Bit EEI15.
	DMA_EEI_EEI15 = 0x8000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI15_EEI15_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI15_EEI15_1 = 0x1
	// Position of EEI16 field.
	DMA_EEI_EEI16_Pos = 0x10
	// Bit mask of EEI16 field.
	DMA_EEI_EEI16_Msk = 0x10000
	// Bit EEI16.
	DMA_EEI_EEI16 = 0x10000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI16_EEI16_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI16_EEI16_1 = 0x1
	// Position of EEI17 field.
	DMA_EEI_EEI17_Pos = 0x11
	// Bit mask of EEI17 field.
	DMA_EEI_EEI17_Msk = 0x20000
	// Bit EEI17.
	DMA_EEI_EEI17 = 0x20000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI17_EEI17_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI17_EEI17_1 = 0x1
	// Position of EEI18 field.
	DMA_EEI_EEI18_Pos = 0x12
	// Bit mask of EEI18 field.
	DMA_EEI_EEI18_Msk = 0x40000
	// Bit EEI18.
	DMA_EEI_EEI18 = 0x40000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI18_EEI18_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI18_EEI18_1 = 0x1
	// Position of EEI19 field.
	DMA_EEI_EEI19_Pos = 0x13
	// Bit mask of EEI19 field.
	DMA_EEI_EEI19_Msk = 0x80000
	// Bit EEI19.
	DMA_EEI_EEI19 = 0x80000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI19_EEI19_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI19_EEI19_1 = 0x1
	// Position of EEI20 field.
	DMA_EEI_EEI20_Pos = 0x14
	// Bit mask of EEI20 field.
	DMA_EEI_EEI20_Msk = 0x100000
	// Bit EEI20.
	DMA_EEI_EEI20 = 0x100000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI20_EEI20_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI20_EEI20_1 = 0x1
	// Position of EEI21 field.
	DMA_EEI_EEI21_Pos = 0x15
	// Bit mask of EEI21 field.
	DMA_EEI_EEI21_Msk = 0x200000
	// Bit EEI21.
	DMA_EEI_EEI21 = 0x200000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI21_EEI21_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI21_EEI21_1 = 0x1
	// Position of EEI22 field.
	DMA_EEI_EEI22_Pos = 0x16
	// Bit mask of EEI22 field.
	DMA_EEI_EEI22_Msk = 0x400000
	// Bit EEI22.
	DMA_EEI_EEI22 = 0x400000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI22_EEI22_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI22_EEI22_1 = 0x1
	// Position of EEI23 field.
	DMA_EEI_EEI23_Pos = 0x17
	// Bit mask of EEI23 field.
	DMA_EEI_EEI23_Msk = 0x800000
	// Bit EEI23.
	DMA_EEI_EEI23 = 0x800000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI23_EEI23_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI23_EEI23_1 = 0x1
	// Position of EEI24 field.
	DMA_EEI_EEI24_Pos = 0x18
	// Bit mask of EEI24 field.
	DMA_EEI_EEI24_Msk = 0x1000000
	// Bit EEI24.
	DMA_EEI_EEI24 = 0x1000000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI24_EEI24_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI24_EEI24_1 = 0x1
	// Position of EEI25 field.
	DMA_EEI_EEI25_Pos = 0x19
	// Bit mask of EEI25 field.
	DMA_EEI_EEI25_Msk = 0x2000000
	// Bit EEI25.
	DMA_EEI_EEI25 = 0x2000000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI25_EEI25_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI25_EEI25_1 = 0x1
	// Position of EEI26 field.
	DMA_EEI_EEI26_Pos = 0x1a
	// Bit mask of EEI26 field.
	DMA_EEI_EEI26_Msk = 0x4000000
	// Bit EEI26.
	DMA_EEI_EEI26 = 0x4000000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI26_EEI26_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI26_EEI26_1 = 0x1
	// Position of EEI27 field.
	DMA_EEI_EEI27_Pos = 0x1b
	// Bit mask of EEI27 field.
	DMA_EEI_EEI27_Msk = 0x8000000
	// Bit EEI27.
	DMA_EEI_EEI27 = 0x8000000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI27_EEI27_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI27_EEI27_1 = 0x1
	// Position of EEI28 field.
	DMA_EEI_EEI28_Pos = 0x1c
	// Bit mask of EEI28 field.
	DMA_EEI_EEI28_Msk = 0x10000000
	// Bit EEI28.
	DMA_EEI_EEI28 = 0x10000000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI28_EEI28_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI28_EEI28_1 = 0x1
	// Position of EEI29 field.
	DMA_EEI_EEI29_Pos = 0x1d
	// Bit mask of EEI29 field.
	DMA_EEI_EEI29_Msk = 0x20000000
	// Bit EEI29.
	DMA_EEI_EEI29 = 0x20000000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI29_EEI29_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI29_EEI29_1 = 0x1
	// Position of EEI30 field.
	DMA_EEI_EEI30_Pos = 0x1e
	// Bit mask of EEI30 field.
	DMA_EEI_EEI30_Msk = 0x40000000
	// Bit EEI30.
	DMA_EEI_EEI30 = 0x40000000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI30_EEI30_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI30_EEI30_1 = 0x1
	// Position of EEI31 field.
	DMA_EEI_EEI31_Pos = 0x1f
	// Bit mask of EEI31 field.
	DMA_EEI_EEI31_Msk = 0x80000000
	// Bit EEI31.
	DMA_EEI_EEI31 = 0x80000000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI31_EEI31_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI31_EEI31_1 = 0x1

	// CEEI: Clear Enable Error Interrupt Register
	// Position of CEEI field.
	DMA_CEEI_CEEI_Pos = 0x0
	// Bit mask of CEEI field.
	DMA_CEEI_CEEI_Msk = 0x1f
	// Position of CAEE field.
	DMA_CEEI_CAEE_Pos = 0x6
	// Bit mask of CAEE field.
	DMA_CEEI_CAEE_Msk = 0x40
	// Bit CAEE.
	DMA_CEEI_CAEE = 0x40
	// Clear only the EEI bit specified in the CEEI field
	DMA_CEEI_CAEE_CAEE_0 = 0x0
	// Clear all bits in EEI
	DMA_CEEI_CAEE_CAEE_1 = 0x1
	// Position of NOP field.
	DMA_CEEI_NOP_Pos = 0x7
	// Bit mask of NOP field.
	DMA_CEEI_NOP_Msk = 0x80
	// Bit NOP.
	DMA_CEEI_NOP = 0x80
	// Normal operation
	DMA_CEEI_NOP_NOP_0 = 0x0
	// No operation, ignore the other bits in this register
	DMA_CEEI_NOP_NOP_1 = 0x1

	// SEEI: Set Enable Error Interrupt Register
	// Position of SEEI field.
	DMA_SEEI_SEEI_Pos = 0x0
	// Bit mask of SEEI field.
	DMA_SEEI_SEEI_Msk = 0x1f
	// Position of SAEE field.
	DMA_SEEI_SAEE_Pos = 0x6
	// Bit mask of SAEE field.
	DMA_SEEI_SAEE_Msk = 0x40
	// Bit SAEE.
	DMA_SEEI_SAEE = 0x40
	// Set only the EEI bit specified in the SEEI field.
	DMA_SEEI_SAEE_SAEE_0 = 0x0
	// Sets all bits in EEI
	DMA_SEEI_SAEE_SAEE_1 = 0x1
	// Position of NOP field.
	DMA_SEEI_NOP_Pos = 0x7
	// Bit mask of NOP field.
	DMA_SEEI_NOP_Msk = 0x80
	// Bit NOP.
	DMA_SEEI_NOP = 0x80
	// Normal operation
	DMA_SEEI_NOP_NOP_0 = 0x0
	// No operation, ignore the other bits in this register
	DMA_SEEI_NOP_NOP_1 = 0x1

	// CERQ: Clear Enable Request Register
	// Position of CERQ field.
	DMA_CERQ_CERQ_Pos = 0x0
	// Bit mask of CERQ field.
	DMA_CERQ_CERQ_Msk = 0x1f
	// Position of CAER field.
	DMA_CERQ_CAER_Pos = 0x6
	// Bit mask of CAER field.
	DMA_CERQ_CAER_Msk = 0x40
	// Bit CAER.
	DMA_CERQ_CAER = 0x40
	// Clear only the ERQ bit specified in the CERQ field
	DMA_CERQ_CAER_CAER_0 = 0x0
	// Clear all bits in ERQ
	DMA_CERQ_CAER_CAER_1 = 0x1
	// Position of NOP field.
	DMA_CERQ_NOP_Pos = 0x7
	// Bit mask of NOP field.
	DMA_CERQ_NOP_Msk = 0x80
	// Bit NOP.
	DMA_CERQ_NOP = 0x80
	// Normal operation
	DMA_CERQ_NOP_NOP_0 = 0x0
	// No operation, ignore the other bits in this register
	DMA_CERQ_NOP_NOP_1 = 0x1

	// SERQ: Set Enable Request Register
	// Position of SERQ field.
	DMA_SERQ_SERQ_Pos = 0x0
	// Bit mask of SERQ field.
	DMA_SERQ_SERQ_Msk = 0x1f
	// Position of SAER field.
	DMA_SERQ_SAER_Pos = 0x6
	// Bit mask of SAER field.
	DMA_SERQ_SAER_Msk = 0x40
	// Bit SAER.
	DMA_SERQ_SAER = 0x40
	// Set only the ERQ bit specified in the SERQ field
	DMA_SERQ_SAER_SAER_0 = 0x0
	// Set all bits in ERQ
	DMA_SERQ_SAER_SAER_1 = 0x1
	// Position of NOP field.
	DMA_SERQ_NOP_Pos = 0x7
	// Bit mask of NOP field.
	DMA_SERQ_NOP_Msk = 0x80
	// Bit NOP.
	DMA_SERQ_NOP = 0x80
	// Normal operation
	DMA_SERQ_NOP_NOP_0 = 0x0
	// No operation, ignore the other bits in this register
	DMA_SERQ_NOP_NOP_1 = 0x1

	// CDNE: Clear DONE Status Bit Register
	// Position of CDNE field.
	DMA_CDNE_CDNE_Pos = 0x0
	// Bit mask of CDNE field.
	DMA_CDNE_CDNE_Msk = 0x1f
	// Position of CADN field.
	DMA_CDNE_CADN_Pos = 0x6
	// Bit mask of CADN field.
	DMA_CDNE_CADN_Msk = 0x40
	// Bit CADN.
	DMA_CDNE_CADN = 0x40
	// Clears only the TCDn_CSR[DONE] bit specified in the CDNE field
	DMA_CDNE_CADN_CADN_0 = 0x0
	// Clears all bits in TCDn_CSR[DONE]
	DMA_CDNE_CADN_CADN_1 = 0x1
	// Position of NOP field.
	DMA_CDNE_NOP_Pos = 0x7
	// Bit mask of NOP field.
	DMA_CDNE_NOP_Msk = 0x80
	// Bit NOP.
	DMA_CDNE_NOP = 0x80
	// Normal operation
	DMA_CDNE_NOP_NOP_0 = 0x0
	// No operation, ignore the other bits in this register
	DMA_CDNE_NOP_NOP_1 = 0x1

	// SSRT: Set START Bit Register
	// Position of SSRT field.
	DMA_SSRT_SSRT_Pos = 0x0
	// Bit mask of SSRT field.
	DMA_SSRT_SSRT_Msk = 0x1f
	// Position of SAST field.
	DMA_SSRT_SAST_Pos = 0x6
	// Bit mask of SAST field.
	DMA_SSRT_SAST_Msk = 0x40
	// Bit SAST.
	DMA_SSRT_SAST = 0x40
	// Set only the TCDn_CSR[START] bit specified in the SSRT field
	DMA_SSRT_SAST_SAST_0 = 0x0
	// Set all bits in TCDn_CSR[START]
	DMA_SSRT_SAST_SAST_1 = 0x1
	// Position of NOP field.
	DMA_SSRT_NOP_Pos = 0x7
	// Bit mask of NOP field.
	DMA_SSRT_NOP_Msk = 0x80
	// Bit NOP.
	DMA_SSRT_NOP = 0x80
	// Normal operation
	DMA_SSRT_NOP_NOP_0 = 0x0
	// No operation, ignore the other bits in this register
	DMA_SSRT_NOP_NOP_1 = 0x1

	// CERR: Clear Error Register
	// Position of CERR field.
	DMA_CERR_CERR_Pos = 0x0
	// Bit mask of CERR field.
	DMA_CERR_CERR_Msk = 0x1f
	// Position of CAEI field.
	DMA_CERR_CAEI_Pos = 0x6
	// Bit mask of CAEI field.
	DMA_CERR_CAEI_Msk = 0x40
	// Bit CAEI.
	DMA_CERR_CAEI = 0x40
	// Clear only the ERR bit specified in the CERR field
	DMA_CERR_CAEI_CAEI_0 = 0x0
	// Clear all bits in ERR
	DMA_CERR_CAEI_CAEI_1 = 0x1
	// Position of NOP field.
	DMA_CERR_NOP_Pos = 0x7
	// Bit mask of NOP field.
	DMA_CERR_NOP_Msk = 0x80
	// Bit NOP.
	DMA_CERR_NOP = 0x80
	// Normal operation
	DMA_CERR_NOP_NOP_0 = 0x0
	// No operation, ignore the other bits in this register
	DMA_CERR_NOP_NOP_1 = 0x1

	// CINT: Clear Interrupt Request Register
	// Position of CINT field.
	DMA_CINT_CINT_Pos = 0x0
	// Bit mask of CINT field.
	DMA_CINT_CINT_Msk = 0x1f
	// Position of CAIR field.
	DMA_CINT_CAIR_Pos = 0x6
	// Bit mask of CAIR field.
	DMA_CINT_CAIR_Msk = 0x40
	// Bit CAIR.
	DMA_CINT_CAIR = 0x40
	// Clear only the INT bit specified in the CINT field
	DMA_CINT_CAIR_CAIR_0 = 0x0
	// Clear all bits in INT
	DMA_CINT_CAIR_CAIR_1 = 0x1
	// Position of NOP field.
	DMA_CINT_NOP_Pos = 0x7
	// Bit mask of NOP field.
	DMA_CINT_NOP_Msk = 0x80
	// Bit NOP.
	DMA_CINT_NOP = 0x80
	// Normal operation
	DMA_CINT_NOP_NOP_0 = 0x0
	// No operation, ignore the other bits in this register
	DMA_CINT_NOP_NOP_1 = 0x1

	// INT: Interrupt Request Register
	// Position of INT0 field.
	DMA_INT_INT0_Pos = 0x0
	// Bit mask of INT0 field.
	DMA_INT_INT0_Msk = 0x1
	// Bit INT0.
	DMA_INT_INT0 = 0x1
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT0_INT0_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT0_INT0_1 = 0x1
	// Position of INT1 field.
	DMA_INT_INT1_Pos = 0x1
	// Bit mask of INT1 field.
	DMA_INT_INT1_Msk = 0x2
	// Bit INT1.
	DMA_INT_INT1 = 0x2
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT1_INT1_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT1_INT1_1 = 0x1
	// Position of INT2 field.
	DMA_INT_INT2_Pos = 0x2
	// Bit mask of INT2 field.
	DMA_INT_INT2_Msk = 0x4
	// Bit INT2.
	DMA_INT_INT2 = 0x4
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT2_INT2_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT2_INT2_1 = 0x1
	// Position of INT3 field.
	DMA_INT_INT3_Pos = 0x3
	// Bit mask of INT3 field.
	DMA_INT_INT3_Msk = 0x8
	// Bit INT3.
	DMA_INT_INT3 = 0x8
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT3_INT3_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT3_INT3_1 = 0x1
	// Position of INT4 field.
	DMA_INT_INT4_Pos = 0x4
	// Bit mask of INT4 field.
	DMA_INT_INT4_Msk = 0x10
	// Bit INT4.
	DMA_INT_INT4 = 0x10
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT4_INT4_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT4_INT4_1 = 0x1
	// Position of INT5 field.
	DMA_INT_INT5_Pos = 0x5
	// Bit mask of INT5 field.
	DMA_INT_INT5_Msk = 0x20
	// Bit INT5.
	DMA_INT_INT5 = 0x20
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT5_INT5_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT5_INT5_1 = 0x1
	// Position of INT6 field.
	DMA_INT_INT6_Pos = 0x6
	// Bit mask of INT6 field.
	DMA_INT_INT6_Msk = 0x40
	// Bit INT6.
	DMA_INT_INT6 = 0x40
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT6_INT6_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT6_INT6_1 = 0x1
	// Position of INT7 field.
	DMA_INT_INT7_Pos = 0x7
	// Bit mask of INT7 field.
	DMA_INT_INT7_Msk = 0x80
	// Bit INT7.
	DMA_INT_INT7 = 0x80
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT7_INT7_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT7_INT7_1 = 0x1
	// Position of INT8 field.
	DMA_INT_INT8_Pos = 0x8
	// Bit mask of INT8 field.
	DMA_INT_INT8_Msk = 0x100
	// Bit INT8.
	DMA_INT_INT8 = 0x100
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT8_INT8_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT8_INT8_1 = 0x1
	// Position of INT9 field.
	DMA_INT_INT9_Pos = 0x9
	// Bit mask of INT9 field.
	DMA_INT_INT9_Msk = 0x200
	// Bit INT9.
	DMA_INT_INT9 = 0x200
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT9_INT9_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT9_INT9_1 = 0x1
	// Position of INT10 field.
	DMA_INT_INT10_Pos = 0xa
	// Bit mask of INT10 field.
	DMA_INT_INT10_Msk = 0x400
	// Bit INT10.
	DMA_INT_INT10 = 0x400
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT10_INT10_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT10_INT10_1 = 0x1
	// Position of INT11 field.
	DMA_INT_INT11_Pos = 0xb
	// Bit mask of INT11 field.
	DMA_INT_INT11_Msk = 0x800
	// Bit INT11.
	DMA_INT_INT11 = 0x800
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT11_INT11_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT11_INT11_1 = 0x1
	// Position of INT12 field.
	DMA_INT_INT12_Pos = 0xc
	// Bit mask of INT12 field.
	DMA_INT_INT12_Msk = 0x1000
	// Bit INT12.
	DMA_INT_INT12 = 0x1000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT12_INT12_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT12_INT12_1 = 0x1
	// Position of INT13 field.
	DMA_INT_INT13_Pos = 0xd
	// Bit mask of INT13 field.
	DMA_INT_INT13_Msk = 0x2000
	// Bit INT13.
	DMA_INT_INT13 = 0x2000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT13_INT13_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT13_INT13_1 = 0x1
	// Position of INT14 field.
	DMA_INT_INT14_Pos = 0xe
	// Bit mask of INT14 field.
	DMA_INT_INT14_Msk = 0x4000
	// Bit INT14.
	DMA_INT_INT14 = 0x4000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT14_INT14_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT14_INT14_1 = 0x1
	// Position of INT15 field.
	DMA_INT_INT15_Pos = 0xf
	// Bit mask of INT15 field.
	DMA_INT_INT15_Msk = 0x8000
	// Bit INT15.
	DMA_INT_INT15 = 0x8000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT15_INT15_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT15_INT15_1 = 0x1
	// Position of INT16 field.
	DMA_INT_INT16_Pos = 0x10
	// Bit mask of INT16 field.
	DMA_INT_INT16_Msk = 0x10000
	// Bit INT16.
	DMA_INT_INT16 = 0x10000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT16_INT16_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT16_INT16_1 = 0x1
	// Position of INT17 field.
	DMA_INT_INT17_Pos = 0x11
	// Bit mask of INT17 field.
	DMA_INT_INT17_Msk = 0x20000
	// Bit INT17.
	DMA_INT_INT17 = 0x20000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT17_INT17_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT17_INT17_1 = 0x1
	// Position of INT18 field.
	DMA_INT_INT18_Pos = 0x12
	// Bit mask of INT18 field.
	DMA_INT_INT18_Msk = 0x40000
	// Bit INT18.
	DMA_INT_INT18 = 0x40000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT18_INT18_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT18_INT18_1 = 0x1
	// Position of INT19 field.
	DMA_INT_INT19_Pos = 0x13
	// Bit mask of INT19 field.
	DMA_INT_INT19_Msk = 0x80000
	// Bit INT19.
	DMA_INT_INT19 = 0x80000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT19_INT19_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT19_INT19_1 = 0x1
	// Position of INT20 field.
	DMA_INT_INT20_Pos = 0x14
	// Bit mask of INT20 field.
	DMA_INT_INT20_Msk = 0x100000
	// Bit INT20.
	DMA_INT_INT20 = 0x100000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT20_INT20_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT20_INT20_1 = 0x1
	// Position of INT21 field.
	DMA_INT_INT21_Pos = 0x15
	// Bit mask of INT21 field.
	DMA_INT_INT21_Msk = 0x200000
	// Bit INT21.
	DMA_INT_INT21 = 0x200000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT21_INT21_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT21_INT21_1 = 0x1
	// Position of INT22 field.
	DMA_INT_INT22_Pos = 0x16
	// Bit mask of INT22 field.
	DMA_INT_INT22_Msk = 0x400000
	// Bit INT22.
	DMA_INT_INT22 = 0x400000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT22_INT22_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT22_INT22_1 = 0x1
	// Position of INT23 field.
	DMA_INT_INT23_Pos = 0x17
	// Bit mask of INT23 field.
	DMA_INT_INT23_Msk = 0x800000
	// Bit INT23.
	DMA_INT_INT23 = 0x800000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT23_INT23_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT23_INT23_1 = 0x1
	// Position of INT24 field.
	DMA_INT_INT24_Pos = 0x18
	// Bit mask of INT24 field.
	DMA_INT_INT24_Msk = 0x1000000
	// Bit INT24.
	DMA_INT_INT24 = 0x1000000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT24_INT24_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT24_INT24_1 = 0x1
	// Position of INT25 field.
	DMA_INT_INT25_Pos = 0x19
	// Bit mask of INT25 field.
	DMA_INT_INT25_Msk = 0x2000000
	// Bit INT25.
	DMA_INT_INT25 = 0x2000000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT25_INT25_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT25_INT25_1 = 0x1
	// Position of INT26 field.
	DMA_INT_INT26_Pos = 0x1a
	// Bit mask of INT26 field.
	DMA_INT_INT26_Msk = 0x4000000
	// Bit INT26.
	DMA_INT_INT26 = 0x4000000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT26_INT26_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT26_INT26_1 = 0x1
	// Position of INT27 field.
	DMA_INT_INT27_Pos = 0x1b
	// Bit mask of INT27 field.
	DMA_INT_INT27_Msk = 0x8000000
	// Bit INT27.
	DMA_INT_INT27 = 0x8000000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT27_INT27_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT27_INT27_1 = 0x1
	// Position of INT28 field.
	DMA_INT_INT28_Pos = 0x1c
	// Bit mask of INT28 field.
	DMA_INT_INT28_Msk = 0x10000000
	// Bit INT28.
	DMA_INT_INT28 = 0x10000000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT28_INT28_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT28_INT28_1 = 0x1
	// Position of INT29 field.
	DMA_INT_INT29_Pos = 0x1d
	// Bit mask of INT29 field.
	DMA_INT_INT29_Msk = 0x20000000
	// Bit INT29.
	DMA_INT_INT29 = 0x20000000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT29_INT29_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT29_INT29_1 = 0x1
	// Position of INT30 field.
	DMA_INT_INT30_Pos = 0x1e
	// Bit mask of INT30 field.
	DMA_INT_INT30_Msk = 0x40000000
	// Bit INT30.
	DMA_INT_INT30 = 0x40000000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT30_INT30_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT30_INT30_1 = 0x1
	// Position of INT31 field.
	DMA_INT_INT31_Pos = 0x1f
	// Bit mask of INT31 field.
	DMA_INT_INT31_Msk = 0x80000000
	// Bit INT31.
	DMA_INT_INT31 = 0x80000000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT31_INT31_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT31_INT31_1 = 0x1

	// ERR: Error Register
	// Position of ERR0 field.
	DMA_ERR_ERR0_Pos = 0x0
	// Bit mask of ERR0 field.
	DMA_ERR_ERR0_Msk = 0x1
	// Bit ERR0.
	DMA_ERR_ERR0 = 0x1
	// An error in this channel has not occurred
	DMA_ERR_ERR0_ERR0_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR0_ERR0_1 = 0x1
	// Position of ERR1 field.
	DMA_ERR_ERR1_Pos = 0x1
	// Bit mask of ERR1 field.
	DMA_ERR_ERR1_Msk = 0x2
	// Bit ERR1.
	DMA_ERR_ERR1 = 0x2
	// An error in this channel has not occurred
	DMA_ERR_ERR1_ERR1_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR1_ERR1_1 = 0x1
	// Position of ERR2 field.
	DMA_ERR_ERR2_Pos = 0x2
	// Bit mask of ERR2 field.
	DMA_ERR_ERR2_Msk = 0x4
	// Bit ERR2.
	DMA_ERR_ERR2 = 0x4
	// An error in this channel has not occurred
	DMA_ERR_ERR2_ERR2_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR2_ERR2_1 = 0x1
	// Position of ERR3 field.
	DMA_ERR_ERR3_Pos = 0x3
	// Bit mask of ERR3 field.
	DMA_ERR_ERR3_Msk = 0x8
	// Bit ERR3.
	DMA_ERR_ERR3 = 0x8
	// An error in this channel has not occurred
	DMA_ERR_ERR3_ERR3_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR3_ERR3_1 = 0x1
	// Position of ERR4 field.
	DMA_ERR_ERR4_Pos = 0x4
	// Bit mask of ERR4 field.
	DMA_ERR_ERR4_Msk = 0x10
	// Bit ERR4.
	DMA_ERR_ERR4 = 0x10
	// An error in this channel has not occurred
	DMA_ERR_ERR4_ERR4_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR4_ERR4_1 = 0x1
	// Position of ERR5 field.
	DMA_ERR_ERR5_Pos = 0x5
	// Bit mask of ERR5 field.
	DMA_ERR_ERR5_Msk = 0x20
	// Bit ERR5.
	DMA_ERR_ERR5 = 0x20
	// An error in this channel has not occurred
	DMA_ERR_ERR5_ERR5_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR5_ERR5_1 = 0x1
	// Position of ERR6 field.
	DMA_ERR_ERR6_Pos = 0x6
	// Bit mask of ERR6 field.
	DMA_ERR_ERR6_Msk = 0x40
	// Bit ERR6.
	DMA_ERR_ERR6 = 0x40
	// An error in this channel has not occurred
	DMA_ERR_ERR6_ERR6_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR6_ERR6_1 = 0x1
	// Position of ERR7 field.
	DMA_ERR_ERR7_Pos = 0x7
	// Bit mask of ERR7 field.
	DMA_ERR_ERR7_Msk = 0x80
	// Bit ERR7.
	DMA_ERR_ERR7 = 0x80
	// An error in this channel has not occurred
	DMA_ERR_ERR7_ERR7_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR7_ERR7_1 = 0x1
	// Position of ERR8 field.
	DMA_ERR_ERR8_Pos = 0x8
	// Bit mask of ERR8 field.
	DMA_ERR_ERR8_Msk = 0x100
	// Bit ERR8.
	DMA_ERR_ERR8 = 0x100
	// An error in this channel has not occurred
	DMA_ERR_ERR8_ERR8_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR8_ERR8_1 = 0x1
	// Position of ERR9 field.
	DMA_ERR_ERR9_Pos = 0x9
	// Bit mask of ERR9 field.
	DMA_ERR_ERR9_Msk = 0x200
	// Bit ERR9.
	DMA_ERR_ERR9 = 0x200
	// An error in this channel has not occurred
	DMA_ERR_ERR9_ERR9_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR9_ERR9_1 = 0x1
	// Position of ERR10 field.
	DMA_ERR_ERR10_Pos = 0xa
	// Bit mask of ERR10 field.
	DMA_ERR_ERR10_Msk = 0x400
	// Bit ERR10.
	DMA_ERR_ERR10 = 0x400
	// An error in this channel has not occurred
	DMA_ERR_ERR10_ERR10_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR10_ERR10_1 = 0x1
	// Position of ERR11 field.
	DMA_ERR_ERR11_Pos = 0xb
	// Bit mask of ERR11 field.
	DMA_ERR_ERR11_Msk = 0x800
	// Bit ERR11.
	DMA_ERR_ERR11 = 0x800
	// An error in this channel has not occurred
	DMA_ERR_ERR11_ERR11_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR11_ERR11_1 = 0x1
	// Position of ERR12 field.
	DMA_ERR_ERR12_Pos = 0xc
	// Bit mask of ERR12 field.
	DMA_ERR_ERR12_Msk = 0x1000
	// Bit ERR12.
	DMA_ERR_ERR12 = 0x1000
	// An error in this channel has not occurred
	DMA_ERR_ERR12_ERR12_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR12_ERR12_1 = 0x1
	// Position of ERR13 field.
	DMA_ERR_ERR13_Pos = 0xd
	// Bit mask of ERR13 field.
	DMA_ERR_ERR13_Msk = 0x2000
	// Bit ERR13.
	DMA_ERR_ERR13 = 0x2000
	// An error in this channel has not occurred
	DMA_ERR_ERR13_ERR13_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR13_ERR13_1 = 0x1
	// Position of ERR14 field.
	DMA_ERR_ERR14_Pos = 0xe
	// Bit mask of ERR14 field.
	DMA_ERR_ERR14_Msk = 0x4000
	// Bit ERR14.
	DMA_ERR_ERR14 = 0x4000
	// An error in this channel has not occurred
	DMA_ERR_ERR14_ERR14_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR14_ERR14_1 = 0x1
	// Position of ERR15 field.
	DMA_ERR_ERR15_Pos = 0xf
	// Bit mask of ERR15 field.
	DMA_ERR_ERR15_Msk = 0x8000
	// Bit ERR15.
	DMA_ERR_ERR15 = 0x8000
	// An error in this channel has not occurred
	DMA_ERR_ERR15_ERR15_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR15_ERR15_1 = 0x1
	// Position of ERR16 field.
	DMA_ERR_ERR16_Pos = 0x10
	// Bit mask of ERR16 field.
	DMA_ERR_ERR16_Msk = 0x10000
	// Bit ERR16.
	DMA_ERR_ERR16 = 0x10000
	// An error in this channel has not occurred
	DMA_ERR_ERR16_ERR16_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR16_ERR16_1 = 0x1
	// Position of ERR17 field.
	DMA_ERR_ERR17_Pos = 0x11
	// Bit mask of ERR17 field.
	DMA_ERR_ERR17_Msk = 0x20000
	// Bit ERR17.
	DMA_ERR_ERR17 = 0x20000
	// An error in this channel has not occurred
	DMA_ERR_ERR17_ERR17_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR17_ERR17_1 = 0x1
	// Position of ERR18 field.
	DMA_ERR_ERR18_Pos = 0x12
	// Bit mask of ERR18 field.
	DMA_ERR_ERR18_Msk = 0x40000
	// Bit ERR18.
	DMA_ERR_ERR18 = 0x40000
	// An error in this channel has not occurred
	DMA_ERR_ERR18_ERR18_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR18_ERR18_1 = 0x1
	// Position of ERR19 field.
	DMA_ERR_ERR19_Pos = 0x13
	// Bit mask of ERR19 field.
	DMA_ERR_ERR19_Msk = 0x80000
	// Bit ERR19.
	DMA_ERR_ERR19 = 0x80000
	// An error in this channel has not occurred
	DMA_ERR_ERR19_ERR19_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR19_ERR19_1 = 0x1
	// Position of ERR20 field.
	DMA_ERR_ERR20_Pos = 0x14
	// Bit mask of ERR20 field.
	DMA_ERR_ERR20_Msk = 0x100000
	// Bit ERR20.
	DMA_ERR_ERR20 = 0x100000
	// An error in this channel has not occurred
	DMA_ERR_ERR20_ERR20_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR20_ERR20_1 = 0x1
	// Position of ERR21 field.
	DMA_ERR_ERR21_Pos = 0x15
	// Bit mask of ERR21 field.
	DMA_ERR_ERR21_Msk = 0x200000
	// Bit ERR21.
	DMA_ERR_ERR21 = 0x200000
	// An error in this channel has not occurred
	DMA_ERR_ERR21_ERR21_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR21_ERR21_1 = 0x1
	// Position of ERR22 field.
	DMA_ERR_ERR22_Pos = 0x16
	// Bit mask of ERR22 field.
	DMA_ERR_ERR22_Msk = 0x400000
	// Bit ERR22.
	DMA_ERR_ERR22 = 0x400000
	// An error in this channel has not occurred
	DMA_ERR_ERR22_ERR22_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR22_ERR22_1 = 0x1
	// Position of ERR23 field.
	DMA_ERR_ERR23_Pos = 0x17
	// Bit mask of ERR23 field.
	DMA_ERR_ERR23_Msk = 0x800000
	// Bit ERR23.
	DMA_ERR_ERR23 = 0x800000
	// An error in this channel has not occurred
	DMA_ERR_ERR23_ERR23_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR23_ERR23_1 = 0x1
	// Position of ERR24 field.
	DMA_ERR_ERR24_Pos = 0x18
	// Bit mask of ERR24 field.
	DMA_ERR_ERR24_Msk = 0x1000000
	// Bit ERR24.
	DMA_ERR_ERR24 = 0x1000000
	// An error in this channel has not occurred
	DMA_ERR_ERR24_ERR24_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR24_ERR24_1 = 0x1
	// Position of ERR25 field.
	DMA_ERR_ERR25_Pos = 0x19
	// Bit mask of ERR25 field.
	DMA_ERR_ERR25_Msk = 0x2000000
	// Bit ERR25.
	DMA_ERR_ERR25 = 0x2000000
	// An error in this channel has not occurred
	DMA_ERR_ERR25_ERR25_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR25_ERR25_1 = 0x1
	// Position of ERR26 field.
	DMA_ERR_ERR26_Pos = 0x1a
	// Bit mask of ERR26 field.
	DMA_ERR_ERR26_Msk = 0x4000000
	// Bit ERR26.
	DMA_ERR_ERR26 = 0x4000000
	// An error in this channel has not occurred
	DMA_ERR_ERR26_ERR26_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR26_ERR26_1 = 0x1
	// Position of ERR27 field.
	DMA_ERR_ERR27_Pos = 0x1b
	// Bit mask of ERR27 field.
	DMA_ERR_ERR27_Msk = 0x8000000
	// Bit ERR27.
	DMA_ERR_ERR27 = 0x8000000
	// An error in this channel has not occurred
	DMA_ERR_ERR27_ERR27_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR27_ERR27_1 = 0x1
	// Position of ERR28 field.
	DMA_ERR_ERR28_Pos = 0x1c
	// Bit mask of ERR28 field.
	DMA_ERR_ERR28_Msk = 0x10000000
	// Bit ERR28.
	DMA_ERR_ERR28 = 0x10000000
	// An error in this channel has not occurred
	DMA_ERR_ERR28_ERR28_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR28_ERR28_1 = 0x1
	// Position of ERR29 field.
	DMA_ERR_ERR29_Pos = 0x1d
	// Bit mask of ERR29 field.
	DMA_ERR_ERR29_Msk = 0x20000000
	// Bit ERR29.
	DMA_ERR_ERR29 = 0x20000000
	// An error in this channel has not occurred
	DMA_ERR_ERR29_ERR29_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR29_ERR29_1 = 0x1
	// Position of ERR30 field.
	DMA_ERR_ERR30_Pos = 0x1e
	// Bit mask of ERR30 field.
	DMA_ERR_ERR30_Msk = 0x40000000
	// Bit ERR30.
	DMA_ERR_ERR30 = 0x40000000
	// An error in this channel has not occurred
	DMA_ERR_ERR30_ERR30_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR30_ERR30_1 = 0x1
	// Position of ERR31 field.
	DMA_ERR_ERR31_Pos = 0x1f
	// Bit mask of ERR31 field.
	DMA_ERR_ERR31_Msk = 0x80000000
	// Bit ERR31.
	DMA_ERR_ERR31 = 0x80000000
	// An error in this channel has not occurred
	DMA_ERR_ERR31_ERR31_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR31_ERR31_1 = 0x1

	// HRS: Hardware Request Status Register
	// Position of HRS0 field.
	DMA_HRS_HRS0_Pos = 0x0
	// Bit mask of HRS0 field.
	DMA_HRS_HRS0_Msk = 0x1
	// Bit HRS0.
	DMA_HRS_HRS0 = 0x1
	// A hardware service request for channel 0 is not present
	DMA_HRS_HRS0_HRS0_0 = 0x0
	// A hardware service request for channel 0 is present
	DMA_HRS_HRS0_HRS0_1 = 0x1
	// Position of HRS1 field.
	DMA_HRS_HRS1_Pos = 0x1
	// Bit mask of HRS1 field.
	DMA_HRS_HRS1_Msk = 0x2
	// Bit HRS1.
	DMA_HRS_HRS1 = 0x2
	// A hardware service request for channel 1 is not present
	DMA_HRS_HRS1_HRS1_0 = 0x0
	// A hardware service request for channel 1 is present
	DMA_HRS_HRS1_HRS1_1 = 0x1
	// Position of HRS2 field.
	DMA_HRS_HRS2_Pos = 0x2
	// Bit mask of HRS2 field.
	DMA_HRS_HRS2_Msk = 0x4
	// Bit HRS2.
	DMA_HRS_HRS2 = 0x4
	// A hardware service request for channel 2 is not present
	DMA_HRS_HRS2_HRS2_0 = 0x0
	// A hardware service request for channel 2 is present
	DMA_HRS_HRS2_HRS2_1 = 0x1
	// Position of HRS3 field.
	DMA_HRS_HRS3_Pos = 0x3
	// Bit mask of HRS3 field.
	DMA_HRS_HRS3_Msk = 0x8
	// Bit HRS3.
	DMA_HRS_HRS3 = 0x8
	// A hardware service request for channel 3 is not present
	DMA_HRS_HRS3_HRS3_0 = 0x0
	// A hardware service request for channel 3 is present
	DMA_HRS_HRS3_HRS3_1 = 0x1
	// Position of HRS4 field.
	DMA_HRS_HRS4_Pos = 0x4
	// Bit mask of HRS4 field.
	DMA_HRS_HRS4_Msk = 0x10
	// Bit HRS4.
	DMA_HRS_HRS4 = 0x10
	// A hardware service request for channel 4 is not present
	DMA_HRS_HRS4_HRS4_0 = 0x0
	// A hardware service request for channel 4 is present
	DMA_HRS_HRS4_HRS4_1 = 0x1
	// Position of HRS5 field.
	DMA_HRS_HRS5_Pos = 0x5
	// Bit mask of HRS5 field.
	DMA_HRS_HRS5_Msk = 0x20
	// Bit HRS5.
	DMA_HRS_HRS5 = 0x20
	// A hardware service request for channel 5 is not present
	DMA_HRS_HRS5_HRS5_0 = 0x0
	// A hardware service request for channel 5 is present
	DMA_HRS_HRS5_HRS5_1 = 0x1
	// Position of HRS6 field.
	DMA_HRS_HRS6_Pos = 0x6
	// Bit mask of HRS6 field.
	DMA_HRS_HRS6_Msk = 0x40
	// Bit HRS6.
	DMA_HRS_HRS6 = 0x40
	// A hardware service request for channel 6 is not present
	DMA_HRS_HRS6_HRS6_0 = 0x0
	// A hardware service request for channel 6 is present
	DMA_HRS_HRS6_HRS6_1 = 0x1
	// Position of HRS7 field.
	DMA_HRS_HRS7_Pos = 0x7
	// Bit mask of HRS7 field.
	DMA_HRS_HRS7_Msk = 0x80
	// Bit HRS7.
	DMA_HRS_HRS7 = 0x80
	// A hardware service request for channel 7 is not present
	DMA_HRS_HRS7_HRS7_0 = 0x0
	// A hardware service request for channel 7 is present
	DMA_HRS_HRS7_HRS7_1 = 0x1
	// Position of HRS8 field.
	DMA_HRS_HRS8_Pos = 0x8
	// Bit mask of HRS8 field.
	DMA_HRS_HRS8_Msk = 0x100
	// Bit HRS8.
	DMA_HRS_HRS8 = 0x100
	// A hardware service request for channel 8 is not present
	DMA_HRS_HRS8_HRS8_0 = 0x0
	// A hardware service request for channel 8 is present
	DMA_HRS_HRS8_HRS8_1 = 0x1
	// Position of HRS9 field.
	DMA_HRS_HRS9_Pos = 0x9
	// Bit mask of HRS9 field.
	DMA_HRS_HRS9_Msk = 0x200
	// Bit HRS9.
	DMA_HRS_HRS9 = 0x200
	// A hardware service request for channel 9 is not present
	DMA_HRS_HRS9_HRS9_0 = 0x0
	// A hardware service request for channel 9 is present
	DMA_HRS_HRS9_HRS9_1 = 0x1
	// Position of HRS10 field.
	DMA_HRS_HRS10_Pos = 0xa
	// Bit mask of HRS10 field.
	DMA_HRS_HRS10_Msk = 0x400
	// Bit HRS10.
	DMA_HRS_HRS10 = 0x400
	// A hardware service request for channel 10 is not present
	DMA_HRS_HRS10_HRS10_0 = 0x0
	// A hardware service request for channel 10 is present
	DMA_HRS_HRS10_HRS10_1 = 0x1
	// Position of HRS11 field.
	DMA_HRS_HRS11_Pos = 0xb
	// Bit mask of HRS11 field.
	DMA_HRS_HRS11_Msk = 0x800
	// Bit HRS11.
	DMA_HRS_HRS11 = 0x800
	// A hardware service request for channel 11 is not present
	DMA_HRS_HRS11_HRS11_0 = 0x0
	// A hardware service request for channel 11 is present
	DMA_HRS_HRS11_HRS11_1 = 0x1
	// Position of HRS12 field.
	DMA_HRS_HRS12_Pos = 0xc
	// Bit mask of HRS12 field.
	DMA_HRS_HRS12_Msk = 0x1000
	// Bit HRS12.
	DMA_HRS_HRS12 = 0x1000
	// A hardware service request for channel 12 is not present
	DMA_HRS_HRS12_HRS12_0 = 0x0
	// A hardware service request for channel 12 is present
	DMA_HRS_HRS12_HRS12_1 = 0x1
	// Position of HRS13 field.
	DMA_HRS_HRS13_Pos = 0xd
	// Bit mask of HRS13 field.
	DMA_HRS_HRS13_Msk = 0x2000
	// Bit HRS13.
	DMA_HRS_HRS13 = 0x2000
	// A hardware service request for channel 13 is not present
	DMA_HRS_HRS13_HRS13_0 = 0x0
	// A hardware service request for channel 13 is present
	DMA_HRS_HRS13_HRS13_1 = 0x1
	// Position of HRS14 field.
	DMA_HRS_HRS14_Pos = 0xe
	// Bit mask of HRS14 field.
	DMA_HRS_HRS14_Msk = 0x4000
	// Bit HRS14.
	DMA_HRS_HRS14 = 0x4000
	// A hardware service request for channel 14 is not present
	DMA_HRS_HRS14_HRS14_0 = 0x0
	// A hardware service request for channel 14 is present
	DMA_HRS_HRS14_HRS14_1 = 0x1
	// Position of HRS15 field.
	DMA_HRS_HRS15_Pos = 0xf
	// Bit mask of HRS15 field.
	DMA_HRS_HRS15_Msk = 0x8000
	// Bit HRS15.
	DMA_HRS_HRS15 = 0x8000
	// A hardware service request for channel 15 is not present
	DMA_HRS_HRS15_HRS15_0 = 0x0
	// A hardware service request for channel 15 is present
	DMA_HRS_HRS15_HRS15_1 = 0x1
	// Position of HRS16 field.
	DMA_HRS_HRS16_Pos = 0x10
	// Bit mask of HRS16 field.
	DMA_HRS_HRS16_Msk = 0x10000
	// Bit HRS16.
	DMA_HRS_HRS16 = 0x10000
	// A hardware service request for channel 16 is not present
	DMA_HRS_HRS16_HRS16_0 = 0x0
	// A hardware service request for channel 16 is present
	DMA_HRS_HRS16_HRS16_1 = 0x1
	// Position of HRS17 field.
	DMA_HRS_HRS17_Pos = 0x11
	// Bit mask of HRS17 field.
	DMA_HRS_HRS17_Msk = 0x20000
	// Bit HRS17.
	DMA_HRS_HRS17 = 0x20000
	// A hardware service request for channel 17 is not present
	DMA_HRS_HRS17_HRS17_0 = 0x0
	// A hardware service request for channel 17 is present
	DMA_HRS_HRS17_HRS17_1 = 0x1
	// Position of HRS18 field.
	DMA_HRS_HRS18_Pos = 0x12
	// Bit mask of HRS18 field.
	DMA_HRS_HRS18_Msk = 0x40000
	// Bit HRS18.
	DMA_HRS_HRS18 = 0x40000
	// A hardware service request for channel 18 is not present
	DMA_HRS_HRS18_HRS18_0 = 0x0
	// A hardware service request for channel 18 is present
	DMA_HRS_HRS18_HRS18_1 = 0x1
	// Position of HRS19 field.
	DMA_HRS_HRS19_Pos = 0x13
	// Bit mask of HRS19 field.
	DMA_HRS_HRS19_Msk = 0x80000
	// Bit HRS19.
	DMA_HRS_HRS19 = 0x80000
	// A hardware service request for channel 19 is not present
	DMA_HRS_HRS19_HRS19_0 = 0x0
	// A hardware service request for channel 19 is present
	DMA_HRS_HRS19_HRS19_1 = 0x1
	// Position of HRS20 field.
	DMA_HRS_HRS20_Pos = 0x14
	// Bit mask of HRS20 field.
	DMA_HRS_HRS20_Msk = 0x100000
	// Bit HRS20.
	DMA_HRS_HRS20 = 0x100000
	// A hardware service request for channel 20 is not present
	DMA_HRS_HRS20_HRS20_0 = 0x0
	// A hardware service request for channel 20 is present
	DMA_HRS_HRS20_HRS20_1 = 0x1
	// Position of HRS21 field.
	DMA_HRS_HRS21_Pos = 0x15
	// Bit mask of HRS21 field.
	DMA_HRS_HRS21_Msk = 0x200000
	// Bit HRS21.
	DMA_HRS_HRS21 = 0x200000
	// A hardware service request for channel 21 is not present
	DMA_HRS_HRS21_HRS21_0 = 0x0
	// A hardware service request for channel 21 is present
	DMA_HRS_HRS21_HRS21_1 = 0x1
	// Position of HRS22 field.
	DMA_HRS_HRS22_Pos = 0x16
	// Bit mask of HRS22 field.
	DMA_HRS_HRS22_Msk = 0x400000
	// Bit HRS22.
	DMA_HRS_HRS22 = 0x400000
	// A hardware service request for channel 22 is not present
	DMA_HRS_HRS22_HRS22_0 = 0x0
	// A hardware service request for channel 22 is present
	DMA_HRS_HRS22_HRS22_1 = 0x1
	// Position of HRS23 field.
	DMA_HRS_HRS23_Pos = 0x17
	// Bit mask of HRS23 field.
	DMA_HRS_HRS23_Msk = 0x800000
	// Bit HRS23.
	DMA_HRS_HRS23 = 0x800000
	// A hardware service request for channel 23 is not present
	DMA_HRS_HRS23_HRS23_0 = 0x0
	// A hardware service request for channel 23 is present
	DMA_HRS_HRS23_HRS23_1 = 0x1
	// Position of HRS24 field.
	DMA_HRS_HRS24_Pos = 0x18
	// Bit mask of HRS24 field.
	DMA_HRS_HRS24_Msk = 0x1000000
	// Bit HRS24.
	DMA_HRS_HRS24 = 0x1000000
	// A hardware service request for channel 24 is not present
	DMA_HRS_HRS24_HRS24_0 = 0x0
	// A hardware service request for channel 24 is present
	DMA_HRS_HRS24_HRS24_1 = 0x1
	// Position of HRS25 field.
	DMA_HRS_HRS25_Pos = 0x19
	// Bit mask of HRS25 field.
	DMA_HRS_HRS25_Msk = 0x2000000
	// Bit HRS25.
	DMA_HRS_HRS25 = 0x2000000
	// A hardware service request for channel 25 is not present
	DMA_HRS_HRS25_HRS25_0 = 0x0
	// A hardware service request for channel 25 is present
	DMA_HRS_HRS25_HRS25_1 = 0x1
	// Position of HRS26 field.
	DMA_HRS_HRS26_Pos = 0x1a
	// Bit mask of HRS26 field.
	DMA_HRS_HRS26_Msk = 0x4000000
	// Bit HRS26.
	DMA_HRS_HRS26 = 0x4000000
	// A hardware service request for channel 26 is not present
	DMA_HRS_HRS26_HRS26_0 = 0x0
	// A hardware service request for channel 26 is present
	DMA_HRS_HRS26_HRS26_1 = 0x1
	// Position of HRS27 field.
	DMA_HRS_HRS27_Pos = 0x1b
	// Bit mask of HRS27 field.
	DMA_HRS_HRS27_Msk = 0x8000000
	// Bit HRS27.
	DMA_HRS_HRS27 = 0x8000000
	// A hardware service request for channel 27 is not present
	DMA_HRS_HRS27_HRS27_0 = 0x0
	// A hardware service request for channel 27 is present
	DMA_HRS_HRS27_HRS27_1 = 0x1
	// Position of HRS28 field.
	DMA_HRS_HRS28_Pos = 0x1c
	// Bit mask of HRS28 field.
	DMA_HRS_HRS28_Msk = 0x10000000
	// Bit HRS28.
	DMA_HRS_HRS28 = 0x10000000
	// A hardware service request for channel 28 is not present
	DMA_HRS_HRS28_HRS28_0 = 0x0
	// A hardware service request for channel 28 is present
	DMA_HRS_HRS28_HRS28_1 = 0x1
	// Position of HRS29 field.
	DMA_HRS_HRS29_Pos = 0x1d
	// Bit mask of HRS29 field.
	DMA_HRS_HRS29_Msk = 0x20000000
	// Bit HRS29.
	DMA_HRS_HRS29 = 0x20000000
	// A hardware service request for channel 29 is not preset
	DMA_HRS_HRS29_HRS29_0 = 0x0
	// A hardware service request for channel 29 is present
	DMA_HRS_HRS29_HRS29_1 = 0x1
	// Position of HRS30 field.
	DMA_HRS_HRS30_Pos = 0x1e
	// Bit mask of HRS30 field.
	DMA_HRS_HRS30_Msk = 0x40000000
	// Bit HRS30.
	DMA_HRS_HRS30 = 0x40000000
	// A hardware service request for channel 30 is not present
	DMA_HRS_HRS30_HRS30_0 = 0x0
	// A hardware service request for channel 30 is present
	DMA_HRS_HRS30_HRS30_1 = 0x1
	// Position of HRS31 field.
	DMA_HRS_HRS31_Pos = 0x1f
	// Bit mask of HRS31 field.
	DMA_HRS_HRS31_Msk = 0x80000000
	// Bit HRS31.
	DMA_HRS_HRS31 = 0x80000000
	// A hardware service request for channel 31 is not present
	DMA_HRS_HRS31_HRS31_0 = 0x0
	// A hardware service request for channel 31 is present
	DMA_HRS_HRS31_HRS31_1 = 0x1

	// EARS: Enable Asynchronous Request in Stop Register
	// Position of EDREQ_0 field.
	DMA_EARS_EDREQ_0_Pos = 0x0
	// Bit mask of EDREQ_0 field.
	DMA_EARS_EDREQ_0_Msk = 0x1
	// Bit EDREQ_0.
	DMA_EARS_EDREQ_0 = 0x1
	// Disable asynchronous DMA request for channel 0.
	DMA_EARS_EDREQ_0_EDREQ_0_0 = 0x0
	// Enable asynchronous DMA request for channel 0.
	DMA_EARS_EDREQ_0_EDREQ_0_1 = 0x1
	// Position of EDREQ_1 field.
	DMA_EARS_EDREQ_1_Pos = 0x1
	// Bit mask of EDREQ_1 field.
	DMA_EARS_EDREQ_1_Msk = 0x2
	// Bit EDREQ_1.
	DMA_EARS_EDREQ_1 = 0x2
	// Disable asynchronous DMA request for channel 1
	DMA_EARS_EDREQ_1_EDREQ_1_0 = 0x0
	// Enable asynchronous DMA request for channel 1.
	DMA_EARS_EDREQ_1_EDREQ_1_1 = 0x1
	// Position of EDREQ_2 field.
	DMA_EARS_EDREQ_2_Pos = 0x2
	// Bit mask of EDREQ_2 field.
	DMA_EARS_EDREQ_2_Msk = 0x4
	// Bit EDREQ_2.
	DMA_EARS_EDREQ_2 = 0x4
	// Disable asynchronous DMA request for channel 2.
	DMA_EARS_EDREQ_2_EDREQ_2_0 = 0x0
	// Enable asynchronous DMA request for channel 2.
	DMA_EARS_EDREQ_2_EDREQ_2_1 = 0x1
	// Position of EDREQ_3 field.
	DMA_EARS_EDREQ_3_Pos = 0x3
	// Bit mask of EDREQ_3 field.
	DMA_EARS_EDREQ_3_Msk = 0x8
	// Bit EDREQ_3.
	DMA_EARS_EDREQ_3 = 0x8
	// Disable asynchronous DMA request for channel 3.
	DMA_EARS_EDREQ_3_EDREQ_3_0 = 0x0
	// Enable asynchronous DMA request for channel 3.
	DMA_EARS_EDREQ_3_EDREQ_3_1 = 0x1
	// Position of EDREQ_4 field.
	DMA_EARS_EDREQ_4_Pos = 0x4
	// Bit mask of EDREQ_4 field.
	DMA_EARS_EDREQ_4_Msk = 0x10
	// Bit EDREQ_4.
	DMA_EARS_EDREQ_4 = 0x10
	// Disable asynchronous DMA request for channel 4.
	DMA_EARS_EDREQ_4_EDREQ_4_0 = 0x0
	// Enable asynchronous DMA request for channel 4.
	DMA_EARS_EDREQ_4_EDREQ_4_1 = 0x1
	// Position of EDREQ_5 field.
	DMA_EARS_EDREQ_5_Pos = 0x5
	// Bit mask of EDREQ_5 field.
	DMA_EARS_EDREQ_5_Msk = 0x20
	// Bit EDREQ_5.
	DMA_EARS_EDREQ_5 = 0x20
	// Disable asynchronous DMA request for channel 5.
	DMA_EARS_EDREQ_5_EDREQ_5_0 = 0x0
	// Enable asynchronous DMA request for channel 5.
	DMA_EARS_EDREQ_5_EDREQ_5_1 = 0x1
	// Position of EDREQ_6 field.
	DMA_EARS_EDREQ_6_Pos = 0x6
	// Bit mask of EDREQ_6 field.
	DMA_EARS_EDREQ_6_Msk = 0x40
	// Bit EDREQ_6.
	DMA_EARS_EDREQ_6 = 0x40
	// Disable asynchronous DMA request for channel 6.
	DMA_EARS_EDREQ_6_EDREQ_6_0 = 0x0
	// Enable asynchronous DMA request for channel 6.
	DMA_EARS_EDREQ_6_EDREQ_6_1 = 0x1
	// Position of EDREQ_7 field.
	DMA_EARS_EDREQ_7_Pos = 0x7
	// Bit mask of EDREQ_7 field.
	DMA_EARS_EDREQ_7_Msk = 0x80
	// Bit EDREQ_7.
	DMA_EARS_EDREQ_7 = 0x80
	// Disable asynchronous DMA request for channel 7.
	DMA_EARS_EDREQ_7_EDREQ_7_0 = 0x0
	// Enable asynchronous DMA request for channel 7.
	DMA_EARS_EDREQ_7_EDREQ_7_1 = 0x1
	// Position of EDREQ_8 field.
	DMA_EARS_EDREQ_8_Pos = 0x8
	// Bit mask of EDREQ_8 field.
	DMA_EARS_EDREQ_8_Msk = 0x100
	// Bit EDREQ_8.
	DMA_EARS_EDREQ_8 = 0x100
	// Disable asynchronous DMA request for channel 8.
	DMA_EARS_EDREQ_8_EDREQ_8_0 = 0x0
	// Enable asynchronous DMA request for channel 8.
	DMA_EARS_EDREQ_8_EDREQ_8_1 = 0x1
	// Position of EDREQ_9 field.
	DMA_EARS_EDREQ_9_Pos = 0x9
	// Bit mask of EDREQ_9 field.
	DMA_EARS_EDREQ_9_Msk = 0x200
	// Bit EDREQ_9.
	DMA_EARS_EDREQ_9 = 0x200
	// Disable asynchronous DMA request for channel 9.
	DMA_EARS_EDREQ_9_EDREQ_9_0 = 0x0
	// Enable asynchronous DMA request for channel 9.
	DMA_EARS_EDREQ_9_EDREQ_9_1 = 0x1
	// Position of EDREQ_10 field.
	DMA_EARS_EDREQ_10_Pos = 0xa
	// Bit mask of EDREQ_10 field.
	DMA_EARS_EDREQ_10_Msk = 0x400
	// Bit EDREQ_10.
	DMA_EARS_EDREQ_10 = 0x400
	// Disable asynchronous DMA request for channel 10.
	DMA_EARS_EDREQ_10_EDREQ_10_0 = 0x0
	// Enable asynchronous DMA request for channel 10.
	DMA_EARS_EDREQ_10_EDREQ_10_1 = 0x1
	// Position of EDREQ_11 field.
	DMA_EARS_EDREQ_11_Pos = 0xb
	// Bit mask of EDREQ_11 field.
	DMA_EARS_EDREQ_11_Msk = 0x800
	// Bit EDREQ_11.
	DMA_EARS_EDREQ_11 = 0x800
	// Disable asynchronous DMA request for channel 11.
	DMA_EARS_EDREQ_11_EDREQ_11_0 = 0x0
	// Enable asynchronous DMA request for channel 11.
	DMA_EARS_EDREQ_11_EDREQ_11_1 = 0x1
	// Position of EDREQ_12 field.
	DMA_EARS_EDREQ_12_Pos = 0xc
	// Bit mask of EDREQ_12 field.
	DMA_EARS_EDREQ_12_Msk = 0x1000
	// Bit EDREQ_12.
	DMA_EARS_EDREQ_12 = 0x1000
	// Disable asynchronous DMA request for channel 12.
	DMA_EARS_EDREQ_12_EDREQ_12_0 = 0x0
	// Enable asynchronous DMA request for channel 12.
	DMA_EARS_EDREQ_12_EDREQ_12_1 = 0x1
	// Position of EDREQ_13 field.
	DMA_EARS_EDREQ_13_Pos = 0xd
	// Bit mask of EDREQ_13 field.
	DMA_EARS_EDREQ_13_Msk = 0x2000
	// Bit EDREQ_13.
	DMA_EARS_EDREQ_13 = 0x2000
	// Disable asynchronous DMA request for channel 13.
	DMA_EARS_EDREQ_13_EDREQ_13_0 = 0x0
	// Enable asynchronous DMA request for channel 13.
	DMA_EARS_EDREQ_13_EDREQ_13_1 = 0x1
	// Position of EDREQ_14 field.
	DMA_EARS_EDREQ_14_Pos = 0xe
	// Bit mask of EDREQ_14 field.
	DMA_EARS_EDREQ_14_Msk = 0x4000
	// Bit EDREQ_14.
	DMA_EARS_EDREQ_14 = 0x4000
	// Disable asynchronous DMA request for channel 14.
	DMA_EARS_EDREQ_14_EDREQ_14_0 = 0x0
	// Enable asynchronous DMA request for channel 14.
	DMA_EARS_EDREQ_14_EDREQ_14_1 = 0x1
	// Position of EDREQ_15 field.
	DMA_EARS_EDREQ_15_Pos = 0xf
	// Bit mask of EDREQ_15 field.
	DMA_EARS_EDREQ_15_Msk = 0x8000
	// Bit EDREQ_15.
	DMA_EARS_EDREQ_15 = 0x8000
	// Disable asynchronous DMA request for channel 15.
	DMA_EARS_EDREQ_15_EDREQ_15_0 = 0x0
	// Enable asynchronous DMA request for channel 15.
	DMA_EARS_EDREQ_15_EDREQ_15_1 = 0x1
	// Position of EDREQ_16 field.
	DMA_EARS_EDREQ_16_Pos = 0x10
	// Bit mask of EDREQ_16 field.
	DMA_EARS_EDREQ_16_Msk = 0x10000
	// Bit EDREQ_16.
	DMA_EARS_EDREQ_16 = 0x10000
	// Disable asynchronous DMA request for channel 16
	DMA_EARS_EDREQ_16_EDREQ_16_0 = 0x0
	// Enable asynchronous DMA request for channel 16
	DMA_EARS_EDREQ_16_EDREQ_16_1 = 0x1
	// Position of EDREQ_17 field.
	DMA_EARS_EDREQ_17_Pos = 0x11
	// Bit mask of EDREQ_17 field.
	DMA_EARS_EDREQ_17_Msk = 0x20000
	// Bit EDREQ_17.
	DMA_EARS_EDREQ_17 = 0x20000
	// Disable asynchronous DMA request for channel 17
	DMA_EARS_EDREQ_17_EDREQ_17_0 = 0x0
	// Enable asynchronous DMA request for channel 17
	DMA_EARS_EDREQ_17_EDREQ_17_1 = 0x1
	// Position of EDREQ_18 field.
	DMA_EARS_EDREQ_18_Pos = 0x12
	// Bit mask of EDREQ_18 field.
	DMA_EARS_EDREQ_18_Msk = 0x40000
	// Bit EDREQ_18.
	DMA_EARS_EDREQ_18 = 0x40000
	// Disable asynchronous DMA request for channel 18
	DMA_EARS_EDREQ_18_EDREQ_18_0 = 0x0
	// Enable asynchronous DMA request for channel 18
	DMA_EARS_EDREQ_18_EDREQ_18_1 = 0x1
	// Position of EDREQ_19 field.
	DMA_EARS_EDREQ_19_Pos = 0x13
	// Bit mask of EDREQ_19 field.
	DMA_EARS_EDREQ_19_Msk = 0x80000
	// Bit EDREQ_19.
	DMA_EARS_EDREQ_19 = 0x80000
	// Disable asynchronous DMA request for channel 19
	DMA_EARS_EDREQ_19_EDREQ_19_0 = 0x0
	// Enable asynchronous DMA request for channel 19
	DMA_EARS_EDREQ_19_EDREQ_19_1 = 0x1
	// Position of EDREQ_20 field.
	DMA_EARS_EDREQ_20_Pos = 0x14
	// Bit mask of EDREQ_20 field.
	DMA_EARS_EDREQ_20_Msk = 0x100000
	// Bit EDREQ_20.
	DMA_EARS_EDREQ_20 = 0x100000
	// Disable asynchronous DMA request for channel 20
	DMA_EARS_EDREQ_20_EDREQ_20_0 = 0x0
	// Enable asynchronous DMA request for channel 20
	DMA_EARS_EDREQ_20_EDREQ_20_1 = 0x1
	// Position of EDREQ_21 field.
	DMA_EARS_EDREQ_21_Pos = 0x15
	// Bit mask of EDREQ_21 field.
	DMA_EARS_EDREQ_21_Msk = 0x200000
	// Bit EDREQ_21.
	DMA_EARS_EDREQ_21 = 0x200000
	// Disable asynchronous DMA request for channel 21
	DMA_EARS_EDREQ_21_EDREQ_21_0 = 0x0
	// Enable asynchronous DMA request for channel 21
	DMA_EARS_EDREQ_21_EDREQ_21_1 = 0x1
	// Position of EDREQ_22 field.
	DMA_EARS_EDREQ_22_Pos = 0x16
	// Bit mask of EDREQ_22 field.
	DMA_EARS_EDREQ_22_Msk = 0x400000
	// Bit EDREQ_22.
	DMA_EARS_EDREQ_22 = 0x400000
	// Disable asynchronous DMA request for channel 22
	DMA_EARS_EDREQ_22_EDREQ_22_0 = 0x0
	// Enable asynchronous DMA request for channel 22
	DMA_EARS_EDREQ_22_EDREQ_22_1 = 0x1
	// Position of EDREQ_23 field.
	DMA_EARS_EDREQ_23_Pos = 0x17
	// Bit mask of EDREQ_23 field.
	DMA_EARS_EDREQ_23_Msk = 0x800000
	// Bit EDREQ_23.
	DMA_EARS_EDREQ_23 = 0x800000
	// Disable asynchronous DMA request for channel 23
	DMA_EARS_EDREQ_23_EDREQ_23_0 = 0x0
	// Enable asynchronous DMA request for channel 23
	DMA_EARS_EDREQ_23_EDREQ_23_1 = 0x1
	// Position of EDREQ_24 field.
	DMA_EARS_EDREQ_24_Pos = 0x18
	// Bit mask of EDREQ_24 field.
	DMA_EARS_EDREQ_24_Msk = 0x1000000
	// Bit EDREQ_24.
	DMA_EARS_EDREQ_24 = 0x1000000
	// Disable asynchronous DMA request for channel 24
	DMA_EARS_EDREQ_24_EDREQ_24_0 = 0x0
	// Enable asynchronous DMA request for channel 24
	DMA_EARS_EDREQ_24_EDREQ_24_1 = 0x1
	// Position of EDREQ_25 field.
	DMA_EARS_EDREQ_25_Pos = 0x19
	// Bit mask of EDREQ_25 field.
	DMA_EARS_EDREQ_25_Msk = 0x2000000
	// Bit EDREQ_25.
	DMA_EARS_EDREQ_25 = 0x2000000
	// Disable asynchronous DMA request for channel 25
	DMA_EARS_EDREQ_25_EDREQ_25_0 = 0x0
	// Enable asynchronous DMA request for channel 25
	DMA_EARS_EDREQ_25_EDREQ_25_1 = 0x1
	// Position of EDREQ_26 field.
	DMA_EARS_EDREQ_26_Pos = 0x1a
	// Bit mask of EDREQ_26 field.
	DMA_EARS_EDREQ_26_Msk = 0x4000000
	// Bit EDREQ_26.
	DMA_EARS_EDREQ_26 = 0x4000000
	// Disable asynchronous DMA request for channel 26
	DMA_EARS_EDREQ_26_EDREQ_26_0 = 0x0
	// Enable asynchronous DMA request for channel 26
	DMA_EARS_EDREQ_26_EDREQ_26_1 = 0x1
	// Position of EDREQ_27 field.
	DMA_EARS_EDREQ_27_Pos = 0x1b
	// Bit mask of EDREQ_27 field.
	DMA_EARS_EDREQ_27_Msk = 0x8000000
	// Bit EDREQ_27.
	DMA_EARS_EDREQ_27 = 0x8000000
	// Disable asynchronous DMA request for channel 27
	DMA_EARS_EDREQ_27_EDREQ_27_0 = 0x0
	// Enable asynchronous DMA request for channel 27
	DMA_EARS_EDREQ_27_EDREQ_27_1 = 0x1
	// Position of EDREQ_28 field.
	DMA_EARS_EDREQ_28_Pos = 0x1c
	// Bit mask of EDREQ_28 field.
	DMA_EARS_EDREQ_28_Msk = 0x10000000
	// Bit EDREQ_28.
	DMA_EARS_EDREQ_28 = 0x10000000
	// Disable asynchronous DMA request for channel 28
	DMA_EARS_EDREQ_28_EDREQ_28_0 = 0x0
	// Enable asynchronous DMA request for channel 28
	DMA_EARS_EDREQ_28_EDREQ_28_1 = 0x1
	// Position of EDREQ_29 field.
	DMA_EARS_EDREQ_29_Pos = 0x1d
	// Bit mask of EDREQ_29 field.
	DMA_EARS_EDREQ_29_Msk = 0x20000000
	// Bit EDREQ_29.
	DMA_EARS_EDREQ_29 = 0x20000000
	// Disable asynchronous DMA request for channel 29
	DMA_EARS_EDREQ_29_EDREQ_29_0 = 0x0
	// Enable asynchronous DMA request for channel 29
	DMA_EARS_EDREQ_29_EDREQ_29_1 = 0x1
	// Position of EDREQ_30 field.
	DMA_EARS_EDREQ_30_Pos = 0x1e
	// Bit mask of EDREQ_30 field.
	DMA_EARS_EDREQ_30_Msk = 0x40000000
	// Bit EDREQ_30.
	DMA_EARS_EDREQ_30 = 0x40000000
	// Disable asynchronous DMA request for channel 30
	DMA_EARS_EDREQ_30_EDREQ_30_0 = 0x0
	// Enable asynchronous DMA request for channel 30
	DMA_EARS_EDREQ_30_EDREQ_30_1 = 0x1
	// Position of EDREQ_31 field.
	DMA_EARS_EDREQ_31_Pos = 0x1f
	// Bit mask of EDREQ_31 field.
	DMA_EARS_EDREQ_31_Msk = 0x80000000
	// Bit EDREQ_31.
	DMA_EARS_EDREQ_31 = 0x80000000
	// Disable asynchronous DMA request for channel 31
	DMA_EARS_EDREQ_31_EDREQ_31_0 = 0x0
	// Enable asynchronous DMA request for channel 31
	DMA_EARS_EDREQ_31_EDREQ_31_1 = 0x1

	// DCHPRI3: Channel n Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI3_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI3_CHPRI_Msk = 0xf
	// Position of GRPPRI field.
	DMA_DCHPRI3_GRPPRI_Pos = 0x4
	// Bit mask of GRPPRI field.
	DMA_DCHPRI3_GRPPRI_Msk = 0x30
	// Position of DPA field.
	DMA_DCHPRI3_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI3_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI3_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI3_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI3_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI3_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI3_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI3_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI3_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI3_ECP_ECP_1 = 0x1

	// DCHPRI2: Channel n Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI2_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI2_CHPRI_Msk = 0xf
	// Position of GRPPRI field.
	DMA_DCHPRI2_GRPPRI_Pos = 0x4
	// Bit mask of GRPPRI field.
	DMA_DCHPRI2_GRPPRI_Msk = 0x30
	// Position of DPA field.
	DMA_DCHPRI2_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI2_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI2_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI2_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI2_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI2_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI2_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI2_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI2_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI2_ECP_ECP_1 = 0x1

	// DCHPRI1: Channel n Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI1_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI1_CHPRI_Msk = 0xf
	// Position of GRPPRI field.
	DMA_DCHPRI1_GRPPRI_Pos = 0x4
	// Bit mask of GRPPRI field.
	DMA_DCHPRI1_GRPPRI_Msk = 0x30
	// Position of DPA field.
	DMA_DCHPRI1_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI1_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI1_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI1_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI1_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI1_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI1_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI1_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI1_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI1_ECP_ECP_1 = 0x1

	// DCHPRI0: Channel n Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI0_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI0_CHPRI_Msk = 0xf
	// Position of GRPPRI field.
	DMA_DCHPRI0_GRPPRI_Pos = 0x4
	// Bit mask of GRPPRI field.
	DMA_DCHPRI0_GRPPRI_Msk = 0x30
	// Position of DPA field.
	DMA_DCHPRI0_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI0_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI0_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI0_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI0_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI0_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI0_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI0_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI0_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI0_ECP_ECP_1 = 0x1

	// DCHPRI7: Channel n Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI7_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI7_CHPRI_Msk = 0xf
	// Position of GRPPRI field.
	DMA_DCHPRI7_GRPPRI_Pos = 0x4
	// Bit mask of GRPPRI field.
	DMA_DCHPRI7_GRPPRI_Msk = 0x30
	// Position of DPA field.
	DMA_DCHPRI7_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI7_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI7_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI7_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI7_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI7_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI7_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI7_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI7_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI7_ECP_ECP_1 = 0x1

	// DCHPRI6: Channel n Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI6_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI6_CHPRI_Msk = 0xf
	// Position of GRPPRI field.
	DMA_DCHPRI6_GRPPRI_Pos = 0x4
	// Bit mask of GRPPRI field.
	DMA_DCHPRI6_GRPPRI_Msk = 0x30
	// Position of DPA field.
	DMA_DCHPRI6_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI6_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI6_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI6_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI6_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI6_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI6_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI6_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI6_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI6_ECP_ECP_1 = 0x1

	// DCHPRI5: Channel n Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI5_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI5_CHPRI_Msk = 0xf
	// Position of GRPPRI field.
	DMA_DCHPRI5_GRPPRI_Pos = 0x4
	// Bit mask of GRPPRI field.
	DMA_DCHPRI5_GRPPRI_Msk = 0x30
	// Position of DPA field.
	DMA_DCHPRI5_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI5_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI5_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI5_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI5_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI5_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI5_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI5_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI5_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI5_ECP_ECP_1 = 0x1

	// DCHPRI4: Channel n Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI4_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI4_CHPRI_Msk = 0xf
	// Position of GRPPRI field.
	DMA_DCHPRI4_GRPPRI_Pos = 0x4
	// Bit mask of GRPPRI field.
	DMA_DCHPRI4_GRPPRI_Msk = 0x30
	// Position of DPA field.
	DMA_DCHPRI4_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI4_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI4_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI4_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI4_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI4_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI4_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI4_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI4_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI4_ECP_ECP_1 = 0x1

	// DCHPRI11: Channel n Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI11_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI11_CHPRI_Msk = 0xf
	// Position of GRPPRI field.
	DMA_DCHPRI11_GRPPRI_Pos = 0x4
	// Bit mask of GRPPRI field.
	DMA_DCHPRI11_GRPPRI_Msk = 0x30
	// Position of DPA field.
	DMA_DCHPRI11_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI11_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI11_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI11_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI11_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI11_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI11_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI11_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI11_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI11_ECP_ECP_1 = 0x1

	// DCHPRI10: Channel n Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI10_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI10_CHPRI_Msk = 0xf
	// Position of GRPPRI field.
	DMA_DCHPRI10_GRPPRI_Pos = 0x4
	// Bit mask of GRPPRI field.
	DMA_DCHPRI10_GRPPRI_Msk = 0x30
	// Position of DPA field.
	DMA_DCHPRI10_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI10_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI10_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI10_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI10_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI10_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI10_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI10_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI10_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI10_ECP_ECP_1 = 0x1

	// DCHPRI9: Channel n Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI9_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI9_CHPRI_Msk = 0xf
	// Position of GRPPRI field.
	DMA_DCHPRI9_GRPPRI_Pos = 0x4
	// Bit mask of GRPPRI field.
	DMA_DCHPRI9_GRPPRI_Msk = 0x30
	// Position of DPA field.
	DMA_DCHPRI9_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI9_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI9_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI9_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI9_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI9_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI9_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI9_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI9_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI9_ECP_ECP_1 = 0x1

	// DCHPRI8: Channel n Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI8_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI8_CHPRI_Msk = 0xf
	// Position of GRPPRI field.
	DMA_DCHPRI8_GRPPRI_Pos = 0x4
	// Bit mask of GRPPRI field.
	DMA_DCHPRI8_GRPPRI_Msk = 0x30
	// Position of DPA field.
	DMA_DCHPRI8_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI8_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI8_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI8_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI8_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI8_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI8_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI8_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI8_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI8_ECP_ECP_1 = 0x1

	// DCHPRI15: Channel n Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI15_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI15_CHPRI_Msk = 0xf
	// Position of GRPPRI field.
	DMA_DCHPRI15_GRPPRI_Pos = 0x4
	// Bit mask of GRPPRI field.
	DMA_DCHPRI15_GRPPRI_Msk = 0x30
	// Position of DPA field.
	DMA_DCHPRI15_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI15_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI15_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI15_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI15_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI15_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI15_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI15_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI15_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI15_ECP_ECP_1 = 0x1

	// DCHPRI14: Channel n Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI14_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI14_CHPRI_Msk = 0xf
	// Position of GRPPRI field.
	DMA_DCHPRI14_GRPPRI_Pos = 0x4
	// Bit mask of GRPPRI field.
	DMA_DCHPRI14_GRPPRI_Msk = 0x30
	// Position of DPA field.
	DMA_DCHPRI14_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI14_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI14_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI14_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI14_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI14_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI14_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI14_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI14_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI14_ECP_ECP_1 = 0x1

	// DCHPRI13: Channel n Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI13_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI13_CHPRI_Msk = 0xf
	// Position of GRPPRI field.
	DMA_DCHPRI13_GRPPRI_Pos = 0x4
	// Bit mask of GRPPRI field.
	DMA_DCHPRI13_GRPPRI_Msk = 0x30
	// Position of DPA field.
	DMA_DCHPRI13_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI13_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI13_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI13_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI13_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI13_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI13_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI13_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI13_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI13_ECP_ECP_1 = 0x1

	// DCHPRI12: Channel n Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI12_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI12_CHPRI_Msk = 0xf
	// Position of GRPPRI field.
	DMA_DCHPRI12_GRPPRI_Pos = 0x4
	// Bit mask of GRPPRI field.
	DMA_DCHPRI12_GRPPRI_Msk = 0x30
	// Position of DPA field.
	DMA_DCHPRI12_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI12_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI12_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI12_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI12_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI12_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI12_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI12_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI12_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI12_ECP_ECP_1 = 0x1

	// DCHPRI19: Channel n Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI19_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI19_CHPRI_Msk = 0xf
	// Position of GRPPRI field.
	DMA_DCHPRI19_GRPPRI_Pos = 0x4
	// Bit mask of GRPPRI field.
	DMA_DCHPRI19_GRPPRI_Msk = 0x30
	// Position of DPA field.
	DMA_DCHPRI19_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI19_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI19_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI19_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI19_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI19_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI19_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI19_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI19_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI19_ECP_ECP_1 = 0x1

	// DCHPRI18: Channel n Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI18_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI18_CHPRI_Msk = 0xf
	// Position of GRPPRI field.
	DMA_DCHPRI18_GRPPRI_Pos = 0x4
	// Bit mask of GRPPRI field.
	DMA_DCHPRI18_GRPPRI_Msk = 0x30
	// Position of DPA field.
	DMA_DCHPRI18_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI18_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI18_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI18_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI18_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI18_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI18_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI18_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI18_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI18_ECP_ECP_1 = 0x1

	// DCHPRI17: Channel n Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI17_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI17_CHPRI_Msk = 0xf
	// Position of GRPPRI field.
	DMA_DCHPRI17_GRPPRI_Pos = 0x4
	// Bit mask of GRPPRI field.
	DMA_DCHPRI17_GRPPRI_Msk = 0x30
	// Position of DPA field.
	DMA_DCHPRI17_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI17_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI17_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI17_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI17_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI17_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI17_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI17_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI17_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI17_ECP_ECP_1 = 0x1

	// DCHPRI16: Channel n Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI16_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI16_CHPRI_Msk = 0xf
	// Position of GRPPRI field.
	DMA_DCHPRI16_GRPPRI_Pos = 0x4
	// Bit mask of GRPPRI field.
	DMA_DCHPRI16_GRPPRI_Msk = 0x30
	// Position of DPA field.
	DMA_DCHPRI16_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI16_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI16_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI16_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI16_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI16_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI16_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI16_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI16_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI16_ECP_ECP_1 = 0x1

	// DCHPRI23: Channel n Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI23_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI23_CHPRI_Msk = 0xf
	// Position of GRPPRI field.
	DMA_DCHPRI23_GRPPRI_Pos = 0x4
	// Bit mask of GRPPRI field.
	DMA_DCHPRI23_GRPPRI_Msk = 0x30
	// Position of DPA field.
	DMA_DCHPRI23_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI23_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI23_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI23_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI23_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI23_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI23_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI23_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI23_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI23_ECP_ECP_1 = 0x1

	// DCHPRI22: Channel n Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI22_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI22_CHPRI_Msk = 0xf
	// Position of GRPPRI field.
	DMA_DCHPRI22_GRPPRI_Pos = 0x4
	// Bit mask of GRPPRI field.
	DMA_DCHPRI22_GRPPRI_Msk = 0x30
	// Position of DPA field.
	DMA_DCHPRI22_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI22_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI22_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI22_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI22_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI22_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI22_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI22_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI22_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI22_ECP_ECP_1 = 0x1

	// DCHPRI21: Channel n Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI21_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI21_CHPRI_Msk = 0xf
	// Position of GRPPRI field.
	DMA_DCHPRI21_GRPPRI_Pos = 0x4
	// Bit mask of GRPPRI field.
	DMA_DCHPRI21_GRPPRI_Msk = 0x30
	// Position of DPA field.
	DMA_DCHPRI21_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI21_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI21_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI21_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI21_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI21_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI21_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI21_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI21_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI21_ECP_ECP_1 = 0x1

	// DCHPRI20: Channel n Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI20_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI20_CHPRI_Msk = 0xf
	// Position of GRPPRI field.
	DMA_DCHPRI20_GRPPRI_Pos = 0x4
	// Bit mask of GRPPRI field.
	DMA_DCHPRI20_GRPPRI_Msk = 0x30
	// Position of DPA field.
	DMA_DCHPRI20_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI20_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI20_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI20_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI20_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI20_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI20_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI20_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI20_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI20_ECP_ECP_1 = 0x1

	// DCHPRI27: Channel n Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI27_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI27_CHPRI_Msk = 0xf
	// Position of GRPPRI field.
	DMA_DCHPRI27_GRPPRI_Pos = 0x4
	// Bit mask of GRPPRI field.
	DMA_DCHPRI27_GRPPRI_Msk = 0x30
	// Position of DPA field.
	DMA_DCHPRI27_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI27_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI27_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI27_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI27_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI27_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI27_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI27_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI27_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI27_ECP_ECP_1 = 0x1

	// DCHPRI26: Channel n Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI26_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI26_CHPRI_Msk = 0xf
	// Position of GRPPRI field.
	DMA_DCHPRI26_GRPPRI_Pos = 0x4
	// Bit mask of GRPPRI field.
	DMA_DCHPRI26_GRPPRI_Msk = 0x30
	// Position of DPA field.
	DMA_DCHPRI26_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI26_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI26_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI26_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI26_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI26_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI26_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI26_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI26_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI26_ECP_ECP_1 = 0x1

	// DCHPRI25: Channel n Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI25_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI25_CHPRI_Msk = 0xf
	// Position of GRPPRI field.
	DMA_DCHPRI25_GRPPRI_Pos = 0x4
	// Bit mask of GRPPRI field.
	DMA_DCHPRI25_GRPPRI_Msk = 0x30
	// Position of DPA field.
	DMA_DCHPRI25_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI25_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI25_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI25_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI25_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI25_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI25_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI25_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI25_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI25_ECP_ECP_1 = 0x1

	// DCHPRI24: Channel n Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI24_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI24_CHPRI_Msk = 0xf
	// Position of GRPPRI field.
	DMA_DCHPRI24_GRPPRI_Pos = 0x4
	// Bit mask of GRPPRI field.
	DMA_DCHPRI24_GRPPRI_Msk = 0x30
	// Position of DPA field.
	DMA_DCHPRI24_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI24_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI24_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI24_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI24_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI24_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI24_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI24_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI24_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI24_ECP_ECP_1 = 0x1

	// DCHPRI31: Channel n Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI31_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI31_CHPRI_Msk = 0xf
	// Position of GRPPRI field.
	DMA_DCHPRI31_GRPPRI_Pos = 0x4
	// Bit mask of GRPPRI field.
	DMA_DCHPRI31_GRPPRI_Msk = 0x30
	// Position of DPA field.
	DMA_DCHPRI31_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI31_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI31_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI31_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI31_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI31_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI31_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI31_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI31_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI31_ECP_ECP_1 = 0x1

	// DCHPRI30: Channel n Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI30_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI30_CHPRI_Msk = 0xf
	// Position of GRPPRI field.
	DMA_DCHPRI30_GRPPRI_Pos = 0x4
	// Bit mask of GRPPRI field.
	DMA_DCHPRI30_GRPPRI_Msk = 0x30
	// Position of DPA field.
	DMA_DCHPRI30_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI30_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI30_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI30_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI30_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI30_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI30_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI30_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI30_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI30_ECP_ECP_1 = 0x1

	// DCHPRI29: Channel n Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI29_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI29_CHPRI_Msk = 0xf
	// Position of GRPPRI field.
	DMA_DCHPRI29_GRPPRI_Pos = 0x4
	// Bit mask of GRPPRI field.
	DMA_DCHPRI29_GRPPRI_Msk = 0x30
	// Position of DPA field.
	DMA_DCHPRI29_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI29_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI29_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI29_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI29_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI29_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI29_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI29_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI29_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI29_ECP_ECP_1 = 0x1

	// DCHPRI28: Channel n Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI28_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI28_CHPRI_Msk = 0xf
	// Position of GRPPRI field.
	DMA_DCHPRI28_GRPPRI_Pos = 0x4
	// Bit mask of GRPPRI field.
	DMA_DCHPRI28_GRPPRI_Msk = 0x30
	// Position of DPA field.
	DMA_DCHPRI28_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI28_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI28_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI28_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI28_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI28_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI28_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI28_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI28_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI28_ECP_ECP_1 = 0x1

	// TCD0_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD0_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD0_SADDR_SADDR_Msk = 0xffffffff

	// TCD0_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD0_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD0_SOFF_SOFF_Msk = 0xffff

	// TCD0_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD0_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD0_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD0_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD0_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD0_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD0_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD0_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD0_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD0_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD0_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD0_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD0_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD0_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD0_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD0_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD0_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD0_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD0_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD0_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD0_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD0_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD0_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD0_ATTR_SMOD_SMOD_9 = 0x9

	// TCD0_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD0_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD0_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD0_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD0_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD0_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD0_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD0_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD0_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD0_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD0_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD0_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD0_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD0_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD0_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD0_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD0_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD0_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD0_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD0_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD0_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD0_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD0_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD0_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD0_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD0_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD0_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD0_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD0_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD0_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD0_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD0_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD0_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD0_SLAST_SLAST_Msk = 0xffffffff

	// TCD0_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD0_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD0_DADDR_DADDR_Msk = 0xffffffff

	// TCD0_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD0_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD0_DOFF_DOFF_Msk = 0xffff

	// TCD0_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD0_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD0_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD0_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD0_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD0_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD0_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD0_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD0_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD0_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD0_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD0_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD0_CITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD0_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD0_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD0_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD0_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD0_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD0_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD0_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD0_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD0_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD0_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD0_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD0_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD0_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD0_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD0_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD0_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD0_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD0_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD0_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD0_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD0_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD0_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD0_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD0_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD0_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD0_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD0_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD0_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD0_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD0_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD0_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD0_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD0_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD0_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD0_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD0_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD0_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD0_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD0_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD0_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD0_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD0_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD0_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD0_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD0_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD0_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD0_CSR_MAJORLINKCH_Msk = 0x1f00
	// Position of BWC field.
	DMA_TCD0_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD0_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD0_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD0_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD0_CSR_BWC_BWC_3 = 0x3

	// TCD0_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD0_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD0_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD0_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD0_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD0_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD0_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD0_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD0_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD0_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD0_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD0_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD0_BITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD0_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD0_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD0_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD0_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD0_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD1_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD1_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD1_SADDR_SADDR_Msk = 0xffffffff

	// TCD1_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD1_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD1_SOFF_SOFF_Msk = 0xffff

	// TCD1_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD1_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD1_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD1_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD1_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD1_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD1_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD1_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD1_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD1_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD1_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD1_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD1_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD1_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD1_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD1_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD1_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD1_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD1_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD1_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD1_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD1_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD1_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD1_ATTR_SMOD_SMOD_9 = 0x9

	// TCD1_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD1_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD1_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD1_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD1_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD1_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD1_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD1_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD1_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD1_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD1_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD1_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD1_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD1_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD1_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD1_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD1_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD1_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD1_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD1_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD1_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD1_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD1_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD1_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD1_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD1_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD1_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD1_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD1_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD1_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD1_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD1_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD1_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD1_SLAST_SLAST_Msk = 0xffffffff

	// TCD1_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD1_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD1_DADDR_DADDR_Msk = 0xffffffff

	// TCD1_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD1_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD1_DOFF_DOFF_Msk = 0xffff

	// TCD1_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD1_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD1_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD1_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD1_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD1_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD1_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD1_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD1_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD1_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD1_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD1_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD1_CITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD1_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD1_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD1_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD1_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD1_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD1_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD1_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD1_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD1_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD1_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD1_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD1_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD1_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD1_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD1_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD1_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD1_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD1_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD1_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD1_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD1_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD1_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD1_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD1_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD1_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD1_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD1_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD1_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD1_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD1_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD1_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD1_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD1_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD1_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD1_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD1_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD1_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD1_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD1_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD1_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD1_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD1_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD1_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD1_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD1_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD1_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD1_CSR_MAJORLINKCH_Msk = 0x1f00
	// Position of BWC field.
	DMA_TCD1_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD1_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD1_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD1_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD1_CSR_BWC_BWC_3 = 0x3

	// TCD1_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD1_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD1_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD1_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD1_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD1_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD1_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD1_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD1_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD1_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD1_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD1_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD1_BITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD1_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD1_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD1_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD1_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD1_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD2_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD2_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD2_SADDR_SADDR_Msk = 0xffffffff

	// TCD2_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD2_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD2_SOFF_SOFF_Msk = 0xffff

	// TCD2_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD2_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD2_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD2_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD2_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD2_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD2_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD2_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD2_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD2_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD2_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD2_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD2_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD2_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD2_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD2_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD2_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD2_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD2_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD2_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD2_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD2_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD2_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD2_ATTR_SMOD_SMOD_9 = 0x9

	// TCD2_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD2_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD2_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD2_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD2_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD2_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD2_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD2_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD2_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD2_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD2_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD2_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD2_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD2_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD2_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD2_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD2_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD2_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD2_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD2_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD2_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD2_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD2_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD2_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD2_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD2_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD2_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD2_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD2_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD2_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD2_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD2_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD2_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD2_SLAST_SLAST_Msk = 0xffffffff

	// TCD2_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD2_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD2_DADDR_DADDR_Msk = 0xffffffff

	// TCD2_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD2_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD2_DOFF_DOFF_Msk = 0xffff

	// TCD2_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD2_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD2_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD2_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD2_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD2_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD2_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD2_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD2_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD2_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD2_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD2_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD2_CITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD2_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD2_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD2_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD2_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD2_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD2_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD2_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD2_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD2_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD2_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD2_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD2_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD2_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD2_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD2_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD2_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD2_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD2_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD2_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD2_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD2_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD2_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD2_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD2_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD2_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD2_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD2_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD2_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD2_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD2_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD2_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD2_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD2_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD2_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD2_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD2_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD2_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD2_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD2_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD2_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD2_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD2_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD2_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD2_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD2_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD2_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD2_CSR_MAJORLINKCH_Msk = 0x1f00
	// Position of BWC field.
	DMA_TCD2_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD2_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD2_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD2_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD2_CSR_BWC_BWC_3 = 0x3

	// TCD2_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD2_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD2_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD2_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD2_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD2_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD2_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD2_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD2_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD2_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD2_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD2_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD2_BITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD2_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD2_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD2_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD2_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD2_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD3_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD3_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD3_SADDR_SADDR_Msk = 0xffffffff

	// TCD3_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD3_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD3_SOFF_SOFF_Msk = 0xffff

	// TCD3_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD3_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD3_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD3_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD3_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD3_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD3_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD3_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD3_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD3_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD3_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD3_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD3_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD3_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD3_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD3_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD3_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD3_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD3_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD3_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD3_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD3_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD3_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD3_ATTR_SMOD_SMOD_9 = 0x9

	// TCD3_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD3_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD3_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD3_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD3_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD3_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD3_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD3_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD3_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD3_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD3_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD3_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD3_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD3_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD3_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD3_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD3_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD3_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD3_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD3_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD3_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD3_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD3_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD3_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD3_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD3_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD3_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD3_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD3_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD3_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD3_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD3_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD3_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD3_SLAST_SLAST_Msk = 0xffffffff

	// TCD3_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD3_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD3_DADDR_DADDR_Msk = 0xffffffff

	// TCD3_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD3_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD3_DOFF_DOFF_Msk = 0xffff

	// TCD3_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD3_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD3_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD3_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD3_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD3_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD3_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD3_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD3_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD3_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD3_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD3_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD3_CITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD3_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD3_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD3_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD3_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD3_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD3_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD3_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD3_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD3_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD3_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD3_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD3_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD3_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD3_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD3_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD3_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD3_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD3_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD3_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD3_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD3_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD3_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD3_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD3_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD3_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD3_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD3_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD3_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD3_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD3_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD3_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD3_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD3_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD3_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD3_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD3_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD3_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD3_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD3_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD3_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD3_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD3_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD3_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD3_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD3_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD3_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD3_CSR_MAJORLINKCH_Msk = 0x1f00
	// Position of BWC field.
	DMA_TCD3_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD3_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD3_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD3_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD3_CSR_BWC_BWC_3 = 0x3

	// TCD3_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD3_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD3_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD3_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD3_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD3_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD3_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD3_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD3_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD3_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD3_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD3_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD3_BITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD3_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD3_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD3_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD3_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD3_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD4_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD4_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD4_SADDR_SADDR_Msk = 0xffffffff

	// TCD4_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD4_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD4_SOFF_SOFF_Msk = 0xffff

	// TCD4_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD4_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD4_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD4_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD4_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD4_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD4_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD4_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD4_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD4_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD4_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD4_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD4_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD4_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD4_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD4_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD4_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD4_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD4_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD4_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD4_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD4_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD4_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD4_ATTR_SMOD_SMOD_9 = 0x9

	// TCD4_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD4_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD4_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD4_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD4_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD4_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD4_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD4_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD4_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD4_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD4_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD4_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD4_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD4_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD4_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD4_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD4_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD4_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD4_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD4_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD4_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD4_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD4_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD4_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD4_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD4_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD4_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD4_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD4_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD4_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD4_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD4_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD4_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD4_SLAST_SLAST_Msk = 0xffffffff

	// TCD4_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD4_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD4_DADDR_DADDR_Msk = 0xffffffff

	// TCD4_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD4_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD4_DOFF_DOFF_Msk = 0xffff

	// TCD4_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD4_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD4_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD4_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD4_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD4_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD4_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD4_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD4_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD4_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD4_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD4_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD4_CITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD4_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD4_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD4_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD4_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD4_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD4_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD4_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD4_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD4_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD4_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD4_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD4_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD4_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD4_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD4_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD4_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD4_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD4_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD4_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD4_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD4_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD4_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD4_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD4_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD4_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD4_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD4_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD4_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD4_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD4_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD4_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD4_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD4_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD4_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD4_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD4_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD4_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD4_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD4_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD4_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD4_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD4_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD4_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD4_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD4_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD4_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD4_CSR_MAJORLINKCH_Msk = 0x1f00
	// Position of BWC field.
	DMA_TCD4_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD4_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD4_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD4_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD4_CSR_BWC_BWC_3 = 0x3

	// TCD4_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD4_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD4_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD4_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD4_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD4_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD4_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD4_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD4_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD4_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD4_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD4_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD4_BITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD4_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD4_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD4_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD4_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD4_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD5_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD5_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD5_SADDR_SADDR_Msk = 0xffffffff

	// TCD5_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD5_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD5_SOFF_SOFF_Msk = 0xffff

	// TCD5_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD5_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD5_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD5_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD5_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD5_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD5_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD5_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD5_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD5_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD5_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD5_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD5_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD5_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD5_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD5_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD5_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD5_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD5_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD5_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD5_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD5_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD5_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD5_ATTR_SMOD_SMOD_9 = 0x9

	// TCD5_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD5_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD5_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD5_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD5_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD5_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD5_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD5_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD5_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD5_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD5_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD5_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD5_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD5_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD5_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD5_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD5_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD5_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD5_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD5_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD5_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD5_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD5_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD5_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD5_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD5_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD5_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD5_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD5_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD5_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD5_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD5_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD5_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD5_SLAST_SLAST_Msk = 0xffffffff

	// TCD5_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD5_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD5_DADDR_DADDR_Msk = 0xffffffff

	// TCD5_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD5_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD5_DOFF_DOFF_Msk = 0xffff

	// TCD5_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD5_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD5_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD5_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD5_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD5_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD5_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD5_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD5_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD5_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD5_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD5_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD5_CITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD5_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD5_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD5_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD5_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD5_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD5_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD5_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD5_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD5_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD5_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD5_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD5_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD5_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD5_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD5_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD5_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD5_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD5_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD5_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD5_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD5_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD5_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD5_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD5_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD5_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD5_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD5_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD5_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD5_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD5_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD5_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD5_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD5_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD5_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD5_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD5_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD5_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD5_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD5_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD5_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD5_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD5_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD5_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD5_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD5_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD5_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD5_CSR_MAJORLINKCH_Msk = 0x1f00
	// Position of BWC field.
	DMA_TCD5_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD5_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD5_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD5_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD5_CSR_BWC_BWC_3 = 0x3

	// TCD5_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD5_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD5_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD5_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD5_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD5_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD5_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD5_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD5_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD5_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD5_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD5_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD5_BITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD5_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD5_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD5_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD5_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD5_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD6_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD6_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD6_SADDR_SADDR_Msk = 0xffffffff

	// TCD6_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD6_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD6_SOFF_SOFF_Msk = 0xffff

	// TCD6_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD6_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD6_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD6_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD6_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD6_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD6_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD6_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD6_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD6_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD6_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD6_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD6_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD6_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD6_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD6_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD6_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD6_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD6_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD6_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD6_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD6_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD6_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD6_ATTR_SMOD_SMOD_9 = 0x9

	// TCD6_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD6_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD6_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD6_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD6_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD6_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD6_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD6_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD6_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD6_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD6_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD6_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD6_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD6_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD6_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD6_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD6_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD6_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD6_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD6_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD6_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD6_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD6_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD6_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD6_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD6_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD6_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD6_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD6_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD6_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD6_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD6_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD6_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD6_SLAST_SLAST_Msk = 0xffffffff

	// TCD6_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD6_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD6_DADDR_DADDR_Msk = 0xffffffff

	// TCD6_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD6_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD6_DOFF_DOFF_Msk = 0xffff

	// TCD6_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD6_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD6_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD6_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD6_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD6_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD6_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD6_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD6_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD6_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD6_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD6_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD6_CITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD6_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD6_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD6_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD6_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD6_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD6_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD6_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD6_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD6_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD6_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD6_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD6_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD6_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD6_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD6_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD6_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD6_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD6_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD6_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD6_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD6_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD6_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD6_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD6_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD6_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD6_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD6_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD6_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD6_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD6_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD6_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD6_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD6_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD6_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD6_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD6_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD6_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD6_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD6_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD6_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD6_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD6_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD6_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD6_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD6_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD6_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD6_CSR_MAJORLINKCH_Msk = 0x1f00
	// Position of BWC field.
	DMA_TCD6_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD6_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD6_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD6_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD6_CSR_BWC_BWC_3 = 0x3

	// TCD6_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD6_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD6_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD6_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD6_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD6_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD6_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD6_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD6_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD6_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD6_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD6_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD6_BITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD6_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD6_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD6_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD6_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD6_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD7_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD7_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD7_SADDR_SADDR_Msk = 0xffffffff

	// TCD7_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD7_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD7_SOFF_SOFF_Msk = 0xffff

	// TCD7_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD7_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD7_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD7_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD7_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD7_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD7_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD7_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD7_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD7_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD7_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD7_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD7_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD7_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD7_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD7_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD7_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD7_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD7_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD7_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD7_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD7_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD7_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD7_ATTR_SMOD_SMOD_9 = 0x9

	// TCD7_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD7_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD7_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD7_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD7_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD7_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD7_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD7_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD7_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD7_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD7_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD7_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD7_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD7_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD7_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD7_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD7_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD7_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD7_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD7_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD7_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD7_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD7_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD7_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD7_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD7_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD7_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD7_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD7_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD7_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD7_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD7_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD7_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD7_SLAST_SLAST_Msk = 0xffffffff

	// TCD7_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD7_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD7_DADDR_DADDR_Msk = 0xffffffff

	// TCD7_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD7_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD7_DOFF_DOFF_Msk = 0xffff

	// TCD7_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD7_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD7_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD7_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD7_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD7_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD7_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD7_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD7_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD7_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD7_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD7_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD7_CITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD7_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD7_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD7_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD7_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD7_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD7_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD7_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD7_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD7_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD7_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD7_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD7_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD7_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD7_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD7_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD7_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD7_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD7_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD7_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD7_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD7_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD7_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD7_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD7_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD7_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD7_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD7_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD7_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD7_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD7_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD7_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD7_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD7_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD7_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD7_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD7_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD7_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD7_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD7_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD7_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD7_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD7_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD7_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD7_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD7_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD7_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD7_CSR_MAJORLINKCH_Msk = 0x1f00
	// Position of BWC field.
	DMA_TCD7_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD7_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD7_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD7_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD7_CSR_BWC_BWC_3 = 0x3

	// TCD7_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD7_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD7_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD7_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD7_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD7_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD7_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD7_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD7_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD7_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD7_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD7_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD7_BITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD7_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD7_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD7_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD7_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD7_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD8_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD8_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD8_SADDR_SADDR_Msk = 0xffffffff

	// TCD8_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD8_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD8_SOFF_SOFF_Msk = 0xffff

	// TCD8_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD8_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD8_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD8_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD8_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD8_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD8_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD8_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD8_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD8_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD8_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD8_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD8_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD8_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD8_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD8_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD8_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD8_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD8_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD8_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD8_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD8_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD8_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD8_ATTR_SMOD_SMOD_9 = 0x9

	// TCD8_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD8_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD8_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD8_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD8_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD8_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD8_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD8_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD8_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD8_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD8_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD8_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD8_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD8_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD8_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD8_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD8_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD8_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD8_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD8_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD8_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD8_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD8_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD8_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD8_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD8_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD8_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD8_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD8_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD8_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD8_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD8_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD8_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD8_SLAST_SLAST_Msk = 0xffffffff

	// TCD8_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD8_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD8_DADDR_DADDR_Msk = 0xffffffff

	// TCD8_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD8_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD8_DOFF_DOFF_Msk = 0xffff

	// TCD8_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD8_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD8_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD8_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD8_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD8_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD8_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD8_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD8_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD8_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD8_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD8_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD8_CITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD8_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD8_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD8_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD8_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD8_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD8_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD8_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD8_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD8_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD8_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD8_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD8_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD8_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD8_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD8_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD8_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD8_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD8_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD8_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD8_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD8_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD8_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD8_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD8_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD8_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD8_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD8_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD8_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD8_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD8_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD8_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD8_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD8_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD8_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD8_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD8_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD8_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD8_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD8_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD8_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD8_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD8_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD8_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD8_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD8_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD8_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD8_CSR_MAJORLINKCH_Msk = 0x1f00
	// Position of BWC field.
	DMA_TCD8_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD8_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD8_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD8_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD8_CSR_BWC_BWC_3 = 0x3

	// TCD8_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD8_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD8_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD8_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD8_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD8_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD8_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD8_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD8_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD8_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD8_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD8_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD8_BITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD8_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD8_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD8_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD8_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD8_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD9_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD9_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD9_SADDR_SADDR_Msk = 0xffffffff

	// TCD9_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD9_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD9_SOFF_SOFF_Msk = 0xffff

	// TCD9_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD9_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD9_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD9_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD9_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD9_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD9_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD9_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD9_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD9_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD9_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD9_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD9_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD9_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD9_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD9_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD9_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD9_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD9_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD9_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD9_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD9_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD9_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD9_ATTR_SMOD_SMOD_9 = 0x9

	// TCD9_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD9_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD9_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD9_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD9_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD9_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD9_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD9_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD9_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD9_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD9_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD9_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD9_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD9_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD9_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD9_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD9_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD9_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD9_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD9_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD9_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD9_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD9_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD9_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD9_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD9_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD9_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD9_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD9_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD9_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD9_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD9_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD9_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD9_SLAST_SLAST_Msk = 0xffffffff

	// TCD9_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD9_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD9_DADDR_DADDR_Msk = 0xffffffff

	// TCD9_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD9_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD9_DOFF_DOFF_Msk = 0xffff

	// TCD9_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD9_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD9_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD9_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD9_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD9_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD9_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD9_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD9_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD9_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD9_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD9_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD9_CITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD9_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD9_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD9_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD9_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD9_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD9_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD9_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD9_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD9_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD9_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD9_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD9_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD9_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD9_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD9_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD9_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD9_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD9_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD9_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD9_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD9_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD9_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD9_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD9_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD9_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD9_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD9_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD9_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD9_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD9_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD9_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD9_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD9_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD9_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD9_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD9_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD9_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD9_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD9_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD9_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD9_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD9_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD9_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD9_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD9_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD9_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD9_CSR_MAJORLINKCH_Msk = 0x1f00
	// Position of BWC field.
	DMA_TCD9_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD9_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD9_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD9_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD9_CSR_BWC_BWC_3 = 0x3

	// TCD9_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD9_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD9_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD9_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD9_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD9_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD9_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD9_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD9_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD9_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD9_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD9_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD9_BITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD9_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD9_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD9_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD9_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD9_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD10_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD10_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD10_SADDR_SADDR_Msk = 0xffffffff

	// TCD10_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD10_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD10_SOFF_SOFF_Msk = 0xffff

	// TCD10_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD10_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD10_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD10_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD10_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD10_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD10_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD10_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD10_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD10_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD10_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD10_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD10_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD10_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD10_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD10_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD10_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD10_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD10_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD10_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD10_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD10_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD10_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD10_ATTR_SMOD_SMOD_9 = 0x9

	// TCD10_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD10_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD10_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD10_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD10_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD10_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD10_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD10_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD10_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD10_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD10_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD10_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD10_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD10_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD10_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD10_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD10_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD10_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD10_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD10_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD10_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD10_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD10_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD10_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD10_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD10_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD10_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD10_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD10_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD10_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD10_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD10_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD10_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD10_SLAST_SLAST_Msk = 0xffffffff

	// TCD10_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD10_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD10_DADDR_DADDR_Msk = 0xffffffff

	// TCD10_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD10_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD10_DOFF_DOFF_Msk = 0xffff

	// TCD10_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD10_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD10_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD10_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD10_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD10_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD10_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD10_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD10_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD10_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD10_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD10_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD10_CITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD10_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD10_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD10_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD10_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD10_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD10_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD10_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD10_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD10_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD10_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD10_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD10_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD10_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD10_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD10_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD10_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD10_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD10_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD10_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD10_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD10_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD10_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD10_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD10_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD10_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD10_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD10_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD10_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD10_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD10_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD10_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD10_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD10_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD10_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD10_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD10_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD10_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD10_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD10_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD10_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD10_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD10_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD10_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD10_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD10_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD10_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD10_CSR_MAJORLINKCH_Msk = 0x1f00
	// Position of BWC field.
	DMA_TCD10_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD10_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD10_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD10_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD10_CSR_BWC_BWC_3 = 0x3

	// TCD10_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD10_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD10_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD10_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD10_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD10_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD10_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD10_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD10_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD10_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD10_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD10_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD10_BITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD10_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD10_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD10_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD10_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD10_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD11_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD11_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD11_SADDR_SADDR_Msk = 0xffffffff

	// TCD11_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD11_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD11_SOFF_SOFF_Msk = 0xffff

	// TCD11_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD11_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD11_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD11_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD11_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD11_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD11_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD11_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD11_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD11_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD11_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD11_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD11_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD11_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD11_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD11_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD11_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD11_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD11_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD11_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD11_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD11_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD11_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD11_ATTR_SMOD_SMOD_9 = 0x9

	// TCD11_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD11_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD11_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD11_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD11_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD11_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD11_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD11_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD11_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD11_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD11_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD11_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD11_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD11_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD11_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD11_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD11_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD11_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD11_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD11_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD11_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD11_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD11_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD11_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD11_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD11_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD11_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD11_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD11_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD11_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD11_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD11_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD11_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD11_SLAST_SLAST_Msk = 0xffffffff

	// TCD11_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD11_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD11_DADDR_DADDR_Msk = 0xffffffff

	// TCD11_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD11_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD11_DOFF_DOFF_Msk = 0xffff

	// TCD11_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD11_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD11_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD11_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD11_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD11_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD11_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD11_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD11_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD11_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD11_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD11_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD11_CITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD11_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD11_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD11_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD11_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD11_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD11_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD11_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD11_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD11_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD11_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD11_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD11_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD11_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD11_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD11_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD11_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD11_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD11_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD11_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD11_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD11_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD11_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD11_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD11_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD11_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD11_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD11_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD11_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD11_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD11_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD11_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD11_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD11_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD11_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD11_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD11_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD11_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD11_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD11_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD11_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD11_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD11_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD11_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD11_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD11_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD11_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD11_CSR_MAJORLINKCH_Msk = 0x1f00
	// Position of BWC field.
	DMA_TCD11_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD11_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD11_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD11_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD11_CSR_BWC_BWC_3 = 0x3

	// TCD11_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD11_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD11_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD11_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD11_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD11_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD11_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD11_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD11_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD11_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD11_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD11_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD11_BITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD11_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD11_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD11_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD11_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD11_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD12_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD12_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD12_SADDR_SADDR_Msk = 0xffffffff

	// TCD12_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD12_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD12_SOFF_SOFF_Msk = 0xffff

	// TCD12_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD12_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD12_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD12_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD12_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD12_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD12_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD12_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD12_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD12_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD12_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD12_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD12_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD12_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD12_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD12_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD12_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD12_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD12_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD12_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD12_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD12_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD12_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD12_ATTR_SMOD_SMOD_9 = 0x9

	// TCD12_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD12_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD12_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD12_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD12_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD12_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD12_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD12_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD12_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD12_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD12_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD12_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD12_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD12_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD12_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD12_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD12_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD12_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD12_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD12_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD12_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD12_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD12_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD12_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD12_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD12_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD12_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD12_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD12_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD12_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD12_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD12_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD12_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD12_SLAST_SLAST_Msk = 0xffffffff

	// TCD12_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD12_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD12_DADDR_DADDR_Msk = 0xffffffff

	// TCD12_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD12_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD12_DOFF_DOFF_Msk = 0xffff

	// TCD12_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD12_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD12_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD12_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD12_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD12_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD12_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD12_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD12_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD12_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD12_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD12_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD12_CITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD12_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD12_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD12_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD12_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD12_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD12_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD12_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD12_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD12_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD12_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD12_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD12_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD12_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD12_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD12_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD12_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD12_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD12_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD12_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD12_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD12_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD12_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD12_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD12_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD12_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD12_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD12_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD12_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD12_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD12_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD12_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD12_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD12_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD12_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD12_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD12_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD12_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD12_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD12_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD12_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD12_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD12_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD12_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD12_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD12_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD12_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD12_CSR_MAJORLINKCH_Msk = 0x1f00
	// Position of BWC field.
	DMA_TCD12_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD12_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD12_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD12_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD12_CSR_BWC_BWC_3 = 0x3

	// TCD12_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD12_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD12_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD12_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD12_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD12_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD12_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD12_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD12_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD12_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD12_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD12_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD12_BITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD12_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD12_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD12_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD12_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD12_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD13_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD13_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD13_SADDR_SADDR_Msk = 0xffffffff

	// TCD13_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD13_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD13_SOFF_SOFF_Msk = 0xffff

	// TCD13_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD13_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD13_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD13_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD13_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD13_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD13_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD13_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD13_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD13_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD13_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD13_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD13_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD13_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD13_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD13_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD13_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD13_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD13_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD13_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD13_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD13_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD13_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD13_ATTR_SMOD_SMOD_9 = 0x9

	// TCD13_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD13_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD13_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD13_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD13_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD13_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD13_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD13_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD13_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD13_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD13_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD13_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD13_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD13_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD13_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD13_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD13_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD13_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD13_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD13_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD13_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD13_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD13_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD13_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD13_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD13_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD13_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD13_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD13_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD13_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD13_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD13_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD13_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD13_SLAST_SLAST_Msk = 0xffffffff

	// TCD13_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD13_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD13_DADDR_DADDR_Msk = 0xffffffff

	// TCD13_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD13_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD13_DOFF_DOFF_Msk = 0xffff

	// TCD13_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD13_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD13_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD13_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD13_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD13_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD13_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD13_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD13_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD13_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD13_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD13_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD13_CITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD13_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD13_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD13_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD13_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD13_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD13_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD13_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD13_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD13_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD13_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD13_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD13_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD13_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD13_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD13_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD13_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD13_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD13_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD13_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD13_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD13_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD13_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD13_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD13_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD13_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD13_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD13_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD13_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD13_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD13_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD13_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD13_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD13_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD13_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD13_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD13_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD13_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD13_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD13_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD13_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD13_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD13_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD13_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD13_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD13_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD13_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD13_CSR_MAJORLINKCH_Msk = 0x1f00
	// Position of BWC field.
	DMA_TCD13_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD13_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD13_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD13_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD13_CSR_BWC_BWC_3 = 0x3

	// TCD13_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD13_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD13_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD13_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD13_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD13_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD13_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD13_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD13_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD13_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD13_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD13_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD13_BITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD13_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD13_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD13_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD13_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD13_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD14_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD14_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD14_SADDR_SADDR_Msk = 0xffffffff

	// TCD14_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD14_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD14_SOFF_SOFF_Msk = 0xffff

	// TCD14_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD14_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD14_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD14_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD14_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD14_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD14_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD14_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD14_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD14_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD14_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD14_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD14_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD14_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD14_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD14_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD14_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD14_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD14_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD14_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD14_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD14_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD14_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD14_ATTR_SMOD_SMOD_9 = 0x9

	// TCD14_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD14_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD14_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD14_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD14_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD14_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD14_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD14_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD14_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD14_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD14_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD14_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD14_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD14_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD14_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD14_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD14_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD14_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD14_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD14_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD14_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD14_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD14_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD14_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD14_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD14_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD14_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD14_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD14_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD14_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD14_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD14_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD14_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD14_SLAST_SLAST_Msk = 0xffffffff

	// TCD14_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD14_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD14_DADDR_DADDR_Msk = 0xffffffff

	// TCD14_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD14_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD14_DOFF_DOFF_Msk = 0xffff

	// TCD14_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD14_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD14_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD14_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD14_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD14_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD14_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD14_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD14_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD14_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD14_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD14_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD14_CITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD14_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD14_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD14_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD14_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD14_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD14_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD14_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD14_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD14_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD14_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD14_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD14_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD14_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD14_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD14_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD14_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD14_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD14_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD14_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD14_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD14_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD14_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD14_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD14_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD14_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD14_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD14_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD14_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD14_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD14_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD14_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD14_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD14_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD14_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD14_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD14_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD14_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD14_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD14_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD14_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD14_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD14_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD14_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD14_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD14_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD14_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD14_CSR_MAJORLINKCH_Msk = 0x1f00
	// Position of BWC field.
	DMA_TCD14_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD14_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD14_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD14_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD14_CSR_BWC_BWC_3 = 0x3

	// TCD14_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD14_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD14_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD14_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD14_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD14_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD14_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD14_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD14_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD14_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD14_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD14_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD14_BITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD14_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD14_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD14_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD14_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD14_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD15_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD15_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD15_SADDR_SADDR_Msk = 0xffffffff

	// TCD15_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD15_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD15_SOFF_SOFF_Msk = 0xffff

	// TCD15_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD15_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD15_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD15_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD15_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD15_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD15_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD15_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD15_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD15_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD15_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD15_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD15_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD15_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD15_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD15_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD15_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD15_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD15_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD15_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD15_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD15_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD15_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD15_ATTR_SMOD_SMOD_9 = 0x9

	// TCD15_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD15_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD15_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD15_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD15_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD15_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD15_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD15_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD15_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD15_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD15_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD15_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD15_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD15_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD15_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD15_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD15_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD15_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD15_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD15_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD15_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD15_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD15_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD15_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD15_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD15_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD15_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD15_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD15_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD15_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD15_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD15_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD15_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD15_SLAST_SLAST_Msk = 0xffffffff

	// TCD15_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD15_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD15_DADDR_DADDR_Msk = 0xffffffff

	// TCD15_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD15_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD15_DOFF_DOFF_Msk = 0xffff

	// TCD15_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD15_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD15_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD15_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD15_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD15_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD15_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD15_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD15_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD15_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD15_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD15_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD15_CITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD15_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD15_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD15_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD15_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD15_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD15_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD15_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD15_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD15_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD15_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD15_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD15_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD15_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD15_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD15_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD15_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD15_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD15_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD15_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD15_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD15_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD15_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD15_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD15_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD15_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD15_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD15_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD15_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD15_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD15_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD15_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD15_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD15_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD15_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD15_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD15_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD15_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD15_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD15_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD15_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD15_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD15_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD15_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD15_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD15_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD15_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD15_CSR_MAJORLINKCH_Msk = 0x1f00
	// Position of BWC field.
	DMA_TCD15_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD15_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD15_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD15_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD15_CSR_BWC_BWC_3 = 0x3

	// TCD15_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD15_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD15_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD15_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD15_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD15_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD15_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD15_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD15_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD15_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD15_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD15_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD15_BITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD15_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD15_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD15_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD15_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD15_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD16_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD16_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD16_SADDR_SADDR_Msk = 0xffffffff

	// TCD16_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD16_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD16_SOFF_SOFF_Msk = 0xffff

	// TCD16_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD16_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD16_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD16_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD16_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD16_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD16_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD16_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD16_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD16_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD16_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD16_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD16_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD16_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD16_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD16_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD16_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD16_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD16_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD16_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD16_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD16_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD16_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD16_ATTR_SMOD_SMOD_9 = 0x9

	// TCD16_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD16_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD16_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD16_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD16_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD16_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD16_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD16_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD16_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD16_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD16_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD16_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD16_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD16_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD16_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD16_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD16_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD16_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD16_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD16_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD16_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD16_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD16_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD16_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD16_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD16_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD16_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD16_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD16_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD16_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD16_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD16_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD16_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD16_SLAST_SLAST_Msk = 0xffffffff

	// TCD16_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD16_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD16_DADDR_DADDR_Msk = 0xffffffff

	// TCD16_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD16_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD16_DOFF_DOFF_Msk = 0xffff

	// TCD16_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD16_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD16_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD16_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD16_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD16_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD16_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD16_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD16_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD16_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD16_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD16_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD16_CITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD16_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD16_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD16_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD16_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD16_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD16_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD16_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD16_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD16_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD16_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD16_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD16_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD16_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD16_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD16_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD16_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD16_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD16_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD16_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD16_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD16_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD16_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD16_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD16_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD16_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD16_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD16_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD16_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD16_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD16_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD16_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD16_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD16_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD16_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD16_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD16_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD16_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD16_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD16_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD16_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD16_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD16_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD16_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD16_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD16_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD16_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD16_CSR_MAJORLINKCH_Msk = 0x1f00
	// Position of BWC field.
	DMA_TCD16_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD16_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD16_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD16_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD16_CSR_BWC_BWC_3 = 0x3

	// TCD16_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD16_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD16_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD16_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD16_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD16_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD16_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD16_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD16_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD16_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD16_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD16_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD16_BITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD16_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD16_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD16_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD16_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD16_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD17_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD17_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD17_SADDR_SADDR_Msk = 0xffffffff

	// TCD17_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD17_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD17_SOFF_SOFF_Msk = 0xffff

	// TCD17_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD17_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD17_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD17_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD17_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD17_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD17_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD17_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD17_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD17_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD17_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD17_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD17_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD17_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD17_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD17_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD17_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD17_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD17_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD17_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD17_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD17_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD17_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD17_ATTR_SMOD_SMOD_9 = 0x9

	// TCD17_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD17_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD17_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD17_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD17_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD17_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD17_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD17_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD17_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD17_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD17_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD17_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD17_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD17_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD17_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD17_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD17_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD17_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD17_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD17_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD17_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD17_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD17_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD17_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD17_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD17_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD17_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD17_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD17_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD17_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD17_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD17_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD17_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD17_SLAST_SLAST_Msk = 0xffffffff

	// TCD17_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD17_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD17_DADDR_DADDR_Msk = 0xffffffff

	// TCD17_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD17_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD17_DOFF_DOFF_Msk = 0xffff

	// TCD17_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD17_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD17_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD17_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD17_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD17_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD17_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD17_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD17_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD17_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD17_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD17_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD17_CITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD17_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD17_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD17_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD17_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD17_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD17_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD17_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD17_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD17_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD17_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD17_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD17_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD17_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD17_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD17_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD17_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD17_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD17_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD17_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD17_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD17_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD17_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD17_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD17_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD17_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD17_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD17_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD17_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD17_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD17_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD17_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD17_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD17_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD17_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD17_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD17_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD17_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD17_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD17_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD17_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD17_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD17_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD17_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD17_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD17_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD17_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD17_CSR_MAJORLINKCH_Msk = 0x1f00
	// Position of BWC field.
	DMA_TCD17_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD17_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD17_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD17_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD17_CSR_BWC_BWC_3 = 0x3

	// TCD17_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD17_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD17_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD17_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD17_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD17_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD17_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD17_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD17_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD17_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD17_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD17_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD17_BITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD17_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD17_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD17_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD17_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD17_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD18_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD18_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD18_SADDR_SADDR_Msk = 0xffffffff

	// TCD18_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD18_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD18_SOFF_SOFF_Msk = 0xffff

	// TCD18_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD18_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD18_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD18_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD18_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD18_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD18_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD18_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD18_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD18_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD18_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD18_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD18_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD18_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD18_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD18_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD18_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD18_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD18_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD18_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD18_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD18_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD18_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD18_ATTR_SMOD_SMOD_9 = 0x9

	// TCD18_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD18_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD18_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD18_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD18_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD18_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD18_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD18_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD18_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD18_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD18_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD18_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD18_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD18_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD18_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD18_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD18_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD18_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD18_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD18_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD18_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD18_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD18_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD18_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD18_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD18_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD18_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD18_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD18_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD18_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD18_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD18_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD18_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD18_SLAST_SLAST_Msk = 0xffffffff

	// TCD18_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD18_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD18_DADDR_DADDR_Msk = 0xffffffff

	// TCD18_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD18_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD18_DOFF_DOFF_Msk = 0xffff

	// TCD18_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD18_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD18_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD18_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD18_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD18_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD18_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD18_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD18_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD18_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD18_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD18_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD18_CITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD18_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD18_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD18_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD18_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD18_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD18_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD18_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD18_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD18_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD18_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD18_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD18_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD18_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD18_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD18_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD18_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD18_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD18_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD18_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD18_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD18_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD18_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD18_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD18_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD18_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD18_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD18_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD18_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD18_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD18_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD18_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD18_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD18_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD18_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD18_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD18_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD18_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD18_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD18_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD18_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD18_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD18_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD18_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD18_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD18_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD18_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD18_CSR_MAJORLINKCH_Msk = 0x1f00
	// Position of BWC field.
	DMA_TCD18_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD18_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD18_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD18_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD18_CSR_BWC_BWC_3 = 0x3

	// TCD18_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD18_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD18_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD18_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD18_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD18_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD18_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD18_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD18_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD18_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD18_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD18_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD18_BITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD18_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD18_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD18_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD18_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD18_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD19_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD19_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD19_SADDR_SADDR_Msk = 0xffffffff

	// TCD19_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD19_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD19_SOFF_SOFF_Msk = 0xffff

	// TCD19_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD19_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD19_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD19_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD19_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD19_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD19_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD19_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD19_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD19_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD19_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD19_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD19_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD19_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD19_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD19_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD19_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD19_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD19_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD19_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD19_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD19_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD19_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD19_ATTR_SMOD_SMOD_9 = 0x9

	// TCD19_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD19_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD19_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD19_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD19_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD19_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD19_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD19_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD19_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD19_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD19_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD19_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD19_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD19_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD19_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD19_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD19_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD19_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD19_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD19_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD19_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD19_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD19_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD19_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD19_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD19_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD19_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD19_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD19_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD19_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD19_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD19_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD19_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD19_SLAST_SLAST_Msk = 0xffffffff

	// TCD19_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD19_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD19_DADDR_DADDR_Msk = 0xffffffff

	// TCD19_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD19_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD19_DOFF_DOFF_Msk = 0xffff

	// TCD19_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD19_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD19_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD19_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD19_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD19_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD19_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD19_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD19_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD19_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD19_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD19_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD19_CITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD19_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD19_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD19_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD19_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD19_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD19_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD19_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD19_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD19_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD19_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD19_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD19_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD19_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD19_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD19_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD19_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD19_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD19_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD19_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD19_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD19_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD19_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD19_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD19_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD19_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD19_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD19_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD19_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD19_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD19_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD19_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD19_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD19_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD19_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD19_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD19_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD19_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD19_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD19_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD19_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD19_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD19_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD19_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD19_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD19_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD19_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD19_CSR_MAJORLINKCH_Msk = 0x1f00
	// Position of BWC field.
	DMA_TCD19_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD19_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD19_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD19_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD19_CSR_BWC_BWC_3 = 0x3

	// TCD19_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD19_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD19_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD19_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD19_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD19_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD19_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD19_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD19_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD19_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD19_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD19_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD19_BITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD19_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD19_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD19_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD19_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD19_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD20_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD20_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD20_SADDR_SADDR_Msk = 0xffffffff

	// TCD20_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD20_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD20_SOFF_SOFF_Msk = 0xffff

	// TCD20_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD20_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD20_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD20_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD20_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD20_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD20_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD20_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD20_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD20_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD20_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD20_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD20_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD20_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD20_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD20_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD20_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD20_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD20_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD20_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD20_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD20_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD20_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD20_ATTR_SMOD_SMOD_9 = 0x9

	// TCD20_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD20_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD20_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD20_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD20_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD20_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD20_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD20_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD20_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD20_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD20_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD20_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD20_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD20_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD20_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD20_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD20_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD20_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD20_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD20_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD20_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD20_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD20_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD20_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD20_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD20_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD20_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD20_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD20_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD20_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD20_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD20_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD20_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD20_SLAST_SLAST_Msk = 0xffffffff

	// TCD20_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD20_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD20_DADDR_DADDR_Msk = 0xffffffff

	// TCD20_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD20_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD20_DOFF_DOFF_Msk = 0xffff

	// TCD20_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD20_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD20_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD20_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD20_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD20_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD20_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD20_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD20_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD20_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD20_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD20_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD20_CITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD20_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD20_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD20_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD20_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD20_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD20_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD20_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD20_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD20_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD20_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD20_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD20_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD20_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD20_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD20_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD20_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD20_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD20_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD20_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD20_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD20_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD20_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD20_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD20_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD20_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD20_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD20_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD20_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD20_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD20_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD20_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD20_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD20_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD20_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD20_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD20_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD20_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD20_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD20_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD20_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD20_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD20_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD20_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD20_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD20_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD20_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD20_CSR_MAJORLINKCH_Msk = 0x1f00
	// Position of BWC field.
	DMA_TCD20_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD20_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD20_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD20_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD20_CSR_BWC_BWC_3 = 0x3

	// TCD20_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD20_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD20_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD20_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD20_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD20_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD20_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD20_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD20_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD20_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD20_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD20_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD20_BITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD20_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD20_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD20_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD20_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD20_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD21_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD21_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD21_SADDR_SADDR_Msk = 0xffffffff

	// TCD21_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD21_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD21_SOFF_SOFF_Msk = 0xffff

	// TCD21_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD21_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD21_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD21_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD21_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD21_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD21_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD21_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD21_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD21_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD21_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD21_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD21_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD21_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD21_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD21_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD21_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD21_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD21_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD21_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD21_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD21_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD21_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD21_ATTR_SMOD_SMOD_9 = 0x9

	// TCD21_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD21_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD21_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD21_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD21_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD21_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD21_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD21_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD21_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD21_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD21_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD21_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD21_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD21_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD21_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD21_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD21_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD21_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD21_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD21_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD21_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD21_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD21_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD21_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD21_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD21_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD21_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD21_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD21_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD21_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD21_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD21_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD21_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD21_SLAST_SLAST_Msk = 0xffffffff

	// TCD21_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD21_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD21_DADDR_DADDR_Msk = 0xffffffff

	// TCD21_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD21_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD21_DOFF_DOFF_Msk = 0xffff

	// TCD21_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD21_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD21_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD21_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD21_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD21_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD21_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD21_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD21_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD21_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD21_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD21_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD21_CITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD21_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD21_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD21_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD21_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD21_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD21_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD21_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD21_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD21_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD21_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD21_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD21_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD21_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD21_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD21_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD21_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD21_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD21_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD21_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD21_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD21_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD21_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD21_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD21_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD21_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD21_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD21_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD21_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD21_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD21_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD21_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD21_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD21_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD21_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD21_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD21_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD21_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD21_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD21_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD21_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD21_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD21_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD21_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD21_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD21_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD21_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD21_CSR_MAJORLINKCH_Msk = 0x1f00
	// Position of BWC field.
	DMA_TCD21_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD21_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD21_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD21_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD21_CSR_BWC_BWC_3 = 0x3

	// TCD21_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD21_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD21_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD21_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD21_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD21_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD21_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD21_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD21_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD21_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD21_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD21_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD21_BITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD21_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD21_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD21_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD21_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD21_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD22_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD22_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD22_SADDR_SADDR_Msk = 0xffffffff

	// TCD22_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD22_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD22_SOFF_SOFF_Msk = 0xffff

	// TCD22_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD22_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD22_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD22_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD22_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD22_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD22_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD22_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD22_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD22_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD22_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD22_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD22_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD22_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD22_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD22_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD22_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD22_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD22_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD22_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD22_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD22_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD22_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD22_ATTR_SMOD_SMOD_9 = 0x9

	// TCD22_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD22_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD22_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD22_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD22_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD22_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD22_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD22_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD22_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD22_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD22_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD22_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD22_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD22_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD22_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD22_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD22_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD22_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD22_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD22_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD22_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD22_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD22_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD22_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD22_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD22_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD22_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD22_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD22_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD22_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD22_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD22_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD22_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD22_SLAST_SLAST_Msk = 0xffffffff

	// TCD22_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD22_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD22_DADDR_DADDR_Msk = 0xffffffff

	// TCD22_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD22_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD22_DOFF_DOFF_Msk = 0xffff

	// TCD22_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD22_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD22_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD22_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD22_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD22_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD22_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD22_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD22_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD22_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD22_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD22_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD22_CITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD22_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD22_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD22_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD22_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD22_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD22_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD22_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD22_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD22_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD22_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD22_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD22_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD22_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD22_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD22_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD22_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD22_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD22_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD22_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD22_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD22_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD22_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD22_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD22_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD22_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD22_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD22_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD22_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD22_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD22_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD22_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD22_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD22_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD22_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD22_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD22_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD22_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD22_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD22_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD22_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD22_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD22_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD22_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD22_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD22_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD22_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD22_CSR_MAJORLINKCH_Msk = 0x1f00
	// Position of BWC field.
	DMA_TCD22_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD22_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD22_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD22_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD22_CSR_BWC_BWC_3 = 0x3

	// TCD22_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD22_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD22_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD22_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD22_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD22_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD22_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD22_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD22_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD22_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD22_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD22_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD22_BITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD22_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD22_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD22_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD22_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD22_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD23_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD23_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD23_SADDR_SADDR_Msk = 0xffffffff

	// TCD23_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD23_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD23_SOFF_SOFF_Msk = 0xffff

	// TCD23_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD23_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD23_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD23_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD23_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD23_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD23_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD23_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD23_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD23_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD23_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD23_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD23_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD23_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD23_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD23_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD23_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD23_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD23_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD23_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD23_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD23_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD23_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD23_ATTR_SMOD_SMOD_9 = 0x9

	// TCD23_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD23_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD23_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD23_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD23_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD23_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD23_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD23_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD23_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD23_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD23_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD23_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD23_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD23_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD23_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD23_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD23_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD23_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD23_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD23_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD23_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD23_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD23_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD23_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD23_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD23_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD23_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD23_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD23_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD23_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD23_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD23_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD23_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD23_SLAST_SLAST_Msk = 0xffffffff

	// TCD23_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD23_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD23_DADDR_DADDR_Msk = 0xffffffff

	// TCD23_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD23_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD23_DOFF_DOFF_Msk = 0xffff

	// TCD23_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD23_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD23_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD23_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD23_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD23_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD23_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD23_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD23_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD23_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD23_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD23_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD23_CITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD23_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD23_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD23_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD23_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD23_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD23_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD23_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD23_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD23_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD23_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD23_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD23_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD23_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD23_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD23_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD23_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD23_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD23_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD23_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD23_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD23_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD23_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD23_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD23_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD23_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD23_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD23_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD23_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD23_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD23_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD23_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD23_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD23_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD23_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD23_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD23_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD23_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD23_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD23_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD23_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD23_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD23_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD23_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD23_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD23_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD23_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD23_CSR_MAJORLINKCH_Msk = 0x1f00
	// Position of BWC field.
	DMA_TCD23_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD23_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD23_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD23_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD23_CSR_BWC_BWC_3 = 0x3

	// TCD23_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD23_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD23_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD23_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD23_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD23_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD23_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD23_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD23_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD23_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD23_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD23_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD23_BITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD23_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD23_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD23_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD23_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD23_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD24_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD24_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD24_SADDR_SADDR_Msk = 0xffffffff

	// TCD24_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD24_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD24_SOFF_SOFF_Msk = 0xffff

	// TCD24_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD24_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD24_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD24_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD24_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD24_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD24_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD24_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD24_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD24_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD24_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD24_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD24_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD24_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD24_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD24_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD24_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD24_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD24_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD24_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD24_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD24_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD24_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD24_ATTR_SMOD_SMOD_9 = 0x9

	// TCD24_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD24_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD24_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD24_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD24_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD24_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD24_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD24_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD24_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD24_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD24_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD24_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD24_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD24_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD24_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD24_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD24_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD24_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD24_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD24_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD24_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD24_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD24_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD24_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD24_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD24_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD24_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD24_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD24_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD24_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD24_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD24_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD24_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD24_SLAST_SLAST_Msk = 0xffffffff

	// TCD24_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD24_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD24_DADDR_DADDR_Msk = 0xffffffff

	// TCD24_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD24_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD24_DOFF_DOFF_Msk = 0xffff

	// TCD24_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD24_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD24_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD24_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD24_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD24_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD24_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD24_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD24_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD24_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD24_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD24_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD24_CITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD24_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD24_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD24_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD24_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD24_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD24_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD24_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD24_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD24_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD24_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD24_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD24_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD24_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD24_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD24_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD24_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD24_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD24_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD24_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD24_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD24_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD24_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD24_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD24_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD24_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD24_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD24_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD24_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD24_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD24_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD24_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD24_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD24_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD24_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD24_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD24_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD24_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD24_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD24_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD24_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD24_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD24_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD24_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD24_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD24_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD24_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD24_CSR_MAJORLINKCH_Msk = 0x1f00
	// Position of BWC field.
	DMA_TCD24_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD24_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD24_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD24_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD24_CSR_BWC_BWC_3 = 0x3

	// TCD24_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD24_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD24_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD24_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD24_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD24_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD24_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD24_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD24_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD24_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD24_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD24_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD24_BITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD24_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD24_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD24_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD24_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD24_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD25_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD25_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD25_SADDR_SADDR_Msk = 0xffffffff

	// TCD25_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD25_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD25_SOFF_SOFF_Msk = 0xffff

	// TCD25_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD25_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD25_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD25_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD25_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD25_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD25_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD25_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD25_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD25_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD25_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD25_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD25_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD25_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD25_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD25_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD25_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD25_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD25_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD25_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD25_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD25_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD25_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD25_ATTR_SMOD_SMOD_9 = 0x9

	// TCD25_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD25_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD25_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD25_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD25_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD25_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD25_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD25_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD25_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD25_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD25_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD25_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD25_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD25_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD25_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD25_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD25_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD25_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD25_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD25_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD25_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD25_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD25_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD25_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD25_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD25_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD25_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD25_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD25_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD25_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD25_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD25_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD25_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD25_SLAST_SLAST_Msk = 0xffffffff

	// TCD25_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD25_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD25_DADDR_DADDR_Msk = 0xffffffff

	// TCD25_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD25_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD25_DOFF_DOFF_Msk = 0xffff

	// TCD25_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD25_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD25_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD25_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD25_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD25_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD25_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD25_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD25_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD25_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD25_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD25_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD25_CITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD25_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD25_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD25_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD25_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD25_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD25_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD25_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD25_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD25_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD25_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD25_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD25_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD25_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD25_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD25_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD25_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD25_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD25_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD25_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD25_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD25_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD25_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD25_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD25_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD25_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD25_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD25_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD25_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD25_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD25_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD25_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD25_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD25_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD25_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD25_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD25_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD25_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD25_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD25_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD25_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD25_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD25_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD25_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD25_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD25_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD25_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD25_CSR_MAJORLINKCH_Msk = 0x1f00
	// Position of BWC field.
	DMA_TCD25_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD25_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD25_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD25_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD25_CSR_BWC_BWC_3 = 0x3

	// TCD25_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD25_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD25_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD25_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD25_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD25_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD25_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD25_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD25_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD25_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD25_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD25_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD25_BITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD25_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD25_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD25_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD25_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD25_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD26_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD26_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD26_SADDR_SADDR_Msk = 0xffffffff

	// TCD26_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD26_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD26_SOFF_SOFF_Msk = 0xffff

	// TCD26_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD26_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD26_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD26_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD26_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD26_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD26_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD26_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD26_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD26_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD26_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD26_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD26_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD26_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD26_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD26_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD26_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD26_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD26_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD26_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD26_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD26_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD26_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD26_ATTR_SMOD_SMOD_9 = 0x9

	// TCD26_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD26_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD26_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD26_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD26_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD26_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD26_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD26_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD26_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD26_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD26_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD26_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD26_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD26_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD26_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD26_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD26_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD26_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD26_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD26_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD26_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD26_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD26_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD26_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD26_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD26_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD26_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD26_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD26_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD26_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD26_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD26_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD26_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD26_SLAST_SLAST_Msk = 0xffffffff

	// TCD26_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD26_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD26_DADDR_DADDR_Msk = 0xffffffff

	// TCD26_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD26_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD26_DOFF_DOFF_Msk = 0xffff

	// TCD26_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD26_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD26_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD26_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD26_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD26_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD26_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD26_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD26_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD26_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD26_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD26_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD26_CITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD26_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD26_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD26_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD26_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD26_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD26_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD26_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD26_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD26_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD26_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD26_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD26_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD26_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD26_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD26_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD26_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD26_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD26_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD26_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD26_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD26_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD26_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD26_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD26_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD26_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD26_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD26_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD26_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD26_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD26_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD26_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD26_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD26_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD26_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD26_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD26_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD26_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD26_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD26_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD26_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD26_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD26_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD26_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD26_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD26_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD26_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD26_CSR_MAJORLINKCH_Msk = 0x1f00
	// Position of BWC field.
	DMA_TCD26_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD26_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD26_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD26_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD26_CSR_BWC_BWC_3 = 0x3

	// TCD26_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD26_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD26_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD26_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD26_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD26_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD26_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD26_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD26_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD26_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD26_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD26_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD26_BITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD26_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD26_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD26_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD26_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD26_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD27_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD27_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD27_SADDR_SADDR_Msk = 0xffffffff

	// TCD27_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD27_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD27_SOFF_SOFF_Msk = 0xffff

	// TCD27_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD27_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD27_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD27_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD27_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD27_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD27_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD27_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD27_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD27_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD27_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD27_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD27_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD27_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD27_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD27_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD27_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD27_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD27_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD27_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD27_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD27_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD27_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD27_ATTR_SMOD_SMOD_9 = 0x9

	// TCD27_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD27_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD27_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD27_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD27_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD27_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD27_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD27_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD27_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD27_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD27_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD27_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD27_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD27_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD27_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD27_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD27_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD27_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD27_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD27_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD27_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD27_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD27_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD27_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD27_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD27_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD27_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD27_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD27_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD27_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD27_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD27_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD27_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD27_SLAST_SLAST_Msk = 0xffffffff

	// TCD27_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD27_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD27_DADDR_DADDR_Msk = 0xffffffff

	// TCD27_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD27_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD27_DOFF_DOFF_Msk = 0xffff

	// TCD27_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD27_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD27_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD27_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD27_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD27_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD27_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD27_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD27_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD27_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD27_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD27_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD27_CITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD27_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD27_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD27_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD27_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD27_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD27_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD27_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD27_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD27_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD27_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD27_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD27_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD27_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD27_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD27_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD27_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD27_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD27_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD27_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD27_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD27_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD27_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD27_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD27_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD27_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD27_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD27_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD27_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD27_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD27_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD27_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD27_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD27_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD27_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD27_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD27_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD27_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD27_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD27_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD27_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD27_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD27_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD27_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD27_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD27_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD27_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD27_CSR_MAJORLINKCH_Msk = 0x1f00
	// Position of BWC field.
	DMA_TCD27_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD27_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD27_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD27_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD27_CSR_BWC_BWC_3 = 0x3

	// TCD27_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD27_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD27_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD27_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD27_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD27_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD27_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD27_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD27_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD27_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD27_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD27_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD27_BITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD27_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD27_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD27_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD27_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD27_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD28_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD28_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD28_SADDR_SADDR_Msk = 0xffffffff

	// TCD28_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD28_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD28_SOFF_SOFF_Msk = 0xffff

	// TCD28_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD28_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD28_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD28_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD28_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD28_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD28_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD28_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD28_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD28_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD28_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD28_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD28_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD28_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD28_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD28_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD28_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD28_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD28_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD28_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD28_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD28_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD28_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD28_ATTR_SMOD_SMOD_9 = 0x9

	// TCD28_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD28_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD28_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD28_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD28_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD28_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD28_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD28_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD28_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD28_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD28_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD28_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD28_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD28_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD28_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD28_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD28_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD28_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD28_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD28_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD28_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD28_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD28_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD28_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD28_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD28_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD28_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD28_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD28_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD28_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD28_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD28_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD28_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD28_SLAST_SLAST_Msk = 0xffffffff

	// TCD28_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD28_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD28_DADDR_DADDR_Msk = 0xffffffff

	// TCD28_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD28_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD28_DOFF_DOFF_Msk = 0xffff

	// TCD28_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD28_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD28_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD28_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD28_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD28_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD28_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD28_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD28_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD28_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD28_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD28_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD28_CITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD28_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD28_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD28_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD28_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD28_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD28_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD28_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD28_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD28_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD28_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD28_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD28_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD28_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD28_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD28_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD28_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD28_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD28_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD28_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD28_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD28_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD28_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD28_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD28_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD28_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD28_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD28_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD28_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD28_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD28_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD28_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD28_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD28_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD28_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD28_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD28_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD28_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD28_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD28_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD28_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD28_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD28_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD28_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD28_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD28_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD28_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD28_CSR_MAJORLINKCH_Msk = 0x1f00
	// Position of BWC field.
	DMA_TCD28_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD28_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD28_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD28_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD28_CSR_BWC_BWC_3 = 0x3

	// TCD28_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD28_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD28_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD28_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD28_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD28_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD28_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD28_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD28_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD28_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD28_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD28_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD28_BITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD28_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD28_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD28_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD28_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD28_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD29_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD29_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD29_SADDR_SADDR_Msk = 0xffffffff

	// TCD29_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD29_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD29_SOFF_SOFF_Msk = 0xffff

	// TCD29_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD29_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD29_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD29_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD29_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD29_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD29_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD29_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD29_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD29_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD29_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD29_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD29_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD29_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD29_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD29_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD29_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD29_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD29_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD29_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD29_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD29_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD29_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD29_ATTR_SMOD_SMOD_9 = 0x9

	// TCD29_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD29_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD29_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD29_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD29_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD29_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD29_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD29_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD29_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD29_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD29_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD29_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD29_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD29_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD29_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD29_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD29_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD29_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD29_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD29_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD29_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD29_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD29_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD29_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD29_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD29_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD29_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD29_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD29_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD29_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD29_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD29_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD29_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD29_SLAST_SLAST_Msk = 0xffffffff

	// TCD29_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD29_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD29_DADDR_DADDR_Msk = 0xffffffff

	// TCD29_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD29_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD29_DOFF_DOFF_Msk = 0xffff

	// TCD29_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD29_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD29_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD29_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD29_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD29_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD29_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD29_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD29_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD29_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD29_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD29_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD29_CITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD29_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD29_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD29_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD29_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD29_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD29_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD29_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD29_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD29_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD29_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD29_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD29_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD29_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD29_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD29_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD29_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD29_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD29_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD29_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD29_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD29_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD29_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD29_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD29_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD29_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD29_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD29_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD29_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD29_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD29_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD29_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD29_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD29_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD29_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD29_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD29_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD29_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD29_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD29_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD29_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD29_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD29_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD29_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD29_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD29_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD29_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD29_CSR_MAJORLINKCH_Msk = 0x1f00
	// Position of BWC field.
	DMA_TCD29_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD29_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD29_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD29_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD29_CSR_BWC_BWC_3 = 0x3

	// TCD29_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD29_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD29_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD29_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD29_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD29_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD29_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD29_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD29_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD29_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD29_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD29_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD29_BITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD29_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD29_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD29_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD29_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD29_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD30_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD30_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD30_SADDR_SADDR_Msk = 0xffffffff

	// TCD30_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD30_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD30_SOFF_SOFF_Msk = 0xffff

	// TCD30_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD30_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD30_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD30_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD30_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD30_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD30_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD30_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD30_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD30_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD30_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD30_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD30_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD30_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD30_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD30_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD30_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD30_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD30_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD30_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD30_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD30_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD30_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD30_ATTR_SMOD_SMOD_9 = 0x9

	// TCD30_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD30_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD30_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD30_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD30_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD30_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD30_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD30_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD30_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD30_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD30_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD30_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD30_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD30_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD30_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD30_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD30_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD30_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD30_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD30_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD30_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD30_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD30_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD30_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD30_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD30_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD30_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD30_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD30_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD30_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD30_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD30_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD30_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD30_SLAST_SLAST_Msk = 0xffffffff

	// TCD30_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD30_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD30_DADDR_DADDR_Msk = 0xffffffff

	// TCD30_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD30_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD30_DOFF_DOFF_Msk = 0xffff

	// TCD30_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD30_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD30_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD30_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD30_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD30_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD30_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD30_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD30_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD30_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD30_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD30_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD30_CITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD30_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD30_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD30_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD30_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD30_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD30_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD30_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD30_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD30_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD30_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD30_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD30_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD30_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD30_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD30_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD30_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD30_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD30_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD30_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD30_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD30_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD30_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD30_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD30_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD30_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD30_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD30_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD30_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD30_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD30_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD30_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD30_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD30_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD30_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD30_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD30_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD30_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD30_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD30_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD30_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD30_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD30_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD30_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD30_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD30_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD30_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD30_CSR_MAJORLINKCH_Msk = 0x1f00
	// Position of BWC field.
	DMA_TCD30_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD30_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD30_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD30_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD30_CSR_BWC_BWC_3 = 0x3

	// TCD30_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD30_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD30_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD30_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD30_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD30_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD30_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD30_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD30_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD30_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD30_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD30_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD30_BITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD30_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD30_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD30_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD30_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD30_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD31_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD31_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD31_SADDR_SADDR_Msk = 0xffffffff

	// TCD31_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD31_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD31_SOFF_SOFF_Msk = 0xffff

	// TCD31_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD31_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD31_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD31_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD31_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD31_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD31_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD31_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD31_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD31_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD31_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD31_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD31_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD31_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD31_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD31_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD31_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD31_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD31_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD31_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD31_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD31_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD31_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD31_ATTR_SMOD_SMOD_9 = 0x9

	// TCD31_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD31_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD31_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD31_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD31_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD31_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD31_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD31_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD31_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD31_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD31_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD31_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD31_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD31_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD31_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD31_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD31_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD31_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD31_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD31_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD31_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD31_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD31_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD31_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD31_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD31_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD31_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD31_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD31_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD31_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD31_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD31_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD31_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD31_SLAST_SLAST_Msk = 0xffffffff

	// TCD31_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD31_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD31_DADDR_DADDR_Msk = 0xffffffff

	// TCD31_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD31_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD31_DOFF_DOFF_Msk = 0xffff

	// TCD31_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD31_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD31_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD31_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD31_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD31_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD31_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD31_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD31_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD31_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD31_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD31_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD31_CITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD31_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD31_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD31_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD31_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD31_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD31_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD31_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD31_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD31_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD31_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD31_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD31_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD31_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD31_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD31_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD31_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD31_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD31_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD31_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD31_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD31_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD31_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD31_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD31_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD31_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD31_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD31_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD31_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD31_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD31_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD31_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD31_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD31_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD31_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD31_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD31_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD31_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD31_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD31_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD31_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD31_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD31_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD31_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD31_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD31_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD31_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD31_CSR_MAJORLINKCH_Msk = 0x1f00
	// Position of BWC field.
	DMA_TCD31_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD31_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD31_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD31_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD31_CSR_BWC_BWC_3 = 0x3

	// TCD31_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD31_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD31_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD31_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD31_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD31_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD31_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD31_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD31_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD31_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD31_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD31_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD31_BITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD31_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD31_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD31_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD31_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD31_BITER_ELINKYES_ELINK_ELINK_1 = 0x1
)

// Bitfields for DMAMUX: DMA_CH_MUX
const (
	// CHCFG: Channel 0 Configuration Register
	// Position of SOURCE field.
	DMAMUX_CHCFG_SOURCE_Pos = 0x0
	// Bit mask of SOURCE field.
	DMAMUX_CHCFG_SOURCE_Msk = 0x7f
	// Position of A_ON field.
	DMAMUX_CHCFG_A_ON_Pos = 0x1d
	// Bit mask of A_ON field.
	DMAMUX_CHCFG_A_ON_Msk = 0x20000000
	// Bit A_ON.
	DMAMUX_CHCFG_A_ON = 0x20000000
	// DMA Channel Always ON function is disabled
	DMAMUX_CHCFG_A_ON_A_ON_0 = 0x0
	// DMA Channel Always ON function is enabled
	DMAMUX_CHCFG_A_ON_A_ON_1 = 0x1
	// Position of TRIG field.
	DMAMUX_CHCFG_TRIG_Pos = 0x1e
	// Bit mask of TRIG field.
	DMAMUX_CHCFG_TRIG_Msk = 0x40000000
	// Bit TRIG.
	DMAMUX_CHCFG_TRIG = 0x40000000
	// Triggering is disabled. If triggering is disabled and ENBL is set, the DMA Channel will simply route the specified source to the DMA channel. (Normal mode)
	DMAMUX_CHCFG_TRIG_TRIG_0 = 0x0
	// Triggering is enabled. If triggering is enabled and ENBL is set, the DMA_CH_MUX is in Periodic Trigger mode.
	DMAMUX_CHCFG_TRIG_TRIG_1 = 0x1
	// Position of ENBL field.
	DMAMUX_CHCFG_ENBL_Pos = 0x1f
	// Bit mask of ENBL field.
	DMAMUX_CHCFG_ENBL_Msk = 0x80000000
	// Bit ENBL.
	DMAMUX_CHCFG_ENBL = 0x80000000
	// DMA Mux channel is disabled
	DMAMUX_CHCFG_ENBL_ENBL_0 = 0x0
	// DMA Mux channel is enabled
	DMAMUX_CHCFG_ENBL_ENBL_1 = 0x1
)

// Bitfields for GPC: GPC
const (
	// CNTR: GPC Interface control register
	// Position of MEGA_PDN_REQ field.
	GPC_CNTR_MEGA_PDN_REQ_Pos = 0x2
	// Bit mask of MEGA_PDN_REQ field.
	GPC_CNTR_MEGA_PDN_REQ_Msk = 0x4
	// Bit MEGA_PDN_REQ.
	GPC_CNTR_MEGA_PDN_REQ = 0x4
	// No Request
	GPC_CNTR_MEGA_PDN_REQ_MEGA_PDN_REQ_0 = 0x0
	// Request power down sequence
	GPC_CNTR_MEGA_PDN_REQ_MEGA_PDN_REQ_1 = 0x1
	// Position of MEGA_PUP_REQ field.
	GPC_CNTR_MEGA_PUP_REQ_Pos = 0x3
	// Bit mask of MEGA_PUP_REQ field.
	GPC_CNTR_MEGA_PUP_REQ_Msk = 0x8
	// Bit MEGA_PUP_REQ.
	GPC_CNTR_MEGA_PUP_REQ = 0x8
	// No Request
	GPC_CNTR_MEGA_PUP_REQ_MEGA_PUP_REQ_0 = 0x0
	// Request power up sequence
	GPC_CNTR_MEGA_PUP_REQ_MEGA_PUP_REQ_1 = 0x1
	// Position of PDRAM0_PGE field.
	GPC_CNTR_PDRAM0_PGE_Pos = 0x16
	// Bit mask of PDRAM0_PGE field.
	GPC_CNTR_PDRAM0_PGE_Msk = 0x400000
	// Bit PDRAM0_PGE.
	GPC_CNTR_PDRAM0_PGE = 0x400000
	// FlexRAM PDRAM0 domain will keep power on even if CPU core is power down.
	GPC_CNTR_PDRAM0_PGE_PDRAM0_PGE_0 = 0x0
	// FlexRAM PDRAM0 domain will be power down once when CPU core is power down.
	GPC_CNTR_PDRAM0_PGE_PDRAM0_PGE_1 = 0x1

	// IMR1: IRQ masking register 1
	// Position of IMR1 field.
	GPC_IMR1_IMR1_Pos = 0x0
	// Bit mask of IMR1 field.
	GPC_IMR1_IMR1_Msk = 0xffffffff

	// IMR2: IRQ masking register 2
	// Position of IMR2 field.
	GPC_IMR2_IMR2_Pos = 0x0
	// Bit mask of IMR2 field.
	GPC_IMR2_IMR2_Msk = 0xffffffff

	// IMR3: IRQ masking register 3
	// Position of IMR3 field.
	GPC_IMR3_IMR3_Pos = 0x0
	// Bit mask of IMR3 field.
	GPC_IMR3_IMR3_Msk = 0xffffffff

	// IMR4: IRQ masking register 4
	// Position of IMR4 field.
	GPC_IMR4_IMR4_Pos = 0x0
	// Bit mask of IMR4 field.
	GPC_IMR4_IMR4_Msk = 0xffffffff

	// ISR1: IRQ status resister 1
	// Position of ISR1 field.
	GPC_ISR1_ISR1_Pos = 0x0
	// Bit mask of ISR1 field.
	GPC_ISR1_ISR1_Msk = 0xffffffff

	// ISR2: IRQ status resister 2
	// Position of ISR2 field.
	GPC_ISR2_ISR2_Pos = 0x0
	// Bit mask of ISR2 field.
	GPC_ISR2_ISR2_Msk = 0xffffffff

	// ISR3: IRQ status resister 3
	// Position of ISR3 field.
	GPC_ISR3_ISR3_Pos = 0x0
	// Bit mask of ISR3 field.
	GPC_ISR3_ISR3_Msk = 0xffffffff

	// ISR4: IRQ status resister 4
	// Position of ISR4 field.
	GPC_ISR4_ISR4_Pos = 0x0
	// Bit mask of ISR4 field.
	GPC_ISR4_ISR4_Msk = 0xffffffff

	// IMR5: IRQ masking register 5
	// Position of IMR5 field.
	GPC_IMR5_IMR5_Pos = 0x0
	// Bit mask of IMR5 field.
	GPC_IMR5_IMR5_Msk = 0xffffffff

	// ISR5: IRQ status resister 5
	// Position of ISR4 field.
	GPC_ISR5_ISR4_Pos = 0x0
	// Bit mask of ISR4 field.
	GPC_ISR5_ISR4_Msk = 0xffffffff
)

// Bitfields for PGC: PGC
const (
	// MEGA_CTRL: PGC Mega Control Register
	// Position of PCR field.
	PGC_MEGA_CTRL_PCR_Pos = 0x0
	// Bit mask of PCR field.
	PGC_MEGA_CTRL_PCR_Msk = 0x1
	// Bit PCR.
	PGC_MEGA_CTRL_PCR = 0x1
	// Do not switch off power even if pdn_req is asserted.
	PGC_MEGA_CTRL_PCR_PCR_0 = 0x0
	// Switch off power when pdn_req is asserted.
	PGC_MEGA_CTRL_PCR_PCR_1 = 0x1

	// MEGA_PUPSCR: PGC Mega Power Up Sequence Control Register
	// Position of SW field.
	PGC_MEGA_PUPSCR_SW_Pos = 0x0
	// Bit mask of SW field.
	PGC_MEGA_PUPSCR_SW_Msk = 0x3f
	// Position of SW2ISO field.
	PGC_MEGA_PUPSCR_SW2ISO_Pos = 0x8
	// Bit mask of SW2ISO field.
	PGC_MEGA_PUPSCR_SW2ISO_Msk = 0x3f00

	// MEGA_PDNSCR: PGC Mega Pull Down Sequence Control Register
	// Position of ISO field.
	PGC_MEGA_PDNSCR_ISO_Pos = 0x0
	// Bit mask of ISO field.
	PGC_MEGA_PDNSCR_ISO_Msk = 0x3f
	// Position of ISO2SW field.
	PGC_MEGA_PDNSCR_ISO2SW_Pos = 0x8
	// Bit mask of ISO2SW field.
	PGC_MEGA_PDNSCR_ISO2SW_Msk = 0x3f00

	// MEGA_SR: PGC Mega Power Gating Controller Status Register
	// Position of PSR field.
	PGC_MEGA_SR_PSR_Pos = 0x0
	// Bit mask of PSR field.
	PGC_MEGA_SR_PSR_Msk = 0x1
	// Bit PSR.
	PGC_MEGA_SR_PSR = 0x1
	// The target subsystem was not powered down for the previous power-down request.
	PGC_MEGA_SR_PSR_PSR_0 = 0x0
	// The target subsystem was powered down for the previous power-down request.
	PGC_MEGA_SR_PSR_PSR_1 = 0x1

	// CPU_CTRL: PGC CPU Control Register
	// Position of PCR field.
	PGC_CPU_CTRL_PCR_Pos = 0x0
	// Bit mask of PCR field.
	PGC_CPU_CTRL_PCR_Msk = 0x1
	// Bit PCR.
	PGC_CPU_CTRL_PCR = 0x1
	// Do not switch off power even if pdn_req is asserted.
	PGC_CPU_CTRL_PCR_PCR_0 = 0x0
	// Switch off power when pdn_req is asserted.
	PGC_CPU_CTRL_PCR_PCR_1 = 0x1

	// CPU_PUPSCR: PGC CPU Power Up Sequence Control Register
	// Position of SW field.
	PGC_CPU_PUPSCR_SW_Pos = 0x0
	// Bit mask of SW field.
	PGC_CPU_PUPSCR_SW_Msk = 0x3f
	// Position of SW2ISO field.
	PGC_CPU_PUPSCR_SW2ISO_Pos = 0x8
	// Bit mask of SW2ISO field.
	PGC_CPU_PUPSCR_SW2ISO_Msk = 0x3f00

	// CPU_PDNSCR: PGC CPU Pull Down Sequence Control Register
	// Position of ISO field.
	PGC_CPU_PDNSCR_ISO_Pos = 0x0
	// Bit mask of ISO field.
	PGC_CPU_PDNSCR_ISO_Msk = 0x3f
	// Position of ISO2SW field.
	PGC_CPU_PDNSCR_ISO2SW_Pos = 0x8
	// Bit mask of ISO2SW field.
	PGC_CPU_PDNSCR_ISO2SW_Msk = 0x3f00

	// CPU_SR: PGC CPU Power Gating Controller Status Register
	// Position of PSR field.
	PGC_CPU_SR_PSR_Pos = 0x0
	// Bit mask of PSR field.
	PGC_CPU_SR_PSR_Msk = 0x1
	// Bit PSR.
	PGC_CPU_SR_PSR = 0x1
	// The target subsystem was not powered down for the previous power-down request.
	PGC_CPU_SR_PSR_PSR_0 = 0x0
	// The target subsystem was powered down for the previous power-down request.
	PGC_CPU_SR_PSR_PSR_1 = 0x1
)

// Bitfields for SRC: SRC
const (
	// SCR: SRC Control Register
	// Position of MASK_WDOG_RST field.
	SRC_SCR_MASK_WDOG_RST_Pos = 0x7
	// Bit mask of MASK_WDOG_RST field.
	SRC_SCR_MASK_WDOG_RST_Msk = 0x780
	// wdog_rst_b is masked
	SRC_SCR_MASK_WDOG_RST_MASK_WDOG_RST_5 = 0x5
	// wdog_rst_b is not masked (default)
	SRC_SCR_MASK_WDOG_RST_MASK_WDOG_RST_10 = 0xa
	// Position of CORE0_RST field.
	SRC_SCR_CORE0_RST_Pos = 0xd
	// Bit mask of CORE0_RST field.
	SRC_SCR_CORE0_RST_Msk = 0x2000
	// Bit CORE0_RST.
	SRC_SCR_CORE0_RST = 0x2000
	// do not assert core0 reset
	SRC_SCR_CORE0_RST_CORE0_RST_0 = 0x0
	// assert core0 reset
	SRC_SCR_CORE0_RST_CORE0_RST_1 = 0x1
	// Position of CORE0_DBG_RST field.
	SRC_SCR_CORE0_DBG_RST_Pos = 0x11
	// Bit mask of CORE0_DBG_RST field.
	SRC_SCR_CORE0_DBG_RST_Msk = 0x20000
	// Bit CORE0_DBG_RST.
	SRC_SCR_CORE0_DBG_RST = 0x20000
	// do not assert core0 debug reset
	SRC_SCR_CORE0_DBG_RST_CORE0_DBG_RST_0 = 0x0
	// assert core0 debug reset
	SRC_SCR_CORE0_DBG_RST_CORE0_DBG_RST_1 = 0x1
	// Position of DBG_RST_MSK_PG field.
	SRC_SCR_DBG_RST_MSK_PG_Pos = 0x19
	// Bit mask of DBG_RST_MSK_PG field.
	SRC_SCR_DBG_RST_MSK_PG_Msk = 0x2000000
	// Bit DBG_RST_MSK_PG.
	SRC_SCR_DBG_RST_MSK_PG = 0x2000000
	// do not mask core debug resets (debug resets will be asserted after power gating event)
	SRC_SCR_DBG_RST_MSK_PG_DBG_RST_MSK_PG_0 = 0x0
	// mask core debug resets (debug resets won't be asserted after power gating event)
	SRC_SCR_DBG_RST_MSK_PG_DBG_RST_MSK_PG_1 = 0x1
	// Position of MASK_WDOG3_RST field.
	SRC_SCR_MASK_WDOG3_RST_Pos = 0x1c
	// Bit mask of MASK_WDOG3_RST field.
	SRC_SCR_MASK_WDOG3_RST_Msk = 0xf0000000
	// wdog3_rst_b is masked
	SRC_SCR_MASK_WDOG3_RST_MASK_WDOG3_RST_5 = 0x5
	// wdog3_rst_b is not masked
	SRC_SCR_MASK_WDOG3_RST_MASK_WDOG3_RST_10 = 0xa

	// SBMR1: SRC Boot Mode Register 1
	// Position of BOOT_CFG1 field.
	SRC_SBMR1_BOOT_CFG1_Pos = 0x0
	// Bit mask of BOOT_CFG1 field.
	SRC_SBMR1_BOOT_CFG1_Msk = 0xff
	// Position of BOOT_CFG2 field.
	SRC_SBMR1_BOOT_CFG2_Pos = 0x8
	// Bit mask of BOOT_CFG2 field.
	SRC_SBMR1_BOOT_CFG2_Msk = 0xff00
	// Position of BOOT_CFG3 field.
	SRC_SBMR1_BOOT_CFG3_Pos = 0x10
	// Bit mask of BOOT_CFG3 field.
	SRC_SBMR1_BOOT_CFG3_Msk = 0xff0000
	// Position of BOOT_CFG4 field.
	SRC_SBMR1_BOOT_CFG4_Pos = 0x18
	// Bit mask of BOOT_CFG4 field.
	SRC_SBMR1_BOOT_CFG4_Msk = 0xff000000

	// SRSR: SRC Reset Status Register
	// Position of IPP_RESET_B field.
	SRC_SRSR_IPP_RESET_B_Pos = 0x0
	// Bit mask of IPP_RESET_B field.
	SRC_SRSR_IPP_RESET_B_Msk = 0x1
	// Bit IPP_RESET_B.
	SRC_SRSR_IPP_RESET_B = 0x1
	// Reset is not a result of ipp_reset_b pin.
	SRC_SRSR_IPP_RESET_B_IPP_RESET_B_0 = 0x0
	// Reset is a result of ipp_reset_b pin.
	SRC_SRSR_IPP_RESET_B_IPP_RESET_B_1 = 0x1
	// Position of LOCKUP_SYSRESETREQ field.
	SRC_SRSR_LOCKUP_SYSRESETREQ_Pos = 0x1
	// Bit mask of LOCKUP_SYSRESETREQ field.
	SRC_SRSR_LOCKUP_SYSRESETREQ_Msk = 0x2
	// Bit LOCKUP_SYSRESETREQ.
	SRC_SRSR_LOCKUP_SYSRESETREQ = 0x2
	// Reset is not a result of the mentioned case.
	SRC_SRSR_LOCKUP_SYSRESETREQ_LOCKUP_SYSRESETREQ_0 = 0x0
	// Reset is a result of the mentioned case.
	SRC_SRSR_LOCKUP_SYSRESETREQ_LOCKUP_SYSRESETREQ_1 = 0x1
	// Position of CSU_RESET_B field.
	SRC_SRSR_CSU_RESET_B_Pos = 0x2
	// Bit mask of CSU_RESET_B field.
	SRC_SRSR_CSU_RESET_B_Msk = 0x4
	// Bit CSU_RESET_B.
	SRC_SRSR_CSU_RESET_B = 0x4
	// Reset is not a result of the csu_reset_b event.
	SRC_SRSR_CSU_RESET_B_CSU_RESET_B_0 = 0x0
	// Reset is a result of the csu_reset_b event.
	SRC_SRSR_CSU_RESET_B_CSU_RESET_B_1 = 0x1
	// Position of IPP_USER_RESET_B field.
	SRC_SRSR_IPP_USER_RESET_B_Pos = 0x3
	// Bit mask of IPP_USER_RESET_B field.
	SRC_SRSR_IPP_USER_RESET_B_Msk = 0x8
	// Bit IPP_USER_RESET_B.
	SRC_SRSR_IPP_USER_RESET_B = 0x8
	// Reset is not a result of the ipp_user_reset_b qualified as COLD reset event.
	SRC_SRSR_IPP_USER_RESET_B_IPP_USER_RESET_B_0 = 0x0
	// Reset is a result of the ipp_user_reset_b qualified as COLD reset event.
	SRC_SRSR_IPP_USER_RESET_B_IPP_USER_RESET_B_1 = 0x1
	// Position of WDOG_RST_B field.
	SRC_SRSR_WDOG_RST_B_Pos = 0x4
	// Bit mask of WDOG_RST_B field.
	SRC_SRSR_WDOG_RST_B_Msk = 0x10
	// Bit WDOG_RST_B.
	SRC_SRSR_WDOG_RST_B = 0x10
	// Reset is not a result of the watchdog time-out event.
	SRC_SRSR_WDOG_RST_B_WDOG_RST_B_0 = 0x0
	// Reset is a result of the watchdog time-out event.
	SRC_SRSR_WDOG_RST_B_WDOG_RST_B_1 = 0x1
	// Position of JTAG_RST_B field.
	SRC_SRSR_JTAG_RST_B_Pos = 0x5
	// Bit mask of JTAG_RST_B field.
	SRC_SRSR_JTAG_RST_B_Msk = 0x20
	// Bit JTAG_RST_B.
	SRC_SRSR_JTAG_RST_B = 0x20
	// Reset is not a result of HIGH-Z reset from JTAG.
	SRC_SRSR_JTAG_RST_B_JTAG_RST_B_0 = 0x0
	// Reset is a result of HIGH-Z reset from JTAG.
	SRC_SRSR_JTAG_RST_B_JTAG_RST_B_1 = 0x1
	// Position of JTAG_SW_RST field.
	SRC_SRSR_JTAG_SW_RST_Pos = 0x6
	// Bit mask of JTAG_SW_RST field.
	SRC_SRSR_JTAG_SW_RST_Msk = 0x40
	// Bit JTAG_SW_RST.
	SRC_SRSR_JTAG_SW_RST = 0x40
	// Reset is not a result of software reset from JTAG.
	SRC_SRSR_JTAG_SW_RST_JTAG_SW_RST_0 = 0x0
	// Reset is a result of software reset from JTAG.
	SRC_SRSR_JTAG_SW_RST_JTAG_SW_RST_1 = 0x1
	// Position of WDOG3_RST_B field.
	SRC_SRSR_WDOG3_RST_B_Pos = 0x7
	// Bit mask of WDOG3_RST_B field.
	SRC_SRSR_WDOG3_RST_B_Msk = 0x80
	// Bit WDOG3_RST_B.
	SRC_SRSR_WDOG3_RST_B = 0x80
	// Reset is not a result of the watchdog3 time-out event.
	SRC_SRSR_WDOG3_RST_B_WDOG3_RST_B_0 = 0x0
	// Reset is a result of the watchdog3 time-out event.
	SRC_SRSR_WDOG3_RST_B_WDOG3_RST_B_1 = 0x1
	// Position of TEMPSENSE_RST_B field.
	SRC_SRSR_TEMPSENSE_RST_B_Pos = 0x8
	// Bit mask of TEMPSENSE_RST_B field.
	SRC_SRSR_TEMPSENSE_RST_B_Msk = 0x100
	// Bit TEMPSENSE_RST_B.
	SRC_SRSR_TEMPSENSE_RST_B = 0x100
	// Reset is not a result of software reset from Temperature Sensor.
	SRC_SRSR_TEMPSENSE_RST_B_TEMPSENSE_RST_B_0 = 0x0
	// Reset is a result of software reset from Temperature Sensor.
	SRC_SRSR_TEMPSENSE_RST_B_TEMPSENSE_RST_B_1 = 0x1

	// SBMR2: SRC Boot Mode Register 2
	// Position of SEC_CONFIG field.
	SRC_SBMR2_SEC_CONFIG_Pos = 0x0
	// Bit mask of SEC_CONFIG field.
	SRC_SBMR2_SEC_CONFIG_Msk = 0x3
	// Position of DIR_BT_DIS field.
	SRC_SBMR2_DIR_BT_DIS_Pos = 0x3
	// Bit mask of DIR_BT_DIS field.
	SRC_SBMR2_DIR_BT_DIS_Msk = 0x8
	// Bit DIR_BT_DIS.
	SRC_SBMR2_DIR_BT_DIS = 0x8
	// Position of BT_FUSE_SEL field.
	SRC_SBMR2_BT_FUSE_SEL_Pos = 0x4
	// Bit mask of BT_FUSE_SEL field.
	SRC_SBMR2_BT_FUSE_SEL_Msk = 0x10
	// Bit BT_FUSE_SEL.
	SRC_SBMR2_BT_FUSE_SEL = 0x10
	// Position of BMOD field.
	SRC_SBMR2_BMOD_Pos = 0x18
	// Bit mask of BMOD field.
	SRC_SBMR2_BMOD_Msk = 0x3000000

	// GPR1: SRC General Purpose Register 1
	// Position of PERSISTENT_ENTRY0 field.
	SRC_GPR1_PERSISTENT_ENTRY0_Pos = 0x0
	// Bit mask of PERSISTENT_ENTRY0 field.
	SRC_GPR1_PERSISTENT_ENTRY0_Msk = 0xffffffff

	// GPR2: SRC General Purpose Register 2
	// Position of PERSISTENT_ARG0 field.
	SRC_GPR2_PERSISTENT_ARG0_Pos = 0x0
	// Bit mask of PERSISTENT_ARG0 field.
	SRC_GPR2_PERSISTENT_ARG0_Msk = 0xffffffff
)

// Bitfields for CCM: CCM
const (
	// CCR: CCM Control Register
	// Position of OSCNT field.
	CCM_CCR_OSCNT_Pos = 0x0
	// Bit mask of OSCNT field.
	CCM_CCR_OSCNT_Msk = 0xff
	// Position of COSC_EN field.
	CCM_CCR_COSC_EN_Pos = 0xc
	// Bit mask of COSC_EN field.
	CCM_CCR_COSC_EN_Msk = 0x1000
	// Bit COSC_EN.
	CCM_CCR_COSC_EN = 0x1000
	// disable on chip oscillator
	CCM_CCR_COSC_EN_COSC_EN_0 = 0x0
	// enable on chip oscillator
	CCM_CCR_COSC_EN_COSC_EN_1 = 0x1
	// Position of REG_BYPASS_COUNT field.
	CCM_CCR_REG_BYPASS_COUNT_Pos = 0x15
	// Bit mask of REG_BYPASS_COUNT field.
	CCM_CCR_REG_BYPASS_COUNT_Msk = 0x7e00000
	// no delay
	CCM_CCR_REG_BYPASS_COUNT_REG_BYPASS_COUNT_0 = 0x0
	// 1 CKIL clock period delay
	CCM_CCR_REG_BYPASS_COUNT_REG_BYPASS_COUNT_1 = 0x1
	// 63 CKIL clock periods delay
	CCM_CCR_REG_BYPASS_COUNT_REG_BYPASS_COUNT_63 = 0x3f
	// Position of RBC_EN field.
	CCM_CCR_RBC_EN_Pos = 0x1b
	// Bit mask of RBC_EN field.
	CCM_CCR_RBC_EN_Msk = 0x8000000
	// Bit RBC_EN.
	CCM_CCR_RBC_EN = 0x8000000
	// REG_BYPASS_COUNTER disabled
	CCM_CCR_RBC_EN_RBC_EN_0 = 0x0
	// REG_BYPASS_COUNTER enabled.
	CCM_CCR_RBC_EN_RBC_EN_1 = 0x1

	// CSR: CCM Status Register
	// Position of REF_EN_B field.
	CCM_CSR_REF_EN_B_Pos = 0x0
	// Bit mask of REF_EN_B field.
	CCM_CSR_REF_EN_B_Msk = 0x1
	// Bit REF_EN_B.
	CCM_CSR_REF_EN_B = 0x1
	// value of CCM_REF_EN_B is '0'
	CCM_CSR_REF_EN_B_REF_EN_B_0 = 0x0
	// value of CCM_REF_EN_B is '1'
	CCM_CSR_REF_EN_B_REF_EN_B_1 = 0x1
	// Position of CAMP2_READY field.
	CCM_CSR_CAMP2_READY_Pos = 0x3
	// Bit mask of CAMP2_READY field.
	CCM_CSR_CAMP2_READY_Msk = 0x8
	// Bit CAMP2_READY.
	CCM_CSR_CAMP2_READY = 0x8
	// CAMP2 is not ready.
	CCM_CSR_CAMP2_READY_CAMP2_READY_0 = 0x0
	// CAMP2 is ready.
	CCM_CSR_CAMP2_READY_CAMP2_READY_1 = 0x1
	// Position of COSC_READY field.
	CCM_CSR_COSC_READY_Pos = 0x5
	// Bit mask of COSC_READY field.
	CCM_CSR_COSC_READY_Msk = 0x20
	// Bit COSC_READY.
	CCM_CSR_COSC_READY = 0x20
	// on board oscillator is not ready.
	CCM_CSR_COSC_READY_COSC_READY_0 = 0x0
	// on board oscillator is ready.
	CCM_CSR_COSC_READY_COSC_READY_1 = 0x1

	// CCSR: CCM Clock Switcher Register
	// Position of PLL3_SW_CLK_SEL field.
	CCM_CCSR_PLL3_SW_CLK_SEL_Pos = 0x0
	// Bit mask of PLL3_SW_CLK_SEL field.
	CCM_CCSR_PLL3_SW_CLK_SEL_Msk = 0x1
	// Bit PLL3_SW_CLK_SEL.
	CCM_CCSR_PLL3_SW_CLK_SEL = 0x1
	// pll3_main_clk
	CCM_CCSR_PLL3_SW_CLK_SEL_PLL3_SW_CLK_SEL_0 = 0x0
	// pll3 bypass clock
	CCM_CCSR_PLL3_SW_CLK_SEL_PLL3_SW_CLK_SEL_1 = 0x1

	// CACRR: CCM Arm Clock Root Register
	// Position of ARM_PODF field.
	CCM_CACRR_ARM_PODF_Pos = 0x0
	// Bit mask of ARM_PODF field.
	CCM_CACRR_ARM_PODF_Msk = 0x7
	// divide by 1
	CCM_CACRR_ARM_PODF_ARM_PODF_0 = 0x0
	// divide by 2
	CCM_CACRR_ARM_PODF_ARM_PODF_1 = 0x1
	// divide by 3
	CCM_CACRR_ARM_PODF_ARM_PODF_2 = 0x2
	// divide by 4
	CCM_CACRR_ARM_PODF_ARM_PODF_3 = 0x3
	// divide by 5
	CCM_CACRR_ARM_PODF_ARM_PODF_4 = 0x4
	// divide by 6
	CCM_CACRR_ARM_PODF_ARM_PODF_5 = 0x5
	// divide by 7
	CCM_CACRR_ARM_PODF_ARM_PODF_6 = 0x6
	// divide by 8
	CCM_CACRR_ARM_PODF_ARM_PODF_7 = 0x7

	// CBCDR: CCM Bus Clock Divider Register
	// Position of SEMC_CLK_SEL field.
	CCM_CBCDR_SEMC_CLK_SEL_Pos = 0x6
	// Bit mask of SEMC_CLK_SEL field.
	CCM_CBCDR_SEMC_CLK_SEL_Msk = 0x40
	// Bit SEMC_CLK_SEL.
	CCM_CBCDR_SEMC_CLK_SEL = 0x40
	// Periph_clk output will be used as SEMC clock root
	CCM_CBCDR_SEMC_CLK_SEL_SEMC_CLK_SEL_0 = 0x0
	// SEMC alternative clock will be used as SEMC clock root
	CCM_CBCDR_SEMC_CLK_SEL_SEMC_CLK_SEL_1 = 0x1
	// Position of SEMC_ALT_CLK_SEL field.
	CCM_CBCDR_SEMC_ALT_CLK_SEL_Pos = 0x7
	// Bit mask of SEMC_ALT_CLK_SEL field.
	CCM_CBCDR_SEMC_ALT_CLK_SEL_Msk = 0x80
	// Bit SEMC_ALT_CLK_SEL.
	CCM_CBCDR_SEMC_ALT_CLK_SEL = 0x80
	// PLL2 PFD2 will be selected as alternative clock for SEMC root clock
	CCM_CBCDR_SEMC_ALT_CLK_SEL_SEMC_ALT_CLK_SEL_0 = 0x0
	// PLL3 PFD1 will be selected as alternative clock for SEMC root clock
	CCM_CBCDR_SEMC_ALT_CLK_SEL_SEMC_ALT_CLK_SEL_1 = 0x1
	// Position of IPG_PODF field.
	CCM_CBCDR_IPG_PODF_Pos = 0x8
	// Bit mask of IPG_PODF field.
	CCM_CBCDR_IPG_PODF_Msk = 0x300
	// divide by 1
	CCM_CBCDR_IPG_PODF_IPG_PODF_0 = 0x0
	// divide by 2
	CCM_CBCDR_IPG_PODF_IPG_PODF_1 = 0x1
	// divide by 3
	CCM_CBCDR_IPG_PODF_IPG_PODF_2 = 0x2
	// divide by 4
	CCM_CBCDR_IPG_PODF_IPG_PODF_3 = 0x3
	// Position of AHB_PODF field.
	CCM_CBCDR_AHB_PODF_Pos = 0xa
	// Bit mask of AHB_PODF field.
	CCM_CBCDR_AHB_PODF_Msk = 0x1c00
	// divide by 1
	CCM_CBCDR_AHB_PODF_AHB_PODF_0 = 0x0
	// divide by 2
	CCM_CBCDR_AHB_PODF_AHB_PODF_1 = 0x1
	// divide by 3
	CCM_CBCDR_AHB_PODF_AHB_PODF_2 = 0x2
	// divide by 4
	CCM_CBCDR_AHB_PODF_AHB_PODF_3 = 0x3
	// divide by 5
	CCM_CBCDR_AHB_PODF_AHB_PODF_4 = 0x4
	// divide by 6
	CCM_CBCDR_AHB_PODF_AHB_PODF_5 = 0x5
	// divide by 7
	CCM_CBCDR_AHB_PODF_AHB_PODF_6 = 0x6
	// divide by 8
	CCM_CBCDR_AHB_PODF_AHB_PODF_7 = 0x7
	// Position of SEMC_PODF field.
	CCM_CBCDR_SEMC_PODF_Pos = 0x10
	// Bit mask of SEMC_PODF field.
	CCM_CBCDR_SEMC_PODF_Msk = 0x70000
	// divide by 1
	CCM_CBCDR_SEMC_PODF_SEMC_PODF_0 = 0x0
	// divide by 2
	CCM_CBCDR_SEMC_PODF_SEMC_PODF_1 = 0x1
	// divide by 3
	CCM_CBCDR_SEMC_PODF_SEMC_PODF_2 = 0x2
	// divide by 4
	CCM_CBCDR_SEMC_PODF_SEMC_PODF_3 = 0x3
	// divide by 5
	CCM_CBCDR_SEMC_PODF_SEMC_PODF_4 = 0x4
	// divide by 6
	CCM_CBCDR_SEMC_PODF_SEMC_PODF_5 = 0x5
	// divide by 7
	CCM_CBCDR_SEMC_PODF_SEMC_PODF_6 = 0x6
	// divide by 8
	CCM_CBCDR_SEMC_PODF_SEMC_PODF_7 = 0x7
	// Position of PERIPH_CLK_SEL field.
	CCM_CBCDR_PERIPH_CLK_SEL_Pos = 0x19
	// Bit mask of PERIPH_CLK_SEL field.
	CCM_CBCDR_PERIPH_CLK_SEL_Msk = 0x2000000
	// Bit PERIPH_CLK_SEL.
	CCM_CBCDR_PERIPH_CLK_SEL = 0x2000000
	// derive clock from pre_periph_clk_sel
	CCM_CBCDR_PERIPH_CLK_SEL_PERIPH_CLK_SEL_0 = 0x0
	// derive clock from periph_clk2_clk_divided
	CCM_CBCDR_PERIPH_CLK_SEL_PERIPH_CLK_SEL_1 = 0x1
	// Position of PERIPH_CLK2_PODF field.
	CCM_CBCDR_PERIPH_CLK2_PODF_Pos = 0x1b
	// Bit mask of PERIPH_CLK2_PODF field.
	CCM_CBCDR_PERIPH_CLK2_PODF_Msk = 0x38000000
	// divide by 1
	CCM_CBCDR_PERIPH_CLK2_PODF_PERIPH_CLK2_PODF_0 = 0x0
	// divide by 2
	CCM_CBCDR_PERIPH_CLK2_PODF_PERIPH_CLK2_PODF_1 = 0x1
	// divide by 3
	CCM_CBCDR_PERIPH_CLK2_PODF_PERIPH_CLK2_PODF_2 = 0x2
	// divide by 4
	CCM_CBCDR_PERIPH_CLK2_PODF_PERIPH_CLK2_PODF_3 = 0x3
	// divide by 5
	CCM_CBCDR_PERIPH_CLK2_PODF_PERIPH_CLK2_PODF_4 = 0x4
	// divide by 6
	CCM_CBCDR_PERIPH_CLK2_PODF_PERIPH_CLK2_PODF_5 = 0x5
	// divide by 7
	CCM_CBCDR_PERIPH_CLK2_PODF_PERIPH_CLK2_PODF_6 = 0x6
	// divide by 8
	CCM_CBCDR_PERIPH_CLK2_PODF_PERIPH_CLK2_PODF_7 = 0x7

	// CBCMR: CCM Bus Clock Multiplexer Register
	// Position of LPSPI_CLK_SEL field.
	CCM_CBCMR_LPSPI_CLK_SEL_Pos = 0x4
	// Bit mask of LPSPI_CLK_SEL field.
	CCM_CBCMR_LPSPI_CLK_SEL_Msk = 0x30
	// derive clock from PLL3 PFD1 clk
	CCM_CBCMR_LPSPI_CLK_SEL_LPSPI_CLK_SEL_0 = 0x0
	// derive clock from PLL3 PFD0
	CCM_CBCMR_LPSPI_CLK_SEL_LPSPI_CLK_SEL_1 = 0x1
	// derive clock from PLL2
	CCM_CBCMR_LPSPI_CLK_SEL_LPSPI_CLK_SEL_2 = 0x2
	// derive clock from PLL2 PFD2
	CCM_CBCMR_LPSPI_CLK_SEL_LPSPI_CLK_SEL_3 = 0x3
	// Position of FLEXSPI2_CLK_SEL field.
	CCM_CBCMR_FLEXSPI2_CLK_SEL_Pos = 0x8
	// Bit mask of FLEXSPI2_CLK_SEL field.
	CCM_CBCMR_FLEXSPI2_CLK_SEL_Msk = 0x300
	// derive clock from PLL2 PFD2
	CCM_CBCMR_FLEXSPI2_CLK_SEL_FLEXSPI2_CLK_SEL_0 = 0x0
	// derive clock from PLL3 PFD0
	CCM_CBCMR_FLEXSPI2_CLK_SEL_FLEXSPI2_CLK_SEL_1 = 0x1
	// derive clock from PLL3 PFD1
	CCM_CBCMR_FLEXSPI2_CLK_SEL_FLEXSPI2_CLK_SEL_2 = 0x2
	// derive clock from PLL2 (pll2_main_clk)
	CCM_CBCMR_FLEXSPI2_CLK_SEL_FLEXSPI2_CLK_SEL_3 = 0x3
	// Position of PERIPH_CLK2_SEL field.
	CCM_CBCMR_PERIPH_CLK2_SEL_Pos = 0xc
	// Bit mask of PERIPH_CLK2_SEL field.
	CCM_CBCMR_PERIPH_CLK2_SEL_Msk = 0x3000
	// derive clock from pll3_sw_clk
	CCM_CBCMR_PERIPH_CLK2_SEL_PERIPH_CLK2_SEL_0 = 0x0
	// derive clock from osc_clk (pll1_ref_clk)
	CCM_CBCMR_PERIPH_CLK2_SEL_PERIPH_CLK2_SEL_1 = 0x1
	// derive clock from pll2_bypass_clk
	CCM_CBCMR_PERIPH_CLK2_SEL_PERIPH_CLK2_SEL_2 = 0x2
	// Position of TRACE_CLK_SEL field.
	CCM_CBCMR_TRACE_CLK_SEL_Pos = 0xe
	// Bit mask of TRACE_CLK_SEL field.
	CCM_CBCMR_TRACE_CLK_SEL_Msk = 0xc000
	// derive clock from PLL2
	CCM_CBCMR_TRACE_CLK_SEL_TRACE_CLK_SEL_0 = 0x0
	// derive clock from PLL2 PFD2
	CCM_CBCMR_TRACE_CLK_SEL_TRACE_CLK_SEL_1 = 0x1
	// derive clock from PLL2 PFD0
	CCM_CBCMR_TRACE_CLK_SEL_TRACE_CLK_SEL_2 = 0x2
	// derive clock from PLL2 PFD1
	CCM_CBCMR_TRACE_CLK_SEL_TRACE_CLK_SEL_3 = 0x3
	// Position of PRE_PERIPH_CLK_SEL field.
	CCM_CBCMR_PRE_PERIPH_CLK_SEL_Pos = 0x12
	// Bit mask of PRE_PERIPH_CLK_SEL field.
	CCM_CBCMR_PRE_PERIPH_CLK_SEL_Msk = 0xc0000
	// derive clock from PLL2
	CCM_CBCMR_PRE_PERIPH_CLK_SEL_PRE_PERIPH_CLK_SEL_0 = 0x0
	// derive clock from PLL2 PFD2
	CCM_CBCMR_PRE_PERIPH_CLK_SEL_PRE_PERIPH_CLK_SEL_1 = 0x1
	// derive clock from PLL2 PFD0
	CCM_CBCMR_PRE_PERIPH_CLK_SEL_PRE_PERIPH_CLK_SEL_2 = 0x2
	// derive clock from divided PLL1
	CCM_CBCMR_PRE_PERIPH_CLK_SEL_PRE_PERIPH_CLK_SEL_3 = 0x3
	// Position of LCDIF_PODF field.
	CCM_CBCMR_LCDIF_PODF_Pos = 0x17
	// Bit mask of LCDIF_PODF field.
	CCM_CBCMR_LCDIF_PODF_Msk = 0x3800000
	// divide by 1
	CCM_CBCMR_LCDIF_PODF_LCDIF_PODF_0 = 0x0
	// divide by 2
	CCM_CBCMR_LCDIF_PODF_LCDIF_PODF_1 = 0x1
	// divide by 3
	CCM_CBCMR_LCDIF_PODF_LCDIF_PODF_2 = 0x2
	// divide by 4
	CCM_CBCMR_LCDIF_PODF_LCDIF_PODF_3 = 0x3
	// divide by 5
	CCM_CBCMR_LCDIF_PODF_LCDIF_PODF_4 = 0x4
	// divide by 6
	CCM_CBCMR_LCDIF_PODF_LCDIF_PODF_5 = 0x5
	// divide by 7
	CCM_CBCMR_LCDIF_PODF_LCDIF_PODF_6 = 0x6
	// divide by 8
	CCM_CBCMR_LCDIF_PODF_LCDIF_PODF_7 = 0x7
	// Position of LPSPI_PODF field.
	CCM_CBCMR_LPSPI_PODF_Pos = 0x1a
	// Bit mask of LPSPI_PODF field.
	CCM_CBCMR_LPSPI_PODF_Msk = 0x1c000000
	// divide by 1
	CCM_CBCMR_LPSPI_PODF_LPSPI_PODF_0 = 0x0
	// divide by 2
	CCM_CBCMR_LPSPI_PODF_LPSPI_PODF_1 = 0x1
	// divide by 3
	CCM_CBCMR_LPSPI_PODF_LPSPI_PODF_2 = 0x2
	// divide by 4
	CCM_CBCMR_LPSPI_PODF_LPSPI_PODF_3 = 0x3
	// divide by 5
	CCM_CBCMR_LPSPI_PODF_LPSPI_PODF_4 = 0x4
	// divide by 6
	CCM_CBCMR_LPSPI_PODF_LPSPI_PODF_5 = 0x5
	// divide by 7
	CCM_CBCMR_LPSPI_PODF_LPSPI_PODF_6 = 0x6
	// divide by 8
	CCM_CBCMR_LPSPI_PODF_LPSPI_PODF_7 = 0x7
	// Position of FLEXSPI2_PODF field.
	CCM_CBCMR_FLEXSPI2_PODF_Pos = 0x1d
	// Bit mask of FLEXSPI2_PODF field.
	CCM_CBCMR_FLEXSPI2_PODF_Msk = 0xe0000000
	// divide by 1
	CCM_CBCMR_FLEXSPI2_PODF_FLEXSPI2_PODF_0 = 0x0
	// divide by 2
	CCM_CBCMR_FLEXSPI2_PODF_FLEXSPI2_PODF_1 = 0x1
	// divide by 3
	CCM_CBCMR_FLEXSPI2_PODF_FLEXSPI2_PODF_2 = 0x2
	// divide by 4
	CCM_CBCMR_FLEXSPI2_PODF_FLEXSPI2_PODF_3 = 0x3
	// divide by 5
	CCM_CBCMR_FLEXSPI2_PODF_FLEXSPI2_PODF_4 = 0x4
	// divide by 6
	CCM_CBCMR_FLEXSPI2_PODF_FLEXSPI2_PODF_5 = 0x5
	// divide by 7
	CCM_CBCMR_FLEXSPI2_PODF_FLEXSPI2_PODF_6 = 0x6
	// divide by 8
	CCM_CBCMR_FLEXSPI2_PODF_FLEXSPI2_PODF_7 = 0x7

	// CSCMR1: CCM Serial Clock Multiplexer Register 1
	// Position of PERCLK_PODF field.
	CCM_CSCMR1_PERCLK_PODF_Pos = 0x0
	// Bit mask of PERCLK_PODF field.
	CCM_CSCMR1_PERCLK_PODF_Msk = 0x3f
	// Divide by 1
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_1 = 0x0
	// Divide by 2
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_2 = 0x1
	// Divide by 3
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_3 = 0x2
	// Divide by 4
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_4 = 0x3
	// Divide by 5
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_5 = 0x4
	// Divide by 6
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_6 = 0x5
	// Divide by 7
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_7 = 0x6
	// Divide by 8
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_8 = 0x7
	// Divide by 9
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_9 = 0x8
	// Divide by 10
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_10 = 0x9
	// Divide by 11
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_11 = 0xa
	// Divide by 12
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_12 = 0xb
	// Divide by 13
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_13 = 0xc
	// Divide by 14
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_14 = 0xd
	// Divide by 15
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_15 = 0xe
	// Divide by 16
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_16 = 0xf
	// Divide by 17
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_17 = 0x10
	// Divide by 18
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_18 = 0x11
	// Divide by 19
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_19 = 0x12
	// Divide by 20
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_20 = 0x13
	// Divide by 21
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_21 = 0x14
	// Divide by 22
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_22 = 0x15
	// Divide by 23
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_23 = 0x16
	// Divide by 24
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_24 = 0x17
	// Divide by 25
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_25 = 0x18
	// Divide by 26
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_26 = 0x19
	// Divide by 27
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_27 = 0x1a
	// Divide by 28
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_28 = 0x1b
	// Divide by 29
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_29 = 0x1c
	// Divide by 30
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_30 = 0x1d
	// Divide by 31
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_31 = 0x1e
	// Divide by 32
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_32 = 0x1f
	// Divide by 33
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_33 = 0x20
	// Divide by 34
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_34 = 0x21
	// Divide by 35
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_35 = 0x22
	// Divide by 36
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_36 = 0x23
	// Divide by 37
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_37 = 0x24
	// Divide by 38
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_38 = 0x25
	// Divide by 39
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_39 = 0x26
	// Divide by 40
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_40 = 0x27
	// Divide by 41
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_41 = 0x28
	// Divide by 42
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_42 = 0x29
	// Divide by 43
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_43 = 0x2a
	// Divide by 44
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_44 = 0x2b
	// Divide by 45
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_45 = 0x2c
	// Divide by 46
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_46 = 0x2d
	// Divide by 47
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_47 = 0x2e
	// Divide by 48
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_48 = 0x2f
	// Divide by 49
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_49 = 0x30
	// Divide by 50
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_50 = 0x31
	// Divide by 51
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_51 = 0x32
	// Divide by 52
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_52 = 0x33
	// Divide by 53
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_53 = 0x34
	// Divide by 54
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_54 = 0x35
	// Divide by 55
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_55 = 0x36
	// Divide by 56
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_56 = 0x37
	// Divide by 57
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_57 = 0x38
	// Divide by 58
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_58 = 0x39
	// Divide by 59
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_59 = 0x3a
	// Divide by 60
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_60 = 0x3b
	// Divide by 61
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_61 = 0x3c
	// Divide by 62
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_62 = 0x3d
	// Divide by 63
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_63 = 0x3e
	// Divide by 64
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_64 = 0x3f
	// Position of PERCLK_CLK_SEL field.
	CCM_CSCMR1_PERCLK_CLK_SEL_Pos = 0x6
	// Bit mask of PERCLK_CLK_SEL field.
	CCM_CSCMR1_PERCLK_CLK_SEL_Msk = 0x40
	// Bit PERCLK_CLK_SEL.
	CCM_CSCMR1_PERCLK_CLK_SEL = 0x40
	// derive clock from ipg clk root
	CCM_CSCMR1_PERCLK_CLK_SEL_PERCLK_CLK_SEL_0 = 0x0
	// derive clock from osc_clk
	CCM_CSCMR1_PERCLK_CLK_SEL_PERCLK_CLK_SEL_1 = 0x1
	// Position of SAI1_CLK_SEL field.
	CCM_CSCMR1_SAI1_CLK_SEL_Pos = 0xa
	// Bit mask of SAI1_CLK_SEL field.
	CCM_CSCMR1_SAI1_CLK_SEL_Msk = 0xc00
	// derive clock from PLL3 PFD2
	CCM_CSCMR1_SAI1_CLK_SEL_SAI1_CLK_SEL_0 = 0x0
	// derive clock from PLL5
	CCM_CSCMR1_SAI1_CLK_SEL_SAI1_CLK_SEL_1 = 0x1
	// derive clock from PLL4
	CCM_CSCMR1_SAI1_CLK_SEL_SAI1_CLK_SEL_2 = 0x2
	// Position of SAI2_CLK_SEL field.
	CCM_CSCMR1_SAI2_CLK_SEL_Pos = 0xc
	// Bit mask of SAI2_CLK_SEL field.
	CCM_CSCMR1_SAI2_CLK_SEL_Msk = 0x3000
	// derive clock from PLL3 PFD2
	CCM_CSCMR1_SAI2_CLK_SEL_SAI2_CLK_SEL_0 = 0x0
	// derive clock from PLL5
	CCM_CSCMR1_SAI2_CLK_SEL_SAI2_CLK_SEL_1 = 0x1
	// derive clock from PLL4
	CCM_CSCMR1_SAI2_CLK_SEL_SAI2_CLK_SEL_2 = 0x2
	// Position of SAI3_CLK_SEL field.
	CCM_CSCMR1_SAI3_CLK_SEL_Pos = 0xe
	// Bit mask of SAI3_CLK_SEL field.
	CCM_CSCMR1_SAI3_CLK_SEL_Msk = 0xc000
	// derive clock from PLL3 PFD2
	CCM_CSCMR1_SAI3_CLK_SEL_SAI3_CLK_SEL_0 = 0x0
	// derive clock from PLL5
	CCM_CSCMR1_SAI3_CLK_SEL_SAI3_CLK_SEL_1 = 0x1
	// derive clock from PLL4
	CCM_CSCMR1_SAI3_CLK_SEL_SAI3_CLK_SEL_2 = 0x2
	// Position of USDHC1_CLK_SEL field.
	CCM_CSCMR1_USDHC1_CLK_SEL_Pos = 0x10
	// Bit mask of USDHC1_CLK_SEL field.
	CCM_CSCMR1_USDHC1_CLK_SEL_Msk = 0x10000
	// Bit USDHC1_CLK_SEL.
	CCM_CSCMR1_USDHC1_CLK_SEL = 0x10000
	// derive clock from PLL2 PFD2
	CCM_CSCMR1_USDHC1_CLK_SEL_USDHC1_CLK_SEL_0 = 0x0
	// derive clock from PLL2 PFD0
	CCM_CSCMR1_USDHC1_CLK_SEL_USDHC1_CLK_SEL_1 = 0x1
	// Position of USDHC2_CLK_SEL field.
	CCM_CSCMR1_USDHC2_CLK_SEL_Pos = 0x11
	// Bit mask of USDHC2_CLK_SEL field.
	CCM_CSCMR1_USDHC2_CLK_SEL_Msk = 0x20000
	// Bit USDHC2_CLK_SEL.
	CCM_CSCMR1_USDHC2_CLK_SEL = 0x20000
	// derive clock from PLL2 PFD2
	CCM_CSCMR1_USDHC2_CLK_SEL_USDHC2_CLK_SEL_0 = 0x0
	// derive clock from PLL2 PFD0
	CCM_CSCMR1_USDHC2_CLK_SEL_USDHC2_CLK_SEL_1 = 0x1
	// Position of FLEXSPI_PODF field.
	CCM_CSCMR1_FLEXSPI_PODF_Pos = 0x17
	// Bit mask of FLEXSPI_PODF field.
	CCM_CSCMR1_FLEXSPI_PODF_Msk = 0x3800000
	// divide by 1
	CCM_CSCMR1_FLEXSPI_PODF_FLEXSPI_PODF_0 = 0x0
	// divide by 2
	CCM_CSCMR1_FLEXSPI_PODF_FLEXSPI_PODF_1 = 0x1
	// divide by 3
	CCM_CSCMR1_FLEXSPI_PODF_FLEXSPI_PODF_2 = 0x2
	// divide by 4
	CCM_CSCMR1_FLEXSPI_PODF_FLEXSPI_PODF_3 = 0x3
	// divide by 5
	CCM_CSCMR1_FLEXSPI_PODF_FLEXSPI_PODF_4 = 0x4
	// divide by 6
	CCM_CSCMR1_FLEXSPI_PODF_FLEXSPI_PODF_5 = 0x5
	// divide by 7
	CCM_CSCMR1_FLEXSPI_PODF_FLEXSPI_PODF_6 = 0x6
	// divide by 8
	CCM_CSCMR1_FLEXSPI_PODF_FLEXSPI_PODF_7 = 0x7
	// Position of FLEXSPI_CLK_SEL field.
	CCM_CSCMR1_FLEXSPI_CLK_SEL_Pos = 0x1d
	// Bit mask of FLEXSPI_CLK_SEL field.
	CCM_CSCMR1_FLEXSPI_CLK_SEL_Msk = 0x60000000
	// derive clock from semc_clk_root_pre
	CCM_CSCMR1_FLEXSPI_CLK_SEL_FLEXSPI_CLK_SEL_0 = 0x0
	// derive clock from pll3_sw_clk
	CCM_CSCMR1_FLEXSPI_CLK_SEL_FLEXSPI_CLK_SEL_1 = 0x1
	// derive clock from PLL2 PFD2
	CCM_CSCMR1_FLEXSPI_CLK_SEL_FLEXSPI_CLK_SEL_2 = 0x2
	// derive clock from PLL3 PFD0
	CCM_CSCMR1_FLEXSPI_CLK_SEL_FLEXSPI_CLK_SEL_3 = 0x3

	// CSCMR2: CCM Serial Clock Multiplexer Register 2
	// Position of CAN_CLK_PODF field.
	CCM_CSCMR2_CAN_CLK_PODF_Pos = 0x2
	// Bit mask of CAN_CLK_PODF field.
	CCM_CSCMR2_CAN_CLK_PODF_Msk = 0xfc
	// Divide by 1
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_1 = 0x0
	// Divide by 2
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_2 = 0x1
	// Divide by 3
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_3 = 0x2
	// Divide by 4
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_4 = 0x3
	// Divide by 5
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_5 = 0x4
	// Divide by 6
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_6 = 0x5
	// Divide by 7
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_7 = 0x6
	// Divide by 8
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_8 = 0x7
	// Divide by 9
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_9 = 0x8
	// Divide by 10
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_10 = 0x9
	// Divide by 11
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_11 = 0xa
	// Divide by 12
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_12 = 0xb
	// Divide by 13
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_13 = 0xc
	// Divide by 14
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_14 = 0xd
	// Divide by 15
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_15 = 0xe
	// Divide by 16
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_16 = 0xf
	// Divide by 17
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_17 = 0x10
	// Divide by 18
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_18 = 0x11
	// Divide by 19
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_19 = 0x12
	// Divide by 20
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_20 = 0x13
	// Divide by 21
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_21 = 0x14
	// Divide by 22
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_22 = 0x15
	// Divide by 23
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_23 = 0x16
	// Divide by 24
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_24 = 0x17
	// Divide by 25
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_25 = 0x18
	// Divide by 26
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_26 = 0x19
	// Divide by 27
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_27 = 0x1a
	// Divide by 28
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_28 = 0x1b
	// Divide by 29
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_29 = 0x1c
	// Divide by 30
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_30 = 0x1d
	// Divide by 31
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_31 = 0x1e
	// Divide by 32
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_32 = 0x1f
	// Divide by 33
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_33 = 0x20
	// Divide by 34
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_34 = 0x21
	// Divide by 35
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_35 = 0x22
	// Divide by 36
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_36 = 0x23
	// Divide by 37
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_37 = 0x24
	// Divide by 38
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_38 = 0x25
	// Divide by 39
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_39 = 0x26
	// Divide by 40
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_40 = 0x27
	// Divide by 41
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_41 = 0x28
	// Divide by 42
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_42 = 0x29
	// Divide by 43
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_43 = 0x2a
	// Divide by 44
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_44 = 0x2b
	// Divide by 45
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_45 = 0x2c
	// Divide by 46
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_46 = 0x2d
	// Divide by 47
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_47 = 0x2e
	// Divide by 48
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_48 = 0x2f
	// Divide by 49
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_49 = 0x30
	// Divide by 50
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_50 = 0x31
	// Divide by 51
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_51 = 0x32
	// Divide by 52
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_52 = 0x33
	// Divide by 53
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_53 = 0x34
	// Divide by 54
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_54 = 0x35
	// Divide by 55
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_55 = 0x36
	// Divide by 56
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_56 = 0x37
	// Divide by 57
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_57 = 0x38
	// Divide by 58
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_58 = 0x39
	// Divide by 59
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_59 = 0x3a
	// Divide by 60
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_60 = 0x3b
	// Divide by 61
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_61 = 0x3c
	// Divide by 62
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_62 = 0x3d
	// Divide by 63
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_63 = 0x3e
	// Divide by 64
	CCM_CSCMR2_CAN_CLK_PODF_DIVIDE_64 = 0x3f
	// Position of CAN_CLK_SEL field.
	CCM_CSCMR2_CAN_CLK_SEL_Pos = 0x8
	// Bit mask of CAN_CLK_SEL field.
	CCM_CSCMR2_CAN_CLK_SEL_Msk = 0x300
	// derive clock from pll3_sw_clk divided clock (60M)
	CCM_CSCMR2_CAN_CLK_SEL_CAN_CLK_SEL_0 = 0x0
	// derive clock from osc_clk (24M)
	CCM_CSCMR2_CAN_CLK_SEL_CAN_CLK_SEL_1 = 0x1
	// derive clock from pll3_sw_clk divided clock (80M)
	CCM_CSCMR2_CAN_CLK_SEL_CAN_CLK_SEL_2 = 0x2
	// Disable FlexCAN clock
	CCM_CSCMR2_CAN_CLK_SEL_CAN_CLK_SEL_3 = 0x3
	// Position of FLEXIO2_CLK_SEL field.
	CCM_CSCMR2_FLEXIO2_CLK_SEL_Pos = 0x13
	// Bit mask of FLEXIO2_CLK_SEL field.
	CCM_CSCMR2_FLEXIO2_CLK_SEL_Msk = 0x180000
	// derive clock from PLL4 divided clock
	CCM_CSCMR2_FLEXIO2_CLK_SEL_FLEXIO2_CLK_SEL_0 = 0x0
	// derive clock from PLL3 PFD2 clock
	CCM_CSCMR2_FLEXIO2_CLK_SEL_FLEXIO2_CLK_SEL_1 = 0x1
	// derive clock from PLL5 clock
	CCM_CSCMR2_FLEXIO2_CLK_SEL_FLEXIO2_CLK_SEL_2 = 0x2
	// derive clock from pll3_sw_clk
	CCM_CSCMR2_FLEXIO2_CLK_SEL_FLEXIO2_CLK_SEL_3 = 0x3

	// CSCDR1: CCM Serial Clock Divider Register 1
	// Position of UART_CLK_PODF field.
	CCM_CSCDR1_UART_CLK_PODF_Pos = 0x0
	// Bit mask of UART_CLK_PODF field.
	CCM_CSCDR1_UART_CLK_PODF_Msk = 0x3f
	// Divide by 1
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_1 = 0x0
	// Divide by 2
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_2 = 0x1
	// Divide by 3
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_3 = 0x2
	// Divide by 4
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_4 = 0x3
	// Divide by 5
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_5 = 0x4
	// Divide by 6
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_6 = 0x5
	// Divide by 7
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_7 = 0x6
	// Divide by 8
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_8 = 0x7
	// Divide by 9
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_9 = 0x8
	// Divide by 10
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_10 = 0x9
	// Divide by 11
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_11 = 0xa
	// Divide by 12
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_12 = 0xb
	// Divide by 13
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_13 = 0xc
	// Divide by 14
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_14 = 0xd
	// Divide by 15
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_15 = 0xe
	// Divide by 16
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_16 = 0xf
	// Divide by 17
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_17 = 0x10
	// Divide by 18
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_18 = 0x11
	// Divide by 19
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_19 = 0x12
	// Divide by 20
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_20 = 0x13
	// Divide by 21
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_21 = 0x14
	// Divide by 22
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_22 = 0x15
	// Divide by 23
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_23 = 0x16
	// Divide by 24
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_24 = 0x17
	// Divide by 25
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_25 = 0x18
	// Divide by 26
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_26 = 0x19
	// Divide by 27
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_27 = 0x1a
	// Divide by 28
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_28 = 0x1b
	// Divide by 29
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_29 = 0x1c
	// Divide by 30
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_30 = 0x1d
	// Divide by 31
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_31 = 0x1e
	// Divide by 32
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_32 = 0x1f
	// Divide by 33
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_33 = 0x20
	// Divide by 34
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_34 = 0x21
	// Divide by 35
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_35 = 0x22
	// Divide by 36
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_36 = 0x23
	// Divide by 37
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_37 = 0x24
	// Divide by 38
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_38 = 0x25
	// Divide by 39
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_39 = 0x26
	// Divide by 40
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_40 = 0x27
	// Divide by 41
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_41 = 0x28
	// Divide by 42
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_42 = 0x29
	// Divide by 43
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_43 = 0x2a
	// Divide by 44
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_44 = 0x2b
	// Divide by 45
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_45 = 0x2c
	// Divide by 46
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_46 = 0x2d
	// Divide by 47
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_47 = 0x2e
	// Divide by 48
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_48 = 0x2f
	// Divide by 49
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_49 = 0x30
	// Divide by 50
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_50 = 0x31
	// Divide by 51
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_51 = 0x32
	// Divide by 52
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_52 = 0x33
	// Divide by 53
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_53 = 0x34
	// Divide by 54
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_54 = 0x35
	// Divide by 55
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_55 = 0x36
	// Divide by 56
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_56 = 0x37
	// Divide by 57
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_57 = 0x38
	// Divide by 58
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_58 = 0x39
	// Divide by 59
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_59 = 0x3a
	// Divide by 60
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_60 = 0x3b
	// Divide by 61
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_61 = 0x3c
	// Divide by 62
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_62 = 0x3d
	// Divide by 63
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_63 = 0x3e
	// Divide by 64
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_64 = 0x3f
	// Position of UART_CLK_SEL field.
	CCM_CSCDR1_UART_CLK_SEL_Pos = 0x6
	// Bit mask of UART_CLK_SEL field.
	CCM_CSCDR1_UART_CLK_SEL_Msk = 0x40
	// Bit UART_CLK_SEL.
	CCM_CSCDR1_UART_CLK_SEL = 0x40
	// derive clock from pll3_80m
	CCM_CSCDR1_UART_CLK_SEL_UART_CLK_SEL_0 = 0x0
	// derive clock from osc_clk
	CCM_CSCDR1_UART_CLK_SEL_UART_CLK_SEL_1 = 0x1
	// Position of USDHC1_PODF field.
	CCM_CSCDR1_USDHC1_PODF_Pos = 0xb
	// Bit mask of USDHC1_PODF field.
	CCM_CSCDR1_USDHC1_PODF_Msk = 0x3800
	// divide by 1
	CCM_CSCDR1_USDHC1_PODF_USDHC1_PODF_0 = 0x0
	// divide by 2
	CCM_CSCDR1_USDHC1_PODF_USDHC1_PODF_1 = 0x1
	// divide by 3
	CCM_CSCDR1_USDHC1_PODF_USDHC1_PODF_2 = 0x2
	// divide by 4
	CCM_CSCDR1_USDHC1_PODF_USDHC1_PODF_3 = 0x3
	// divide by 5
	CCM_CSCDR1_USDHC1_PODF_USDHC1_PODF_4 = 0x4
	// divide by 6
	CCM_CSCDR1_USDHC1_PODF_USDHC1_PODF_5 = 0x5
	// divide by 7
	CCM_CSCDR1_USDHC1_PODF_USDHC1_PODF_6 = 0x6
	// divide by 8
	CCM_CSCDR1_USDHC1_PODF_USDHC1_PODF_7 = 0x7
	// Position of USDHC2_PODF field.
	CCM_CSCDR1_USDHC2_PODF_Pos = 0x10
	// Bit mask of USDHC2_PODF field.
	CCM_CSCDR1_USDHC2_PODF_Msk = 0x70000
	// divide by 1
	CCM_CSCDR1_USDHC2_PODF_USDHC2_PODF_0 = 0x0
	// divide by 2
	CCM_CSCDR1_USDHC2_PODF_USDHC2_PODF_1 = 0x1
	// divide by 3
	CCM_CSCDR1_USDHC2_PODF_USDHC2_PODF_2 = 0x2
	// divide by 4
	CCM_CSCDR1_USDHC2_PODF_USDHC2_PODF_3 = 0x3
	// divide by 5
	CCM_CSCDR1_USDHC2_PODF_USDHC2_PODF_4 = 0x4
	// divide by 6
	CCM_CSCDR1_USDHC2_PODF_USDHC2_PODF_5 = 0x5
	// divide by 7
	CCM_CSCDR1_USDHC2_PODF_USDHC2_PODF_6 = 0x6
	// divide by 8
	CCM_CSCDR1_USDHC2_PODF_USDHC2_PODF_7 = 0x7
	// Position of TRACE_PODF field.
	CCM_CSCDR1_TRACE_PODF_Pos = 0x19
	// Bit mask of TRACE_PODF field.
	CCM_CSCDR1_TRACE_PODF_Msk = 0x6000000
	// divide by 1
	CCM_CSCDR1_TRACE_PODF_TRACE_PODF_0 = 0x0
	// divide by 2
	CCM_CSCDR1_TRACE_PODF_TRACE_PODF_1 = 0x1
	// divide by 3
	CCM_CSCDR1_TRACE_PODF_TRACE_PODF_2 = 0x2
	// divide by 4
	CCM_CSCDR1_TRACE_PODF_TRACE_PODF_3 = 0x3

	// CS1CDR: CCM Clock Divider Register
	// Position of SAI1_CLK_PODF field.
	CCM_CS1CDR_SAI1_CLK_PODF_Pos = 0x0
	// Bit mask of SAI1_CLK_PODF field.
	CCM_CS1CDR_SAI1_CLK_PODF_Msk = 0x3f
	// Divide by 1
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_1 = 0x0
	// Divide by 2
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_2 = 0x1
	// Divide by 3
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_3 = 0x2
	// Divide by 4
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_4 = 0x3
	// Divide by 5
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_5 = 0x4
	// Divide by 6
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_6 = 0x5
	// Divide by 7
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_7 = 0x6
	// Divide by 8
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_8 = 0x7
	// Divide by 9
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_9 = 0x8
	// Divide by 10
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_10 = 0x9
	// Divide by 11
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_11 = 0xa
	// Divide by 12
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_12 = 0xb
	// Divide by 13
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_13 = 0xc
	// Divide by 14
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_14 = 0xd
	// Divide by 15
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_15 = 0xe
	// Divide by 16
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_16 = 0xf
	// Divide by 17
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_17 = 0x10
	// Divide by 18
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_18 = 0x11
	// Divide by 19
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_19 = 0x12
	// Divide by 20
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_20 = 0x13
	// Divide by 21
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_21 = 0x14
	// Divide by 22
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_22 = 0x15
	// Divide by 23
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_23 = 0x16
	// Divide by 24
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_24 = 0x17
	// Divide by 25
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_25 = 0x18
	// Divide by 26
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_26 = 0x19
	// Divide by 27
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_27 = 0x1a
	// Divide by 28
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_28 = 0x1b
	// Divide by 29
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_29 = 0x1c
	// Divide by 30
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_30 = 0x1d
	// Divide by 31
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_31 = 0x1e
	// Divide by 32
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_32 = 0x1f
	// Divide by 33
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_33 = 0x20
	// Divide by 34
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_34 = 0x21
	// Divide by 35
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_35 = 0x22
	// Divide by 36
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_36 = 0x23
	// Divide by 37
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_37 = 0x24
	// Divide by 38
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_38 = 0x25
	// Divide by 39
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_39 = 0x26
	// Divide by 40
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_40 = 0x27
	// Divide by 41
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_41 = 0x28
	// Divide by 42
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_42 = 0x29
	// Divide by 43
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_43 = 0x2a
	// Divide by 44
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_44 = 0x2b
	// Divide by 45
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_45 = 0x2c
	// Divide by 46
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_46 = 0x2d
	// Divide by 47
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_47 = 0x2e
	// Divide by 48
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_48 = 0x2f
	// Divide by 49
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_49 = 0x30
	// Divide by 50
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_50 = 0x31
	// Divide by 51
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_51 = 0x32
	// Divide by 52
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_52 = 0x33
	// Divide by 53
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_53 = 0x34
	// Divide by 54
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_54 = 0x35
	// Divide by 55
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_55 = 0x36
	// Divide by 56
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_56 = 0x37
	// Divide by 57
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_57 = 0x38
	// Divide by 58
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_58 = 0x39
	// Divide by 59
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_59 = 0x3a
	// Divide by 60
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_60 = 0x3b
	// Divide by 61
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_61 = 0x3c
	// Divide by 62
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_62 = 0x3d
	// Divide by 63
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_63 = 0x3e
	// Divide by 64
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_64 = 0x3f
	// Position of SAI1_CLK_PRED field.
	CCM_CS1CDR_SAI1_CLK_PRED_Pos = 0x6
	// Bit mask of SAI1_CLK_PRED field.
	CCM_CS1CDR_SAI1_CLK_PRED_Msk = 0x1c0
	// divide by 1
	CCM_CS1CDR_SAI1_CLK_PRED_SAI1_CLK_PRED_0 = 0x0
	// divide by 2
	CCM_CS1CDR_SAI1_CLK_PRED_SAI1_CLK_PRED_1 = 0x1
	// divide by 3
	CCM_CS1CDR_SAI1_CLK_PRED_SAI1_CLK_PRED_2 = 0x2
	// divide by 4
	CCM_CS1CDR_SAI1_CLK_PRED_SAI1_CLK_PRED_3 = 0x3
	// divide by 5
	CCM_CS1CDR_SAI1_CLK_PRED_SAI1_CLK_PRED_4 = 0x4
	// divide by 6
	CCM_CS1CDR_SAI1_CLK_PRED_SAI1_CLK_PRED_5 = 0x5
	// divide by 7
	CCM_CS1CDR_SAI1_CLK_PRED_SAI1_CLK_PRED_6 = 0x6
	// divide by 8
	CCM_CS1CDR_SAI1_CLK_PRED_SAI1_CLK_PRED_7 = 0x7
	// Position of FLEXIO2_CLK_PRED field.
	CCM_CS1CDR_FLEXIO2_CLK_PRED_Pos = 0x9
	// Bit mask of FLEXIO2_CLK_PRED field.
	CCM_CS1CDR_FLEXIO2_CLK_PRED_Msk = 0xe00
	// divide by 1
	CCM_CS1CDR_FLEXIO2_CLK_PRED_FLEXIO2_CLK_PRED_0 = 0x0
	// divide by 2
	CCM_CS1CDR_FLEXIO2_CLK_PRED_FLEXIO2_CLK_PRED_1 = 0x1
	// divide by 3
	CCM_CS1CDR_FLEXIO2_CLK_PRED_FLEXIO2_CLK_PRED_2 = 0x2
	// divide by 4
	CCM_CS1CDR_FLEXIO2_CLK_PRED_FLEXIO2_CLK_PRED_3 = 0x3
	// divide by 5
	CCM_CS1CDR_FLEXIO2_CLK_PRED_FLEXIO2_CLK_PRED_4 = 0x4
	// divide by 6
	CCM_CS1CDR_FLEXIO2_CLK_PRED_FLEXIO2_CLK_PRED_5 = 0x5
	// divide by 7
	CCM_CS1CDR_FLEXIO2_CLK_PRED_FLEXIO2_CLK_PRED_6 = 0x6
	// divide by 8
	CCM_CS1CDR_FLEXIO2_CLK_PRED_FLEXIO2_CLK_PRED_7 = 0x7
	// Position of SAI3_CLK_PODF field.
	CCM_CS1CDR_SAI3_CLK_PODF_Pos = 0x10
	// Bit mask of SAI3_CLK_PODF field.
	CCM_CS1CDR_SAI3_CLK_PODF_Msk = 0x3f0000
	// Divide by 1
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_1 = 0x0
	// Divide by 2
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_2 = 0x1
	// Divide by 3
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_3 = 0x2
	// Divide by 4
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_4 = 0x3
	// Divide by 5
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_5 = 0x4
	// Divide by 6
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_6 = 0x5
	// Divide by 7
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_7 = 0x6
	// Divide by 8
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_8 = 0x7
	// Divide by 9
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_9 = 0x8
	// Divide by 10
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_10 = 0x9
	// Divide by 11
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_11 = 0xa
	// Divide by 12
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_12 = 0xb
	// Divide by 13
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_13 = 0xc
	// Divide by 14
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_14 = 0xd
	// Divide by 15
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_15 = 0xe
	// Divide by 16
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_16 = 0xf
	// Divide by 17
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_17 = 0x10
	// Divide by 18
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_18 = 0x11
	// Divide by 19
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_19 = 0x12
	// Divide by 20
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_20 = 0x13
	// Divide by 21
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_21 = 0x14
	// Divide by 22
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_22 = 0x15
	// Divide by 23
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_23 = 0x16
	// Divide by 24
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_24 = 0x17
	// Divide by 25
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_25 = 0x18
	// Divide by 26
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_26 = 0x19
	// Divide by 27
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_27 = 0x1a
	// Divide by 28
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_28 = 0x1b
	// Divide by 29
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_29 = 0x1c
	// Divide by 30
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_30 = 0x1d
	// Divide by 31
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_31 = 0x1e
	// Divide by 32
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_32 = 0x1f
	// Divide by 33
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_33 = 0x20
	// Divide by 34
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_34 = 0x21
	// Divide by 35
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_35 = 0x22
	// Divide by 36
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_36 = 0x23
	// Divide by 37
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_37 = 0x24
	// Divide by 38
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_38 = 0x25
	// Divide by 39
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_39 = 0x26
	// Divide by 40
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_40 = 0x27
	// Divide by 41
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_41 = 0x28
	// Divide by 42
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_42 = 0x29
	// Divide by 43
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_43 = 0x2a
	// Divide by 44
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_44 = 0x2b
	// Divide by 45
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_45 = 0x2c
	// Divide by 46
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_46 = 0x2d
	// Divide by 47
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_47 = 0x2e
	// Divide by 48
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_48 = 0x2f
	// Divide by 49
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_49 = 0x30
	// Divide by 50
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_50 = 0x31
	// Divide by 51
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_51 = 0x32
	// Divide by 52
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_52 = 0x33
	// Divide by 53
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_53 = 0x34
	// Divide by 54
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_54 = 0x35
	// Divide by 55
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_55 = 0x36
	// Divide by 56
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_56 = 0x37
	// Divide by 57
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_57 = 0x38
	// Divide by 58
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_58 = 0x39
	// Divide by 59
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_59 = 0x3a
	// Divide by 60
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_60 = 0x3b
	// Divide by 61
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_61 = 0x3c
	// Divide by 62
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_62 = 0x3d
	// Divide by 63
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_63 = 0x3e
	// Divide by 64
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_64 = 0x3f
	// Position of SAI3_CLK_PRED field.
	CCM_CS1CDR_SAI3_CLK_PRED_Pos = 0x16
	// Bit mask of SAI3_CLK_PRED field.
	CCM_CS1CDR_SAI3_CLK_PRED_Msk = 0x1c00000
	// divide by 1
	CCM_CS1CDR_SAI3_CLK_PRED_SAI3_CLK_PRED_0 = 0x0
	// divide by 2
	CCM_CS1CDR_SAI3_CLK_PRED_SAI3_CLK_PRED_1 = 0x1
	// divide by 3
	CCM_CS1CDR_SAI3_CLK_PRED_SAI3_CLK_PRED_2 = 0x2
	// divide by 4
	CCM_CS1CDR_SAI3_CLK_PRED_SAI3_CLK_PRED_3 = 0x3
	// divide by 5
	CCM_CS1CDR_SAI3_CLK_PRED_SAI3_CLK_PRED_4 = 0x4
	// divide by 6
	CCM_CS1CDR_SAI3_CLK_PRED_SAI3_CLK_PRED_5 = 0x5
	// divide by 7
	CCM_CS1CDR_SAI3_CLK_PRED_SAI3_CLK_PRED_6 = 0x6
	// divide by 8
	CCM_CS1CDR_SAI3_CLK_PRED_SAI3_CLK_PRED_7 = 0x7
	// Position of FLEXIO2_CLK_PODF field.
	CCM_CS1CDR_FLEXIO2_CLK_PODF_Pos = 0x19
	// Bit mask of FLEXIO2_CLK_PODF field.
	CCM_CS1CDR_FLEXIO2_CLK_PODF_Msk = 0xe000000
	// Divide by 1
	CCM_CS1CDR_FLEXIO2_CLK_PODF_DIVIDE_1 = 0x0
	// Divide by 2
	CCM_CS1CDR_FLEXIO2_CLK_PODF_DIVIDE_2 = 0x1
	// Divide by 3
	CCM_CS1CDR_FLEXIO2_CLK_PODF_DIVIDE_3 = 0x2
	// Divide by 4
	CCM_CS1CDR_FLEXIO2_CLK_PODF_DIVIDE_4 = 0x3
	// Divide by 5
	CCM_CS1CDR_FLEXIO2_CLK_PODF_DIVIDE_5 = 0x4
	// Divide by 6
	CCM_CS1CDR_FLEXIO2_CLK_PODF_DIVIDE_6 = 0x5
	// Divide by 7
	CCM_CS1CDR_FLEXIO2_CLK_PODF_DIVIDE_7 = 0x6
	// Divide by 8
	CCM_CS1CDR_FLEXIO2_CLK_PODF_DIVIDE_8 = 0x7

	// CS2CDR: CCM Clock Divider Register
	// Position of SAI2_CLK_PODF field.
	CCM_CS2CDR_SAI2_CLK_PODF_Pos = 0x0
	// Bit mask of SAI2_CLK_PODF field.
	CCM_CS2CDR_SAI2_CLK_PODF_Msk = 0x3f
	// Divide by 1
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_1 = 0x0
	// Divide by 2
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_2 = 0x1
	// Divide by 3
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_3 = 0x2
	// Divide by 4
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_4 = 0x3
	// Divide by 5
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_5 = 0x4
	// Divide by 6
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_6 = 0x5
	// Divide by 7
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_7 = 0x6
	// Divide by 8
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_8 = 0x7
	// Divide by 9
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_9 = 0x8
	// Divide by 10
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_10 = 0x9
	// Divide by 11
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_11 = 0xa
	// Divide by 12
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_12 = 0xb
	// Divide by 13
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_13 = 0xc
	// Divide by 14
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_14 = 0xd
	// Divide by 15
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_15 = 0xe
	// Divide by 16
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_16 = 0xf
	// Divide by 17
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_17 = 0x10
	// Divide by 18
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_18 = 0x11
	// Divide by 19
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_19 = 0x12
	// Divide by 20
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_20 = 0x13
	// Divide by 21
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_21 = 0x14
	// Divide by 22
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_22 = 0x15
	// Divide by 23
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_23 = 0x16
	// Divide by 24
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_24 = 0x17
	// Divide by 25
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_25 = 0x18
	// Divide by 26
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_26 = 0x19
	// Divide by 27
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_27 = 0x1a
	// Divide by 28
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_28 = 0x1b
	// Divide by 29
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_29 = 0x1c
	// Divide by 30
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_30 = 0x1d
	// Divide by 31
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_31 = 0x1e
	// Divide by 32
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_32 = 0x1f
	// Divide by 33
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_33 = 0x20
	// Divide by 34
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_34 = 0x21
	// Divide by 35
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_35 = 0x22
	// Divide by 36
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_36 = 0x23
	// Divide by 37
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_37 = 0x24
	// Divide by 38
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_38 = 0x25
	// Divide by 39
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_39 = 0x26
	// Divide by 40
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_40 = 0x27
	// Divide by 41
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_41 = 0x28
	// Divide by 42
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_42 = 0x29
	// Divide by 43
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_43 = 0x2a
	// Divide by 44
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_44 = 0x2b
	// Divide by 45
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_45 = 0x2c
	// Divide by 46
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_46 = 0x2d
	// Divide by 47
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_47 = 0x2e
	// Divide by 48
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_48 = 0x2f
	// Divide by 49
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_49 = 0x30
	// Divide by 50
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_50 = 0x31
	// Divide by 51
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_51 = 0x32
	// Divide by 52
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_52 = 0x33
	// Divide by 53
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_53 = 0x34
	// Divide by 54
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_54 = 0x35
	// Divide by 55
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_55 = 0x36
	// Divide by 56
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_56 = 0x37
	// Divide by 57
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_57 = 0x38
	// Divide by 58
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_58 = 0x39
	// Divide by 59
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_59 = 0x3a
	// Divide by 60
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_60 = 0x3b
	// Divide by 61
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_61 = 0x3c
	// Divide by 62
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_62 = 0x3d
	// Divide by 63
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_63 = 0x3e
	// Divide by 64
	CCM_CS2CDR_SAI2_CLK_PODF_DIVIDE_64 = 0x3f
	// Position of SAI2_CLK_PRED field.
	CCM_CS2CDR_SAI2_CLK_PRED_Pos = 0x6
	// Bit mask of SAI2_CLK_PRED field.
	CCM_CS2CDR_SAI2_CLK_PRED_Msk = 0x1c0
	// divide by 1
	CCM_CS2CDR_SAI2_CLK_PRED_SAI2_CLK_PRED_0 = 0x0
	// divide by 2
	CCM_CS2CDR_SAI2_CLK_PRED_SAI2_CLK_PRED_1 = 0x1
	// divide by 3
	CCM_CS2CDR_SAI2_CLK_PRED_SAI2_CLK_PRED_2 = 0x2
	// divide by 4
	CCM_CS2CDR_SAI2_CLK_PRED_SAI2_CLK_PRED_3 = 0x3
	// divide by 5
	CCM_CS2CDR_SAI2_CLK_PRED_SAI2_CLK_PRED_4 = 0x4
	// divide by 6
	CCM_CS2CDR_SAI2_CLK_PRED_SAI2_CLK_PRED_5 = 0x5
	// divide by 7
	CCM_CS2CDR_SAI2_CLK_PRED_SAI2_CLK_PRED_6 = 0x6
	// divide by 8
	CCM_CS2CDR_SAI2_CLK_PRED_SAI2_CLK_PRED_7 = 0x7

	// CDCDR: CCM D1 Clock Divider Register
	// Position of FLEXIO1_CLK_SEL field.
	CCM_CDCDR_FLEXIO1_CLK_SEL_Pos = 0x7
	// Bit mask of FLEXIO1_CLK_SEL field.
	CCM_CDCDR_FLEXIO1_CLK_SEL_Msk = 0x180
	// derive clock from PLL4
	CCM_CDCDR_FLEXIO1_CLK_SEL_FLEXIO1_CLK_SEL_0 = 0x0
	// derive clock from PLL3 PFD2
	CCM_CDCDR_FLEXIO1_CLK_SEL_FLEXIO1_CLK_SEL_1 = 0x1
	// derive clock from PLL5
	CCM_CDCDR_FLEXIO1_CLK_SEL_FLEXIO1_CLK_SEL_2 = 0x2
	// derive clock from pll3_sw_clk
	CCM_CDCDR_FLEXIO1_CLK_SEL_FLEXIO1_CLK_SEL_3 = 0x3
	// Position of FLEXIO1_CLK_PODF field.
	CCM_CDCDR_FLEXIO1_CLK_PODF_Pos = 0x9
	// Bit mask of FLEXIO1_CLK_PODF field.
	CCM_CDCDR_FLEXIO1_CLK_PODF_Msk = 0xe00
	// Divide by 1
	CCM_CDCDR_FLEXIO1_CLK_PODF_DIVIDE_1 = 0x0
	// Divide by 2
	CCM_CDCDR_FLEXIO1_CLK_PODF_DIVIDE_2 = 0x1
	// Divide by 3
	CCM_CDCDR_FLEXIO1_CLK_PODF_DIVIDE_3 = 0x2
	// Divide by 4
	CCM_CDCDR_FLEXIO1_CLK_PODF_DIVIDE_4 = 0x3
	// Divide by 5
	CCM_CDCDR_FLEXIO1_CLK_PODF_DIVIDE_5 = 0x4
	// Divide by 6
	CCM_CDCDR_FLEXIO1_CLK_PODF_DIVIDE_6 = 0x5
	// Divide by 7
	CCM_CDCDR_FLEXIO1_CLK_PODF_DIVIDE_7 = 0x6
	// Divide by 8
	CCM_CDCDR_FLEXIO1_CLK_PODF_DIVIDE_8 = 0x7
	// Position of FLEXIO1_CLK_PRED field.
	CCM_CDCDR_FLEXIO1_CLK_PRED_Pos = 0xc
	// Bit mask of FLEXIO1_CLK_PRED field.
	CCM_CDCDR_FLEXIO1_CLK_PRED_Msk = 0x7000
	// Divide by 1
	CCM_CDCDR_FLEXIO1_CLK_PRED_DIVIDE_1 = 0x0
	// Divide by 2
	CCM_CDCDR_FLEXIO1_CLK_PRED_DIVIDE_2 = 0x1
	// Divide by 3
	CCM_CDCDR_FLEXIO1_CLK_PRED_DIVIDE_3 = 0x2
	// Divide by 4
	CCM_CDCDR_FLEXIO1_CLK_PRED_DIVIDE_4 = 0x3
	// Divide by 5
	CCM_CDCDR_FLEXIO1_CLK_PRED_DIVIDE_5 = 0x4
	// Divide by 6
	CCM_CDCDR_FLEXIO1_CLK_PRED_DIVIDE_6 = 0x5
	// Divide by 7
	CCM_CDCDR_FLEXIO1_CLK_PRED_DIVIDE_7 = 0x6
	// Divide by 8
	CCM_CDCDR_FLEXIO1_CLK_PRED_DIVIDE_8 = 0x7
	// Position of SPDIF0_CLK_SEL field.
	CCM_CDCDR_SPDIF0_CLK_SEL_Pos = 0x14
	// Bit mask of SPDIF0_CLK_SEL field.
	CCM_CDCDR_SPDIF0_CLK_SEL_Msk = 0x300000
	// derive clock from PLL4
	CCM_CDCDR_SPDIF0_CLK_SEL_SPDIF0_CLK_SEL_0 = 0x0
	// derive clock from PLL3 PFD2
	CCM_CDCDR_SPDIF0_CLK_SEL_SPDIF0_CLK_SEL_1 = 0x1
	// derive clock from PLL5
	CCM_CDCDR_SPDIF0_CLK_SEL_SPDIF0_CLK_SEL_2 = 0x2
	// derive clock from pll3_sw_clk
	CCM_CDCDR_SPDIF0_CLK_SEL_SPDIF0_CLK_SEL_3 = 0x3
	// Position of SPDIF0_CLK_PODF field.
	CCM_CDCDR_SPDIF0_CLK_PODF_Pos = 0x16
	// Bit mask of SPDIF0_CLK_PODF field.
	CCM_CDCDR_SPDIF0_CLK_PODF_Msk = 0x1c00000
	// Divide by 1
	CCM_CDCDR_SPDIF0_CLK_PODF_DIVIDE_1 = 0x0
	// Divide by 2
	CCM_CDCDR_SPDIF0_CLK_PODF_DIVIDE_2 = 0x1
	// Divide by 3
	CCM_CDCDR_SPDIF0_CLK_PODF_DIVIDE_3 = 0x2
	// Divide by 4
	CCM_CDCDR_SPDIF0_CLK_PODF_DIVIDE_4 = 0x3
	// Divide by 5
	CCM_CDCDR_SPDIF0_CLK_PODF_DIVIDE_5 = 0x4
	// Divide by 6
	CCM_CDCDR_SPDIF0_CLK_PODF_DIVIDE_6 = 0x5
	// Divide by 7
	CCM_CDCDR_SPDIF0_CLK_PODF_DIVIDE_7 = 0x6
	// Divide by 8
	CCM_CDCDR_SPDIF0_CLK_PODF_DIVIDE_8 = 0x7
	// Position of SPDIF0_CLK_PRED field.
	CCM_CDCDR_SPDIF0_CLK_PRED_Pos = 0x19
	// Bit mask of SPDIF0_CLK_PRED field.
	CCM_CDCDR_SPDIF0_CLK_PRED_Msk = 0xe000000
	// Divide by 1
	CCM_CDCDR_SPDIF0_CLK_PRED_DIVIDE_1 = 0x0
	// Divide by 2
	CCM_CDCDR_SPDIF0_CLK_PRED_DIVIDE_2 = 0x1
	// Divide by 3
	CCM_CDCDR_SPDIF0_CLK_PRED_DIVIDE_3 = 0x2
	// Divide by 4
	CCM_CDCDR_SPDIF0_CLK_PRED_DIVIDE_4 = 0x3
	// Divide by 5
	CCM_CDCDR_SPDIF0_CLK_PRED_DIVIDE_5 = 0x4
	// Divide by 6
	CCM_CDCDR_SPDIF0_CLK_PRED_DIVIDE_6 = 0x5
	// Divide by 7
	CCM_CDCDR_SPDIF0_CLK_PRED_DIVIDE_7 = 0x6
	// Divide by 8
	CCM_CDCDR_SPDIF0_CLK_PRED_DIVIDE_8 = 0x7

	// CSCDR2: CCM Serial Clock Divider Register 2
	// Position of LCDIF_PRED field.
	CCM_CSCDR2_LCDIF_PRED_Pos = 0xc
	// Bit mask of LCDIF_PRED field.
	CCM_CSCDR2_LCDIF_PRED_Msk = 0x7000
	// divide by 1
	CCM_CSCDR2_LCDIF_PRED_LCDIF_PRED_0 = 0x0
	// divide by 2
	CCM_CSCDR2_LCDIF_PRED_LCDIF_PRED_1 = 0x1
	// divide by 3
	CCM_CSCDR2_LCDIF_PRED_LCDIF_PRED_2 = 0x2
	// divide by 4
	CCM_CSCDR2_LCDIF_PRED_LCDIF_PRED_3 = 0x3
	// divide by 5
	CCM_CSCDR2_LCDIF_PRED_LCDIF_PRED_4 = 0x4
	// divide by 6
	CCM_CSCDR2_LCDIF_PRED_LCDIF_PRED_5 = 0x5
	// divide by 7
	CCM_CSCDR2_LCDIF_PRED_LCDIF_PRED_6 = 0x6
	// divide by 8
	CCM_CSCDR2_LCDIF_PRED_LCDIF_PRED_7 = 0x7
	// Position of LCDIF_PRE_CLK_SEL field.
	CCM_CSCDR2_LCDIF_PRE_CLK_SEL_Pos = 0xf
	// Bit mask of LCDIF_PRE_CLK_SEL field.
	CCM_CSCDR2_LCDIF_PRE_CLK_SEL_Msk = 0x38000
	// derive clock from PLL2
	CCM_CSCDR2_LCDIF_PRE_CLK_SEL_LCDIF_PRE_CLK_SEL_0 = 0x0
	// derive clock from PLL3 PFD3
	CCM_CSCDR2_LCDIF_PRE_CLK_SEL_LCDIF_PRE_CLK_SEL_1 = 0x1
	// derive clock from PLL5
	CCM_CSCDR2_LCDIF_PRE_CLK_SEL_LCDIF_PRE_CLK_SEL_2 = 0x2
	// derive clock from PLL2 PFD0
	CCM_CSCDR2_LCDIF_PRE_CLK_SEL_LCDIF_PRE_CLK_SEL_3 = 0x3
	// derive clock from PLL2 PFD1
	CCM_CSCDR2_LCDIF_PRE_CLK_SEL_LCDIF_PRE_CLK_SEL_4 = 0x4
	// derive clock from PLL3 PFD1
	CCM_CSCDR2_LCDIF_PRE_CLK_SEL_LCDIF_PRE_CLK_SEL_5 = 0x5
	// Position of LPI2C_CLK_SEL field.
	CCM_CSCDR2_LPI2C_CLK_SEL_Pos = 0x12
	// Bit mask of LPI2C_CLK_SEL field.
	CCM_CSCDR2_LPI2C_CLK_SEL_Msk = 0x40000
	// Bit LPI2C_CLK_SEL.
	CCM_CSCDR2_LPI2C_CLK_SEL = 0x40000
	// derive clock from pll3_60m
	CCM_CSCDR2_LPI2C_CLK_SEL_LPI2C_CLK_SEL_0 = 0x0
	// derive clock from osc_clk
	CCM_CSCDR2_LPI2C_CLK_SEL_LPI2C_CLK_SEL_1 = 0x1
	// Position of LPI2C_CLK_PODF field.
	CCM_CSCDR2_LPI2C_CLK_PODF_Pos = 0x13
	// Bit mask of LPI2C_CLK_PODF field.
	CCM_CSCDR2_LPI2C_CLK_PODF_Msk = 0x1f80000
	// Divide by 1
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_1 = 0x0
	// Divide by 2
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_2 = 0x1
	// Divide by 3
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_3 = 0x2
	// Divide by 4
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_4 = 0x3
	// Divide by 5
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_5 = 0x4
	// Divide by 6
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_6 = 0x5
	// Divide by 7
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_7 = 0x6
	// Divide by 8
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_8 = 0x7
	// Divide by 9
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_9 = 0x8
	// Divide by 10
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_10 = 0x9
	// Divide by 11
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_11 = 0xa
	// Divide by 12
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_12 = 0xb
	// Divide by 13
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_13 = 0xc
	// Divide by 14
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_14 = 0xd
	// Divide by 15
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_15 = 0xe
	// Divide by 16
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_16 = 0xf
	// Divide by 17
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_17 = 0x10
	// Divide by 18
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_18 = 0x11
	// Divide by 19
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_19 = 0x12
	// Divide by 20
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_20 = 0x13
	// Divide by 21
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_21 = 0x14
	// Divide by 22
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_22 = 0x15
	// Divide by 23
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_23 = 0x16
	// Divide by 24
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_24 = 0x17
	// Divide by 25
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_25 = 0x18
	// Divide by 26
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_26 = 0x19
	// Divide by 27
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_27 = 0x1a
	// Divide by 28
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_28 = 0x1b
	// Divide by 29
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_29 = 0x1c
	// Divide by 30
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_30 = 0x1d
	// Divide by 31
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_31 = 0x1e
	// Divide by 32
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_32 = 0x1f
	// Divide by 33
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_33 = 0x20
	// Divide by 34
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_34 = 0x21
	// Divide by 35
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_35 = 0x22
	// Divide by 36
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_36 = 0x23
	// Divide by 37
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_37 = 0x24
	// Divide by 38
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_38 = 0x25
	// Divide by 39
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_39 = 0x26
	// Divide by 40
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_40 = 0x27
	// Divide by 41
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_41 = 0x28
	// Divide by 42
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_42 = 0x29
	// Divide by 43
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_43 = 0x2a
	// Divide by 44
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_44 = 0x2b
	// Divide by 45
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_45 = 0x2c
	// Divide by 46
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_46 = 0x2d
	// Divide by 47
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_47 = 0x2e
	// Divide by 48
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_48 = 0x2f
	// Divide by 49
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_49 = 0x30
	// Divide by 50
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_50 = 0x31
	// Divide by 51
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_51 = 0x32
	// Divide by 52
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_52 = 0x33
	// Divide by 53
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_53 = 0x34
	// Divide by 54
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_54 = 0x35
	// Divide by 55
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_55 = 0x36
	// Divide by 56
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_56 = 0x37
	// Divide by 57
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_57 = 0x38
	// Divide by 58
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_58 = 0x39
	// Divide by 59
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_59 = 0x3a
	// Divide by 60
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_60 = 0x3b
	// Divide by 61
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_61 = 0x3c
	// Divide by 62
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_62 = 0x3d
	// Divide by 63
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_63 = 0x3e
	// Divide by 64
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_64 = 0x3f

	// CSCDR3: CCM Serial Clock Divider Register 3
	// Position of CSI_CLK_SEL field.
	CCM_CSCDR3_CSI_CLK_SEL_Pos = 0x9
	// Bit mask of CSI_CLK_SEL field.
	CCM_CSCDR3_CSI_CLK_SEL_Msk = 0x600
	// derive clock from osc_clk (24M)
	CCM_CSCDR3_CSI_CLK_SEL_CSI_CLK_SEL_0 = 0x0
	// derive clock from PLL2 PFD2
	CCM_CSCDR3_CSI_CLK_SEL_CSI_CLK_SEL_1 = 0x1
	// derive clock from pll3_120M
	CCM_CSCDR3_CSI_CLK_SEL_CSI_CLK_SEL_2 = 0x2
	// derive clock from PLL3 PFD1
	CCM_CSCDR3_CSI_CLK_SEL_CSI_CLK_SEL_3 = 0x3
	// Position of CSI_PODF field.
	CCM_CSCDR3_CSI_PODF_Pos = 0xb
	// Bit mask of CSI_PODF field.
	CCM_CSCDR3_CSI_PODF_Msk = 0x3800
	// divide by 1
	CCM_CSCDR3_CSI_PODF_CSI_PODF_0 = 0x0
	// divide by 2
	CCM_CSCDR3_CSI_PODF_CSI_PODF_1 = 0x1
	// divide by 3
	CCM_CSCDR3_CSI_PODF_CSI_PODF_2 = 0x2
	// divide by 4
	CCM_CSCDR3_CSI_PODF_CSI_PODF_3 = 0x3
	// divide by 5
	CCM_CSCDR3_CSI_PODF_CSI_PODF_4 = 0x4
	// divide by 6
	CCM_CSCDR3_CSI_PODF_CSI_PODF_5 = 0x5
	// divide by 7
	CCM_CSCDR3_CSI_PODF_CSI_PODF_6 = 0x6
	// divide by 8
	CCM_CSCDR3_CSI_PODF_CSI_PODF_7 = 0x7

	// CDHIPR: CCM Divider Handshake In-Process Register
	// Position of SEMC_PODF_BUSY field.
	CCM_CDHIPR_SEMC_PODF_BUSY_Pos = 0x0
	// Bit mask of SEMC_PODF_BUSY field.
	CCM_CDHIPR_SEMC_PODF_BUSY_Msk = 0x1
	// Bit SEMC_PODF_BUSY.
	CCM_CDHIPR_SEMC_PODF_BUSY = 0x1
	// divider is not busy and its value represents the actual division.
	CCM_CDHIPR_SEMC_PODF_BUSY_SEMC_PODF_BUSY_0 = 0x0
	// divider is busy with handshake process with module. The value read in the divider represents the previous value of the division factor, and after the handshake the written value of the semc_podf will be applied.
	CCM_CDHIPR_SEMC_PODF_BUSY_SEMC_PODF_BUSY_1 = 0x1
	// Position of AHB_PODF_BUSY field.
	CCM_CDHIPR_AHB_PODF_BUSY_Pos = 0x1
	// Bit mask of AHB_PODF_BUSY field.
	CCM_CDHIPR_AHB_PODF_BUSY_Msk = 0x2
	// Bit AHB_PODF_BUSY.
	CCM_CDHIPR_AHB_PODF_BUSY = 0x2
	// divider is not busy and its value represents the actual division.
	CCM_CDHIPR_AHB_PODF_BUSY_AHB_PODF_BUSY_0 = 0x0
	// divider is busy with handshake process with module. The value read in the divider represents the previous value of the division factor, and after the handshake the written value of the ahb_podf will be applied.
	CCM_CDHIPR_AHB_PODF_BUSY_AHB_PODF_BUSY_1 = 0x1
	// Position of PERIPH2_CLK_SEL_BUSY field.
	CCM_CDHIPR_PERIPH2_CLK_SEL_BUSY_Pos = 0x3
	// Bit mask of PERIPH2_CLK_SEL_BUSY field.
	CCM_CDHIPR_PERIPH2_CLK_SEL_BUSY_Msk = 0x8
	// Bit PERIPH2_CLK_SEL_BUSY.
	CCM_CDHIPR_PERIPH2_CLK_SEL_BUSY = 0x8
	// mux is not busy and its value represents the actual division.
	CCM_CDHIPR_PERIPH2_CLK_SEL_BUSY_PERIPH2_CLK_SEL_BUSY_0 = 0x0
	// mux is busy with handshake process with module. The value read in the periph2_clk_sel represents the previous value of select, and after the handshake periph2_clk_sel value will be applied.
	CCM_CDHIPR_PERIPH2_CLK_SEL_BUSY_PERIPH2_CLK_SEL_BUSY_1 = 0x1
	// Position of PERIPH_CLK_SEL_BUSY field.
	CCM_CDHIPR_PERIPH_CLK_SEL_BUSY_Pos = 0x5
	// Bit mask of PERIPH_CLK_SEL_BUSY field.
	CCM_CDHIPR_PERIPH_CLK_SEL_BUSY_Msk = 0x20
	// Bit PERIPH_CLK_SEL_BUSY.
	CCM_CDHIPR_PERIPH_CLK_SEL_BUSY = 0x20
	// mux is not busy and its value represents the actual division.
	CCM_CDHIPR_PERIPH_CLK_SEL_BUSY_PERIPH_CLK_SEL_BUSY_0 = 0x0
	// mux is busy with handshake process with module. The value read in the periph_clk_sel represents the previous value of select, and after the handshake periph_clk_sel value will be applied.
	CCM_CDHIPR_PERIPH_CLK_SEL_BUSY_PERIPH_CLK_SEL_BUSY_1 = 0x1
	// Position of ARM_PODF_BUSY field.
	CCM_CDHIPR_ARM_PODF_BUSY_Pos = 0x10
	// Bit mask of ARM_PODF_BUSY field.
	CCM_CDHIPR_ARM_PODF_BUSY_Msk = 0x10000
	// Bit ARM_PODF_BUSY.
	CCM_CDHIPR_ARM_PODF_BUSY = 0x10000
	// divider is not busy and its value represents the actual division.
	CCM_CDHIPR_ARM_PODF_BUSY_ARM_PODF_BUSY_0 = 0x0
	// divider is busy with handshake process with module. The value read in the divider represents the previous value of the division factor, and after the handshake the written value of the arm_podf will be applied.
	CCM_CDHIPR_ARM_PODF_BUSY_ARM_PODF_BUSY_1 = 0x1

	// CLPCR: CCM Low Power Control Register
	// Position of LPM field.
	CCM_CLPCR_LPM_Pos = 0x0
	// Bit mask of LPM field.
	CCM_CLPCR_LPM_Msk = 0x3
	// Remain in run mode
	CCM_CLPCR_LPM_LPM_0 = 0x0
	// Transfer to wait mode
	CCM_CLPCR_LPM_LPM_1 = 0x1
	// Transfer to stop mode
	CCM_CLPCR_LPM_LPM_2 = 0x2
	// Position of ARM_CLK_DIS_ON_LPM field.
	CCM_CLPCR_ARM_CLK_DIS_ON_LPM_Pos = 0x5
	// Bit mask of ARM_CLK_DIS_ON_LPM field.
	CCM_CLPCR_ARM_CLK_DIS_ON_LPM_Msk = 0x20
	// Bit ARM_CLK_DIS_ON_LPM.
	CCM_CLPCR_ARM_CLK_DIS_ON_LPM = 0x20
	// ARM clock enabled on wait mode.
	CCM_CLPCR_ARM_CLK_DIS_ON_LPM_ARM_CLK_DIS_ON_LPM_0 = 0x0
	// ARM clock disabled on wait mode. .
	CCM_CLPCR_ARM_CLK_DIS_ON_LPM_ARM_CLK_DIS_ON_LPM_1 = 0x1
	// Position of SBYOS field.
	CCM_CLPCR_SBYOS_Pos = 0x6
	// Bit mask of SBYOS field.
	CCM_CLPCR_SBYOS_Msk = 0x40
	// Bit SBYOS.
	CCM_CLPCR_SBYOS = 0x40
	// On-chip oscillator will not be powered down, after next entrance to STOP mode. (CCM_REF_EN_B will remain asserted - '0' and cosc_pwrdown will remain de asserted - '0')
	CCM_CLPCR_SBYOS_SBYOS_0 = 0x0
	// On-chip oscillator will be powered down, after next entrance to STOP mode. (CCM_REF_EN_B will be deasserted - '1' and cosc_pwrdown will be asserted - '1'). When returning from STOP mode, external oscillator will be enabled again, on-chip oscillator will return to oscillator mode, and after oscnt count, CCM will continue with the exit from the STOP mode process.
	CCM_CLPCR_SBYOS_SBYOS_1 = 0x1
	// Position of DIS_REF_OSC field.
	CCM_CLPCR_DIS_REF_OSC_Pos = 0x7
	// Bit mask of DIS_REF_OSC field.
	CCM_CLPCR_DIS_REF_OSC_Msk = 0x80
	// Bit DIS_REF_OSC.
	CCM_CLPCR_DIS_REF_OSC = 0x80
	// external high frequency oscillator will be enabled, i.e. CCM_REF_EN_B = '0'.
	CCM_CLPCR_DIS_REF_OSC_DIS_REF_OSC_0 = 0x0
	// external high frequency oscillator will be disabled, i.e. CCM_REF_EN_B = '1'
	CCM_CLPCR_DIS_REF_OSC_DIS_REF_OSC_1 = 0x1
	// Position of VSTBY field.
	CCM_CLPCR_VSTBY_Pos = 0x8
	// Bit mask of VSTBY field.
	CCM_CLPCR_VSTBY_Msk = 0x100
	// Bit VSTBY.
	CCM_CLPCR_VSTBY = 0x100
	// Voltage will not be changed to standby voltage after next entrance to STOP mode. ( PMIC_STBY_REQ will remain negated - '0')
	CCM_CLPCR_VSTBY_VSTBY_0 = 0x0
	// Voltage will be requested to change to standby voltage after next entrance to stop mode. ( PMIC_STBY_REQ will be asserted - '1').
	CCM_CLPCR_VSTBY_VSTBY_1 = 0x1
	// Position of STBY_COUNT field.
	CCM_CLPCR_STBY_COUNT_Pos = 0x9
	// Bit mask of STBY_COUNT field.
	CCM_CLPCR_STBY_COUNT_Msk = 0x600
	// CCM will wait (1*pmic_delay_scaler)+1 ckil clock cycles
	CCM_CLPCR_STBY_COUNT_STBY_COUNT_0 = 0x0
	// CCM will wait (3*pmic_delay_scaler)+1 ckil clock cycles
	CCM_CLPCR_STBY_COUNT_STBY_COUNT_1 = 0x1
	// CCM will wait (7*pmic_delay_scaler)+1 ckil clock cycles
	CCM_CLPCR_STBY_COUNT_STBY_COUNT_2 = 0x2
	// CCM will wait (15*pmic_delay_scaler)+1 ckil clock cycles
	CCM_CLPCR_STBY_COUNT_STBY_COUNT_3 = 0x3
	// Position of COSC_PWRDOWN field.
	CCM_CLPCR_COSC_PWRDOWN_Pos = 0xb
	// Bit mask of COSC_PWRDOWN field.
	CCM_CLPCR_COSC_PWRDOWN_Msk = 0x800
	// Bit COSC_PWRDOWN.
	CCM_CLPCR_COSC_PWRDOWN = 0x800
	// On chip oscillator will not be powered down, i.e. cosc_pwrdown = '0'.
	CCM_CLPCR_COSC_PWRDOWN_COSC_PWRDOWN_0 = 0x0
	// On chip oscillator will be powered down, i.e. cosc_pwrdown = '1'.
	CCM_CLPCR_COSC_PWRDOWN_COSC_PWRDOWN_1 = 0x1
	// Position of BYPASS_LPM_HS1 field.
	CCM_CLPCR_BYPASS_LPM_HS1_Pos = 0x13
	// Bit mask of BYPASS_LPM_HS1 field.
	CCM_CLPCR_BYPASS_LPM_HS1_Msk = 0x80000
	// Bit BYPASS_LPM_HS1.
	CCM_CLPCR_BYPASS_LPM_HS1 = 0x80000
	// Position of BYPASS_LPM_HS0 field.
	CCM_CLPCR_BYPASS_LPM_HS0_Pos = 0x15
	// Bit mask of BYPASS_LPM_HS0 field.
	CCM_CLPCR_BYPASS_LPM_HS0_Msk = 0x200000
	// Bit BYPASS_LPM_HS0.
	CCM_CLPCR_BYPASS_LPM_HS0 = 0x200000
	// Position of MASK_CORE0_WFI field.
	CCM_CLPCR_MASK_CORE0_WFI_Pos = 0x16
	// Bit mask of MASK_CORE0_WFI field.
	CCM_CLPCR_MASK_CORE0_WFI_Msk = 0x400000
	// Bit MASK_CORE0_WFI.
	CCM_CLPCR_MASK_CORE0_WFI = 0x400000
	// WFI of core0 is not masked
	CCM_CLPCR_MASK_CORE0_WFI_MASK_CORE0_WFI_0 = 0x0
	// WFI of core0 is masked
	CCM_CLPCR_MASK_CORE0_WFI_MASK_CORE0_WFI_1 = 0x1
	// Position of MASK_SCU_IDLE field.
	CCM_CLPCR_MASK_SCU_IDLE_Pos = 0x1a
	// Bit mask of MASK_SCU_IDLE field.
	CCM_CLPCR_MASK_SCU_IDLE_Msk = 0x4000000
	// Bit MASK_SCU_IDLE.
	CCM_CLPCR_MASK_SCU_IDLE = 0x4000000
	// SCU IDLE is not masked
	CCM_CLPCR_MASK_SCU_IDLE_MASK_SCU_IDLE_0 = 0x0
	// SCU IDLE is masked
	CCM_CLPCR_MASK_SCU_IDLE_MASK_SCU_IDLE_1 = 0x1
	// Position of MASK_L2CC_IDLE field.
	CCM_CLPCR_MASK_L2CC_IDLE_Pos = 0x1b
	// Bit mask of MASK_L2CC_IDLE field.
	CCM_CLPCR_MASK_L2CC_IDLE_Msk = 0x8000000
	// Bit MASK_L2CC_IDLE.
	CCM_CLPCR_MASK_L2CC_IDLE = 0x8000000
	// L2CC IDLE is not masked
	CCM_CLPCR_MASK_L2CC_IDLE_MASK_L2CC_IDLE_0 = 0x0
	// L2CC IDLE is masked
	CCM_CLPCR_MASK_L2CC_IDLE_MASK_L2CC_IDLE_1 = 0x1

	// CISR: CCM Interrupt Status Register
	// Position of LRF_PLL field.
	CCM_CISR_LRF_PLL_Pos = 0x0
	// Bit mask of LRF_PLL field.
	CCM_CISR_LRF_PLL_Msk = 0x1
	// Bit LRF_PLL.
	CCM_CISR_LRF_PLL = 0x1
	// interrupt is not generated due to lock ready of all enabled and not bypaseed PLLs
	CCM_CISR_LRF_PLL_LRF_PLL_0 = 0x0
	// interrupt generated due to lock ready of all enabled and not bypaseed PLLs
	CCM_CISR_LRF_PLL_LRF_PLL_1 = 0x1
	// Position of COSC_READY field.
	CCM_CISR_COSC_READY_Pos = 0x6
	// Bit mask of COSC_READY field.
	CCM_CISR_COSC_READY_Msk = 0x40
	// Bit COSC_READY.
	CCM_CISR_COSC_READY = 0x40
	// interrupt is not generated due to on board oscillator ready
	CCM_CISR_COSC_READY_COSC_READY_0 = 0x0
	// interrupt generated due to on board oscillator ready
	CCM_CISR_COSC_READY_COSC_READY_1 = 0x1
	// Position of SEMC_PODF_LOADED field.
	CCM_CISR_SEMC_PODF_LOADED_Pos = 0x11
	// Bit mask of SEMC_PODF_LOADED field.
	CCM_CISR_SEMC_PODF_LOADED_Msk = 0x20000
	// Bit SEMC_PODF_LOADED.
	CCM_CISR_SEMC_PODF_LOADED = 0x20000
	// interrupt is not generated due to frequency change of semc_podf
	CCM_CISR_SEMC_PODF_LOADED_SEMC_PODF_LOADED_0 = 0x0
	// interrupt generated due to frequency change of semc_podf
	CCM_CISR_SEMC_PODF_LOADED_SEMC_PODF_LOADED_1 = 0x1
	// Position of PERIPH2_CLK_SEL_LOADED field.
	CCM_CISR_PERIPH2_CLK_SEL_LOADED_Pos = 0x13
	// Bit mask of PERIPH2_CLK_SEL_LOADED field.
	CCM_CISR_PERIPH2_CLK_SEL_LOADED_Msk = 0x80000
	// Bit PERIPH2_CLK_SEL_LOADED.
	CCM_CISR_PERIPH2_CLK_SEL_LOADED = 0x80000
	// interrupt is not generated due to frequency change of periph2_clk_sel
	CCM_CISR_PERIPH2_CLK_SEL_LOADED_PERIPH2_CLK_SEL_LOADED_0 = 0x0
	// interrupt generated due to frequency change of periph2_clk_sel
	CCM_CISR_PERIPH2_CLK_SEL_LOADED_PERIPH2_CLK_SEL_LOADED_1 = 0x1
	// Position of AHB_PODF_LOADED field.
	CCM_CISR_AHB_PODF_LOADED_Pos = 0x14
	// Bit mask of AHB_PODF_LOADED field.
	CCM_CISR_AHB_PODF_LOADED_Msk = 0x100000
	// Bit AHB_PODF_LOADED.
	CCM_CISR_AHB_PODF_LOADED = 0x100000
	// interrupt is not generated due to frequency change of ahb_podf
	CCM_CISR_AHB_PODF_LOADED_AHB_PODF_LOADED_0 = 0x0
	// interrupt generated due to frequency change of ahb_podf
	CCM_CISR_AHB_PODF_LOADED_AHB_PODF_LOADED_1 = 0x1
	// Position of PERIPH_CLK_SEL_LOADED field.
	CCM_CISR_PERIPH_CLK_SEL_LOADED_Pos = 0x16
	// Bit mask of PERIPH_CLK_SEL_LOADED field.
	CCM_CISR_PERIPH_CLK_SEL_LOADED_Msk = 0x400000
	// Bit PERIPH_CLK_SEL_LOADED.
	CCM_CISR_PERIPH_CLK_SEL_LOADED = 0x400000
	// interrupt is not generated due to update of periph_clk_sel.
	CCM_CISR_PERIPH_CLK_SEL_LOADED_PERIPH_CLK_SEL_LOADED_0 = 0x0
	// interrupt generated due to update of periph_clk_sel.
	CCM_CISR_PERIPH_CLK_SEL_LOADED_PERIPH_CLK_SEL_LOADED_1 = 0x1
	// Position of ARM_PODF_LOADED field.
	CCM_CISR_ARM_PODF_LOADED_Pos = 0x1a
	// Bit mask of ARM_PODF_LOADED field.
	CCM_CISR_ARM_PODF_LOADED_Msk = 0x4000000
	// Bit ARM_PODF_LOADED.
	CCM_CISR_ARM_PODF_LOADED = 0x4000000
	// interrupt is not generated due to frequency change of arm_podf
	CCM_CISR_ARM_PODF_LOADED_ARM_PODF_LOADED_0 = 0x0
	// interrupt generated due to frequency change of arm_podf
	CCM_CISR_ARM_PODF_LOADED_ARM_PODF_LOADED_1 = 0x1

	// CIMR: CCM Interrupt Mask Register
	// Position of MASK_LRF_PLL field.
	CCM_CIMR_MASK_LRF_PLL_Pos = 0x0
	// Bit mask of MASK_LRF_PLL field.
	CCM_CIMR_MASK_LRF_PLL_Msk = 0x1
	// Bit MASK_LRF_PLL.
	CCM_CIMR_MASK_LRF_PLL = 0x1
	// don't mask interrupt due to lrf of PLLs - interrupt will be created
	CCM_CIMR_MASK_LRF_PLL_MASK_LRF_PLL_0 = 0x0
	// mask interrupt due to lrf of PLLs
	CCM_CIMR_MASK_LRF_PLL_MASK_LRF_PLL_1 = 0x1
	// Position of MASK_COSC_READY field.
	CCM_CIMR_MASK_COSC_READY_Pos = 0x6
	// Bit mask of MASK_COSC_READY field.
	CCM_CIMR_MASK_COSC_READY_Msk = 0x40
	// Bit MASK_COSC_READY.
	CCM_CIMR_MASK_COSC_READY = 0x40
	// don't mask interrupt due to on board oscillator ready - interrupt will be created
	CCM_CIMR_MASK_COSC_READY_MASK_COSC_READY_0 = 0x0
	// mask interrupt due to on board oscillator ready
	CCM_CIMR_MASK_COSC_READY_MASK_COSC_READY_1 = 0x1
	// Position of MASK_SEMC_PODF_LOADED field.
	CCM_CIMR_MASK_SEMC_PODF_LOADED_Pos = 0x11
	// Bit mask of MASK_SEMC_PODF_LOADED field.
	CCM_CIMR_MASK_SEMC_PODF_LOADED_Msk = 0x20000
	// Bit MASK_SEMC_PODF_LOADED.
	CCM_CIMR_MASK_SEMC_PODF_LOADED = 0x20000
	// don't mask interrupt due to frequency change of semc_podf - interrupt will be created
	CCM_CIMR_MASK_SEMC_PODF_LOADED_MASK_SEMC_PODF_LOADED_0 = 0x0
	// mask interrupt due to frequency change of semc_podf
	CCM_CIMR_MASK_SEMC_PODF_LOADED_MASK_SEMC_PODF_LOADED_1 = 0x1
	// Position of MASK_PERIPH2_CLK_SEL_LOADED field.
	CCM_CIMR_MASK_PERIPH2_CLK_SEL_LOADED_Pos = 0x13
	// Bit mask of MASK_PERIPH2_CLK_SEL_LOADED field.
	CCM_CIMR_MASK_PERIPH2_CLK_SEL_LOADED_Msk = 0x80000
	// Bit MASK_PERIPH2_CLK_SEL_LOADED.
	CCM_CIMR_MASK_PERIPH2_CLK_SEL_LOADED = 0x80000
	// don't mask interrupt due to update of periph2_clk_sel - interrupt will be created
	CCM_CIMR_MASK_PERIPH2_CLK_SEL_LOADED_MASK_PERIPH2_CLK_SEL_LOADED_0 = 0x0
	// mask interrupt due to update of periph2_clk_sel
	CCM_CIMR_MASK_PERIPH2_CLK_SEL_LOADED_MASK_PERIPH2_CLK_SEL_LOADED_1 = 0x1
	// Position of MASK_AHB_PODF_LOADED field.
	CCM_CIMR_MASK_AHB_PODF_LOADED_Pos = 0x14
	// Bit mask of MASK_AHB_PODF_LOADED field.
	CCM_CIMR_MASK_AHB_PODF_LOADED_Msk = 0x100000
	// Bit MASK_AHB_PODF_LOADED.
	CCM_CIMR_MASK_AHB_PODF_LOADED = 0x100000
	// don't mask interrupt due to frequency change of ahb_podf - interrupt will be created
	CCM_CIMR_MASK_AHB_PODF_LOADED_MASK_AHB_PODF_LOADED_0 = 0x0
	// mask interrupt due to frequency change of ahb_podf
	CCM_CIMR_MASK_AHB_PODF_LOADED_MASK_AHB_PODF_LOADED_1 = 0x1
	// Position of MASK_PERIPH_CLK_SEL_LOADED field.
	CCM_CIMR_MASK_PERIPH_CLK_SEL_LOADED_Pos = 0x16
	// Bit mask of MASK_PERIPH_CLK_SEL_LOADED field.
	CCM_CIMR_MASK_PERIPH_CLK_SEL_LOADED_Msk = 0x400000
	// Bit MASK_PERIPH_CLK_SEL_LOADED.
	CCM_CIMR_MASK_PERIPH_CLK_SEL_LOADED = 0x400000
	// don't mask interrupt due to update of periph_clk_sel - interrupt will be created
	CCM_CIMR_MASK_PERIPH_CLK_SEL_LOADED_MASK_PERIPH_CLK_SEL_LOADED_0 = 0x0
	// mask interrupt due to update of periph_clk_sel
	CCM_CIMR_MASK_PERIPH_CLK_SEL_LOADED_MASK_PERIPH_CLK_SEL_LOADED_1 = 0x1
	// Position of ARM_PODF_LOADED field.
	CCM_CIMR_ARM_PODF_LOADED_Pos = 0x1a
	// Bit mask of ARM_PODF_LOADED field.
	CCM_CIMR_ARM_PODF_LOADED_Msk = 0x4000000
	// Bit ARM_PODF_LOADED.
	CCM_CIMR_ARM_PODF_LOADED = 0x4000000
	// don't mask interrupt due to frequency change of arm_podf - interrupt will be created
	CCM_CIMR_ARM_PODF_LOADED_ARM_PODF_LOADED_0 = 0x0
	// mask interrupt due to frequency change of arm_podf
	CCM_CIMR_ARM_PODF_LOADED_ARM_PODF_LOADED_1 = 0x1

	// CCOSR: CCM Clock Output Source Register
	// Position of CLKO1_SEL field.
	CCM_CCOSR_CLKO1_SEL_Pos = 0x0
	// Bit mask of CLKO1_SEL field.
	CCM_CCOSR_CLKO1_SEL_Msk = 0xf
	// USB1 PLL clock (divided by 2)
	CCM_CCOSR_CLKO1_SEL_CLKO1_SEL_0 = 0x0
	// SYS PLL clock (divided by 2)
	CCM_CCOSR_CLKO1_SEL_CLKO1_SEL_1 = 0x1
	// VIDEO PLL clock (divided by 2)
	CCM_CCOSR_CLKO1_SEL_CLKO1_SEL_3 = 0x3
	// semc_clk_root
	CCM_CCOSR_CLKO1_SEL_CLKO1_SEL_5 = 0x5
	// lcdif_pix_clk_root
	CCM_CCOSR_CLKO1_SEL_CLKO1_SEL_10 = 0xa
	// ahb_clk_root
	CCM_CCOSR_CLKO1_SEL_CLKO1_SEL_11 = 0xb
	// ipg_clk_root
	CCM_CCOSR_CLKO1_SEL_CLKO1_SEL_12 = 0xc
	// perclk_root
	CCM_CCOSR_CLKO1_SEL_CLKO1_SEL_13 = 0xd
	// ckil_sync_clk_root
	CCM_CCOSR_CLKO1_SEL_CLKO1_SEL_14 = 0xe
	// pll4_main_clk
	CCM_CCOSR_CLKO1_SEL_CLKO1_SEL_15 = 0xf
	// Position of CLKO1_DIV field.
	CCM_CCOSR_CLKO1_DIV_Pos = 0x4
	// Bit mask of CLKO1_DIV field.
	CCM_CCOSR_CLKO1_DIV_Msk = 0x70
	// divide by 1
	CCM_CCOSR_CLKO1_DIV_CLKO1_DIV_0 = 0x0
	// divide by 2
	CCM_CCOSR_CLKO1_DIV_CLKO1_DIV_1 = 0x1
	// divide by 3
	CCM_CCOSR_CLKO1_DIV_CLKO1_DIV_2 = 0x2
	// divide by 4
	CCM_CCOSR_CLKO1_DIV_CLKO1_DIV_3 = 0x3
	// divide by 5
	CCM_CCOSR_CLKO1_DIV_CLKO1_DIV_4 = 0x4
	// divide by 6
	CCM_CCOSR_CLKO1_DIV_CLKO1_DIV_5 = 0x5
	// divide by 7
	CCM_CCOSR_CLKO1_DIV_CLKO1_DIV_6 = 0x6
	// divide by 8
	CCM_CCOSR_CLKO1_DIV_CLKO1_DIV_7 = 0x7
	// Position of CLKO1_EN field.
	CCM_CCOSR_CLKO1_EN_Pos = 0x7
	// Bit mask of CLKO1_EN field.
	CCM_CCOSR_CLKO1_EN_Msk = 0x80
	// Bit CLKO1_EN.
	CCM_CCOSR_CLKO1_EN = 0x80
	// CCM_CLKO1 disabled.
	CCM_CCOSR_CLKO1_EN_CLKO1_EN_0 = 0x0
	// CCM_CLKO1 enabled.
	CCM_CCOSR_CLKO1_EN_CLKO1_EN_1 = 0x1
	// Position of CLK_OUT_SEL field.
	CCM_CCOSR_CLK_OUT_SEL_Pos = 0x8
	// Bit mask of CLK_OUT_SEL field.
	CCM_CCOSR_CLK_OUT_SEL_Msk = 0x100
	// Bit CLK_OUT_SEL.
	CCM_CCOSR_CLK_OUT_SEL = 0x100
	// CCM_CLKO1 output drives CCM_CLKO1 clock
	CCM_CCOSR_CLK_OUT_SEL_CLK_OUT_SEL_0 = 0x0
	// CCM_CLKO1 output drives CCM_CLKO2 clock
	CCM_CCOSR_CLK_OUT_SEL_CLK_OUT_SEL_1 = 0x1
	// Position of CLKO2_SEL field.
	CCM_CCOSR_CLKO2_SEL_Pos = 0x10
	// Bit mask of CLKO2_SEL field.
	CCM_CCOSR_CLKO2_SEL_Msk = 0x1f0000
	// usdhc1_clk_root
	CCM_CCOSR_CLKO2_SEL_CLKO2_SEL_3 = 0x3
	// lpi2c_clk_root
	CCM_CCOSR_CLKO2_SEL_CLKO2_SEL_6 = 0x6
	// csi_clk_root
	CCM_CCOSR_CLKO2_SEL_CLKO2_SEL_11 = 0xb
	// osc_clk
	CCM_CCOSR_CLKO2_SEL_CLKO2_SEL_14 = 0xe
	// usdhc2_clk_root
	CCM_CCOSR_CLKO2_SEL_CLKO2_SEL_17 = 0x11
	// sai1_clk_root
	CCM_CCOSR_CLKO2_SEL_CLKO2_SEL_18 = 0x12
	// sai2_clk_root
	CCM_CCOSR_CLKO2_SEL_CLKO2_SEL_19 = 0x13
	// sai3_clk_root (shared with ADC1 and ADC2 alt_clk root)
	CCM_CCOSR_CLKO2_SEL_CLKO2_SEL_20 = 0x14
	// can_clk_root (FlexCAN, shared with CANFD)
	CCM_CCOSR_CLKO2_SEL_CLKO2_SEL_23 = 0x17
	// flexspi_clk_root
	CCM_CCOSR_CLKO2_SEL_CLKO2_SEL_27 = 0x1b
	// uart_clk_root
	CCM_CCOSR_CLKO2_SEL_CLKO2_SEL_28 = 0x1c
	// spdif0_clk_root
	CCM_CCOSR_CLKO2_SEL_CLKO2_SEL_29 = 0x1d
	// Position of CLKO2_DIV field.
	CCM_CCOSR_CLKO2_DIV_Pos = 0x15
	// Bit mask of CLKO2_DIV field.
	CCM_CCOSR_CLKO2_DIV_Msk = 0xe00000
	// divide by 1
	CCM_CCOSR_CLKO2_DIV_CLKO2_DIV_0 = 0x0
	// divide by 2
	CCM_CCOSR_CLKO2_DIV_CLKO2_DIV_1 = 0x1
	// divide by 3
	CCM_CCOSR_CLKO2_DIV_CLKO2_DIV_2 = 0x2
	// divide by 4
	CCM_CCOSR_CLKO2_DIV_CLKO2_DIV_3 = 0x3
	// divide by 5
	CCM_CCOSR_CLKO2_DIV_CLKO2_DIV_4 = 0x4
	// divide by 6
	CCM_CCOSR_CLKO2_DIV_CLKO2_DIV_5 = 0x5
	// divide by 7
	CCM_CCOSR_CLKO2_DIV_CLKO2_DIV_6 = 0x6
	// divide by 8
	CCM_CCOSR_CLKO2_DIV_CLKO2_DIV_7 = 0x7
	// Position of CLKO2_EN field.
	CCM_CCOSR_CLKO2_EN_Pos = 0x18
	// Bit mask of CLKO2_EN field.
	CCM_CCOSR_CLKO2_EN_Msk = 0x1000000
	// Bit CLKO2_EN.
	CCM_CCOSR_CLKO2_EN = 0x1000000
	// CCM_CLKO2 disabled.
	CCM_CCOSR_CLKO2_EN_CLKO2_EN_0 = 0x0
	// CCM_CLKO2 enabled.
	CCM_CCOSR_CLKO2_EN_CLKO2_EN_1 = 0x1

	// CGPR: CCM General Purpose Register
	// Position of PMIC_DELAY_SCALER field.
	CCM_CGPR_PMIC_DELAY_SCALER_Pos = 0x0
	// Bit mask of PMIC_DELAY_SCALER field.
	CCM_CGPR_PMIC_DELAY_SCALER_Msk = 0x1
	// Bit PMIC_DELAY_SCALER.
	CCM_CGPR_PMIC_DELAY_SCALER = 0x1
	// clock is not divided
	CCM_CGPR_PMIC_DELAY_SCALER_PMIC_DELAY_SCALER_0 = 0x0
	// clock is divided /8
	CCM_CGPR_PMIC_DELAY_SCALER_PMIC_DELAY_SCALER_1 = 0x1
	// Position of EFUSE_PROG_SUPPLY_GATE field.
	CCM_CGPR_EFUSE_PROG_SUPPLY_GATE_Pos = 0x4
	// Bit mask of EFUSE_PROG_SUPPLY_GATE field.
	CCM_CGPR_EFUSE_PROG_SUPPLY_GATE_Msk = 0x10
	// Bit EFUSE_PROG_SUPPLY_GATE.
	CCM_CGPR_EFUSE_PROG_SUPPLY_GATE = 0x10
	// fuse programing supply voltage is gated off to the efuse module
	CCM_CGPR_EFUSE_PROG_SUPPLY_GATE_EFUSE_PROG_SUPPLY_GATE_0 = 0x0
	// allow fuse programing.
	CCM_CGPR_EFUSE_PROG_SUPPLY_GATE_EFUSE_PROG_SUPPLY_GATE_1 = 0x1
	// Position of SYS_MEM_DS_CTRL field.
	CCM_CGPR_SYS_MEM_DS_CTRL_Pos = 0xe
	// Bit mask of SYS_MEM_DS_CTRL field.
	CCM_CGPR_SYS_MEM_DS_CTRL_Msk = 0xc000
	// Disable memory DS mode always
	CCM_CGPR_SYS_MEM_DS_CTRL_SYS_MEM_DS_CTRL_0 = 0x0
	// Enable memory (outside ARM platform) DS mode when system STOP and PLL are disabled
	CCM_CGPR_SYS_MEM_DS_CTRL_SYS_MEM_DS_CTRL_1 = 0x1
	// enable memory (outside ARM platform) DS mode when system is in STOP mode
	CCM_CGPR_SYS_MEM_DS_CTRL_SYS_MEM_DS_CTRL_2 = 0x2
	// Position of FPL field.
	CCM_CGPR_FPL_Pos = 0x10
	// Bit mask of FPL field.
	CCM_CGPR_FPL_Msk = 0x10000
	// Bit FPL.
	CCM_CGPR_FPL = 0x10000
	// Engage PLL enable default way.
	CCM_CGPR_FPL_FPL_0 = 0x0
	// Engage PLL enable 3 CKIL clocks earlier at exiting low power mode (STOP). Should be used only if 24MHz OSC was active in low power mode.
	CCM_CGPR_FPL_FPL_1 = 0x1
	// Position of INT_MEM_CLK_LPM field.
	CCM_CGPR_INT_MEM_CLK_LPM_Pos = 0x11
	// Bit mask of INT_MEM_CLK_LPM field.
	CCM_CGPR_INT_MEM_CLK_LPM_Msk = 0x20000
	// Bit INT_MEM_CLK_LPM.
	CCM_CGPR_INT_MEM_CLK_LPM = 0x20000
	// Disable the clock to the ARM platform memories when entering Low Power Mode
	CCM_CGPR_INT_MEM_CLK_LPM_INT_MEM_CLK_LPM_0 = 0x0
	// Keep the clocks to the ARM platform memories enabled only if an interrupt is pending when entering Low Power Modes (WAIT and STOP without power gating)
	CCM_CGPR_INT_MEM_CLK_LPM_INT_MEM_CLK_LPM_1 = 0x1

	// CCGR0: CCM Clock Gating Register 0
	// Position of CG0 field.
	CCM_CCGR0_CG0_Pos = 0x0
	// Bit mask of CG0 field.
	CCM_CCGR0_CG0_Msk = 0x3
	// Position of CG1 field.
	CCM_CCGR0_CG1_Pos = 0x2
	// Bit mask of CG1 field.
	CCM_CCGR0_CG1_Msk = 0xc
	// Position of CG2 field.
	CCM_CCGR0_CG2_Pos = 0x4
	// Bit mask of CG2 field.
	CCM_CCGR0_CG2_Msk = 0x30
	// Position of CG3 field.
	CCM_CCGR0_CG3_Pos = 0x6
	// Bit mask of CG3 field.
	CCM_CCGR0_CG3_Msk = 0xc0
	// Position of CG4 field.
	CCM_CCGR0_CG4_Pos = 0x8
	// Bit mask of CG4 field.
	CCM_CCGR0_CG4_Msk = 0x300
	// Position of CG5 field.
	CCM_CCGR0_CG5_Pos = 0xa
	// Bit mask of CG5 field.
	CCM_CCGR0_CG5_Msk = 0xc00
	// Position of CG6 field.
	CCM_CCGR0_CG6_Pos = 0xc
	// Bit mask of CG6 field.
	CCM_CCGR0_CG6_Msk = 0x3000
	// Position of CG7 field.
	CCM_CCGR0_CG7_Pos = 0xe
	// Bit mask of CG7 field.
	CCM_CCGR0_CG7_Msk = 0xc000
	// Position of CG8 field.
	CCM_CCGR0_CG8_Pos = 0x10
	// Bit mask of CG8 field.
	CCM_CCGR0_CG8_Msk = 0x30000
	// Position of CG9 field.
	CCM_CCGR0_CG9_Pos = 0x12
	// Bit mask of CG9 field.
	CCM_CCGR0_CG9_Msk = 0xc0000
	// Position of CG10 field.
	CCM_CCGR0_CG10_Pos = 0x14
	// Bit mask of CG10 field.
	CCM_CCGR0_CG10_Msk = 0x300000
	// Position of CG11 field.
	CCM_CCGR0_CG11_Pos = 0x16
	// Bit mask of CG11 field.
	CCM_CCGR0_CG11_Msk = 0xc00000
	// Position of CG12 field.
	CCM_CCGR0_CG12_Pos = 0x18
	// Bit mask of CG12 field.
	CCM_CCGR0_CG12_Msk = 0x3000000
	// Position of CG13 field.
	CCM_CCGR0_CG13_Pos = 0x1a
	// Bit mask of CG13 field.
	CCM_CCGR0_CG13_Msk = 0xc000000
	// Position of CG14 field.
	CCM_CCGR0_CG14_Pos = 0x1c
	// Bit mask of CG14 field.
	CCM_CCGR0_CG14_Msk = 0x30000000
	// Position of CG15 field.
	CCM_CCGR0_CG15_Pos = 0x1e
	// Bit mask of CG15 field.
	CCM_CCGR0_CG15_Msk = 0xc0000000

	// CCGR1: CCM Clock Gating Register 1
	// Position of CG0 field.
	CCM_CCGR1_CG0_Pos = 0x0
	// Bit mask of CG0 field.
	CCM_CCGR1_CG0_Msk = 0x3
	// Position of CG1 field.
	CCM_CCGR1_CG1_Pos = 0x2
	// Bit mask of CG1 field.
	CCM_CCGR1_CG1_Msk = 0xc
	// Position of CG2 field.
	CCM_CCGR1_CG2_Pos = 0x4
	// Bit mask of CG2 field.
	CCM_CCGR1_CG2_Msk = 0x30
	// Position of CG3 field.
	CCM_CCGR1_CG3_Pos = 0x6
	// Bit mask of CG3 field.
	CCM_CCGR1_CG3_Msk = 0xc0
	// Position of CG4 field.
	CCM_CCGR1_CG4_Pos = 0x8
	// Bit mask of CG4 field.
	CCM_CCGR1_CG4_Msk = 0x300
	// Position of CG5 field.
	CCM_CCGR1_CG5_Pos = 0xa
	// Bit mask of CG5 field.
	CCM_CCGR1_CG5_Msk = 0xc00
	// Position of CG6 field.
	CCM_CCGR1_CG6_Pos = 0xc
	// Bit mask of CG6 field.
	CCM_CCGR1_CG6_Msk = 0x3000
	// Position of CG7 field.
	CCM_CCGR1_CG7_Pos = 0xe
	// Bit mask of CG7 field.
	CCM_CCGR1_CG7_Msk = 0xc000
	// Position of CG8 field.
	CCM_CCGR1_CG8_Pos = 0x10
	// Bit mask of CG8 field.
	CCM_CCGR1_CG8_Msk = 0x30000
	// Position of CG9 field.
	CCM_CCGR1_CG9_Pos = 0x12
	// Bit mask of CG9 field.
	CCM_CCGR1_CG9_Msk = 0xc0000
	// Position of CG10 field.
	CCM_CCGR1_CG10_Pos = 0x14
	// Bit mask of CG10 field.
	CCM_CCGR1_CG10_Msk = 0x300000
	// Position of CG11 field.
	CCM_CCGR1_CG11_Pos = 0x16
	// Bit mask of CG11 field.
	CCM_CCGR1_CG11_Msk = 0xc00000
	// Position of CG12 field.
	CCM_CCGR1_CG12_Pos = 0x18
	// Bit mask of CG12 field.
	CCM_CCGR1_CG12_Msk = 0x3000000
	// Position of CG13 field.
	CCM_CCGR1_CG13_Pos = 0x1a
	// Bit mask of CG13 field.
	CCM_CCGR1_CG13_Msk = 0xc000000
	// Position of CG14 field.
	CCM_CCGR1_CG14_Pos = 0x1c
	// Bit mask of CG14 field.
	CCM_CCGR1_CG14_Msk = 0x30000000
	// Position of CG15 field.
	CCM_CCGR1_CG15_Pos = 0x1e
	// Bit mask of CG15 field.
	CCM_CCGR1_CG15_Msk = 0xc0000000

	// CCGR2: CCM Clock Gating Register 2
	// Position of CG0 field.
	CCM_CCGR2_CG0_Pos = 0x0
	// Bit mask of CG0 field.
	CCM_CCGR2_CG0_Msk = 0x3
	// Position of CG1 field.
	CCM_CCGR2_CG1_Pos = 0x2
	// Bit mask of CG1 field.
	CCM_CCGR2_CG1_Msk = 0xc
	// Position of CG2 field.
	CCM_CCGR2_CG2_Pos = 0x4
	// Bit mask of CG2 field.
	CCM_CCGR2_CG2_Msk = 0x30
	// Position of CG3 field.
	CCM_CCGR2_CG3_Pos = 0x6
	// Bit mask of CG3 field.
	CCM_CCGR2_CG3_Msk = 0xc0
	// Position of CG4 field.
	CCM_CCGR2_CG4_Pos = 0x8
	// Bit mask of CG4 field.
	CCM_CCGR2_CG4_Msk = 0x300
	// Position of CG5 field.
	CCM_CCGR2_CG5_Pos = 0xa
	// Bit mask of CG5 field.
	CCM_CCGR2_CG5_Msk = 0xc00
	// Position of CG6 field.
	CCM_CCGR2_CG6_Pos = 0xc
	// Bit mask of CG6 field.
	CCM_CCGR2_CG6_Msk = 0x3000
	// Position of CG7 field.
	CCM_CCGR2_CG7_Pos = 0xe
	// Bit mask of CG7 field.
	CCM_CCGR2_CG7_Msk = 0xc000
	// Position of CG8 field.
	CCM_CCGR2_CG8_Pos = 0x10
	// Bit mask of CG8 field.
	CCM_CCGR2_CG8_Msk = 0x30000
	// Position of CG9 field.
	CCM_CCGR2_CG9_Pos = 0x12
	// Bit mask of CG9 field.
	CCM_CCGR2_CG9_Msk = 0xc0000
	// Position of CG10 field.
	CCM_CCGR2_CG10_Pos = 0x14
	// Bit mask of CG10 field.
	CCM_CCGR2_CG10_Msk = 0x300000
	// Position of CG11 field.
	CCM_CCGR2_CG11_Pos = 0x16
	// Bit mask of CG11 field.
	CCM_CCGR2_CG11_Msk = 0xc00000
	// Position of CG12 field.
	CCM_CCGR2_CG12_Pos = 0x18
	// Bit mask of CG12 field.
	CCM_CCGR2_CG12_Msk = 0x3000000
	// Position of CG13 field.
	CCM_CCGR2_CG13_Pos = 0x1a
	// Bit mask of CG13 field.
	CCM_CCGR2_CG13_Msk = 0xc000000
	// Position of CG14 field.
	CCM_CCGR2_CG14_Pos = 0x1c
	// Bit mask of CG14 field.
	CCM_CCGR2_CG14_Msk = 0x30000000
	// Position of CG15 field.
	CCM_CCGR2_CG15_Pos = 0x1e
	// Bit mask of CG15 field.
	CCM_CCGR2_CG15_Msk = 0xc0000000

	// CCGR3: CCM Clock Gating Register 3
	// Position of CG0 field.
	CCM_CCGR3_CG0_Pos = 0x0
	// Bit mask of CG0 field.
	CCM_CCGR3_CG0_Msk = 0x3
	// Position of CG1 field.
	CCM_CCGR3_CG1_Pos = 0x2
	// Bit mask of CG1 field.
	CCM_CCGR3_CG1_Msk = 0xc
	// Position of CG2 field.
	CCM_CCGR3_CG2_Pos = 0x4
	// Bit mask of CG2 field.
	CCM_CCGR3_CG2_Msk = 0x30
	// Position of CG3 field.
	CCM_CCGR3_CG3_Pos = 0x6
	// Bit mask of CG3 field.
	CCM_CCGR3_CG3_Msk = 0xc0
	// Position of CG4 field.
	CCM_CCGR3_CG4_Pos = 0x8
	// Bit mask of CG4 field.
	CCM_CCGR3_CG4_Msk = 0x300
	// Position of CG5 field.
	CCM_CCGR3_CG5_Pos = 0xa
	// Bit mask of CG5 field.
	CCM_CCGR3_CG5_Msk = 0xc00
	// Position of CG6 field.
	CCM_CCGR3_CG6_Pos = 0xc
	// Bit mask of CG6 field.
	CCM_CCGR3_CG6_Msk = 0x3000
	// Position of CG7 field.
	CCM_CCGR3_CG7_Pos = 0xe
	// Bit mask of CG7 field.
	CCM_CCGR3_CG7_Msk = 0xc000
	// Position of CG8 field.
	CCM_CCGR3_CG8_Pos = 0x10
	// Bit mask of CG8 field.
	CCM_CCGR3_CG8_Msk = 0x30000
	// Position of CG9 field.
	CCM_CCGR3_CG9_Pos = 0x12
	// Bit mask of CG9 field.
	CCM_CCGR3_CG9_Msk = 0xc0000
	// Position of CG10 field.
	CCM_CCGR3_CG10_Pos = 0x14
	// Bit mask of CG10 field.
	CCM_CCGR3_CG10_Msk = 0x300000
	// Position of CG11 field.
	CCM_CCGR3_CG11_Pos = 0x16
	// Bit mask of CG11 field.
	CCM_CCGR3_CG11_Msk = 0xc00000
	// Position of CG12 field.
	CCM_CCGR3_CG12_Pos = 0x18
	// Bit mask of CG12 field.
	CCM_CCGR3_CG12_Msk = 0x3000000
	// Position of CG13 field.
	CCM_CCGR3_CG13_Pos = 0x1a
	// Bit mask of CG13 field.
	CCM_CCGR3_CG13_Msk = 0xc000000
	// Position of CG14 field.
	CCM_CCGR3_CG14_Pos = 0x1c
	// Bit mask of CG14 field.
	CCM_CCGR3_CG14_Msk = 0x30000000
	// Position of CG15 field.
	CCM_CCGR3_CG15_Pos = 0x1e
	// Bit mask of CG15 field.
	CCM_CCGR3_CG15_Msk = 0xc0000000

	// CCGR4: CCM Clock Gating Register 4
	// Position of CG0 field.
	CCM_CCGR4_CG0_Pos = 0x0
	// Bit mask of CG0 field.
	CCM_CCGR4_CG0_Msk = 0x3
	// Position of CG1 field.
	CCM_CCGR4_CG1_Pos = 0x2
	// Bit mask of CG1 field.
	CCM_CCGR4_CG1_Msk = 0xc
	// Position of CG2 field.
	CCM_CCGR4_CG2_Pos = 0x4
	// Bit mask of CG2 field.
	CCM_CCGR4_CG2_Msk = 0x30
	// Position of CG3 field.
	CCM_CCGR4_CG3_Pos = 0x6
	// Bit mask of CG3 field.
	CCM_CCGR4_CG3_Msk = 0xc0
	// Position of CG4 field.
	CCM_CCGR4_CG4_Pos = 0x8
	// Bit mask of CG4 field.
	CCM_CCGR4_CG4_Msk = 0x300
	// Position of CG5 field.
	CCM_CCGR4_CG5_Pos = 0xa
	// Bit mask of CG5 field.
	CCM_CCGR4_CG5_Msk = 0xc00
	// Position of CG6 field.
	CCM_CCGR4_CG6_Pos = 0xc
	// Bit mask of CG6 field.
	CCM_CCGR4_CG6_Msk = 0x3000
	// Position of CG7 field.
	CCM_CCGR4_CG7_Pos = 0xe
	// Bit mask of CG7 field.
	CCM_CCGR4_CG7_Msk = 0xc000
	// Position of CG8 field.
	CCM_CCGR4_CG8_Pos = 0x10
	// Bit mask of CG8 field.
	CCM_CCGR4_CG8_Msk = 0x30000
	// Position of CG9 field.
	CCM_CCGR4_CG9_Pos = 0x12
	// Bit mask of CG9 field.
	CCM_CCGR4_CG9_Msk = 0xc0000
	// Position of CG10 field.
	CCM_CCGR4_CG10_Pos = 0x14
	// Bit mask of CG10 field.
	CCM_CCGR4_CG10_Msk = 0x300000
	// Position of CG11 field.
	CCM_CCGR4_CG11_Pos = 0x16
	// Bit mask of CG11 field.
	CCM_CCGR4_CG11_Msk = 0xc00000
	// Position of CG12 field.
	CCM_CCGR4_CG12_Pos = 0x18
	// Bit mask of CG12 field.
	CCM_CCGR4_CG12_Msk = 0x3000000
	// Position of CG13 field.
	CCM_CCGR4_CG13_Pos = 0x1a
	// Bit mask of CG13 field.
	CCM_CCGR4_CG13_Msk = 0xc000000
	// Position of CG14 field.
	CCM_CCGR4_CG14_Pos = 0x1c
	// Bit mask of CG14 field.
	CCM_CCGR4_CG14_Msk = 0x30000000
	// Position of CG15 field.
	CCM_CCGR4_CG15_Pos = 0x1e
	// Bit mask of CG15 field.
	CCM_CCGR4_CG15_Msk = 0xc0000000

	// CCGR5: CCM Clock Gating Register 5
	// Position of CG0 field.
	CCM_CCGR5_CG0_Pos = 0x0
	// Bit mask of CG0 field.
	CCM_CCGR5_CG0_Msk = 0x3
	// Position of CG1 field.
	CCM_CCGR5_CG1_Pos = 0x2
	// Bit mask of CG1 field.
	CCM_CCGR5_CG1_Msk = 0xc
	// Position of CG2 field.
	CCM_CCGR5_CG2_Pos = 0x4
	// Bit mask of CG2 field.
	CCM_CCGR5_CG2_Msk = 0x30
	// Position of CG3 field.
	CCM_CCGR5_CG3_Pos = 0x6
	// Bit mask of CG3 field.
	CCM_CCGR5_CG3_Msk = 0xc0
	// Position of CG4 field.
	CCM_CCGR5_CG4_Pos = 0x8
	// Bit mask of CG4 field.
	CCM_CCGR5_CG4_Msk = 0x300
	// Position of CG5 field.
	CCM_CCGR5_CG5_Pos = 0xa
	// Bit mask of CG5 field.
	CCM_CCGR5_CG5_Msk = 0xc00
	// Position of CG6 field.
	CCM_CCGR5_CG6_Pos = 0xc
	// Bit mask of CG6 field.
	CCM_CCGR5_CG6_Msk = 0x3000
	// Position of CG7 field.
	CCM_CCGR5_CG7_Pos = 0xe
	// Bit mask of CG7 field.
	CCM_CCGR5_CG7_Msk = 0xc000
	// Position of CG8 field.
	CCM_CCGR5_CG8_Pos = 0x10
	// Bit mask of CG8 field.
	CCM_CCGR5_CG8_Msk = 0x30000
	// Position of CG9 field.
	CCM_CCGR5_CG9_Pos = 0x12
	// Bit mask of CG9 field.
	CCM_CCGR5_CG9_Msk = 0xc0000
	// Position of CG10 field.
	CCM_CCGR5_CG10_Pos = 0x14
	// Bit mask of CG10 field.
	CCM_CCGR5_CG10_Msk = 0x300000
	// Position of CG11 field.
	CCM_CCGR5_CG11_Pos = 0x16
	// Bit mask of CG11 field.
	CCM_CCGR5_CG11_Msk = 0xc00000
	// Position of CG12 field.
	CCM_CCGR5_CG12_Pos = 0x18
	// Bit mask of CG12 field.
	CCM_CCGR5_CG12_Msk = 0x3000000
	// Position of CG13 field.
	CCM_CCGR5_CG13_Pos = 0x1a
	// Bit mask of CG13 field.
	CCM_CCGR5_CG13_Msk = 0xc000000
	// Position of CG14 field.
	CCM_CCGR5_CG14_Pos = 0x1c
	// Bit mask of CG14 field.
	CCM_CCGR5_CG14_Msk = 0x30000000
	// Position of CG15 field.
	CCM_CCGR5_CG15_Pos = 0x1e
	// Bit mask of CG15 field.
	CCM_CCGR5_CG15_Msk = 0xc0000000

	// CCGR6: CCM Clock Gating Register 6
	// Position of CG0 field.
	CCM_CCGR6_CG0_Pos = 0x0
	// Bit mask of CG0 field.
	CCM_CCGR6_CG0_Msk = 0x3
	// Position of CG1 field.
	CCM_CCGR6_CG1_Pos = 0x2
	// Bit mask of CG1 field.
	CCM_CCGR6_CG1_Msk = 0xc
	// Position of CG2 field.
	CCM_CCGR6_CG2_Pos = 0x4
	// Bit mask of CG2 field.
	CCM_CCGR6_CG2_Msk = 0x30
	// Position of CG3 field.
	CCM_CCGR6_CG3_Pos = 0x6
	// Bit mask of CG3 field.
	CCM_CCGR6_CG3_Msk = 0xc0
	// Position of CG4 field.
	CCM_CCGR6_CG4_Pos = 0x8
	// Bit mask of CG4 field.
	CCM_CCGR6_CG4_Msk = 0x300
	// Position of CG5 field.
	CCM_CCGR6_CG5_Pos = 0xa
	// Bit mask of CG5 field.
	CCM_CCGR6_CG5_Msk = 0xc00
	// Position of CG6 field.
	CCM_CCGR6_CG6_Pos = 0xc
	// Bit mask of CG6 field.
	CCM_CCGR6_CG6_Msk = 0x3000
	// Position of CG7 field.
	CCM_CCGR6_CG7_Pos = 0xe
	// Bit mask of CG7 field.
	CCM_CCGR6_CG7_Msk = 0xc000
	// Position of CG8 field.
	CCM_CCGR6_CG8_Pos = 0x10
	// Bit mask of CG8 field.
	CCM_CCGR6_CG8_Msk = 0x30000
	// Position of CG9 field.
	CCM_CCGR6_CG9_Pos = 0x12
	// Bit mask of CG9 field.
	CCM_CCGR6_CG9_Msk = 0xc0000
	// Position of CG10 field.
	CCM_CCGR6_CG10_Pos = 0x14
	// Bit mask of CG10 field.
	CCM_CCGR6_CG10_Msk = 0x300000
	// Position of CG11 field.
	CCM_CCGR6_CG11_Pos = 0x16
	// Bit mask of CG11 field.
	CCM_CCGR6_CG11_Msk = 0xc00000
	// Position of CG12 field.
	CCM_CCGR6_CG12_Pos = 0x18
	// Bit mask of CG12 field.
	CCM_CCGR6_CG12_Msk = 0x3000000
	// Position of CG13 field.
	CCM_CCGR6_CG13_Pos = 0x1a
	// Bit mask of CG13 field.
	CCM_CCGR6_CG13_Msk = 0xc000000
	// Position of CG14 field.
	CCM_CCGR6_CG14_Pos = 0x1c
	// Bit mask of CG14 field.
	CCM_CCGR6_CG14_Msk = 0x30000000
	// Position of CG15 field.
	CCM_CCGR6_CG15_Pos = 0x1e
	// Bit mask of CG15 field.
	CCM_CCGR6_CG15_Msk = 0xc0000000

	// CCGR7: CCM Clock Gating Register 7
	// Position of CG0 field.
	CCM_CCGR7_CG0_Pos = 0x0
	// Bit mask of CG0 field.
	CCM_CCGR7_CG0_Msk = 0x3
	// Position of CG1 field.
	CCM_CCGR7_CG1_Pos = 0x2
	// Bit mask of CG1 field.
	CCM_CCGR7_CG1_Msk = 0xc
	// Position of CG2 field.
	CCM_CCGR7_CG2_Pos = 0x4
	// Bit mask of CG2 field.
	CCM_CCGR7_CG2_Msk = 0x30
	// Position of CG3 field.
	CCM_CCGR7_CG3_Pos = 0x6
	// Bit mask of CG3 field.
	CCM_CCGR7_CG3_Msk = 0xc0
	// Position of CG4 field.
	CCM_CCGR7_CG4_Pos = 0x8
	// Bit mask of CG4 field.
	CCM_CCGR7_CG4_Msk = 0x300
	// Position of CG5 field.
	CCM_CCGR7_CG5_Pos = 0xa
	// Bit mask of CG5 field.
	CCM_CCGR7_CG5_Msk = 0xc00
	// Position of CG6 field.
	CCM_CCGR7_CG6_Pos = 0xc
	// Bit mask of CG6 field.
	CCM_CCGR7_CG6_Msk = 0x3000

	// CMEOR: CCM Module Enable Overide Register
	// Position of MOD_EN_OV_GPT field.
	CCM_CMEOR_MOD_EN_OV_GPT_Pos = 0x5
	// Bit mask of MOD_EN_OV_GPT field.
	CCM_CMEOR_MOD_EN_OV_GPT_Msk = 0x20
	// Bit MOD_EN_OV_GPT.
	CCM_CMEOR_MOD_EN_OV_GPT = 0x20
	// don't override module enable signal
	CCM_CMEOR_MOD_EN_OV_GPT_MOD_EN_OV_GPT_0 = 0x0
	// override module enable signal
	CCM_CMEOR_MOD_EN_OV_GPT_MOD_EN_OV_GPT_1 = 0x1
	// Position of MOD_EN_OV_PIT field.
	CCM_CMEOR_MOD_EN_OV_PIT_Pos = 0x6
	// Bit mask of MOD_EN_OV_PIT field.
	CCM_CMEOR_MOD_EN_OV_PIT_Msk = 0x40
	// Bit MOD_EN_OV_PIT.
	CCM_CMEOR_MOD_EN_OV_PIT = 0x40
	// don't override module enable signal
	CCM_CMEOR_MOD_EN_OV_PIT_MOD_EN_OV_PIT_0 = 0x0
	// override module enable signal
	CCM_CMEOR_MOD_EN_OV_PIT_MOD_EN_OV_PIT_1 = 0x1
	// Position of MOD_EN_USDHC field.
	CCM_CMEOR_MOD_EN_USDHC_Pos = 0x7
	// Bit mask of MOD_EN_USDHC field.
	CCM_CMEOR_MOD_EN_USDHC_Msk = 0x80
	// Bit MOD_EN_USDHC.
	CCM_CMEOR_MOD_EN_USDHC = 0x80
	// don't override module enable signal
	CCM_CMEOR_MOD_EN_USDHC_MOD_EN_USDHC_0 = 0x0
	// override module enable signal
	CCM_CMEOR_MOD_EN_USDHC_MOD_EN_USDHC_1 = 0x1
	// Position of MOD_EN_OV_TRNG field.
	CCM_CMEOR_MOD_EN_OV_TRNG_Pos = 0x9
	// Bit mask of MOD_EN_OV_TRNG field.
	CCM_CMEOR_MOD_EN_OV_TRNG_Msk = 0x200
	// Bit MOD_EN_OV_TRNG.
	CCM_CMEOR_MOD_EN_OV_TRNG = 0x200
	// don't override module enable signal
	CCM_CMEOR_MOD_EN_OV_TRNG_MOD_EN_OV_TRNG_0 = 0x0
	// override module enable signal
	CCM_CMEOR_MOD_EN_OV_TRNG_MOD_EN_OV_TRNG_1 = 0x1
	// Position of MOD_EN_OV_CANFD_CPI field.
	CCM_CMEOR_MOD_EN_OV_CANFD_CPI_Pos = 0xa
	// Bit mask of MOD_EN_OV_CANFD_CPI field.
	CCM_CMEOR_MOD_EN_OV_CANFD_CPI_Msk = 0x400
	// Bit MOD_EN_OV_CANFD_CPI.
	CCM_CMEOR_MOD_EN_OV_CANFD_CPI = 0x400
	// don't override module enable signal
	CCM_CMEOR_MOD_EN_OV_CANFD_CPI_MOD_EN_OV_CANFD_CPI_0 = 0x0
	// override module enable signal
	CCM_CMEOR_MOD_EN_OV_CANFD_CPI_MOD_EN_OV_CANFD_CPI_1 = 0x1
	// Position of MOD_EN_OV_CAN2_CPI field.
	CCM_CMEOR_MOD_EN_OV_CAN2_CPI_Pos = 0x1c
	// Bit mask of MOD_EN_OV_CAN2_CPI field.
	CCM_CMEOR_MOD_EN_OV_CAN2_CPI_Msk = 0x10000000
	// Bit MOD_EN_OV_CAN2_CPI.
	CCM_CMEOR_MOD_EN_OV_CAN2_CPI = 0x10000000
	// don't override module enable signal
	CCM_CMEOR_MOD_EN_OV_CAN2_CPI_MOD_EN_OV_CAN2_CPI_0 = 0x0
	// override module enable signal
	CCM_CMEOR_MOD_EN_OV_CAN2_CPI_MOD_EN_OV_CAN2_CPI_1 = 0x1
	// Position of MOD_EN_OV_CAN1_CPI field.
	CCM_CMEOR_MOD_EN_OV_CAN1_CPI_Pos = 0x1e
	// Bit mask of MOD_EN_OV_CAN1_CPI field.
	CCM_CMEOR_MOD_EN_OV_CAN1_CPI_Msk = 0x40000000
	// Bit MOD_EN_OV_CAN1_CPI.
	CCM_CMEOR_MOD_EN_OV_CAN1_CPI = 0x40000000
	// don't overide module enable signal
	CCM_CMEOR_MOD_EN_OV_CAN1_CPI_MOD_EN_OV_CAN1_CPI_0 = 0x0
	// overide module enable signal
	CCM_CMEOR_MOD_EN_OV_CAN1_CPI_MOD_EN_OV_CAN1_CPI_1 = 0x1
)

// Bitfields for ROMC: ROMC
const (
	// ROMPATCH7D: ROMC Data Registers
	// Position of DATAX field.
	ROMC_ROMPATCHD_DATAX_Pos = 0x0
	// Bit mask of DATAX field.
	ROMC_ROMPATCHD_DATAX_Msk = 0xffffffff

	// ROMPATCHCNTL: ROMC Control Register
	// Position of DATAFIX field.
	ROMC_ROMPATCHCNTL_DATAFIX_Pos = 0x0
	// Bit mask of DATAFIX field.
	ROMC_ROMPATCHCNTL_DATAFIX_Msk = 0xff
	// Address comparator triggers a opcode patch
	ROMC_ROMPATCHCNTL_DATAFIX_DATAFIX_0 = 0x0
	// Address comparator triggers a data fix
	ROMC_ROMPATCHCNTL_DATAFIX_DATAFIX_1 = 0x1
	// Position of DIS field.
	ROMC_ROMPATCHCNTL_DIS_Pos = 0x1d
	// Bit mask of DIS field.
	ROMC_ROMPATCHCNTL_DIS_Msk = 0x20000000
	// Bit DIS.
	ROMC_ROMPATCHCNTL_DIS = 0x20000000
	// Does not affect any ROMC functions (default)
	ROMC_ROMPATCHCNTL_DIS_DIS_0 = 0x0
	// Disable all ROMC functions: data fixing, and opcode patching
	ROMC_ROMPATCHCNTL_DIS_DIS_1 = 0x1

	// ROMPATCHENL: ROMC Enable Register Low
	// Position of ENABLE field.
	ROMC_ROMPATCHENL_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	ROMC_ROMPATCHENL_ENABLE_Msk = 0xffff
	// Address comparator disabled
	ROMC_ROMPATCHENL_ENABLE_ENABLE_0 = 0x0
	// Address comparator enabled, ROMC will trigger a opcode patch or data fix event upon matching of the associated address
	ROMC_ROMPATCHENL_ENABLE_ENABLE_1 = 0x1

	// ROMPATCH0A: ROMC Address Registers
	// Position of THUMBX field.
	ROMC_ROMPATCHA_THUMBX_Pos = 0x0
	// Bit mask of THUMBX field.
	ROMC_ROMPATCHA_THUMBX_Msk = 0x1
	// Bit THUMBX.
	ROMC_ROMPATCHA_THUMBX = 0x1
	// Arm patch
	ROMC_ROMPATCHA_THUMBX_THUMBX_0 = 0x0
	// THUMB patch (ignore if data fix)
	ROMC_ROMPATCHA_THUMBX_THUMBX_1 = 0x1
	// Position of ADDRX field.
	ROMC_ROMPATCHA_ADDRX_Pos = 0x1
	// Bit mask of ADDRX field.
	ROMC_ROMPATCHA_ADDRX_Msk = 0x7ffffe

	// ROMPATCHSR: ROMC Status Register
	// Position of SOURCE field.
	ROMC_ROMPATCHSR_SOURCE_Pos = 0x0
	// Bit mask of SOURCE field.
	ROMC_ROMPATCHSR_SOURCE_Msk = 0x3f
	// Address Comparator 0 matched
	ROMC_ROMPATCHSR_SOURCE_SOURCE_0 = 0x0
	// Address Comparator 1 matched
	ROMC_ROMPATCHSR_SOURCE_SOURCE_1 = 0x1
	// Address Comparator 15 matched
	ROMC_ROMPATCHSR_SOURCE_SOURCE_15 = 0xf
	// Position of SW field.
	ROMC_ROMPATCHSR_SW_Pos = 0x11
	// Bit mask of SW field.
	ROMC_ROMPATCHSR_SW_Msk = 0x20000
	// Bit SW.
	ROMC_ROMPATCHSR_SW = 0x20000
	// no event or comparator collisions
	ROMC_ROMPATCHSR_SW_SW_0 = 0x0
	// a collision has occurred
	ROMC_ROMPATCHSR_SW_SW_1 = 0x1
)

// Bitfields for LPUART1: LPUART
const (
	// VERID: Version ID Register
	// Position of FEATURE field.
	LPUART_VERID_FEATURE_Pos = 0x0
	// Bit mask of FEATURE field.
	LPUART_VERID_FEATURE_Msk = 0xffff
	// Standard feature set.
	LPUART_VERID_FEATURE_FEATURE_1 = 0x1
	// Standard feature set with MODEM/IrDA support.
	LPUART_VERID_FEATURE_FEATURE_3 = 0x3
	// Position of MINOR field.
	LPUART_VERID_MINOR_Pos = 0x10
	// Bit mask of MINOR field.
	LPUART_VERID_MINOR_Msk = 0xff0000
	// Position of MAJOR field.
	LPUART_VERID_MAJOR_Pos = 0x18
	// Bit mask of MAJOR field.
	LPUART_VERID_MAJOR_Msk = 0xff000000

	// PARAM: Parameter Register
	// Position of TXFIFO field.
	LPUART_PARAM_TXFIFO_Pos = 0x0
	// Bit mask of TXFIFO field.
	LPUART_PARAM_TXFIFO_Msk = 0xff
	// Position of RXFIFO field.
	LPUART_PARAM_RXFIFO_Pos = 0x8
	// Bit mask of RXFIFO field.
	LPUART_PARAM_RXFIFO_Msk = 0xff00

	// GLOBAL: LPUART Global Register
	// Position of RST field.
	LPUART_GLOBAL_RST_Pos = 0x1
	// Bit mask of RST field.
	LPUART_GLOBAL_RST_Msk = 0x2
	// Bit RST.
	LPUART_GLOBAL_RST = 0x2
	// Module is not reset.
	LPUART_GLOBAL_RST_RST_0 = 0x0
	// Module is reset.
	LPUART_GLOBAL_RST_RST_1 = 0x1

	// PINCFG: LPUART Pin Configuration Register
	// Position of TRGSEL field.
	LPUART_PINCFG_TRGSEL_Pos = 0x0
	// Bit mask of TRGSEL field.
	LPUART_PINCFG_TRGSEL_Msk = 0x3
	// Input trigger is disabled.
	LPUART_PINCFG_TRGSEL_TRGSEL_0 = 0x0
	// Input trigger is used instead of RXD pin input.
	LPUART_PINCFG_TRGSEL_TRGSEL_1 = 0x1
	// Input trigger is used instead of CTS_B pin input.
	LPUART_PINCFG_TRGSEL_TRGSEL_2 = 0x2
	// Input trigger is used to modulate the TXD pin output. The TXD pin output (after TXINV configuration) is ANDed with the input trigger.
	LPUART_PINCFG_TRGSEL_TRGSEL_3 = 0x3

	// BAUD: LPUART Baud Rate Register
	// Position of SBR field.
	LPUART_BAUD_SBR_Pos = 0x0
	// Bit mask of SBR field.
	LPUART_BAUD_SBR_Msk = 0x1fff
	// Position of SBNS field.
	LPUART_BAUD_SBNS_Pos = 0xd
	// Bit mask of SBNS field.
	LPUART_BAUD_SBNS_Msk = 0x2000
	// Bit SBNS.
	LPUART_BAUD_SBNS = 0x2000
	// One stop bit.
	LPUART_BAUD_SBNS_SBNS_0 = 0x0
	// Two stop bits.
	LPUART_BAUD_SBNS_SBNS_1 = 0x1
	// Position of RXEDGIE field.
	LPUART_BAUD_RXEDGIE_Pos = 0xe
	// Bit mask of RXEDGIE field.
	LPUART_BAUD_RXEDGIE_Msk = 0x4000
	// Bit RXEDGIE.
	LPUART_BAUD_RXEDGIE = 0x4000
	// Hardware interrupts from STAT[RXEDGIF] are disabled.
	LPUART_BAUD_RXEDGIE_RXEDGIE_0 = 0x0
	// Hardware interrupt is requested when STAT[RXEDGIF] flag is 1.
	LPUART_BAUD_RXEDGIE_RXEDGIE_1 = 0x1
	// Position of LBKDIE field.
	LPUART_BAUD_LBKDIE_Pos = 0xf
	// Bit mask of LBKDIE field.
	LPUART_BAUD_LBKDIE_Msk = 0x8000
	// Bit LBKDIE.
	LPUART_BAUD_LBKDIE = 0x8000
	// Hardware interrupts from STAT[LBKDIF] flag are disabled (use polling).
	LPUART_BAUD_LBKDIE_LBKDIE_0 = 0x0
	// Hardware interrupt requested when STAT[LBKDIF] flag is 1.
	LPUART_BAUD_LBKDIE_LBKDIE_1 = 0x1
	// Position of RESYNCDIS field.
	LPUART_BAUD_RESYNCDIS_Pos = 0x10
	// Bit mask of RESYNCDIS field.
	LPUART_BAUD_RESYNCDIS_Msk = 0x10000
	// Bit RESYNCDIS.
	LPUART_BAUD_RESYNCDIS = 0x10000
	// Resynchronization during received data word is supported
	LPUART_BAUD_RESYNCDIS_RESYNCDIS_0 = 0x0
	// Resynchronization during received data word is disabled
	LPUART_BAUD_RESYNCDIS_RESYNCDIS_1 = 0x1
	// Position of BOTHEDGE field.
	LPUART_BAUD_BOTHEDGE_Pos = 0x11
	// Bit mask of BOTHEDGE field.
	LPUART_BAUD_BOTHEDGE_Msk = 0x20000
	// Bit BOTHEDGE.
	LPUART_BAUD_BOTHEDGE = 0x20000
	// Receiver samples input data using the rising edge of the baud rate clock.
	LPUART_BAUD_BOTHEDGE_BOTHEDGE_0 = 0x0
	// Receiver samples input data using the rising and falling edge of the baud rate clock.
	LPUART_BAUD_BOTHEDGE_BOTHEDGE_1 = 0x1
	// Position of MATCFG field.
	LPUART_BAUD_MATCFG_Pos = 0x12
	// Bit mask of MATCFG field.
	LPUART_BAUD_MATCFG_Msk = 0xc0000
	// Address Match Wakeup
	LPUART_BAUD_MATCFG_MATCFG_0 = 0x0
	// Idle Match Wakeup
	LPUART_BAUD_MATCFG_MATCFG_1 = 0x1
	// Match On and Match Off
	LPUART_BAUD_MATCFG_MATCFG_2 = 0x2
	// Enables RWU on Data Match and Match On/Off for transmitter CTS input
	LPUART_BAUD_MATCFG_MATCFG_3 = 0x3
	// Position of RIDMAE field.
	LPUART_BAUD_RIDMAE_Pos = 0x14
	// Bit mask of RIDMAE field.
	LPUART_BAUD_RIDMAE_Msk = 0x100000
	// Bit RIDMAE.
	LPUART_BAUD_RIDMAE = 0x100000
	// DMA request disabled.
	LPUART_BAUD_RIDMAE_RIDMAE_0 = 0x0
	// DMA request enabled.
	LPUART_BAUD_RIDMAE_RIDMAE_1 = 0x1
	// Position of RDMAE field.
	LPUART_BAUD_RDMAE_Pos = 0x15
	// Bit mask of RDMAE field.
	LPUART_BAUD_RDMAE_Msk = 0x200000
	// Bit RDMAE.
	LPUART_BAUD_RDMAE = 0x200000
	// DMA request disabled.
	LPUART_BAUD_RDMAE_RDMAE_0 = 0x0
	// DMA request enabled.
	LPUART_BAUD_RDMAE_RDMAE_1 = 0x1
	// Position of TDMAE field.
	LPUART_BAUD_TDMAE_Pos = 0x17
	// Bit mask of TDMAE field.
	LPUART_BAUD_TDMAE_Msk = 0x800000
	// Bit TDMAE.
	LPUART_BAUD_TDMAE = 0x800000
	// DMA request disabled.
	LPUART_BAUD_TDMAE_TDMAE_0 = 0x0
	// DMA request enabled.
	LPUART_BAUD_TDMAE_TDMAE_1 = 0x1
	// Position of OSR field.
	LPUART_BAUD_OSR_Pos = 0x18
	// Bit mask of OSR field.
	LPUART_BAUD_OSR_Msk = 0x1f000000
	// Writing 0 to this field will result in an oversampling ratio of 16
	LPUART_BAUD_OSR_OSR_0 = 0x0
	// Oversampling ratio of 4, requires BOTHEDGE to be set.
	LPUART_BAUD_OSR_OSR_3 = 0x3
	// Oversampling ratio of 5, requires BOTHEDGE to be set.
	LPUART_BAUD_OSR_OSR_4 = 0x4
	// Oversampling ratio of 6, requires BOTHEDGE to be set.
	LPUART_BAUD_OSR_OSR_5 = 0x5
	// Oversampling ratio of 7, requires BOTHEDGE to be set.
	LPUART_BAUD_OSR_OSR_6 = 0x6
	// Oversampling ratio of 8.
	LPUART_BAUD_OSR_OSR_7 = 0x7
	// Oversampling ratio of 9.
	LPUART_BAUD_OSR_OSR_8 = 0x8
	// Oversampling ratio of 10.
	LPUART_BAUD_OSR_OSR_9 = 0x9
	// Oversampling ratio of 11.
	LPUART_BAUD_OSR_OSR_10 = 0xa
	// Oversampling ratio of 12.
	LPUART_BAUD_OSR_OSR_11 = 0xb
	// Oversampling ratio of 13.
	LPUART_BAUD_OSR_OSR_12 = 0xc
	// Oversampling ratio of 14.
	LPUART_BAUD_OSR_OSR_13 = 0xd
	// Oversampling ratio of 15.
	LPUART_BAUD_OSR_OSR_14 = 0xe
	// Oversampling ratio of 16.
	LPUART_BAUD_OSR_OSR_15 = 0xf
	// Oversampling ratio of 17.
	LPUART_BAUD_OSR_OSR_16 = 0x10
	// Oversampling ratio of 18.
	LPUART_BAUD_OSR_OSR_17 = 0x11
	// Oversampling ratio of 19.
	LPUART_BAUD_OSR_OSR_18 = 0x12
	// Oversampling ratio of 20.
	LPUART_BAUD_OSR_OSR_19 = 0x13
	// Oversampling ratio of 21.
	LPUART_BAUD_OSR_OSR_20 = 0x14
	// Oversampling ratio of 22.
	LPUART_BAUD_OSR_OSR_21 = 0x15
	// Oversampling ratio of 23.
	LPUART_BAUD_OSR_OSR_22 = 0x16
	// Oversampling ratio of 24.
	LPUART_BAUD_OSR_OSR_23 = 0x17
	// Oversampling ratio of 25.
	LPUART_BAUD_OSR_OSR_24 = 0x18
	// Oversampling ratio of 26.
	LPUART_BAUD_OSR_OSR_25 = 0x19
	// Oversampling ratio of 27.
	LPUART_BAUD_OSR_OSR_26 = 0x1a
	// Oversampling ratio of 28.
	LPUART_BAUD_OSR_OSR_27 = 0x1b
	// Oversampling ratio of 29.
	LPUART_BAUD_OSR_OSR_28 = 0x1c
	// Oversampling ratio of 30.
	LPUART_BAUD_OSR_OSR_29 = 0x1d
	// Oversampling ratio of 31.
	LPUART_BAUD_OSR_OSR_30 = 0x1e
	// Oversampling ratio of 32.
	LPUART_BAUD_OSR_OSR_31 = 0x1f
	// Position of M10 field.
	LPUART_BAUD_M10_Pos = 0x1d
	// Bit mask of M10 field.
	LPUART_BAUD_M10_Msk = 0x20000000
	// Bit M10.
	LPUART_BAUD_M10 = 0x20000000
	// Receiver and transmitter use 7-bit to 9-bit data characters.
	LPUART_BAUD_M10_M10_0 = 0x0
	// Receiver and transmitter use 10-bit data characters.
	LPUART_BAUD_M10_M10_1 = 0x1
	// Position of MAEN2 field.
	LPUART_BAUD_MAEN2_Pos = 0x1e
	// Bit mask of MAEN2 field.
	LPUART_BAUD_MAEN2_Msk = 0x40000000
	// Bit MAEN2.
	LPUART_BAUD_MAEN2 = 0x40000000
	// Normal operation.
	LPUART_BAUD_MAEN2_MAEN2_0 = 0x0
	// Enables automatic address matching or data matching mode for MATCH[MA2].
	LPUART_BAUD_MAEN2_MAEN2_1 = 0x1
	// Position of MAEN1 field.
	LPUART_BAUD_MAEN1_Pos = 0x1f
	// Bit mask of MAEN1 field.
	LPUART_BAUD_MAEN1_Msk = 0x80000000
	// Bit MAEN1.
	LPUART_BAUD_MAEN1 = 0x80000000
	// Normal operation.
	LPUART_BAUD_MAEN1_MAEN1_0 = 0x0
	// Enables automatic address matching or data matching mode for MATCH[MA1].
	LPUART_BAUD_MAEN1_MAEN1_1 = 0x1

	// STAT: LPUART Status Register
	// Position of MA2F field.
	LPUART_STAT_MA2F_Pos = 0xe
	// Bit mask of MA2F field.
	LPUART_STAT_MA2F_Msk = 0x4000
	// Bit MA2F.
	LPUART_STAT_MA2F = 0x4000
	// Received data is not equal to MA2
	LPUART_STAT_MA2F_MA2F_0 = 0x0
	// Received data is equal to MA2
	LPUART_STAT_MA2F_MA2F_1 = 0x1
	// Position of MA1F field.
	LPUART_STAT_MA1F_Pos = 0xf
	// Bit mask of MA1F field.
	LPUART_STAT_MA1F_Msk = 0x8000
	// Bit MA1F.
	LPUART_STAT_MA1F = 0x8000
	// Received data is not equal to MA1
	LPUART_STAT_MA1F_MA1F_0 = 0x0
	// Received data is equal to MA1
	LPUART_STAT_MA1F_MA1F_1 = 0x1
	// Position of PF field.
	LPUART_STAT_PF_Pos = 0x10
	// Bit mask of PF field.
	LPUART_STAT_PF_Msk = 0x10000
	// Bit PF.
	LPUART_STAT_PF = 0x10000
	// No parity error.
	LPUART_STAT_PF_PF_0 = 0x0
	// Parity error.
	LPUART_STAT_PF_PF_1 = 0x1
	// Position of FE field.
	LPUART_STAT_FE_Pos = 0x11
	// Bit mask of FE field.
	LPUART_STAT_FE_Msk = 0x20000
	// Bit FE.
	LPUART_STAT_FE = 0x20000
	// No framing error detected. This does not guarantee the framing is correct.
	LPUART_STAT_FE_FE_0 = 0x0
	// Framing error.
	LPUART_STAT_FE_FE_1 = 0x1
	// Position of NF field.
	LPUART_STAT_NF_Pos = 0x12
	// Bit mask of NF field.
	LPUART_STAT_NF_Msk = 0x40000
	// Bit NF.
	LPUART_STAT_NF = 0x40000
	// No noise detected.
	LPUART_STAT_NF_NF_0 = 0x0
	// Noise detected in the received character in the DATA register.
	LPUART_STAT_NF_NF_1 = 0x1
	// Position of OR field.
	LPUART_STAT_OR_Pos = 0x13
	// Bit mask of OR field.
	LPUART_STAT_OR_Msk = 0x80000
	// Bit OR.
	LPUART_STAT_OR = 0x80000
	// No overrun.
	LPUART_STAT_OR_OR_0 = 0x0
	// Receive overrun (new LPUART data lost).
	LPUART_STAT_OR_OR_1 = 0x1
	// Position of IDLE field.
	LPUART_STAT_IDLE_Pos = 0x14
	// Bit mask of IDLE field.
	LPUART_STAT_IDLE_Msk = 0x100000
	// Bit IDLE.
	LPUART_STAT_IDLE = 0x100000
	// No idle line detected.
	LPUART_STAT_IDLE_IDLE_0 = 0x0
	// Idle line was detected.
	LPUART_STAT_IDLE_IDLE_1 = 0x1
	// Position of RDRF field.
	LPUART_STAT_RDRF_Pos = 0x15
	// Bit mask of RDRF field.
	LPUART_STAT_RDRF_Msk = 0x200000
	// Bit RDRF.
	LPUART_STAT_RDRF = 0x200000
	// Receive data buffer empty.
	LPUART_STAT_RDRF_RDRF_0 = 0x0
	// Receive data buffer full.
	LPUART_STAT_RDRF_RDRF_1 = 0x1
	// Position of TC field.
	LPUART_STAT_TC_Pos = 0x16
	// Bit mask of TC field.
	LPUART_STAT_TC_Msk = 0x400000
	// Bit TC.
	LPUART_STAT_TC = 0x400000
	// Transmitter active (sending data, a preamble, or a break).
	LPUART_STAT_TC_TC_0 = 0x0
	// Transmitter idle (transmission activity complete).
	LPUART_STAT_TC_TC_1 = 0x1
	// Position of TDRE field.
	LPUART_STAT_TDRE_Pos = 0x17
	// Bit mask of TDRE field.
	LPUART_STAT_TDRE_Msk = 0x800000
	// Bit TDRE.
	LPUART_STAT_TDRE = 0x800000
	// Transmit data buffer full.
	LPUART_STAT_TDRE_TDRE_0 = 0x0
	// Transmit data buffer empty.
	LPUART_STAT_TDRE_TDRE_1 = 0x1
	// Position of RAF field.
	LPUART_STAT_RAF_Pos = 0x18
	// Bit mask of RAF field.
	LPUART_STAT_RAF_Msk = 0x1000000
	// Bit RAF.
	LPUART_STAT_RAF = 0x1000000
	// LPUART receiver idle waiting for a start bit.
	LPUART_STAT_RAF_RAF_0 = 0x0
	// LPUART receiver active (RXD input not idle).
	LPUART_STAT_RAF_RAF_1 = 0x1
	// Position of LBKDE field.
	LPUART_STAT_LBKDE_Pos = 0x19
	// Bit mask of LBKDE field.
	LPUART_STAT_LBKDE_Msk = 0x2000000
	// Bit LBKDE.
	LPUART_STAT_LBKDE = 0x2000000
	// LIN break detect is disabled, normal break character can be detected.
	LPUART_STAT_LBKDE_LBKDE_0 = 0x0
	// LIN break detect is enabled. LIN break character is detected at length of 11 bit times (if M = 0) or 12 (if M = 1) or 13 (M10 = 1).
	LPUART_STAT_LBKDE_LBKDE_1 = 0x1
	// Position of BRK13 field.
	LPUART_STAT_BRK13_Pos = 0x1a
	// Bit mask of BRK13 field.
	LPUART_STAT_BRK13_Msk = 0x4000000
	// Bit BRK13.
	LPUART_STAT_BRK13 = 0x4000000
	// Break character is transmitted with length of 9 to 13 bit times.
	LPUART_STAT_BRK13_BRK13_0 = 0x0
	// Break character is transmitted with length of 12 to 15 bit times.
	LPUART_STAT_BRK13_BRK13_1 = 0x1
	// Position of RWUID field.
	LPUART_STAT_RWUID_Pos = 0x1b
	// Bit mask of RWUID field.
	LPUART_STAT_RWUID_Msk = 0x8000000
	// Bit RWUID.
	LPUART_STAT_RWUID = 0x8000000
	// During receive standby state (RWU = 1), the IDLE bit does not get set upon detection of an idle character. During address match wakeup, the IDLE bit does not set when an address does not match.
	LPUART_STAT_RWUID_RWUID_0 = 0x0
	// During receive standby state (RWU = 1), the IDLE bit gets set upon detection of an idle character. During address match wakeup, the IDLE bit does set when an address does not match.
	LPUART_STAT_RWUID_RWUID_1 = 0x1
	// Position of RXINV field.
	LPUART_STAT_RXINV_Pos = 0x1c
	// Bit mask of RXINV field.
	LPUART_STAT_RXINV_Msk = 0x10000000
	// Bit RXINV.
	LPUART_STAT_RXINV = 0x10000000
	// Receive data not inverted.
	LPUART_STAT_RXINV_RXINV_0 = 0x0
	// Receive data inverted.
	LPUART_STAT_RXINV_RXINV_1 = 0x1
	// Position of MSBF field.
	LPUART_STAT_MSBF_Pos = 0x1d
	// Bit mask of MSBF field.
	LPUART_STAT_MSBF_Msk = 0x20000000
	// Bit MSBF.
	LPUART_STAT_MSBF = 0x20000000
	// LSB (bit0) is the first bit that is transmitted following the start bit. Further, the first bit received after the start bit is identified as bit0.
	LPUART_STAT_MSBF_MSBF_0 = 0x0
	// MSB (bit9, bit8, bit7 or bit6) is the first bit that is transmitted following the start bit depending on the setting of CTRL[M], CTRL[PE] and BAUD[M10]. Further, the first bit received after the start bit is identified as bit9, bit8, bit7 or bit6 depending on the setting of CTRL[M] and CTRL[PE].
	LPUART_STAT_MSBF_MSBF_1 = 0x1
	// Position of RXEDGIF field.
	LPUART_STAT_RXEDGIF_Pos = 0x1e
	// Bit mask of RXEDGIF field.
	LPUART_STAT_RXEDGIF_Msk = 0x40000000
	// Bit RXEDGIF.
	LPUART_STAT_RXEDGIF = 0x40000000
	// No active edge on the receive pin has occurred.
	LPUART_STAT_RXEDGIF_RXEDGIF_0 = 0x0
	// An active edge on the receive pin has occurred.
	LPUART_STAT_RXEDGIF_RXEDGIF_1 = 0x1
	// Position of LBKDIF field.
	LPUART_STAT_LBKDIF_Pos = 0x1f
	// Bit mask of LBKDIF field.
	LPUART_STAT_LBKDIF_Msk = 0x80000000
	// Bit LBKDIF.
	LPUART_STAT_LBKDIF = 0x80000000
	// No LIN break character has been detected.
	LPUART_STAT_LBKDIF_LBKDIF_0 = 0x0
	// LIN break character has been detected.
	LPUART_STAT_LBKDIF_LBKDIF_1 = 0x1

	// CTRL: LPUART Control Register
	// Position of PT field.
	LPUART_CTRL_PT_Pos = 0x0
	// Bit mask of PT field.
	LPUART_CTRL_PT_Msk = 0x1
	// Bit PT.
	LPUART_CTRL_PT = 0x1
	// Even parity.
	LPUART_CTRL_PT_PT_0 = 0x0
	// Odd parity.
	LPUART_CTRL_PT_PT_1 = 0x1
	// Position of PE field.
	LPUART_CTRL_PE_Pos = 0x1
	// Bit mask of PE field.
	LPUART_CTRL_PE_Msk = 0x2
	// Bit PE.
	LPUART_CTRL_PE = 0x2
	// No hardware parity generation or checking.
	LPUART_CTRL_PE_PE_0 = 0x0
	// Parity enabled.
	LPUART_CTRL_PE_PE_1 = 0x1
	// Position of ILT field.
	LPUART_CTRL_ILT_Pos = 0x2
	// Bit mask of ILT field.
	LPUART_CTRL_ILT_Msk = 0x4
	// Bit ILT.
	LPUART_CTRL_ILT = 0x4
	// Idle character bit count starts after start bit.
	LPUART_CTRL_ILT_ILT_0 = 0x0
	// Idle character bit count starts after stop bit.
	LPUART_CTRL_ILT_ILT_1 = 0x1
	// Position of WAKE field.
	LPUART_CTRL_WAKE_Pos = 0x3
	// Bit mask of WAKE field.
	LPUART_CTRL_WAKE_Msk = 0x8
	// Bit WAKE.
	LPUART_CTRL_WAKE = 0x8
	// Configures RWU for idle-line wakeup.
	LPUART_CTRL_WAKE_WAKE_0 = 0x0
	// Configures RWU with address-mark wakeup.
	LPUART_CTRL_WAKE_WAKE_1 = 0x1
	// Position of M field.
	LPUART_CTRL_M_Pos = 0x4
	// Bit mask of M field.
	LPUART_CTRL_M_Msk = 0x10
	// Bit M.
	LPUART_CTRL_M = 0x10
	// Receiver and transmitter use 8-bit data characters.
	LPUART_CTRL_M_M_0 = 0x0
	// Receiver and transmitter use 9-bit data characters.
	LPUART_CTRL_M_M_1 = 0x1
	// Position of RSRC field.
	LPUART_CTRL_RSRC_Pos = 0x5
	// Bit mask of RSRC field.
	LPUART_CTRL_RSRC_Msk = 0x20
	// Bit RSRC.
	LPUART_CTRL_RSRC = 0x20
	// Provided LOOPS is set, RSRC is cleared, selects internal loop back mode and the LPUART does not use the RXD pin.
	LPUART_CTRL_RSRC_RSRC_0 = 0x0
	// Single-wire LPUART mode where the TXD pin is connected to the transmitter output and receiver input.
	LPUART_CTRL_RSRC_RSRC_1 = 0x1
	// Position of DOZEEN field.
	LPUART_CTRL_DOZEEN_Pos = 0x6
	// Bit mask of DOZEEN field.
	LPUART_CTRL_DOZEEN_Msk = 0x40
	// Bit DOZEEN.
	LPUART_CTRL_DOZEEN = 0x40
	// LPUART is enabled in Doze mode.
	LPUART_CTRL_DOZEEN_DOZEEN_0 = 0x0
	// LPUART is disabled in Doze mode.
	LPUART_CTRL_DOZEEN_DOZEEN_1 = 0x1
	// Position of LOOPS field.
	LPUART_CTRL_LOOPS_Pos = 0x7
	// Bit mask of LOOPS field.
	LPUART_CTRL_LOOPS_Msk = 0x80
	// Bit LOOPS.
	LPUART_CTRL_LOOPS = 0x80
	// Normal operation - RXD and TXD use separate pins.
	LPUART_CTRL_LOOPS_LOOPS_0 = 0x0
	// Loop mode or single-wire mode where transmitter outputs are internally connected to receiver input (see RSRC bit).
	LPUART_CTRL_LOOPS_LOOPS_1 = 0x1
	// Position of IDLECFG field.
	LPUART_CTRL_IDLECFG_Pos = 0x8
	// Bit mask of IDLECFG field.
	LPUART_CTRL_IDLECFG_Msk = 0x700
	// 1 idle character
	LPUART_CTRL_IDLECFG_IDLECFG_0 = 0x0
	// 2 idle characters
	LPUART_CTRL_IDLECFG_IDLECFG_1 = 0x1
	// 4 idle characters
	LPUART_CTRL_IDLECFG_IDLECFG_2 = 0x2
	// 8 idle characters
	LPUART_CTRL_IDLECFG_IDLECFG_3 = 0x3
	// 16 idle characters
	LPUART_CTRL_IDLECFG_IDLECFG_4 = 0x4
	// 32 idle characters
	LPUART_CTRL_IDLECFG_IDLECFG_5 = 0x5
	// 64 idle characters
	LPUART_CTRL_IDLECFG_IDLECFG_6 = 0x6
	// 128 idle characters
	LPUART_CTRL_IDLECFG_IDLECFG_7 = 0x7
	// Position of M7 field.
	LPUART_CTRL_M7_Pos = 0xb
	// Bit mask of M7 field.
	LPUART_CTRL_M7_Msk = 0x800
	// Bit M7.
	LPUART_CTRL_M7 = 0x800
	// Receiver and transmitter use 8-bit to 10-bit data characters.
	LPUART_CTRL_M7_M7_0 = 0x0
	// Receiver and transmitter use 7-bit data characters.
	LPUART_CTRL_M7_M7_1 = 0x1
	// Position of MA2IE field.
	LPUART_CTRL_MA2IE_Pos = 0xe
	// Bit mask of MA2IE field.
	LPUART_CTRL_MA2IE_Msk = 0x4000
	// Bit MA2IE.
	LPUART_CTRL_MA2IE = 0x4000
	// MA2F interrupt disabled
	LPUART_CTRL_MA2IE_MA2IE_0 = 0x0
	// MA2F interrupt enabled
	LPUART_CTRL_MA2IE_MA2IE_1 = 0x1
	// Position of MA1IE field.
	LPUART_CTRL_MA1IE_Pos = 0xf
	// Bit mask of MA1IE field.
	LPUART_CTRL_MA1IE_Msk = 0x8000
	// Bit MA1IE.
	LPUART_CTRL_MA1IE = 0x8000
	// MA1F interrupt disabled
	LPUART_CTRL_MA1IE_MA1IE_0 = 0x0
	// MA1F interrupt enabled
	LPUART_CTRL_MA1IE_MA1IE_1 = 0x1
	// Position of SBK field.
	LPUART_CTRL_SBK_Pos = 0x10
	// Bit mask of SBK field.
	LPUART_CTRL_SBK_Msk = 0x10000
	// Bit SBK.
	LPUART_CTRL_SBK = 0x10000
	// Normal transmitter operation.
	LPUART_CTRL_SBK_SBK_0 = 0x0
	// Queue break character(s) to be sent.
	LPUART_CTRL_SBK_SBK_1 = 0x1
	// Position of RWU field.
	LPUART_CTRL_RWU_Pos = 0x11
	// Bit mask of RWU field.
	LPUART_CTRL_RWU_Msk = 0x20000
	// Bit RWU.
	LPUART_CTRL_RWU = 0x20000
	// Normal receiver operation.
	LPUART_CTRL_RWU_RWU_0 = 0x0
	// LPUART receiver in standby waiting for wakeup condition.
	LPUART_CTRL_RWU_RWU_1 = 0x1
	// Position of RE field.
	LPUART_CTRL_RE_Pos = 0x12
	// Bit mask of RE field.
	LPUART_CTRL_RE_Msk = 0x40000
	// Bit RE.
	LPUART_CTRL_RE = 0x40000
	// Receiver disabled.
	LPUART_CTRL_RE_RE_0 = 0x0
	// Receiver enabled.
	LPUART_CTRL_RE_RE_1 = 0x1
	// Position of TE field.
	LPUART_CTRL_TE_Pos = 0x13
	// Bit mask of TE field.
	LPUART_CTRL_TE_Msk = 0x80000
	// Bit TE.
	LPUART_CTRL_TE = 0x80000
	// Transmitter disabled.
	LPUART_CTRL_TE_TE_0 = 0x0
	// Transmitter enabled.
	LPUART_CTRL_TE_TE_1 = 0x1
	// Position of ILIE field.
	LPUART_CTRL_ILIE_Pos = 0x14
	// Bit mask of ILIE field.
	LPUART_CTRL_ILIE_Msk = 0x100000
	// Bit ILIE.
	LPUART_CTRL_ILIE = 0x100000
	// Hardware interrupts from IDLE disabled; use polling.
	LPUART_CTRL_ILIE_ILIE_0 = 0x0
	// Hardware interrupt requested when IDLE flag is 1.
	LPUART_CTRL_ILIE_ILIE_1 = 0x1
	// Position of RIE field.
	LPUART_CTRL_RIE_Pos = 0x15
	// Bit mask of RIE field.
	LPUART_CTRL_RIE_Msk = 0x200000
	// Bit RIE.
	LPUART_CTRL_RIE = 0x200000
	// Hardware interrupts from RDRF disabled; use polling.
	LPUART_CTRL_RIE_RIE_0 = 0x0
	// Hardware interrupt requested when RDRF flag is 1.
	LPUART_CTRL_RIE_RIE_1 = 0x1
	// Position of TCIE field.
	LPUART_CTRL_TCIE_Pos = 0x16
	// Bit mask of TCIE field.
	LPUART_CTRL_TCIE_Msk = 0x400000
	// Bit TCIE.
	LPUART_CTRL_TCIE = 0x400000
	// Hardware interrupts from TC disabled; use polling.
	LPUART_CTRL_TCIE_TCIE_0 = 0x0
	// Hardware interrupt requested when TC flag is 1.
	LPUART_CTRL_TCIE_TCIE_1 = 0x1
	// Position of TIE field.
	LPUART_CTRL_TIE_Pos = 0x17
	// Bit mask of TIE field.
	LPUART_CTRL_TIE_Msk = 0x800000
	// Bit TIE.
	LPUART_CTRL_TIE = 0x800000
	// Hardware interrupts from TDRE disabled; use polling.
	LPUART_CTRL_TIE_TIE_0 = 0x0
	// Hardware interrupt requested when TDRE flag is 1.
	LPUART_CTRL_TIE_TIE_1 = 0x1
	// Position of PEIE field.
	LPUART_CTRL_PEIE_Pos = 0x18
	// Bit mask of PEIE field.
	LPUART_CTRL_PEIE_Msk = 0x1000000
	// Bit PEIE.
	LPUART_CTRL_PEIE = 0x1000000
	// PF interrupts disabled; use polling).
	LPUART_CTRL_PEIE_PEIE_0 = 0x0
	// Hardware interrupt requested when PF is set.
	LPUART_CTRL_PEIE_PEIE_1 = 0x1
	// Position of FEIE field.
	LPUART_CTRL_FEIE_Pos = 0x19
	// Bit mask of FEIE field.
	LPUART_CTRL_FEIE_Msk = 0x2000000
	// Bit FEIE.
	LPUART_CTRL_FEIE = 0x2000000
	// FE interrupts disabled; use polling.
	LPUART_CTRL_FEIE_FEIE_0 = 0x0
	// Hardware interrupt requested when FE is set.
	LPUART_CTRL_FEIE_FEIE_1 = 0x1
	// Position of NEIE field.
	LPUART_CTRL_NEIE_Pos = 0x1a
	// Bit mask of NEIE field.
	LPUART_CTRL_NEIE_Msk = 0x4000000
	// Bit NEIE.
	LPUART_CTRL_NEIE = 0x4000000
	// NF interrupts disabled; use polling.
	LPUART_CTRL_NEIE_NEIE_0 = 0x0
	// Hardware interrupt requested when NF is set.
	LPUART_CTRL_NEIE_NEIE_1 = 0x1
	// Position of ORIE field.
	LPUART_CTRL_ORIE_Pos = 0x1b
	// Bit mask of ORIE field.
	LPUART_CTRL_ORIE_Msk = 0x8000000
	// Bit ORIE.
	LPUART_CTRL_ORIE = 0x8000000
	// OR interrupts disabled; use polling.
	LPUART_CTRL_ORIE_ORIE_0 = 0x0
	// Hardware interrupt requested when OR is set.
	LPUART_CTRL_ORIE_ORIE_1 = 0x1
	// Position of TXINV field.
	LPUART_CTRL_TXINV_Pos = 0x1c
	// Bit mask of TXINV field.
	LPUART_CTRL_TXINV_Msk = 0x10000000
	// Bit TXINV.
	LPUART_CTRL_TXINV = 0x10000000
	// Transmit data not inverted.
	LPUART_CTRL_TXINV_TXINV_0 = 0x0
	// Transmit data inverted.
	LPUART_CTRL_TXINV_TXINV_1 = 0x1
	// Position of TXDIR field.
	LPUART_CTRL_TXDIR_Pos = 0x1d
	// Bit mask of TXDIR field.
	LPUART_CTRL_TXDIR_Msk = 0x20000000
	// Bit TXDIR.
	LPUART_CTRL_TXDIR = 0x20000000
	// TXD pin is an input in single-wire mode.
	LPUART_CTRL_TXDIR_TXDIR_0 = 0x0
	// TXD pin is an output in single-wire mode.
	LPUART_CTRL_TXDIR_TXDIR_1 = 0x1
	// Position of R9T8 field.
	LPUART_CTRL_R9T8_Pos = 0x1e
	// Bit mask of R9T8 field.
	LPUART_CTRL_R9T8_Msk = 0x40000000
	// Bit R9T8.
	LPUART_CTRL_R9T8 = 0x40000000
	// Position of R8T9 field.
	LPUART_CTRL_R8T9_Pos = 0x1f
	// Bit mask of R8T9 field.
	LPUART_CTRL_R8T9_Msk = 0x80000000
	// Bit R8T9.
	LPUART_CTRL_R8T9 = 0x80000000

	// DATA: LPUART Data Register
	// Position of R0T0 field.
	LPUART_DATA_R0T0_Pos = 0x0
	// Bit mask of R0T0 field.
	LPUART_DATA_R0T0_Msk = 0x1
	// Bit R0T0.
	LPUART_DATA_R0T0 = 0x1
	// Position of R1T1 field.
	LPUART_DATA_R1T1_Pos = 0x1
	// Bit mask of R1T1 field.
	LPUART_DATA_R1T1_Msk = 0x2
	// Bit R1T1.
	LPUART_DATA_R1T1 = 0x2
	// Position of R2T2 field.
	LPUART_DATA_R2T2_Pos = 0x2
	// Bit mask of R2T2 field.
	LPUART_DATA_R2T2_Msk = 0x4
	// Bit R2T2.
	LPUART_DATA_R2T2 = 0x4
	// Position of R3T3 field.
	LPUART_DATA_R3T3_Pos = 0x3
	// Bit mask of R3T3 field.
	LPUART_DATA_R3T3_Msk = 0x8
	// Bit R3T3.
	LPUART_DATA_R3T3 = 0x8
	// Position of R4T4 field.
	LPUART_DATA_R4T4_Pos = 0x4
	// Bit mask of R4T4 field.
	LPUART_DATA_R4T4_Msk = 0x10
	// Bit R4T4.
	LPUART_DATA_R4T4 = 0x10
	// Position of R5T5 field.
	LPUART_DATA_R5T5_Pos = 0x5
	// Bit mask of R5T5 field.
	LPUART_DATA_R5T5_Msk = 0x20
	// Bit R5T5.
	LPUART_DATA_R5T5 = 0x20
	// Position of R6T6 field.
	LPUART_DATA_R6T6_Pos = 0x6
	// Bit mask of R6T6 field.
	LPUART_DATA_R6T6_Msk = 0x40
	// Bit R6T6.
	LPUART_DATA_R6T6 = 0x40
	// Position of R7T7 field.
	LPUART_DATA_R7T7_Pos = 0x7
	// Bit mask of R7T7 field.
	LPUART_DATA_R7T7_Msk = 0x80
	// Bit R7T7.
	LPUART_DATA_R7T7 = 0x80
	// Position of R8T8 field.
	LPUART_DATA_R8T8_Pos = 0x8
	// Bit mask of R8T8 field.
	LPUART_DATA_R8T8_Msk = 0x100
	// Bit R8T8.
	LPUART_DATA_R8T8 = 0x100
	// Position of R9T9 field.
	LPUART_DATA_R9T9_Pos = 0x9
	// Bit mask of R9T9 field.
	LPUART_DATA_R9T9_Msk = 0x200
	// Bit R9T9.
	LPUART_DATA_R9T9 = 0x200
	// Position of IDLINE field.
	LPUART_DATA_IDLINE_Pos = 0xb
	// Bit mask of IDLINE field.
	LPUART_DATA_IDLINE_Msk = 0x800
	// Bit IDLINE.
	LPUART_DATA_IDLINE = 0x800
	// Receiver was not idle before receiving this character.
	LPUART_DATA_IDLINE_IDLINE_0 = 0x0
	// Receiver was idle before receiving this character.
	LPUART_DATA_IDLINE_IDLINE_1 = 0x1
	// Position of RXEMPT field.
	LPUART_DATA_RXEMPT_Pos = 0xc
	// Bit mask of RXEMPT field.
	LPUART_DATA_RXEMPT_Msk = 0x1000
	// Bit RXEMPT.
	LPUART_DATA_RXEMPT = 0x1000
	// Receive buffer contains valid data.
	LPUART_DATA_RXEMPT_RXEMPT_0 = 0x0
	// Receive buffer is empty, data returned on read is not valid.
	LPUART_DATA_RXEMPT_RXEMPT_1 = 0x1
	// Position of FRETSC field.
	LPUART_DATA_FRETSC_Pos = 0xd
	// Bit mask of FRETSC field.
	LPUART_DATA_FRETSC_Msk = 0x2000
	// Bit FRETSC.
	LPUART_DATA_FRETSC = 0x2000
	// The dataword was received without a frame error on read, or transmit a normal character on write.
	LPUART_DATA_FRETSC_FRETSC_0 = 0x0
	// The dataword was received with a frame error, or transmit an idle or break character on transmit.
	LPUART_DATA_FRETSC_FRETSC_1 = 0x1
	// Position of PARITYE field.
	LPUART_DATA_PARITYE_Pos = 0xe
	// Bit mask of PARITYE field.
	LPUART_DATA_PARITYE_Msk = 0x4000
	// Bit PARITYE.
	LPUART_DATA_PARITYE = 0x4000
	// The dataword was received without a parity error.
	LPUART_DATA_PARITYE_PARITYE_0 = 0x0
	// The dataword was received with a parity error.
	LPUART_DATA_PARITYE_PARITYE_1 = 0x1
	// Position of NOISY field.
	LPUART_DATA_NOISY_Pos = 0xf
	// Bit mask of NOISY field.
	LPUART_DATA_NOISY_Msk = 0x8000
	// Bit NOISY.
	LPUART_DATA_NOISY = 0x8000
	// The dataword was received without noise.
	LPUART_DATA_NOISY_NOISY_0 = 0x0
	// The data was received with noise.
	LPUART_DATA_NOISY_NOISY_1 = 0x1

	// MATCH: LPUART Match Address Register
	// Position of MA1 field.
	LPUART_MATCH_MA1_Pos = 0x0
	// Bit mask of MA1 field.
	LPUART_MATCH_MA1_Msk = 0x3ff
	// Position of MA2 field.
	LPUART_MATCH_MA2_Pos = 0x10
	// Bit mask of MA2 field.
	LPUART_MATCH_MA2_Msk = 0x3ff0000

	// MODIR: LPUART Modem IrDA Register
	// Position of TXCTSE field.
	LPUART_MODIR_TXCTSE_Pos = 0x0
	// Bit mask of TXCTSE field.
	LPUART_MODIR_TXCTSE_Msk = 0x1
	// Bit TXCTSE.
	LPUART_MODIR_TXCTSE = 0x1
	// CTS has no effect on the transmitter.
	LPUART_MODIR_TXCTSE_TXCTSE_0 = 0x0
	// Enables clear-to-send operation. The transmitter checks the state of CTS each time it is ready to send a character. If CTS is asserted, the character is sent. If CTS is deasserted, the signal TXD remains in the mark state and transmission is delayed until CTS is asserted. Changes in CTS as a character is being sent do not affect its transmission.
	LPUART_MODIR_TXCTSE_TXCTSE_1 = 0x1
	// Position of TXRTSE field.
	LPUART_MODIR_TXRTSE_Pos = 0x1
	// Bit mask of TXRTSE field.
	LPUART_MODIR_TXRTSE_Msk = 0x2
	// Bit TXRTSE.
	LPUART_MODIR_TXRTSE = 0x2
	// The transmitter has no effect on RTS.
	LPUART_MODIR_TXRTSE_TXRTSE_0 = 0x0
	// When a character is placed into an empty transmitter data buffer , RTS asserts one bit time before the start bit is transmitted. RTS deasserts one bit time after all characters in the transmitter data buffer and shift register are completely sent, including the last stop bit.
	LPUART_MODIR_TXRTSE_TXRTSE_1 = 0x1
	// Position of TXRTSPOL field.
	LPUART_MODIR_TXRTSPOL_Pos = 0x2
	// Bit mask of TXRTSPOL field.
	LPUART_MODIR_TXRTSPOL_Msk = 0x4
	// Bit TXRTSPOL.
	LPUART_MODIR_TXRTSPOL = 0x4
	// Transmitter RTS is active low.
	LPUART_MODIR_TXRTSPOL_TXRTSPOL_0 = 0x0
	// Transmitter RTS is active high.
	LPUART_MODIR_TXRTSPOL_TXRTSPOL_1 = 0x1
	// Position of RXRTSE field.
	LPUART_MODIR_RXRTSE_Pos = 0x3
	// Bit mask of RXRTSE field.
	LPUART_MODIR_RXRTSE_Msk = 0x8
	// Bit RXRTSE.
	LPUART_MODIR_RXRTSE = 0x8
	// The receiver has no effect on RTS.
	LPUART_MODIR_RXRTSE_RXRTSE_0 = 0x0
	// RTS is deasserted if the receiver data register is full or a start bit has been detected that would cause the receiver data register to become full. RTS is asserted if the receiver data register is not full and has not detected a start bit that would cause the receiver data register to become full.
	LPUART_MODIR_RXRTSE_RXRTSE_1 = 0x1
	// Position of TXCTSC field.
	LPUART_MODIR_TXCTSC_Pos = 0x4
	// Bit mask of TXCTSC field.
	LPUART_MODIR_TXCTSC_Msk = 0x10
	// Bit TXCTSC.
	LPUART_MODIR_TXCTSC = 0x10
	// CTS input is sampled at the start of each character.
	LPUART_MODIR_TXCTSC_TXCTSC_0 = 0x0
	// CTS input is sampled when the transmitter is idle.
	LPUART_MODIR_TXCTSC_TXCTSC_1 = 0x1
	// Position of TXCTSSRC field.
	LPUART_MODIR_TXCTSSRC_Pos = 0x5
	// Bit mask of TXCTSSRC field.
	LPUART_MODIR_TXCTSSRC_Msk = 0x20
	// Bit TXCTSSRC.
	LPUART_MODIR_TXCTSSRC = 0x20
	// CTS input is the CTS_B pin.
	LPUART_MODIR_TXCTSSRC_TXCTSSRC_0 = 0x0
	// CTS input is the inverted Receiver Match result.
	LPUART_MODIR_TXCTSSRC_TXCTSSRC_1 = 0x1
	// Position of RTSWATER field.
	LPUART_MODIR_RTSWATER_Pos = 0x8
	// Bit mask of RTSWATER field.
	LPUART_MODIR_RTSWATER_Msk = 0x300
	// Position of TNP field.
	LPUART_MODIR_TNP_Pos = 0x10
	// Bit mask of TNP field.
	LPUART_MODIR_TNP_Msk = 0x30000
	// 1/OSR.
	LPUART_MODIR_TNP_TNP_0 = 0x0
	// 2/OSR.
	LPUART_MODIR_TNP_TNP_1 = 0x1
	// 3/OSR.
	LPUART_MODIR_TNP_TNP_2 = 0x2
	// 4/OSR.
	LPUART_MODIR_TNP_TNP_3 = 0x3
	// Position of IREN field.
	LPUART_MODIR_IREN_Pos = 0x12
	// Bit mask of IREN field.
	LPUART_MODIR_IREN_Msk = 0x40000
	// Bit IREN.
	LPUART_MODIR_IREN = 0x40000
	// IR disabled.
	LPUART_MODIR_IREN_IREN_0 = 0x0
	// IR enabled.
	LPUART_MODIR_IREN_IREN_1 = 0x1

	// FIFO: LPUART FIFO Register
	// Position of RXFIFOSIZE field.
	LPUART_FIFO_RXFIFOSIZE_Pos = 0x0
	// Bit mask of RXFIFOSIZE field.
	LPUART_FIFO_RXFIFOSIZE_Msk = 0x7
	// Receive FIFO/Buffer depth = 1 dataword.
	LPUART_FIFO_RXFIFOSIZE_RXFIFOSIZE_0 = 0x0
	// Receive FIFO/Buffer depth = 4 datawords.
	LPUART_FIFO_RXFIFOSIZE_RXFIFOSIZE_1 = 0x1
	// Receive FIFO/Buffer depth = 8 datawords.
	LPUART_FIFO_RXFIFOSIZE_RXFIFOSIZE_2 = 0x2
	// Receive FIFO/Buffer depth = 16 datawords.
	LPUART_FIFO_RXFIFOSIZE_RXFIFOSIZE_3 = 0x3
	// Receive FIFO/Buffer depth = 32 datawords.
	LPUART_FIFO_RXFIFOSIZE_RXFIFOSIZE_4 = 0x4
	// Receive FIFO/Buffer depth = 64 datawords.
	LPUART_FIFO_RXFIFOSIZE_RXFIFOSIZE_5 = 0x5
	// Receive FIFO/Buffer depth = 128 datawords.
	LPUART_FIFO_RXFIFOSIZE_RXFIFOSIZE_6 = 0x6
	// Receive FIFO/Buffer depth = 256 datawords.
	LPUART_FIFO_RXFIFOSIZE_RXFIFOSIZE_7 = 0x7
	// Position of RXFE field.
	LPUART_FIFO_RXFE_Pos = 0x3
	// Bit mask of RXFE field.
	LPUART_FIFO_RXFE_Msk = 0x8
	// Bit RXFE.
	LPUART_FIFO_RXFE = 0x8
	// Receive FIFO is not enabled. Buffer is depth 1.
	LPUART_FIFO_RXFE_RXFE_0 = 0x0
	// Receive FIFO is enabled. Buffer is depth indicted by RXFIFOSIZE.
	LPUART_FIFO_RXFE_RXFE_1 = 0x1
	// Position of TXFIFOSIZE field.
	LPUART_FIFO_TXFIFOSIZE_Pos = 0x4
	// Bit mask of TXFIFOSIZE field.
	LPUART_FIFO_TXFIFOSIZE_Msk = 0x70
	// Transmit FIFO/Buffer depth = 1 dataword.
	LPUART_FIFO_TXFIFOSIZE_TXFIFOSIZE_0 = 0x0
	// Transmit FIFO/Buffer depth = 4 datawords.
	LPUART_FIFO_TXFIFOSIZE_TXFIFOSIZE_1 = 0x1
	// Transmit FIFO/Buffer depth = 8 datawords.
	LPUART_FIFO_TXFIFOSIZE_TXFIFOSIZE_2 = 0x2
	// Transmit FIFO/Buffer depth = 16 datawords.
	LPUART_FIFO_TXFIFOSIZE_TXFIFOSIZE_3 = 0x3
	// Transmit FIFO/Buffer depth = 32 datawords.
	LPUART_FIFO_TXFIFOSIZE_TXFIFOSIZE_4 = 0x4
	// Transmit FIFO/Buffer depth = 64 datawords.
	LPUART_FIFO_TXFIFOSIZE_TXFIFOSIZE_5 = 0x5
	// Transmit FIFO/Buffer depth = 128 datawords.
	LPUART_FIFO_TXFIFOSIZE_TXFIFOSIZE_6 = 0x6
	// Transmit FIFO/Buffer depth = 256 datawords
	LPUART_FIFO_TXFIFOSIZE_TXFIFOSIZE_7 = 0x7
	// Position of TXFE field.
	LPUART_FIFO_TXFE_Pos = 0x7
	// Bit mask of TXFE field.
	LPUART_FIFO_TXFE_Msk = 0x80
	// Bit TXFE.
	LPUART_FIFO_TXFE = 0x80
	// Transmit FIFO is not enabled. Buffer is depth 1.
	LPUART_FIFO_TXFE_TXFE_0 = 0x0
	// Transmit FIFO is enabled. Buffer is depth indicated by TXFIFOSIZE.
	LPUART_FIFO_TXFE_TXFE_1 = 0x1
	// Position of RXUFE field.
	LPUART_FIFO_RXUFE_Pos = 0x8
	// Bit mask of RXUFE field.
	LPUART_FIFO_RXUFE_Msk = 0x100
	// Bit RXUFE.
	LPUART_FIFO_RXUFE = 0x100
	// RXUF flag does not generate an interrupt to the host.
	LPUART_FIFO_RXUFE_RXUFE_0 = 0x0
	// RXUF flag generates an interrupt to the host.
	LPUART_FIFO_RXUFE_RXUFE_1 = 0x1
	// Position of TXOFE field.
	LPUART_FIFO_TXOFE_Pos = 0x9
	// Bit mask of TXOFE field.
	LPUART_FIFO_TXOFE_Msk = 0x200
	// Bit TXOFE.
	LPUART_FIFO_TXOFE = 0x200
	// TXOF flag does not generate an interrupt to the host.
	LPUART_FIFO_TXOFE_TXOFE_0 = 0x0
	// TXOF flag generates an interrupt to the host.
	LPUART_FIFO_TXOFE_TXOFE_1 = 0x1
	// Position of RXIDEN field.
	LPUART_FIFO_RXIDEN_Pos = 0xa
	// Bit mask of RXIDEN field.
	LPUART_FIFO_RXIDEN_Msk = 0x1c00
	// Disable RDRF assertion due to partially filled FIFO when receiver is idle.
	LPUART_FIFO_RXIDEN_RXIDEN_0 = 0x0
	// Enable RDRF assertion due to partially filled FIFO when receiver is idle for 1 character.
	LPUART_FIFO_RXIDEN_RXIDEN_1 = 0x1
	// Enable RDRF assertion due to partially filled FIFO when receiver is idle for 2 characters.
	LPUART_FIFO_RXIDEN_RXIDEN_2 = 0x2
	// Enable RDRF assertion due to partially filled FIFO when receiver is idle for 4 characters.
	LPUART_FIFO_RXIDEN_RXIDEN_3 = 0x3
	// Enable RDRF assertion due to partially filled FIFO when receiver is idle for 8 characters.
	LPUART_FIFO_RXIDEN_RXIDEN_4 = 0x4
	// Enable RDRF assertion due to partially filled FIFO when receiver is idle for 16 characters.
	LPUART_FIFO_RXIDEN_RXIDEN_5 = 0x5
	// Enable RDRF assertion due to partially filled FIFO when receiver is idle for 32 characters.
	LPUART_FIFO_RXIDEN_RXIDEN_6 = 0x6
	// Enable RDRF assertion due to partially filled FIFO when receiver is idle for 64 characters.
	LPUART_FIFO_RXIDEN_RXIDEN_7 = 0x7
	// Position of RXFLUSH field.
	LPUART_FIFO_RXFLUSH_Pos = 0xe
	// Bit mask of RXFLUSH field.
	LPUART_FIFO_RXFLUSH_Msk = 0x4000
	// Bit RXFLUSH.
	LPUART_FIFO_RXFLUSH = 0x4000
	// No flush operation occurs.
	LPUART_FIFO_RXFLUSH_RXFLUSH_0 = 0x0
	// All data in the receive FIFO/buffer is cleared out.
	LPUART_FIFO_RXFLUSH_RXFLUSH_1 = 0x1
	// Position of TXFLUSH field.
	LPUART_FIFO_TXFLUSH_Pos = 0xf
	// Bit mask of TXFLUSH field.
	LPUART_FIFO_TXFLUSH_Msk = 0x8000
	// Bit TXFLUSH.
	LPUART_FIFO_TXFLUSH = 0x8000
	// No flush operation occurs.
	LPUART_FIFO_TXFLUSH_TXFLUSH_0 = 0x0
	// All data in the transmit FIFO/Buffer is cleared out.
	LPUART_FIFO_TXFLUSH_TXFLUSH_1 = 0x1
	// Position of RXUF field.
	LPUART_FIFO_RXUF_Pos = 0x10
	// Bit mask of RXUF field.
	LPUART_FIFO_RXUF_Msk = 0x10000
	// Bit RXUF.
	LPUART_FIFO_RXUF = 0x10000
	// No receive buffer underflow has occurred since the last time the flag was cleared.
	LPUART_FIFO_RXUF_RXUF_0 = 0x0
	// At least one receive buffer underflow has occurred since the last time the flag was cleared.
	LPUART_FIFO_RXUF_RXUF_1 = 0x1
	// Position of TXOF field.
	LPUART_FIFO_TXOF_Pos = 0x11
	// Bit mask of TXOF field.
	LPUART_FIFO_TXOF_Msk = 0x20000
	// Bit TXOF.
	LPUART_FIFO_TXOF = 0x20000
	// No transmit buffer overflow has occurred since the last time the flag was cleared.
	LPUART_FIFO_TXOF_TXOF_0 = 0x0
	// At least one transmit buffer overflow has occurred since the last time the flag was cleared.
	LPUART_FIFO_TXOF_TXOF_1 = 0x1
	// Position of RXEMPT field.
	LPUART_FIFO_RXEMPT_Pos = 0x16
	// Bit mask of RXEMPT field.
	LPUART_FIFO_RXEMPT_Msk = 0x400000
	// Bit RXEMPT.
	LPUART_FIFO_RXEMPT = 0x400000
	// Receive buffer is not empty.
	LPUART_FIFO_RXEMPT_RXEMPT_0 = 0x0
	// Receive buffer is empty.
	LPUART_FIFO_RXEMPT_RXEMPT_1 = 0x1
	// Position of TXEMPT field.
	LPUART_FIFO_TXEMPT_Pos = 0x17
	// Bit mask of TXEMPT field.
	LPUART_FIFO_TXEMPT_Msk = 0x800000
	// Bit TXEMPT.
	LPUART_FIFO_TXEMPT = 0x800000
	// Transmit buffer is not empty.
	LPUART_FIFO_TXEMPT_TXEMPT_0 = 0x0
	// Transmit buffer is empty.
	LPUART_FIFO_TXEMPT_TXEMPT_1 = 0x1

	// WATER: LPUART Watermark Register
	// Position of TXWATER field.
	LPUART_WATER_TXWATER_Pos = 0x0
	// Bit mask of TXWATER field.
	LPUART_WATER_TXWATER_Msk = 0x3
	// Position of TXCOUNT field.
	LPUART_WATER_TXCOUNT_Pos = 0x8
	// Bit mask of TXCOUNT field.
	LPUART_WATER_TXCOUNT_Msk = 0x700
	// Position of RXWATER field.
	LPUART_WATER_RXWATER_Pos = 0x10
	// Bit mask of RXWATER field.
	LPUART_WATER_RXWATER_Msk = 0x30000
	// Position of RXCOUNT field.
	LPUART_WATER_RXCOUNT_Pos = 0x18
	// Bit mask of RXCOUNT field.
	LPUART_WATER_RXCOUNT_Msk = 0x7000000
)

// Bitfields for FLEXIO1: FLEXIO
const (
	// VERID: Version ID Register
	// Position of FEATURE field.
	FLEXIO_VERID_FEATURE_Pos = 0x0
	// Bit mask of FEATURE field.
	FLEXIO_VERID_FEATURE_Msk = 0xffff
	// Standard features implemented.
	FLEXIO_VERID_FEATURE_FEATURE_0 = 0x0
	// Supports state, logic and parallel modes.
	FLEXIO_VERID_FEATURE_FEATURE_1 = 0x1
	// Position of MINOR field.
	FLEXIO_VERID_MINOR_Pos = 0x10
	// Bit mask of MINOR field.
	FLEXIO_VERID_MINOR_Msk = 0xff0000
	// Position of MAJOR field.
	FLEXIO_VERID_MAJOR_Pos = 0x18
	// Bit mask of MAJOR field.
	FLEXIO_VERID_MAJOR_Msk = 0xff000000

	// PARAM: Parameter Register
	// Position of SHIFTER field.
	FLEXIO_PARAM_SHIFTER_Pos = 0x0
	// Bit mask of SHIFTER field.
	FLEXIO_PARAM_SHIFTER_Msk = 0xff
	// Position of TIMER field.
	FLEXIO_PARAM_TIMER_Pos = 0x8
	// Bit mask of TIMER field.
	FLEXIO_PARAM_TIMER_Msk = 0xff00
	// Position of PIN field.
	FLEXIO_PARAM_PIN_Pos = 0x10
	// Bit mask of PIN field.
	FLEXIO_PARAM_PIN_Msk = 0xff0000
	// Position of TRIGGER field.
	FLEXIO_PARAM_TRIGGER_Pos = 0x18
	// Bit mask of TRIGGER field.
	FLEXIO_PARAM_TRIGGER_Msk = 0xff000000

	// CTRL: FlexIO Control Register
	// Position of FLEXEN field.
	FLEXIO_CTRL_FLEXEN_Pos = 0x0
	// Bit mask of FLEXEN field.
	FLEXIO_CTRL_FLEXEN_Msk = 0x1
	// Bit FLEXEN.
	FLEXIO_CTRL_FLEXEN = 0x1
	// FlexIO module is disabled.
	FLEXIO_CTRL_FLEXEN_FLEXEN_0 = 0x0
	// FlexIO module is enabled.
	FLEXIO_CTRL_FLEXEN_FLEXEN_1 = 0x1
	// Position of SWRST field.
	FLEXIO_CTRL_SWRST_Pos = 0x1
	// Bit mask of SWRST field.
	FLEXIO_CTRL_SWRST_Msk = 0x2
	// Bit SWRST.
	FLEXIO_CTRL_SWRST = 0x2
	// Software reset is disabled
	FLEXIO_CTRL_SWRST_SWRST_0 = 0x0
	// Software reset is enabled, all FlexIO registers except the Control Register are reset.
	FLEXIO_CTRL_SWRST_SWRST_1 = 0x1
	// Position of FASTACC field.
	FLEXIO_CTRL_FASTACC_Pos = 0x2
	// Bit mask of FASTACC field.
	FLEXIO_CTRL_FASTACC_Msk = 0x4
	// Bit FASTACC.
	FLEXIO_CTRL_FASTACC = 0x4
	// Configures for normal register accesses to FlexIO
	FLEXIO_CTRL_FASTACC_FASTACC_0 = 0x0
	// Configures for fast register accesses to FlexIO
	FLEXIO_CTRL_FASTACC_FASTACC_1 = 0x1
	// Position of DBGE field.
	FLEXIO_CTRL_DBGE_Pos = 0x1e
	// Bit mask of DBGE field.
	FLEXIO_CTRL_DBGE_Msk = 0x40000000
	// Bit DBGE.
	FLEXIO_CTRL_DBGE = 0x40000000
	// FlexIO is disabled in debug modes.
	FLEXIO_CTRL_DBGE_DBGE_0 = 0x0
	// FlexIO is enabled in debug modes
	FLEXIO_CTRL_DBGE_DBGE_1 = 0x1
	// Position of DOZEN field.
	FLEXIO_CTRL_DOZEN_Pos = 0x1f
	// Bit mask of DOZEN field.
	FLEXIO_CTRL_DOZEN_Msk = 0x80000000
	// Bit DOZEN.
	FLEXIO_CTRL_DOZEN = 0x80000000
	// FlexIO enabled in Doze modes.
	FLEXIO_CTRL_DOZEN_DOZEN_0 = 0x0
	// FlexIO disabled in Doze modes.
	FLEXIO_CTRL_DOZEN_DOZEN_1 = 0x1

	// PIN: Pin State Register
	// Position of PDI field.
	FLEXIO_PIN_PDI_Pos = 0x0
	// Bit mask of PDI field.
	FLEXIO_PIN_PDI_Msk = 0xffff

	// SHIFTSTAT: Shifter Status Register
	// Position of SSF field.
	FLEXIO_SHIFTSTAT_SSF_Pos = 0x0
	// Bit mask of SSF field.
	FLEXIO_SHIFTSTAT_SSF_Msk = 0xf

	// SHIFTERR: Shifter Error Register
	// Position of SEF field.
	FLEXIO_SHIFTERR_SEF_Pos = 0x0
	// Bit mask of SEF field.
	FLEXIO_SHIFTERR_SEF_Msk = 0xf

	// TIMSTAT: Timer Status Register
	// Position of TSF field.
	FLEXIO_TIMSTAT_TSF_Pos = 0x0
	// Bit mask of TSF field.
	FLEXIO_TIMSTAT_TSF_Msk = 0xf

	// SHIFTSIEN: Shifter Status Interrupt Enable
	// Position of SSIE field.
	FLEXIO_SHIFTSIEN_SSIE_Pos = 0x0
	// Bit mask of SSIE field.
	FLEXIO_SHIFTSIEN_SSIE_Msk = 0xf

	// SHIFTEIEN: Shifter Error Interrupt Enable
	// Position of SEIE field.
	FLEXIO_SHIFTEIEN_SEIE_Pos = 0x0
	// Bit mask of SEIE field.
	FLEXIO_SHIFTEIEN_SEIE_Msk = 0xf

	// TIMIEN: Timer Interrupt Enable Register
	// Position of TEIE field.
	FLEXIO_TIMIEN_TEIE_Pos = 0x0
	// Bit mask of TEIE field.
	FLEXIO_TIMIEN_TEIE_Msk = 0xf

	// SHIFTSDEN: Shifter Status DMA Enable
	// Position of SSDE field.
	FLEXIO_SHIFTSDEN_SSDE_Pos = 0x0
	// Bit mask of SSDE field.
	FLEXIO_SHIFTSDEN_SSDE_Msk = 0xf

	// SHIFTSTATE: Shifter State Register
	// Position of STATE field.
	FLEXIO_SHIFTSTATE_STATE_Pos = 0x0
	// Bit mask of STATE field.
	FLEXIO_SHIFTSTATE_STATE_Msk = 0x7

	// SHIFTCTL: Shifter Control N Register
	// Position of SMOD field.
	FLEXIO_SHIFTCTL_SMOD_Pos = 0x0
	// Bit mask of SMOD field.
	FLEXIO_SHIFTCTL_SMOD_Msk = 0x7
	// Disabled.
	FLEXIO_SHIFTCTL_SMOD_SMOD_0 = 0x0
	// Receive mode. Captures the current Shifter content into the SHIFTBUF on expiration of the Timer.
	FLEXIO_SHIFTCTL_SMOD_SMOD_1 = 0x1
	// Transmit mode. Load SHIFTBUF contents into the Shifter on expiration of the Timer.
	FLEXIO_SHIFTCTL_SMOD_SMOD_2 = 0x2
	// Match Store mode. Shifter data is compared to SHIFTBUF content on expiration of the Timer.
	FLEXIO_SHIFTCTL_SMOD_SMOD_4 = 0x4
	// Match Continuous mode. Shifter data is continuously compared to SHIFTBUF contents.
	FLEXIO_SHIFTCTL_SMOD_SMOD_5 = 0x5
	// State mode. SHIFTBUF contents are used for storing programmable state attributes.
	FLEXIO_SHIFTCTL_SMOD_SMOD_6 = 0x6
	// Logic mode. SHIFTBUF contents are used for implementing programmable logic look up table.
	FLEXIO_SHIFTCTL_SMOD_SMOD_7 = 0x7
	// Position of PINPOL field.
	FLEXIO_SHIFTCTL_PINPOL_Pos = 0x7
	// Bit mask of PINPOL field.
	FLEXIO_SHIFTCTL_PINPOL_Msk = 0x80
	// Bit PINPOL.
	FLEXIO_SHIFTCTL_PINPOL = 0x80
	// Pin is active high
	FLEXIO_SHIFTCTL_PINPOL_PINPOL_0 = 0x0
	// Pin is active low
	FLEXIO_SHIFTCTL_PINPOL_PINPOL_1 = 0x1
	// Position of PINSEL field.
	FLEXIO_SHIFTCTL_PINSEL_Pos = 0x8
	// Bit mask of PINSEL field.
	FLEXIO_SHIFTCTL_PINSEL_Msk = 0xf00
	// Position of PINCFG field.
	FLEXIO_SHIFTCTL_PINCFG_Pos = 0x10
	// Bit mask of PINCFG field.
	FLEXIO_SHIFTCTL_PINCFG_Msk = 0x30000
	// Shifter pin output disabled
	FLEXIO_SHIFTCTL_PINCFG_PINCFG_0 = 0x0
	// Shifter pin open drain or bidirectional output enable
	FLEXIO_SHIFTCTL_PINCFG_PINCFG_1 = 0x1
	// Shifter pin bidirectional output data
	FLEXIO_SHIFTCTL_PINCFG_PINCFG_2 = 0x2
	// Shifter pin output
	FLEXIO_SHIFTCTL_PINCFG_PINCFG_3 = 0x3
	// Position of TIMPOL field.
	FLEXIO_SHIFTCTL_TIMPOL_Pos = 0x17
	// Bit mask of TIMPOL field.
	FLEXIO_SHIFTCTL_TIMPOL_Msk = 0x800000
	// Bit TIMPOL.
	FLEXIO_SHIFTCTL_TIMPOL = 0x800000
	// Shift on posedge of Shift clock
	FLEXIO_SHIFTCTL_TIMPOL_TIMPOL_0 = 0x0
	// Shift on negedge of Shift clock
	FLEXIO_SHIFTCTL_TIMPOL_TIMPOL_1 = 0x1
	// Position of TIMSEL field.
	FLEXIO_SHIFTCTL_TIMSEL_Pos = 0x18
	// Bit mask of TIMSEL field.
	FLEXIO_SHIFTCTL_TIMSEL_Msk = 0x3000000

	// SHIFTCFG: Shifter Configuration N Register
	// Position of SSTART field.
	FLEXIO_SHIFTCFG_SSTART_Pos = 0x0
	// Bit mask of SSTART field.
	FLEXIO_SHIFTCFG_SSTART_Msk = 0x3
	// Start bit disabled for transmitter/receiver/match store, transmitter loads data on enable
	FLEXIO_SHIFTCFG_SSTART_SSTART_0 = 0x0
	// Start bit disabled for transmitter/receiver/match store, transmitter loads data on first shift
	FLEXIO_SHIFTCFG_SSTART_SSTART_1 = 0x1
	// Transmitter outputs start bit value 0 before loading data on first shift, receiver/match store sets error flag if start bit is not 0
	FLEXIO_SHIFTCFG_SSTART_SSTART_2 = 0x2
	// Transmitter outputs start bit value 1 before loading data on first shift, receiver/match store sets error flag if start bit is not 1
	FLEXIO_SHIFTCFG_SSTART_SSTART_3 = 0x3
	// Position of SSTOP field.
	FLEXIO_SHIFTCFG_SSTOP_Pos = 0x4
	// Bit mask of SSTOP field.
	FLEXIO_SHIFTCFG_SSTOP_Msk = 0x30
	// Stop bit disabled for transmitter/receiver/match store
	FLEXIO_SHIFTCFG_SSTOP_SSTOP_0 = 0x0
	// Transmitter outputs stop bit value 0 on store, receiver/match store sets error flag if stop bit is not 0
	FLEXIO_SHIFTCFG_SSTOP_SSTOP_2 = 0x2
	// Transmitter outputs stop bit value 1 on store, receiver/match store sets error flag if stop bit is not 1
	FLEXIO_SHIFTCFG_SSTOP_SSTOP_3 = 0x3
	// Position of INSRC field.
	FLEXIO_SHIFTCFG_INSRC_Pos = 0x8
	// Bit mask of INSRC field.
	FLEXIO_SHIFTCFG_INSRC_Msk = 0x100
	// Bit INSRC.
	FLEXIO_SHIFTCFG_INSRC = 0x100
	// Pin
	FLEXIO_SHIFTCFG_INSRC_INSRC_0 = 0x0
	// Shifter N+1 Output
	FLEXIO_SHIFTCFG_INSRC_INSRC_1 = 0x1
	// Position of PWIDTH field.
	FLEXIO_SHIFTCFG_PWIDTH_Pos = 0x10
	// Bit mask of PWIDTH field.
	FLEXIO_SHIFTCFG_PWIDTH_Msk = 0xf0000

	// SHIFTBUF: Shifter Buffer N Register
	// Position of SHIFTBUF field.
	FLEXIO_SHIFTBUF_SHIFTBUF_Pos = 0x0
	// Bit mask of SHIFTBUF field.
	FLEXIO_SHIFTBUF_SHIFTBUF_Msk = 0xffffffff

	// SHIFTBUFBIS: Shifter Buffer N Bit Swapped Register
	// Position of SHIFTBUFBIS field.
	FLEXIO_SHIFTBUFBIS_SHIFTBUFBIS_Pos = 0x0
	// Bit mask of SHIFTBUFBIS field.
	FLEXIO_SHIFTBUFBIS_SHIFTBUFBIS_Msk = 0xffffffff

	// SHIFTBUFBYS: Shifter Buffer N Byte Swapped Register
	// Position of SHIFTBUFBYS field.
	FLEXIO_SHIFTBUFBYS_SHIFTBUFBYS_Pos = 0x0
	// Bit mask of SHIFTBUFBYS field.
	FLEXIO_SHIFTBUFBYS_SHIFTBUFBYS_Msk = 0xffffffff

	// SHIFTBUFBBS: Shifter Buffer N Bit Byte Swapped Register
	// Position of SHIFTBUFBBS field.
	FLEXIO_SHIFTBUFBBS_SHIFTBUFBBS_Pos = 0x0
	// Bit mask of SHIFTBUFBBS field.
	FLEXIO_SHIFTBUFBBS_SHIFTBUFBBS_Msk = 0xffffffff

	// TIMCTL: Timer Control N Register
	// Position of TIMOD field.
	FLEXIO_TIMCTL_TIMOD_Pos = 0x0
	// Bit mask of TIMOD field.
	FLEXIO_TIMCTL_TIMOD_Msk = 0x3
	// Timer Disabled.
	FLEXIO_TIMCTL_TIMOD_TIMOD_0 = 0x0
	// Dual 8-bit counters baud mode.
	FLEXIO_TIMCTL_TIMOD_TIMOD_1 = 0x1
	// Dual 8-bit counters PWM high mode.
	FLEXIO_TIMCTL_TIMOD_TIMOD_2 = 0x2
	// Single 16-bit counter mode.
	FLEXIO_TIMCTL_TIMOD_TIMOD_3 = 0x3
	// Position of PINPOL field.
	FLEXIO_TIMCTL_PINPOL_Pos = 0x7
	// Bit mask of PINPOL field.
	FLEXIO_TIMCTL_PINPOL_Msk = 0x80
	// Bit PINPOL.
	FLEXIO_TIMCTL_PINPOL = 0x80
	// Pin is active high
	FLEXIO_TIMCTL_PINPOL_PINPOL_0 = 0x0
	// Pin is active low
	FLEXIO_TIMCTL_PINPOL_PINPOL_1 = 0x1
	// Position of PINSEL field.
	FLEXIO_TIMCTL_PINSEL_Pos = 0x8
	// Bit mask of PINSEL field.
	FLEXIO_TIMCTL_PINSEL_Msk = 0xf00
	// Position of PINCFG field.
	FLEXIO_TIMCTL_PINCFG_Pos = 0x10
	// Bit mask of PINCFG field.
	FLEXIO_TIMCTL_PINCFG_Msk = 0x30000
	// Timer pin output disabled
	FLEXIO_TIMCTL_PINCFG_PINCFG_0 = 0x0
	// Timer pin open drain or bidirectional output enable
	FLEXIO_TIMCTL_PINCFG_PINCFG_1 = 0x1
	// Timer pin bidirectional output data
	FLEXIO_TIMCTL_PINCFG_PINCFG_2 = 0x2
	// Timer pin output
	FLEXIO_TIMCTL_PINCFG_PINCFG_3 = 0x3
	// Position of TRGSRC field.
	FLEXIO_TIMCTL_TRGSRC_Pos = 0x16
	// Bit mask of TRGSRC field.
	FLEXIO_TIMCTL_TRGSRC_Msk = 0x400000
	// Bit TRGSRC.
	FLEXIO_TIMCTL_TRGSRC = 0x400000
	// External trigger selected
	FLEXIO_TIMCTL_TRGSRC_TRGSRC_0 = 0x0
	// Internal trigger selected
	FLEXIO_TIMCTL_TRGSRC_TRGSRC_1 = 0x1
	// Position of TRGPOL field.
	FLEXIO_TIMCTL_TRGPOL_Pos = 0x17
	// Bit mask of TRGPOL field.
	FLEXIO_TIMCTL_TRGPOL_Msk = 0x800000
	// Bit TRGPOL.
	FLEXIO_TIMCTL_TRGPOL = 0x800000
	// Trigger active high
	FLEXIO_TIMCTL_TRGPOL_TRGPOL_0 = 0x0
	// Trigger active low
	FLEXIO_TIMCTL_TRGPOL_TRGPOL_1 = 0x1
	// Position of TRGSEL field.
	FLEXIO_TIMCTL_TRGSEL_Pos = 0x18
	// Bit mask of TRGSEL field.
	FLEXIO_TIMCTL_TRGSEL_Msk = 0x1f000000

	// TIMCFG: Timer Configuration N Register
	// Position of TSTART field.
	FLEXIO_TIMCFG_TSTART_Pos = 0x1
	// Bit mask of TSTART field.
	FLEXIO_TIMCFG_TSTART_Msk = 0x2
	// Bit TSTART.
	FLEXIO_TIMCFG_TSTART = 0x2
	// Start bit disabled
	FLEXIO_TIMCFG_TSTART_TSTART_0 = 0x0
	// Start bit enabled
	FLEXIO_TIMCFG_TSTART_TSTART_1 = 0x1
	// Position of TSTOP field.
	FLEXIO_TIMCFG_TSTOP_Pos = 0x4
	// Bit mask of TSTOP field.
	FLEXIO_TIMCFG_TSTOP_Msk = 0x30
	// Stop bit disabled
	FLEXIO_TIMCFG_TSTOP_TSTOP_0 = 0x0
	// Stop bit is enabled on timer compare
	FLEXIO_TIMCFG_TSTOP_TSTOP_1 = 0x1
	// Stop bit is enabled on timer disable
	FLEXIO_TIMCFG_TSTOP_TSTOP_2 = 0x2
	// Stop bit is enabled on timer compare and timer disable
	FLEXIO_TIMCFG_TSTOP_TSTOP_3 = 0x3
	// Position of TIMENA field.
	FLEXIO_TIMCFG_TIMENA_Pos = 0x8
	// Bit mask of TIMENA field.
	FLEXIO_TIMCFG_TIMENA_Msk = 0x700
	// Timer always enabled
	FLEXIO_TIMCFG_TIMENA_TIMENA_0 = 0x0
	// Timer enabled on Timer N-1 enable
	FLEXIO_TIMCFG_TIMENA_TIMENA_1 = 0x1
	// Timer enabled on Trigger high
	FLEXIO_TIMCFG_TIMENA_TIMENA_2 = 0x2
	// Timer enabled on Trigger high and Pin high
	FLEXIO_TIMCFG_TIMENA_TIMENA_3 = 0x3
	// Timer enabled on Pin rising edge
	FLEXIO_TIMCFG_TIMENA_TIMENA_4 = 0x4
	// Timer enabled on Pin rising edge and Trigger high
	FLEXIO_TIMCFG_TIMENA_TIMENA_5 = 0x5
	// Timer enabled on Trigger rising edge
	FLEXIO_TIMCFG_TIMENA_TIMENA_6 = 0x6
	// Timer enabled on Trigger rising or falling edge
	FLEXIO_TIMCFG_TIMENA_TIMENA_7 = 0x7
	// Position of TIMDIS field.
	FLEXIO_TIMCFG_TIMDIS_Pos = 0xc
	// Bit mask of TIMDIS field.
	FLEXIO_TIMCFG_TIMDIS_Msk = 0x7000
	// Timer never disabled
	FLEXIO_TIMCFG_TIMDIS_TIMDIS_0 = 0x0
	// Timer disabled on Timer N-1 disable
	FLEXIO_TIMCFG_TIMDIS_TIMDIS_1 = 0x1
	// Timer disabled on Timer compare (upper 8-bits match and decrement)
	FLEXIO_TIMCFG_TIMDIS_TIMDIS_2 = 0x2
	// Timer disabled on Timer compare (upper 8-bits match and decrement) and Trigger Low
	FLEXIO_TIMCFG_TIMDIS_TIMDIS_3 = 0x3
	// Timer disabled on Pin rising or falling edge
	FLEXIO_TIMCFG_TIMDIS_TIMDIS_4 = 0x4
	// Timer disabled on Pin rising or falling edge provided Trigger is high
	FLEXIO_TIMCFG_TIMDIS_TIMDIS_5 = 0x5
	// Timer disabled on Trigger falling edge
	FLEXIO_TIMCFG_TIMDIS_TIMDIS_6 = 0x6
	// Position of TIMRST field.
	FLEXIO_TIMCFG_TIMRST_Pos = 0x10
	// Bit mask of TIMRST field.
	FLEXIO_TIMCFG_TIMRST_Msk = 0x70000
	// Timer never reset
	FLEXIO_TIMCFG_TIMRST_TIMRST_0 = 0x0
	// Timer reset on Timer Pin equal to Timer Output
	FLEXIO_TIMCFG_TIMRST_TIMRST_2 = 0x2
	// Timer reset on Timer Trigger equal to Timer Output
	FLEXIO_TIMCFG_TIMRST_TIMRST_3 = 0x3
	// Timer reset on Timer Pin rising edge
	FLEXIO_TIMCFG_TIMRST_TIMRST_4 = 0x4
	// Timer reset on Trigger rising edge
	FLEXIO_TIMCFG_TIMRST_TIMRST_6 = 0x6
	// Timer reset on Trigger rising or falling edge
	FLEXIO_TIMCFG_TIMRST_TIMRST_7 = 0x7
	// Position of TIMDEC field.
	FLEXIO_TIMCFG_TIMDEC_Pos = 0x14
	// Bit mask of TIMDEC field.
	FLEXIO_TIMCFG_TIMDEC_Msk = 0x300000
	// Decrement counter on FlexIO clock, Shift clock equals Timer output.
	FLEXIO_TIMCFG_TIMDEC_TIMDEC_0 = 0x0
	// Decrement counter on Trigger input (both edges), Shift clock equals Timer output.
	FLEXIO_TIMCFG_TIMDEC_TIMDEC_1 = 0x1
	// Decrement counter on Pin input (both edges), Shift clock equals Pin input.
	FLEXIO_TIMCFG_TIMDEC_TIMDEC_2 = 0x2
	// Decrement counter on Trigger input (both edges), Shift clock equals Trigger input.
	FLEXIO_TIMCFG_TIMDEC_TIMDEC_3 = 0x3
	// Position of TIMOUT field.
	FLEXIO_TIMCFG_TIMOUT_Pos = 0x18
	// Bit mask of TIMOUT field.
	FLEXIO_TIMCFG_TIMOUT_Msk = 0x3000000
	// Timer output is logic one when enabled and is not affected by timer reset
	FLEXIO_TIMCFG_TIMOUT_TIMOUT_0 = 0x0
	// Timer output is logic zero when enabled and is not affected by timer reset
	FLEXIO_TIMCFG_TIMOUT_TIMOUT_1 = 0x1
	// Timer output is logic one when enabled and on timer reset
	FLEXIO_TIMCFG_TIMOUT_TIMOUT_2 = 0x2
	// Timer output is logic zero when enabled and on timer reset
	FLEXIO_TIMCFG_TIMOUT_TIMOUT_3 = 0x3

	// TIMCMP: Timer Compare N Register
	// Position of CMP field.
	FLEXIO_TIMCMP_CMP_Pos = 0x0
	// Bit mask of CMP field.
	FLEXIO_TIMCMP_CMP_Msk = 0xffff

	// SHIFTBUFNBS: Shifter Buffer N Nibble Byte Swapped Register
	// Position of SHIFTBUFNBS field.
	FLEXIO_SHIFTBUFNBS_SHIFTBUFNBS_Pos = 0x0
	// Bit mask of SHIFTBUFNBS field.
	FLEXIO_SHIFTBUFNBS_SHIFTBUFNBS_Msk = 0xffffffff

	// SHIFTBUFHWS: Shifter Buffer N Half Word Swapped Register
	// Position of SHIFTBUFHWS field.
	FLEXIO_SHIFTBUFHWS_SHIFTBUFHWS_Pos = 0x0
	// Bit mask of SHIFTBUFHWS field.
	FLEXIO_SHIFTBUFHWS_SHIFTBUFHWS_Msk = 0xffffffff

	// SHIFTBUFNIS: Shifter Buffer N Nibble Swapped Register
	// Position of SHIFTBUFNIS field.
	FLEXIO_SHIFTBUFNIS_SHIFTBUFNIS_Pos = 0x0
	// Bit mask of SHIFTBUFNIS field.
	FLEXIO_SHIFTBUFNIS_SHIFTBUFNIS_Msk = 0xffffffff
)

// Bitfields for GPIO1: GPIO
const (
	// DR: GPIO data register
	// Position of DR field.
	GPIO_DR_DR_Pos = 0x0
	// Bit mask of DR field.
	GPIO_DR_DR_Msk = 0xffffffff

	// GDIR: GPIO direction register
	// Position of GDIR field.
	GPIO_GDIR_GDIR_Pos = 0x0
	// Bit mask of GDIR field.
	GPIO_GDIR_GDIR_Msk = 0xffffffff

	// PSR: GPIO pad status register
	// Position of PSR field.
	GPIO_PSR_PSR_Pos = 0x0
	// Bit mask of PSR field.
	GPIO_PSR_PSR_Msk = 0xffffffff

	// ICR1: GPIO interrupt configuration register1
	// Position of ICR0 field.
	GPIO_ICR1_ICR0_Pos = 0x0
	// Bit mask of ICR0 field.
	GPIO_ICR1_ICR0_Msk = 0x3
	// Interrupt n is low-level sensitive.
	GPIO_ICR1_ICR0_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR1_ICR0_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR1_ICR0_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR1_ICR0_FALLING_EDGE = 0x3
	// Position of ICR1 field.
	GPIO_ICR1_ICR1_Pos = 0x2
	// Bit mask of ICR1 field.
	GPIO_ICR1_ICR1_Msk = 0xc
	// Interrupt n is low-level sensitive.
	GPIO_ICR1_ICR1_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR1_ICR1_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR1_ICR1_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR1_ICR1_FALLING_EDGE = 0x3
	// Position of ICR2 field.
	GPIO_ICR1_ICR2_Pos = 0x4
	// Bit mask of ICR2 field.
	GPIO_ICR1_ICR2_Msk = 0x30
	// Interrupt n is low-level sensitive.
	GPIO_ICR1_ICR2_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR1_ICR2_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR1_ICR2_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR1_ICR2_FALLING_EDGE = 0x3
	// Position of ICR3 field.
	GPIO_ICR1_ICR3_Pos = 0x6
	// Bit mask of ICR3 field.
	GPIO_ICR1_ICR3_Msk = 0xc0
	// Interrupt n is low-level sensitive.
	GPIO_ICR1_ICR3_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR1_ICR3_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR1_ICR3_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR1_ICR3_FALLING_EDGE = 0x3
	// Position of ICR4 field.
	GPIO_ICR1_ICR4_Pos = 0x8
	// Bit mask of ICR4 field.
	GPIO_ICR1_ICR4_Msk = 0x300
	// Interrupt n is low-level sensitive.
	GPIO_ICR1_ICR4_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR1_ICR4_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR1_ICR4_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR1_ICR4_FALLING_EDGE = 0x3
	// Position of ICR5 field.
	GPIO_ICR1_ICR5_Pos = 0xa
	// Bit mask of ICR5 field.
	GPIO_ICR1_ICR5_Msk = 0xc00
	// Interrupt n is low-level sensitive.
	GPIO_ICR1_ICR5_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR1_ICR5_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR1_ICR5_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR1_ICR5_FALLING_EDGE = 0x3
	// Position of ICR6 field.
	GPIO_ICR1_ICR6_Pos = 0xc
	// Bit mask of ICR6 field.
	GPIO_ICR1_ICR6_Msk = 0x3000
	// Interrupt n is low-level sensitive.
	GPIO_ICR1_ICR6_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR1_ICR6_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR1_ICR6_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR1_ICR6_FALLING_EDGE = 0x3
	// Position of ICR7 field.
	GPIO_ICR1_ICR7_Pos = 0xe
	// Bit mask of ICR7 field.
	GPIO_ICR1_ICR7_Msk = 0xc000
	// Interrupt n is low-level sensitive.
	GPIO_ICR1_ICR7_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR1_ICR7_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR1_ICR7_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR1_ICR7_FALLING_EDGE = 0x3
	// Position of ICR8 field.
	GPIO_ICR1_ICR8_Pos = 0x10
	// Bit mask of ICR8 field.
	GPIO_ICR1_ICR8_Msk = 0x30000
	// Interrupt n is low-level sensitive.
	GPIO_ICR1_ICR8_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR1_ICR8_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR1_ICR8_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR1_ICR8_FALLING_EDGE = 0x3
	// Position of ICR9 field.
	GPIO_ICR1_ICR9_Pos = 0x12
	// Bit mask of ICR9 field.
	GPIO_ICR1_ICR9_Msk = 0xc0000
	// Interrupt n is low-level sensitive.
	GPIO_ICR1_ICR9_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR1_ICR9_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR1_ICR9_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR1_ICR9_FALLING_EDGE = 0x3
	// Position of ICR10 field.
	GPIO_ICR1_ICR10_Pos = 0x14
	// Bit mask of ICR10 field.
	GPIO_ICR1_ICR10_Msk = 0x300000
	// Interrupt n is low-level sensitive.
	GPIO_ICR1_ICR10_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR1_ICR10_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR1_ICR10_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR1_ICR10_FALLING_EDGE = 0x3
	// Position of ICR11 field.
	GPIO_ICR1_ICR11_Pos = 0x16
	// Bit mask of ICR11 field.
	GPIO_ICR1_ICR11_Msk = 0xc00000
	// Interrupt n is low-level sensitive.
	GPIO_ICR1_ICR11_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR1_ICR11_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR1_ICR11_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR1_ICR11_FALLING_EDGE = 0x3
	// Position of ICR12 field.
	GPIO_ICR1_ICR12_Pos = 0x18
	// Bit mask of ICR12 field.
	GPIO_ICR1_ICR12_Msk = 0x3000000
	// Interrupt n is low-level sensitive.
	GPIO_ICR1_ICR12_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR1_ICR12_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR1_ICR12_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR1_ICR12_FALLING_EDGE = 0x3
	// Position of ICR13 field.
	GPIO_ICR1_ICR13_Pos = 0x1a
	// Bit mask of ICR13 field.
	GPIO_ICR1_ICR13_Msk = 0xc000000
	// Interrupt n is low-level sensitive.
	GPIO_ICR1_ICR13_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR1_ICR13_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR1_ICR13_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR1_ICR13_FALLING_EDGE = 0x3
	// Position of ICR14 field.
	GPIO_ICR1_ICR14_Pos = 0x1c
	// Bit mask of ICR14 field.
	GPIO_ICR1_ICR14_Msk = 0x30000000
	// Interrupt n is low-level sensitive.
	GPIO_ICR1_ICR14_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR1_ICR14_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR1_ICR14_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR1_ICR14_FALLING_EDGE = 0x3
	// Position of ICR15 field.
	GPIO_ICR1_ICR15_Pos = 0x1e
	// Bit mask of ICR15 field.
	GPIO_ICR1_ICR15_Msk = 0xc0000000
	// Interrupt n is low-level sensitive.
	GPIO_ICR1_ICR15_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR1_ICR15_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR1_ICR15_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR1_ICR15_FALLING_EDGE = 0x3

	// ICR2: GPIO interrupt configuration register2
	// Position of ICR16 field.
	GPIO_ICR2_ICR16_Pos = 0x0
	// Bit mask of ICR16 field.
	GPIO_ICR2_ICR16_Msk = 0x3
	// Interrupt n is low-level sensitive.
	GPIO_ICR2_ICR16_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR2_ICR16_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR2_ICR16_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR2_ICR16_FALLING_EDGE = 0x3
	// Position of ICR17 field.
	GPIO_ICR2_ICR17_Pos = 0x2
	// Bit mask of ICR17 field.
	GPIO_ICR2_ICR17_Msk = 0xc
	// Interrupt n is low-level sensitive.
	GPIO_ICR2_ICR17_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR2_ICR17_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR2_ICR17_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR2_ICR17_FALLING_EDGE = 0x3
	// Position of ICR18 field.
	GPIO_ICR2_ICR18_Pos = 0x4
	// Bit mask of ICR18 field.
	GPIO_ICR2_ICR18_Msk = 0x30
	// Interrupt n is low-level sensitive.
	GPIO_ICR2_ICR18_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR2_ICR18_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR2_ICR18_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR2_ICR18_FALLING_EDGE = 0x3
	// Position of ICR19 field.
	GPIO_ICR2_ICR19_Pos = 0x6
	// Bit mask of ICR19 field.
	GPIO_ICR2_ICR19_Msk = 0xc0
	// Interrupt n is low-level sensitive.
	GPIO_ICR2_ICR19_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR2_ICR19_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR2_ICR19_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR2_ICR19_FALLING_EDGE = 0x3
	// Position of ICR20 field.
	GPIO_ICR2_ICR20_Pos = 0x8
	// Bit mask of ICR20 field.
	GPIO_ICR2_ICR20_Msk = 0x300
	// Interrupt n is low-level sensitive.
	GPIO_ICR2_ICR20_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR2_ICR20_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR2_ICR20_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR2_ICR20_FALLING_EDGE = 0x3
	// Position of ICR21 field.
	GPIO_ICR2_ICR21_Pos = 0xa
	// Bit mask of ICR21 field.
	GPIO_ICR2_ICR21_Msk = 0xc00
	// Interrupt n is low-level sensitive.
	GPIO_ICR2_ICR21_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR2_ICR21_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR2_ICR21_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR2_ICR21_FALLING_EDGE = 0x3
	// Position of ICR22 field.
	GPIO_ICR2_ICR22_Pos = 0xc
	// Bit mask of ICR22 field.
	GPIO_ICR2_ICR22_Msk = 0x3000
	// Interrupt n is low-level sensitive.
	GPIO_ICR2_ICR22_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR2_ICR22_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR2_ICR22_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR2_ICR22_FALLING_EDGE = 0x3
	// Position of ICR23 field.
	GPIO_ICR2_ICR23_Pos = 0xe
	// Bit mask of ICR23 field.
	GPIO_ICR2_ICR23_Msk = 0xc000
	// Interrupt n is low-level sensitive.
	GPIO_ICR2_ICR23_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR2_ICR23_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR2_ICR23_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR2_ICR23_FALLING_EDGE = 0x3
	// Position of ICR24 field.
	GPIO_ICR2_ICR24_Pos = 0x10
	// Bit mask of ICR24 field.
	GPIO_ICR2_ICR24_Msk = 0x30000
	// Interrupt n is low-level sensitive.
	GPIO_ICR2_ICR24_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR2_ICR24_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR2_ICR24_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR2_ICR24_FALLING_EDGE = 0x3
	// Position of ICR25 field.
	GPIO_ICR2_ICR25_Pos = 0x12
	// Bit mask of ICR25 field.
	GPIO_ICR2_ICR25_Msk = 0xc0000
	// Interrupt n is low-level sensitive.
	GPIO_ICR2_ICR25_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR2_ICR25_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR2_ICR25_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR2_ICR25_FALLING_EDGE = 0x3
	// Position of ICR26 field.
	GPIO_ICR2_ICR26_Pos = 0x14
	// Bit mask of ICR26 field.
	GPIO_ICR2_ICR26_Msk = 0x300000
	// Interrupt n is low-level sensitive.
	GPIO_ICR2_ICR26_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR2_ICR26_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR2_ICR26_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR2_ICR26_FALLING_EDGE = 0x3
	// Position of ICR27 field.
	GPIO_ICR2_ICR27_Pos = 0x16
	// Bit mask of ICR27 field.
	GPIO_ICR2_ICR27_Msk = 0xc00000
	// Interrupt n is low-level sensitive.
	GPIO_ICR2_ICR27_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR2_ICR27_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR2_ICR27_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR2_ICR27_FALLING_EDGE = 0x3
	// Position of ICR28 field.
	GPIO_ICR2_ICR28_Pos = 0x18
	// Bit mask of ICR28 field.
	GPIO_ICR2_ICR28_Msk = 0x3000000
	// Interrupt n is low-level sensitive.
	GPIO_ICR2_ICR28_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR2_ICR28_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR2_ICR28_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR2_ICR28_FALLING_EDGE = 0x3
	// Position of ICR29 field.
	GPIO_ICR2_ICR29_Pos = 0x1a
	// Bit mask of ICR29 field.
	GPIO_ICR2_ICR29_Msk = 0xc000000
	// Interrupt n is low-level sensitive.
	GPIO_ICR2_ICR29_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR2_ICR29_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR2_ICR29_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR2_ICR29_FALLING_EDGE = 0x3
	// Position of ICR30 field.
	GPIO_ICR2_ICR30_Pos = 0x1c
	// Bit mask of ICR30 field.
	GPIO_ICR2_ICR30_Msk = 0x30000000
	// Interrupt n is low-level sensitive.
	GPIO_ICR2_ICR30_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR2_ICR30_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR2_ICR30_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR2_ICR30_FALLING_EDGE = 0x3
	// Position of ICR31 field.
	GPIO_ICR2_ICR31_Pos = 0x1e
	// Bit mask of ICR31 field.
	GPIO_ICR2_ICR31_Msk = 0xc0000000
	// Interrupt n is low-level sensitive.
	GPIO_ICR2_ICR31_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR2_ICR31_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR2_ICR31_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR2_ICR31_FALLING_EDGE = 0x3

	// IMR: GPIO interrupt mask register
	// Position of IMR field.
	GPIO_IMR_IMR_Pos = 0x0
	// Bit mask of IMR field.
	GPIO_IMR_IMR_Msk = 0xffffffff

	// ISR: GPIO interrupt status register
	// Position of ISR field.
	GPIO_ISR_ISR_Pos = 0x0
	// Bit mask of ISR field.
	GPIO_ISR_ISR_Msk = 0xffffffff

	// EDGE_SEL: GPIO edge select register
	// Position of GPIO_EDGE_SEL field.
	GPIO_EDGE_SEL_GPIO_EDGE_SEL_Pos = 0x0
	// Bit mask of GPIO_EDGE_SEL field.
	GPIO_EDGE_SEL_GPIO_EDGE_SEL_Msk = 0xffffffff

	// DR_SET: GPIO data register SET
	// Position of DR_SET field.
	GPIO_DR_SET_DR_SET_Pos = 0x0
	// Bit mask of DR_SET field.
	GPIO_DR_SET_DR_SET_Msk = 0xffffffff

	// DR_CLEAR: GPIO data register CLEAR
	// Position of DR_CLEAR field.
	GPIO_DR_CLEAR_DR_CLEAR_Pos = 0x0
	// Bit mask of DR_CLEAR field.
	GPIO_DR_CLEAR_DR_CLEAR_Msk = 0xffffffff

	// DR_TOGGLE: GPIO data register TOGGLE
	// Position of DR_TOGGLE field.
	GPIO_DR_TOGGLE_DR_TOGGLE_Pos = 0x0
	// Bit mask of DR_TOGGLE field.
	GPIO_DR_TOGGLE_DR_TOGGLE_Msk = 0xffffffff
)

// Bitfields for CAN1: FLEXCAN
const (
	// MCR: Module Configuration Register
	// Position of MAXMB field.
	CAN_MCR_MAXMB_Pos = 0x0
	// Bit mask of MAXMB field.
	CAN_MCR_MAXMB_Msk = 0x7f
	// Position of IDAM field.
	CAN_MCR_IDAM_Pos = 0x8
	// Bit mask of IDAM field.
	CAN_MCR_IDAM_Msk = 0x300
	// Format A One full ID (standard or extended) per ID filter Table element.
	CAN_MCR_IDAM_IDAM_0 = 0x0
	// Format B Two full standard IDs or two partial 14-bit extended IDs per ID filter Table element.
	CAN_MCR_IDAM_IDAM_1 = 0x1
	// Format C Four partial 8-bit IDs (standard or extended) per ID filter Table element.
	CAN_MCR_IDAM_IDAM_2 = 0x2
	// Format D All frames rejected.
	CAN_MCR_IDAM_IDAM_3 = 0x3
	// Position of AEN field.
	CAN_MCR_AEN_Pos = 0xc
	// Bit mask of AEN field.
	CAN_MCR_AEN_Msk = 0x1000
	// Bit AEN.
	CAN_MCR_AEN = 0x1000
	// Abort disabled
	CAN_MCR_AEN_AEN_0 = 0x0
	// Abort enabled
	CAN_MCR_AEN_AEN_1 = 0x1
	// Position of LPRIOEN field.
	CAN_MCR_LPRIOEN_Pos = 0xd
	// Bit mask of LPRIOEN field.
	CAN_MCR_LPRIOEN_Msk = 0x2000
	// Bit LPRIOEN.
	CAN_MCR_LPRIOEN = 0x2000
	// Local Priority disabled
	CAN_MCR_LPRIOEN_LPRIOEN_0 = 0x0
	// Local Priority enabled
	CAN_MCR_LPRIOEN_LPRIOEN_1 = 0x1
	// Position of IRMQ field.
	CAN_MCR_IRMQ_Pos = 0x10
	// Bit mask of IRMQ field.
	CAN_MCR_IRMQ_Msk = 0x10000
	// Bit IRMQ.
	CAN_MCR_IRMQ = 0x10000
	// Individual Rx masking and queue feature are disabled.For backward compatibility, the reading of C/S word locks the MB even if it is EMPTY.
	CAN_MCR_IRMQ_IRMQ_0 = 0x0
	// Individual Rx masking and queue feature are enabled.
	CAN_MCR_IRMQ_IRMQ_1 = 0x1
	// Position of SRXDIS field.
	CAN_MCR_SRXDIS_Pos = 0x11
	// Bit mask of SRXDIS field.
	CAN_MCR_SRXDIS_Msk = 0x20000
	// Bit SRXDIS.
	CAN_MCR_SRXDIS = 0x20000
	// Self reception enabled
	CAN_MCR_SRXDIS_SRXDIS_0 = 0x0
	// Self reception disabled
	CAN_MCR_SRXDIS_SRXDIS_1 = 0x1
	// Position of WAKSRC field.
	CAN_MCR_WAKSRC_Pos = 0x13
	// Bit mask of WAKSRC field.
	CAN_MCR_WAKSRC_Msk = 0x80000
	// Bit WAKSRC.
	CAN_MCR_WAKSRC = 0x80000
	// FLEXCAN uses the unfiltered FLEXCAN_RX input to detect recessive to dominant edges on the CAN bus.
	CAN_MCR_WAKSRC_WAKSRC_0 = 0x0
	// FLEXCAN uses the filtered FLEXCAN_RX input to detect recessive to dominant edges on the CAN bus
	CAN_MCR_WAKSRC_WAKSRC_1 = 0x1
	// Position of LPMACK field.
	CAN_MCR_LPMACK_Pos = 0x14
	// Bit mask of LPMACK field.
	CAN_MCR_LPMACK_Msk = 0x100000
	// Bit LPMACK.
	CAN_MCR_LPMACK = 0x100000
	// FLEXCAN not in any of the low power modes
	CAN_MCR_LPMACK_LPMACK_0 = 0x0
	// FLEXCAN is either in Disable Mode, or Stop mode
	CAN_MCR_LPMACK_LPMACK_1 = 0x1
	// Position of WRNEN field.
	CAN_MCR_WRNEN_Pos = 0x15
	// Bit mask of WRNEN field.
	CAN_MCR_WRNEN_Msk = 0x200000
	// Bit WRNEN.
	CAN_MCR_WRNEN = 0x200000
	// TWRN_INT and RWRN_INT bits are zero, independent of the values in the error counters.
	CAN_MCR_WRNEN_WRNEN_0 = 0x0
	// TWRN_INT and RWRN_INT bits are set when the respective error counter transition from <96 to >= 96.
	CAN_MCR_WRNEN_WRNEN_1 = 0x1
	// Position of SLFWAK field.
	CAN_MCR_SLFWAK_Pos = 0x16
	// Bit mask of SLFWAK field.
	CAN_MCR_SLFWAK_Msk = 0x400000
	// Bit SLFWAK.
	CAN_MCR_SLFWAK = 0x400000
	// FLEXCAN Self Wake Up feature is disabled
	CAN_MCR_SLFWAK_SLFWAK_0 = 0x0
	// FLEXCAN Self Wake Up feature is enabled
	CAN_MCR_SLFWAK_SLFWAK_1 = 0x1
	// Position of SUPV field.
	CAN_MCR_SUPV_Pos = 0x17
	// Bit mask of SUPV field.
	CAN_MCR_SUPV_Msk = 0x800000
	// Bit SUPV.
	CAN_MCR_SUPV = 0x800000
	// FlexCAN is in User Mode. Affected registers allow both Supervisor and Unrestricted accesses
	CAN_MCR_SUPV_SUPV_0 = 0x0
	// FlexCAN is in Supervisor Mode. Affected registers allow only Supervisor access. Unrestricted access behaves as though the access was done to an unimplemented register location
	CAN_MCR_SUPV_SUPV_1 = 0x1
	// Position of FRZACK field.
	CAN_MCR_FRZACK_Pos = 0x18
	// Bit mask of FRZACK field.
	CAN_MCR_FRZACK_Msk = 0x1000000
	// Bit FRZACK.
	CAN_MCR_FRZACK = 0x1000000
	// FLEXCAN not in Freeze Mode, prescaler running
	CAN_MCR_FRZACK_FRZACK_0 = 0x0
	// FLEXCAN in Freeze Mode, prescaler stopped
	CAN_MCR_FRZACK_FRZACK_1 = 0x1
	// Position of SOFTRST field.
	CAN_MCR_SOFTRST_Pos = 0x19
	// Bit mask of SOFTRST field.
	CAN_MCR_SOFTRST_Msk = 0x2000000
	// Bit SOFTRST.
	CAN_MCR_SOFTRST = 0x2000000
	// No reset request
	CAN_MCR_SOFTRST_SOFTRST_0 = 0x0
	// Reset the registers
	CAN_MCR_SOFTRST_SOFTRST_1 = 0x1
	// Position of WAKMSK field.
	CAN_MCR_WAKMSK_Pos = 0x1a
	// Bit mask of WAKMSK field.
	CAN_MCR_WAKMSK_Msk = 0x4000000
	// Bit WAKMSK.
	CAN_MCR_WAKMSK = 0x4000000
	// Wake Up Interrupt is disabled
	CAN_MCR_WAKMSK_WAKMSK_0 = 0x0
	// Wake Up Interrupt is enabled
	CAN_MCR_WAKMSK_WAKMSK_1 = 0x1
	// Position of NOTRDY field.
	CAN_MCR_NOTRDY_Pos = 0x1b
	// Bit mask of NOTRDY field.
	CAN_MCR_NOTRDY_Msk = 0x8000000
	// Bit NOTRDY.
	CAN_MCR_NOTRDY = 0x8000000
	// FLEXCAN module is either in Normal Mode, Listen-Only Mode or Loop-Back Mode
	CAN_MCR_NOTRDY_NOTRDY_0 = 0x0
	// FLEXCAN module is either in Disable Mode, Stop Mode or Freeze Mode
	CAN_MCR_NOTRDY_NOTRDY_1 = 0x1
	// Position of HALT field.
	CAN_MCR_HALT_Pos = 0x1c
	// Bit mask of HALT field.
	CAN_MCR_HALT_Msk = 0x10000000
	// Bit HALT.
	CAN_MCR_HALT = 0x10000000
	// No Freeze Mode request.
	CAN_MCR_HALT_HALT_0 = 0x0
	// Enters Freeze Mode if the FRZ bit is asserted.
	CAN_MCR_HALT_HALT_1 = 0x1
	// Position of RFEN field.
	CAN_MCR_RFEN_Pos = 0x1d
	// Bit mask of RFEN field.
	CAN_MCR_RFEN_Msk = 0x20000000
	// Bit RFEN.
	CAN_MCR_RFEN = 0x20000000
	// FIFO not enabled
	CAN_MCR_RFEN_RFEN_0 = 0x0
	// FIFO enabled
	CAN_MCR_RFEN_RFEN_1 = 0x1
	// Position of FRZ field.
	CAN_MCR_FRZ_Pos = 0x1e
	// Bit mask of FRZ field.
	CAN_MCR_FRZ_Msk = 0x40000000
	// Bit FRZ.
	CAN_MCR_FRZ = 0x40000000
	// Not enabled to enter Freeze Mode
	CAN_MCR_FRZ_FRZ_0 = 0x0
	// Enabled to enter Freeze Mode
	CAN_MCR_FRZ_FRZ_1 = 0x1
	// Position of MDIS field.
	CAN_MCR_MDIS_Pos = 0x1f
	// Bit mask of MDIS field.
	CAN_MCR_MDIS_Msk = 0x80000000
	// Bit MDIS.
	CAN_MCR_MDIS = 0x80000000
	// Enable the FLEXCAN module
	CAN_MCR_MDIS_MDIS_0 = 0x0
	// Disable the FLEXCAN module
	CAN_MCR_MDIS_MDIS_1 = 0x1

	// CTRL1: Control 1 Register
	// Position of PROPSEG field.
	CAN_CTRL1_PROPSEG_Pos = 0x0
	// Bit mask of PROPSEG field.
	CAN_CTRL1_PROPSEG_Msk = 0x7
	// Position of LOM field.
	CAN_CTRL1_LOM_Pos = 0x3
	// Bit mask of LOM field.
	CAN_CTRL1_LOM_Msk = 0x8
	// Bit LOM.
	CAN_CTRL1_LOM = 0x8
	// Listen Only Mode is deactivated
	CAN_CTRL1_LOM_LOM_0 = 0x0
	// FLEXCAN module operates in Listen Only Mode
	CAN_CTRL1_LOM_LOM_1 = 0x1
	// Position of LBUF field.
	CAN_CTRL1_LBUF_Pos = 0x4
	// Bit mask of LBUF field.
	CAN_CTRL1_LBUF_Msk = 0x10
	// Bit LBUF.
	CAN_CTRL1_LBUF = 0x10
	// Buffer with highest priority is transmitted first
	CAN_CTRL1_LBUF_LBUF_0 = 0x0
	// Lowest number buffer is transmitted first
	CAN_CTRL1_LBUF_LBUF_1 = 0x1
	// Position of TSYN field.
	CAN_CTRL1_TSYN_Pos = 0x5
	// Bit mask of TSYN field.
	CAN_CTRL1_TSYN_Msk = 0x20
	// Bit TSYN.
	CAN_CTRL1_TSYN = 0x20
	// Timer Sync feature disabled
	CAN_CTRL1_TSYN_TSYN_0 = 0x0
	// Timer Sync feature enabled
	CAN_CTRL1_TSYN_TSYN_1 = 0x1
	// Position of BOFFREC field.
	CAN_CTRL1_BOFFREC_Pos = 0x6
	// Bit mask of BOFFREC field.
	CAN_CTRL1_BOFFREC_Msk = 0x40
	// Bit BOFFREC.
	CAN_CTRL1_BOFFREC = 0x40
	// Automatic recovering from Bus Off state enabled, according to CAN Spec 2.0 part B
	CAN_CTRL1_BOFFREC_BOFFREC_0 = 0x0
	// Automatic recovering from Bus Off state disabled
	CAN_CTRL1_BOFFREC_BOFFREC_1 = 0x1
	// Position of SMP field.
	CAN_CTRL1_SMP_Pos = 0x7
	// Bit mask of SMP field.
	CAN_CTRL1_SMP_Msk = 0x80
	// Bit SMP.
	CAN_CTRL1_SMP = 0x80
	// Just one sample is used to determine the bit value
	CAN_CTRL1_SMP_SMP_0 = 0x0
	// Three samples are used to determine the value of the received bit: the regular one (sample point) and 2 preceding samples, a majority rule is used
	CAN_CTRL1_SMP_SMP_1 = 0x1
	// Position of RWRNMSK field.
	CAN_CTRL1_RWRNMSK_Pos = 0xa
	// Bit mask of RWRNMSK field.
	CAN_CTRL1_RWRNMSK_Msk = 0x400
	// Bit RWRNMSK.
	CAN_CTRL1_RWRNMSK = 0x400
	// Rx Warning Interrupt disabled
	CAN_CTRL1_RWRNMSK_RWRNMSK_0 = 0x0
	// Rx Warning Interrupt enabled
	CAN_CTRL1_RWRNMSK_RWRNMSK_1 = 0x1
	// Position of TWRNMSK field.
	CAN_CTRL1_TWRNMSK_Pos = 0xb
	// Bit mask of TWRNMSK field.
	CAN_CTRL1_TWRNMSK_Msk = 0x800
	// Bit TWRNMSK.
	CAN_CTRL1_TWRNMSK = 0x800
	// Tx Warning Interrupt disabled
	CAN_CTRL1_TWRNMSK_TWRNMSK_0 = 0x0
	// Tx Warning Interrupt enabled
	CAN_CTRL1_TWRNMSK_TWRNMSK_1 = 0x1
	// Position of LPB field.
	CAN_CTRL1_LPB_Pos = 0xc
	// Bit mask of LPB field.
	CAN_CTRL1_LPB_Msk = 0x1000
	// Bit LPB.
	CAN_CTRL1_LPB = 0x1000
	// Loop Back disabled
	CAN_CTRL1_LPB_LPB_0 = 0x0
	// Loop Back enabled
	CAN_CTRL1_LPB_LPB_1 = 0x1
	// Position of ERRMSK field.
	CAN_CTRL1_ERRMSK_Pos = 0xe
	// Bit mask of ERRMSK field.
	CAN_CTRL1_ERRMSK_Msk = 0x4000
	// Bit ERRMSK.
	CAN_CTRL1_ERRMSK = 0x4000
	// Error interrupt disabled
	CAN_CTRL1_ERRMSK_ERRMSK_0 = 0x0
	// Error interrupt enabled
	CAN_CTRL1_ERRMSK_ERRMSK_1 = 0x1
	// Position of BOFFMSK field.
	CAN_CTRL1_BOFFMSK_Pos = 0xf
	// Bit mask of BOFFMSK field.
	CAN_CTRL1_BOFFMSK_Msk = 0x8000
	// Bit BOFFMSK.
	CAN_CTRL1_BOFFMSK = 0x8000
	// Bus Off interrupt disabled
	CAN_CTRL1_BOFFMSK_BOFFMSK_0 = 0x0
	// Bus Off interrupt enabled
	CAN_CTRL1_BOFFMSK_BOFFMSK_1 = 0x1
	// Position of PSEG2 field.
	CAN_CTRL1_PSEG2_Pos = 0x10
	// Bit mask of PSEG2 field.
	CAN_CTRL1_PSEG2_Msk = 0x70000
	// Position of PSEG1 field.
	CAN_CTRL1_PSEG1_Pos = 0x13
	// Bit mask of PSEG1 field.
	CAN_CTRL1_PSEG1_Msk = 0x380000
	// Position of RJW field.
	CAN_CTRL1_RJW_Pos = 0x16
	// Bit mask of RJW field.
	CAN_CTRL1_RJW_Msk = 0xc00000
	// Position of PRESDIV field.
	CAN_CTRL1_PRESDIV_Pos = 0x18
	// Bit mask of PRESDIV field.
	CAN_CTRL1_PRESDIV_Msk = 0xff000000

	// TIMER: Free Running Timer Register
	// Position of TIMER field.
	CAN_TIMER_TIMER_Pos = 0x0
	// Bit mask of TIMER field.
	CAN_TIMER_TIMER_Msk = 0xffff

	// RXMGMASK: Rx Mailboxes Global Mask Register
	// Position of MG field.
	CAN_RXMGMASK_MG_Pos = 0x0
	// Bit mask of MG field.
	CAN_RXMGMASK_MG_Msk = 0xffffffff
	// the corresponding bit in the filter is "don't care"
	CAN_RXMGMASK_MG_MG_0 = 0x0
	// The corresponding bit in the filter is checked against the one received
	CAN_RXMGMASK_MG_MG_1 = 0x1

	// RX14MASK: Rx Buffer 14 Mask Register
	// Position of RX14M field.
	CAN_RX14MASK_RX14M_Pos = 0x0
	// Bit mask of RX14M field.
	CAN_RX14MASK_RX14M_Msk = 0xffffffff
	// the corresponding bit in the filter is "don't care"
	CAN_RX14MASK_RX14M_RX14M_0 = 0x0
	// The corresponding bit in the filter is checked
	CAN_RX14MASK_RX14M_RX14M_1 = 0x1

	// RX15MASK: Rx Buffer 15 Mask Register
	// Position of RX15M field.
	CAN_RX15MASK_RX15M_Pos = 0x0
	// Bit mask of RX15M field.
	CAN_RX15MASK_RX15M_Msk = 0xffffffff
	// the corresponding bit in the filter is "don't care"
	CAN_RX15MASK_RX15M_RX15M_0 = 0x0
	// The corresponding bit in the filter is checked
	CAN_RX15MASK_RX15M_RX15M_1 = 0x1

	// ECR: Error Counter Register
	// Position of TX_ERR_COUNTER field.
	CAN_ECR_TX_ERR_COUNTER_Pos = 0x0
	// Bit mask of TX_ERR_COUNTER field.
	CAN_ECR_TX_ERR_COUNTER_Msk = 0xff
	// Position of RX_ERR_COUNTER field.
	CAN_ECR_RX_ERR_COUNTER_Pos = 0x8
	// Bit mask of RX_ERR_COUNTER field.
	CAN_ECR_RX_ERR_COUNTER_Msk = 0xff00

	// ESR1: Error and Status 1 Register
	// Position of WAKINT field.
	CAN_ESR1_WAKINT_Pos = 0x0
	// Bit mask of WAKINT field.
	CAN_ESR1_WAKINT_Msk = 0x1
	// Bit WAKINT.
	CAN_ESR1_WAKINT = 0x1
	// No such occurrence
	CAN_ESR1_WAKINT_WAKINT_0 = 0x0
	// Indicates a recessive to dominant transition received on the CAN bus when the FLEXCAN module is in Stop Mode
	CAN_ESR1_WAKINT_WAKINT_1 = 0x1
	// Position of ERRINT field.
	CAN_ESR1_ERRINT_Pos = 0x1
	// Bit mask of ERRINT field.
	CAN_ESR1_ERRINT_Msk = 0x2
	// Bit ERRINT.
	CAN_ESR1_ERRINT = 0x2
	// No such occurrence
	CAN_ESR1_ERRINT_ERRINT_0 = 0x0
	// Indicates setting of any Error Bit in the Error and Status Register
	CAN_ESR1_ERRINT_ERRINT_1 = 0x1
	// Position of BOFFINT field.
	CAN_ESR1_BOFFINT_Pos = 0x2
	// Bit mask of BOFFINT field.
	CAN_ESR1_BOFFINT_Msk = 0x4
	// Bit BOFFINT.
	CAN_ESR1_BOFFINT = 0x4
	// No such occurrence
	CAN_ESR1_BOFFINT_BOFFINT_0 = 0x0
	// FLEXCAN module entered 'Bus Off' state
	CAN_ESR1_BOFFINT_BOFFINT_1 = 0x1
	// Position of RX field.
	CAN_ESR1_RX_Pos = 0x3
	// Bit mask of RX field.
	CAN_ESR1_RX_Msk = 0x8
	// Bit RX.
	CAN_ESR1_RX = 0x8
	// FLEXCAN is receiving a message
	CAN_ESR1_RX_RX_0 = 0x0
	// FLEXCAN is transmitting a message
	CAN_ESR1_RX_RX_1 = 0x1
	// Position of FLTCONF field.
	CAN_ESR1_FLTCONF_Pos = 0x4
	// Bit mask of FLTCONF field.
	CAN_ESR1_FLTCONF_Msk = 0x30
	// Error Active
	CAN_ESR1_FLTCONF_FLTCONF_0 = 0x0
	// Error Passive
	CAN_ESR1_FLTCONF_FLTCONF_1 = 0x1
	// Bus off
	CAN_ESR1_FLTCONF_FLTCONF_2 = 0x2
	// Position of TX field.
	CAN_ESR1_TX_Pos = 0x6
	// Bit mask of TX field.
	CAN_ESR1_TX_Msk = 0x40
	// Bit TX.
	CAN_ESR1_TX = 0x40
	// FLEXCAN is receiving a message
	CAN_ESR1_TX_TX_0 = 0x0
	// FLEXCAN is transmitting a message
	CAN_ESR1_TX_TX_1 = 0x1
	// Position of IDLE field.
	CAN_ESR1_IDLE_Pos = 0x7
	// Bit mask of IDLE field.
	CAN_ESR1_IDLE_Msk = 0x80
	// Bit IDLE.
	CAN_ESR1_IDLE = 0x80
	// No such occurrence
	CAN_ESR1_IDLE_IDLE_0 = 0x0
	// CAN bus is now IDLE
	CAN_ESR1_IDLE_IDLE_1 = 0x1
	// Position of RXWRN field.
	CAN_ESR1_RXWRN_Pos = 0x8
	// Bit mask of RXWRN field.
	CAN_ESR1_RXWRN_Msk = 0x100
	// Bit RXWRN.
	CAN_ESR1_RXWRN = 0x100
	// No such occurrence
	CAN_ESR1_RXWRN_RXWRN_0 = 0x0
	// Rx_Err_Counter >= 96
	CAN_ESR1_RXWRN_RXWRN_1 = 0x1
	// Position of TXWRN field.
	CAN_ESR1_TXWRN_Pos = 0x9
	// Bit mask of TXWRN field.
	CAN_ESR1_TXWRN_Msk = 0x200
	// Bit TXWRN.
	CAN_ESR1_TXWRN = 0x200
	// No such occurrence
	CAN_ESR1_TXWRN_TXWRN_0 = 0x0
	// TX_Err_Counter >= 96
	CAN_ESR1_TXWRN_TXWRN_1 = 0x1
	// Position of STFERR field.
	CAN_ESR1_STFERR_Pos = 0xa
	// Bit mask of STFERR field.
	CAN_ESR1_STFERR_Msk = 0x400
	// Bit STFERR.
	CAN_ESR1_STFERR = 0x400
	// No such occurrence.
	CAN_ESR1_STFERR_STFERR_0 = 0x0
	// A Stuffing Error occurred since last read of this register.
	CAN_ESR1_STFERR_STFERR_1 = 0x1
	// Position of FRMERR field.
	CAN_ESR1_FRMERR_Pos = 0xb
	// Bit mask of FRMERR field.
	CAN_ESR1_FRMERR_Msk = 0x800
	// Bit FRMERR.
	CAN_ESR1_FRMERR = 0x800
	// No such occurrence
	CAN_ESR1_FRMERR_FRMERR_0 = 0x0
	// A Form Error occurred since last read of this register
	CAN_ESR1_FRMERR_FRMERR_1 = 0x1
	// Position of CRCERR field.
	CAN_ESR1_CRCERR_Pos = 0xc
	// Bit mask of CRCERR field.
	CAN_ESR1_CRCERR_Msk = 0x1000
	// Bit CRCERR.
	CAN_ESR1_CRCERR = 0x1000
	// No such occurrence
	CAN_ESR1_CRCERR_CRCERR_0 = 0x0
	// A CRC error occurred since last read of this register.
	CAN_ESR1_CRCERR_CRCERR_1 = 0x1
	// Position of ACKERR field.
	CAN_ESR1_ACKERR_Pos = 0xd
	// Bit mask of ACKERR field.
	CAN_ESR1_ACKERR_Msk = 0x2000
	// Bit ACKERR.
	CAN_ESR1_ACKERR = 0x2000
	// No such occurrence
	CAN_ESR1_ACKERR_ACKERR_0 = 0x0
	// An ACK error occurred since last read of this register
	CAN_ESR1_ACKERR_ACKERR_1 = 0x1
	// Position of BIT0ERR field.
	CAN_ESR1_BIT0ERR_Pos = 0xe
	// Bit mask of BIT0ERR field.
	CAN_ESR1_BIT0ERR_Msk = 0x4000
	// Bit BIT0ERR.
	CAN_ESR1_BIT0ERR = 0x4000
	// No such occurrence
	CAN_ESR1_BIT0ERR_BIT0ERR_0 = 0x0
	// At least one bit sent as dominant is received as recessive
	CAN_ESR1_BIT0ERR_BIT0ERR_1 = 0x1
	// Position of BIT1ERR field.
	CAN_ESR1_BIT1ERR_Pos = 0xf
	// Bit mask of BIT1ERR field.
	CAN_ESR1_BIT1ERR_Msk = 0x8000
	// Bit BIT1ERR.
	CAN_ESR1_BIT1ERR = 0x8000
	// No such occurrence
	CAN_ESR1_BIT1ERR_BIT1ERR_0 = 0x0
	// At least one bit sent as recessive is received as dominant
	CAN_ESR1_BIT1ERR_BIT1ERR_1 = 0x1
	// Position of RWRNINT field.
	CAN_ESR1_RWRNINT_Pos = 0x10
	// Bit mask of RWRNINT field.
	CAN_ESR1_RWRNINT_Msk = 0x10000
	// Bit RWRNINT.
	CAN_ESR1_RWRNINT = 0x10000
	// No such occurrence
	CAN_ESR1_RWRNINT_RWRNINT_0 = 0x0
	// The Rx error counter transition from < 96 to >= 96
	CAN_ESR1_RWRNINT_RWRNINT_1 = 0x1
	// Position of TWRNINT field.
	CAN_ESR1_TWRNINT_Pos = 0x11
	// Bit mask of TWRNINT field.
	CAN_ESR1_TWRNINT_Msk = 0x20000
	// Bit TWRNINT.
	CAN_ESR1_TWRNINT = 0x20000
	// No such occurrence
	CAN_ESR1_TWRNINT_TWRNINT_0 = 0x0
	// The Tx error counter transition from < 96 to >= 96
	CAN_ESR1_TWRNINT_TWRNINT_1 = 0x1
	// Position of SYNCH field.
	CAN_ESR1_SYNCH_Pos = 0x12
	// Bit mask of SYNCH field.
	CAN_ESR1_SYNCH_Msk = 0x40000
	// Bit SYNCH.
	CAN_ESR1_SYNCH = 0x40000
	// FlexCAN is not synchronized to the CAN bus
	CAN_ESR1_SYNCH_SYNCH_0 = 0x0
	// FlexCAN is synchronized to the CAN bus
	CAN_ESR1_SYNCH_SYNCH_1 = 0x1

	// IMASK2: Interrupt Masks 2 Register
	// Position of BUFHM field.
	CAN_IMASK2_BUFHM_Pos = 0x0
	// Bit mask of BUFHM field.
	CAN_IMASK2_BUFHM_Msk = 0xffffffff
	// The corresponding buffer Interrupt is disabled
	CAN_IMASK2_BUFHM_BUFHM_0 = 0x0
	// The corresponding buffer Interrupt is enabled
	CAN_IMASK2_BUFHM_BUFHM_1 = 0x1

	// IMASK1: Interrupt Masks 1 Register
	// Position of BUFLM field.
	CAN_IMASK1_BUFLM_Pos = 0x0
	// Bit mask of BUFLM field.
	CAN_IMASK1_BUFLM_Msk = 0xffffffff
	// The corresponding buffer Interrupt is disabled
	CAN_IMASK1_BUFLM_BUFLM_0 = 0x0
	// The corresponding buffer Interrupt is enabled
	CAN_IMASK1_BUFLM_BUFLM_1 = 0x1

	// IFLAG2: Interrupt Flags 2 Register
	// Position of BUFHI field.
	CAN_IFLAG2_BUFHI_Pos = 0x0
	// Bit mask of BUFHI field.
	CAN_IFLAG2_BUFHI_Msk = 0xffffffff
	// No such occurrence
	CAN_IFLAG2_BUFHI_BUFHI_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception
	CAN_IFLAG2_BUFHI_BUFHI_1 = 0x1

	// IFLAG1: Interrupt Flags 1 Register
	// Position of BUF4TO0I field.
	CAN_IFLAG1_BUF4TO0I_Pos = 0x0
	// Bit mask of BUF4TO0I field.
	CAN_IFLAG1_BUF4TO0I_Msk = 0x1f
	// No such occurrence
	CAN_IFLAG1_BUF4TO0I_BUF4TO0I_0 = 0x0
	// Corresponding MB completed transmission/reception
	CAN_IFLAG1_BUF4TO0I_BUF4TO0I_1 = 0x1
	// Position of BUF5I field.
	CAN_IFLAG1_BUF5I_Pos = 0x5
	// Bit mask of BUF5I field.
	CAN_IFLAG1_BUF5I_Msk = 0x20
	// Bit BUF5I.
	CAN_IFLAG1_BUF5I = 0x20
	// No such occurrence
	CAN_IFLAG1_BUF5I_BUF5I_0 = 0x0
	// MB5 completed transmission/reception or frames available in the FIFO
	CAN_IFLAG1_BUF5I_BUF5I_1 = 0x1
	// Position of BUF6I field.
	CAN_IFLAG1_BUF6I_Pos = 0x6
	// Bit mask of BUF6I field.
	CAN_IFLAG1_BUF6I_Msk = 0x40
	// Bit BUF6I.
	CAN_IFLAG1_BUF6I = 0x40
	// No such occurrence
	CAN_IFLAG1_BUF6I_BUF6I_0 = 0x0
	// MB6 completed transmission/reception or FIFO almost full
	CAN_IFLAG1_BUF6I_BUF6I_1 = 0x1
	// Position of BUF7I field.
	CAN_IFLAG1_BUF7I_Pos = 0x7
	// Bit mask of BUF7I field.
	CAN_IFLAG1_BUF7I_Msk = 0x80
	// Bit BUF7I.
	CAN_IFLAG1_BUF7I = 0x80
	// No such occurrence
	CAN_IFLAG1_BUF7I_BUF7I_0 = 0x0
	// MB7 completed transmission/reception or FIFO overflow
	CAN_IFLAG1_BUF7I_BUF7I_1 = 0x1
	// Position of BUF31TO8I field.
	CAN_IFLAG1_BUF31TO8I_Pos = 0x8
	// Bit mask of BUF31TO8I field.
	CAN_IFLAG1_BUF31TO8I_Msk = 0xffffff00
	// No such occurrence
	CAN_IFLAG1_BUF31TO8I_BUF31TO8I_0 = 0x0
	// The corresponding MB has successfully completed transmission or reception
	CAN_IFLAG1_BUF31TO8I_BUF31TO8I_1 = 0x1

	// CTRL2: Control 2 Register
	// Position of EACEN field.
	CAN_CTRL2_EACEN_Pos = 0x10
	// Bit mask of EACEN field.
	CAN_CTRL2_EACEN_Msk = 0x10000
	// Bit EACEN.
	CAN_CTRL2_EACEN = 0x10000
	// Rx Mailbox filter's IDE bit is always compared and RTR is never compared despite mask bits.
	CAN_CTRL2_EACEN_EACEN_0 = 0x0
	// Enables the comparison of both Rx Mailbox filter's IDE and RTR bit with their corresponding bits within the incoming frame. Mask bits do apply.
	CAN_CTRL2_EACEN_EACEN_1 = 0x1
	// Position of RRS field.
	CAN_CTRL2_RRS_Pos = 0x11
	// Bit mask of RRS field.
	CAN_CTRL2_RRS_Msk = 0x20000
	// Bit RRS.
	CAN_CTRL2_RRS = 0x20000
	// Remote Response Frame is generated
	CAN_CTRL2_RRS_RRS_0 = 0x0
	// Remote Request Frame is stored
	CAN_CTRL2_RRS_RRS_1 = 0x1
	// Position of MRP field.
	CAN_CTRL2_MRP_Pos = 0x12
	// Bit mask of MRP field.
	CAN_CTRL2_MRP_Msk = 0x40000
	// Bit MRP.
	CAN_CTRL2_MRP = 0x40000
	// Matching starts from Rx FIFO and continues on Mailboxes
	CAN_CTRL2_MRP_MRP_0 = 0x0
	// Matching starts from Mailboxes and continues on Rx FIFO
	CAN_CTRL2_MRP_MRP_1 = 0x1
	// Position of TASD field.
	CAN_CTRL2_TASD_Pos = 0x13
	// Bit mask of TASD field.
	CAN_CTRL2_TASD_Msk = 0xf80000
	// Position of RFFN field.
	CAN_CTRL2_RFFN_Pos = 0x18
	// Bit mask of RFFN field.
	CAN_CTRL2_RFFN_Msk = 0xf000000
	// Position of WRMFRZ field.
	CAN_CTRL2_WRMFRZ_Pos = 0x1c
	// Bit mask of WRMFRZ field.
	CAN_CTRL2_WRMFRZ_Msk = 0x10000000
	// Bit WRMFRZ.
	CAN_CTRL2_WRMFRZ = 0x10000000
	// Keep the write access restricted in some regions of FlexCAN memory
	CAN_CTRL2_WRMFRZ_WRMFRZ_0 = 0x0
	// Enable unrestricted write access to FlexCAN memory
	CAN_CTRL2_WRMFRZ_WRMFRZ_1 = 0x1

	// ESR2: Error and Status 2 Register
	// Position of IMB field.
	CAN_ESR2_IMB_Pos = 0xd
	// Bit mask of IMB field.
	CAN_ESR2_IMB_Msk = 0x2000
	// Bit IMB.
	CAN_ESR2_IMB = 0x2000
	// If ESR2[VPS] is asserted, the ESR2[LPTM] is not an inactive Mailbox.
	CAN_ESR2_IMB_IMB_0 = 0x0
	// If ESR2[VPS] is asserted, there is at least one inactive Mailbox. LPTM content is the number of the first one.
	CAN_ESR2_IMB_IMB_1 = 0x1
	// Position of VPS field.
	CAN_ESR2_VPS_Pos = 0xe
	// Bit mask of VPS field.
	CAN_ESR2_VPS_Msk = 0x4000
	// Bit VPS.
	CAN_ESR2_VPS = 0x4000
	// Contents of IMB and LPTM are invalid
	CAN_ESR2_VPS_VPS_0 = 0x0
	// Contents of IMB and LPTM are valid
	CAN_ESR2_VPS_VPS_1 = 0x1
	// Position of LPTM field.
	CAN_ESR2_LPTM_Pos = 0x10
	// Bit mask of LPTM field.
	CAN_ESR2_LPTM_Msk = 0x7f0000

	// CRCR: CRC Register
	// Position of TXCRC field.
	CAN_CRCR_TXCRC_Pos = 0x0
	// Bit mask of TXCRC field.
	CAN_CRCR_TXCRC_Msk = 0x7fff
	// Position of MBCRC field.
	CAN_CRCR_MBCRC_Pos = 0x10
	// Bit mask of MBCRC field.
	CAN_CRCR_MBCRC_Msk = 0x7f0000

	// RXFGMASK: Rx FIFO Global Mask Register
	// Position of FGM field.
	CAN_RXFGMASK_FGM_Pos = 0x0
	// Bit mask of FGM field.
	CAN_RXFGMASK_FGM_Msk = 0xffffffff
	// The corresponding bit in the filter is "don't care"
	CAN_RXFGMASK_FGM_FGM_0 = 0x0
	// The corresponding bit in the filter is checked
	CAN_RXFGMASK_FGM_FGM_1 = 0x1

	// RXFIR: Rx FIFO Information Register
	// Position of IDHIT field.
	CAN_RXFIR_IDHIT_Pos = 0x0
	// Bit mask of IDHIT field.
	CAN_RXFIR_IDHIT_Msk = 0x1ff

	// DBG1: Debug 1 register
	// Position of CFSM field.
	CAN_DBG1_CFSM_Pos = 0x0
	// Bit mask of CFSM field.
	CAN_DBG1_CFSM_Msk = 0x3f
	// Position of CBN field.
	CAN_DBG1_CBN_Pos = 0x18
	// Bit mask of CBN field.
	CAN_DBG1_CBN_Msk = 0x1f000000

	// DBG2: Debug 2 register
	// Position of RMP field.
	CAN_DBG2_RMP_Pos = 0x0
	// Bit mask of RMP field.
	CAN_DBG2_RMP_Msk = 0x7f
	// Position of MPP field.
	CAN_DBG2_MPP_Pos = 0x7
	// Bit mask of MPP field.
	CAN_DBG2_MPP_Msk = 0x80
	// Bit MPP.
	CAN_DBG2_MPP = 0x80
	// No matching process ongoing.
	CAN_DBG2_MPP_MPP_0 = 0x0
	// Matching process is in progress.
	CAN_DBG2_MPP_MPP_1 = 0x1
	// Position of TAP field.
	CAN_DBG2_TAP_Pos = 0x8
	// Bit mask of TAP field.
	CAN_DBG2_TAP_Msk = 0x7f00
	// Position of APP field.
	CAN_DBG2_APP_Pos = 0xf
	// Bit mask of APP field.
	CAN_DBG2_APP_Msk = 0x8000
	// Bit APP.
	CAN_DBG2_APP = 0x8000
	// No matching process ongoing.
	CAN_DBG2_APP_APP_0 = 0x0
	// Matching process is in progress.
	CAN_DBG2_APP_APP_1 = 0x1

	// RXIMR0: Rx Individual Mask Registers
	// Position of MI field.
	CAN_RXIMR_MI_Pos = 0x0
	// Bit mask of MI field.
	CAN_RXIMR_MI_Msk = 0xffffffff
	// the corresponding bit in the filter is "don't care"
	CAN_RXIMR_MI_MI_0 = 0x0
	// The corresponding bit in the filter is checked
	CAN_RXIMR_MI_MI_1 = 0x1

	// GFWR: Glitch Filter Width Registers
	// Position of GFWR field.
	CAN_GFWR_GFWR_Pos = 0x0
	// Bit mask of GFWR field.
	CAN_GFWR_GFWR_Msk = 0xff
)

// Bitfields for TMR1: Quad Timer
const (
	// COMP10: Timer Channel Compare Register 1
	// Position of COMPARISON_1 field.
	TMR_COMP1_COMPARISON_1_Pos = 0x0
	// Bit mask of COMPARISON_1 field.
	TMR_COMP1_COMPARISON_1_Msk = 0xffff

	// COMP20: Timer Channel Compare Register 2
	// Position of COMPARISON_2 field.
	TMR_COMP2_COMPARISON_2_Pos = 0x0
	// Bit mask of COMPARISON_2 field.
	TMR_COMP2_COMPARISON_2_Msk = 0xffff

	// CAPT0: Timer Channel Capture Register
	// Position of CAPTURE field.
	TMR_CAPT_CAPTURE_Pos = 0x0
	// Bit mask of CAPTURE field.
	TMR_CAPT_CAPTURE_Msk = 0xffff

	// LOAD0: Timer Channel Load Register
	// Position of LOAD field.
	TMR_LOAD_LOAD_Pos = 0x0
	// Bit mask of LOAD field.
	TMR_LOAD_LOAD_Msk = 0xffff

	// HOLD0: Timer Channel Hold Register
	// Position of HOLD field.
	TMR_HOLD_HOLD_Pos = 0x0
	// Bit mask of HOLD field.
	TMR_HOLD_HOLD_Msk = 0xffff

	// CNTR0: Timer Channel Counter Register
	// Position of COUNTER field.
	TMR_CNTR_COUNTER_Pos = 0x0
	// Bit mask of COUNTER field.
	TMR_CNTR_COUNTER_Msk = 0xffff

	// CTRL0: Timer Channel Control Register
	// Position of OUTMODE field.
	TMR_CTRL_OUTMODE_Pos = 0x0
	// Bit mask of OUTMODE field.
	TMR_CTRL_OUTMODE_Msk = 0x7
	// Asserted while counter is active
	TMR_CTRL_OUTMODE_OUTMODE_0 = 0x0
	// Clear OFLAG output on successful compare
	TMR_CTRL_OUTMODE_OUTMODE_1 = 0x1
	// Set OFLAG output on successful compare
	TMR_CTRL_OUTMODE_OUTMODE_2 = 0x2
	// Toggle OFLAG output on successful compare
	TMR_CTRL_OUTMODE_OUTMODE_3 = 0x3
	// Toggle OFLAG output using alternating compare registers
	TMR_CTRL_OUTMODE_OUTMODE_4 = 0x4
	// Set on compare, cleared on secondary source input edge
	TMR_CTRL_OUTMODE_OUTMODE_5 = 0x5
	// Set on compare, cleared on counter rollover
	TMR_CTRL_OUTMODE_OUTMODE_6 = 0x6
	// Enable gated clock output while counter is active
	TMR_CTRL_OUTMODE_OUTMODE_7 = 0x7
	// Position of COINIT field.
	TMR_CTRL_COINIT_Pos = 0x3
	// Bit mask of COINIT field.
	TMR_CTRL_COINIT_Msk = 0x8
	// Bit COINIT.
	TMR_CTRL_COINIT = 0x8
	// Co-channel counter/timers cannot force a re-initialization of this counter/timer
	TMR_CTRL_COINIT_COINIT_0 = 0x0
	// Co-channel counter/timers may force a re-initialization of this counter/timer
	TMR_CTRL_COINIT_COINIT_1 = 0x1
	// Position of DIR field.
	TMR_CTRL_DIR_Pos = 0x4
	// Bit mask of DIR field.
	TMR_CTRL_DIR_Msk = 0x10
	// Bit DIR.
	TMR_CTRL_DIR = 0x10
	// Count up.
	TMR_CTRL_DIR_DIR_0 = 0x0
	// Count down.
	TMR_CTRL_DIR_DIR_1 = 0x1
	// Position of LENGTH field.
	TMR_CTRL_LENGTH_Pos = 0x5
	// Bit mask of LENGTH field.
	TMR_CTRL_LENGTH_Msk = 0x20
	// Bit LENGTH.
	TMR_CTRL_LENGTH = 0x20
	// Count until roll over at $FFFF and continue from $0000.
	TMR_CTRL_LENGTH_LENGTH_0 = 0x0
	// Count until compare, then re-initialize. If counting up, a successful compare occurs when the counter reaches a COMP1 value. If counting down, a successful compare occurs when the counter reaches a COMP2 value. When output mode $4 is used, alternating values of COMP1 and COMP2 are used to generate successful comparisons. For example, the counter counts until a COMP1 value is reached, re-initializes, counts until COMP2 value is reached, re-initializes, counts until COMP1 value is reached, and so on.
	TMR_CTRL_LENGTH_LENGTH_1 = 0x1
	// Position of ONCE field.
	TMR_CTRL_ONCE_Pos = 0x6
	// Bit mask of ONCE field.
	TMR_CTRL_ONCE_Msk = 0x40
	// Bit ONCE.
	TMR_CTRL_ONCE = 0x40
	// Count repeatedly.
	TMR_CTRL_ONCE_ONCE_0 = 0x0
	// Count until compare and then stop. If counting up, a successful compare occurs when the counter reaches a COMP1 value. If counting down, a successful compare occurs when the counter reaches a COMP2 value. When output mode $4 is used, the counter re-initializes after reaching the COMP1 value, continues to count to the COMP2 value, and then stops.
	TMR_CTRL_ONCE_ONCE_1 = 0x1
	// Position of SCS field.
	TMR_CTRL_SCS_Pos = 0x7
	// Bit mask of SCS field.
	TMR_CTRL_SCS_Msk = 0x180
	// Counter 0 input pin
	TMR_CTRL_SCS_SCS_0 = 0x0
	// Counter 1 input pin
	TMR_CTRL_SCS_SCS_1 = 0x1
	// Counter 2 input pin
	TMR_CTRL_SCS_SCS_2 = 0x2
	// Counter 3 input pin
	TMR_CTRL_SCS_SCS_3 = 0x3
	// Position of PCS field.
	TMR_CTRL_PCS_Pos = 0x9
	// Bit mask of PCS field.
	TMR_CTRL_PCS_Msk = 0x1e00
	// Counter 0 input pin
	TMR_CTRL_PCS_PCS_0 = 0x0
	// Counter 1 input pin
	TMR_CTRL_PCS_PCS_1 = 0x1
	// Counter 2 input pin
	TMR_CTRL_PCS_PCS_2 = 0x2
	// Counter 3 input pin
	TMR_CTRL_PCS_PCS_3 = 0x3
	// Counter 0 output
	TMR_CTRL_PCS_PCS_4 = 0x4
	// Counter 1 output
	TMR_CTRL_PCS_PCS_5 = 0x5
	// Counter 2 output
	TMR_CTRL_PCS_PCS_6 = 0x6
	// Counter 3 output
	TMR_CTRL_PCS_PCS_7 = 0x7
	// IP bus clock divide by 1 prescaler
	TMR_CTRL_PCS_PCS_8 = 0x8
	// IP bus clock divide by 2 prescaler
	TMR_CTRL_PCS_PCS_9 = 0x9
	// IP bus clock divide by 4 prescaler
	TMR_CTRL_PCS_PCS_10 = 0xa
	// IP bus clock divide by 8 prescaler
	TMR_CTRL_PCS_PCS_11 = 0xb
	// IP bus clock divide by 16 prescaler
	TMR_CTRL_PCS_PCS_12 = 0xc
	// IP bus clock divide by 32 prescaler
	TMR_CTRL_PCS_PCS_13 = 0xd
	// IP bus clock divide by 64 prescaler
	TMR_CTRL_PCS_PCS_14 = 0xe
	// IP bus clock divide by 128 prescaler
	TMR_CTRL_PCS_PCS_15 = 0xf
	// Position of CM field.
	TMR_CTRL_CM_Pos = 0xd
	// Bit mask of CM field.
	TMR_CTRL_CM_Msk = 0xe000
	// No operation
	TMR_CTRL_CM_CM_0 = 0x0
	// Count rising edges of primary sourceRising edges are counted only when SCTRL[IPS] = 0. Falling edges are counted when SCTRL[IPS] = 1. If the primary count source is IP bus clock divide by 1, only rising edges are counted regardless of the value of SCTRL[IPS].
	TMR_CTRL_CM_CM_1 = 0x1
	// Count rising and falling edges of primary sourceIP bus clock divide by 1 cannot be used as a primary count source in edge count mode.
	TMR_CTRL_CM_CM_2 = 0x2
	// Count rising edges of primary source while secondary input high active
	TMR_CTRL_CM_CM_3 = 0x3
	// Quadrature count mode, uses primary and secondary sources
	TMR_CTRL_CM_CM_4 = 0x4
	// Count rising edges of primary source; secondary source specifies directionRising edges are counted only when SCTRL[IPS] = 0. Falling edges are counted when SCTRL[IPS] = 1.
	TMR_CTRL_CM_CM_5 = 0x5
	// Edge of secondary source triggers primary count until compare
	TMR_CTRL_CM_CM_6 = 0x6
	// Cascaded counter mode (up/down)The primary count source must be set to one of the counter outputs.
	TMR_CTRL_CM_CM_7 = 0x7

	// SCTRL0: Timer Channel Status and Control Register
	// Position of OEN field.
	TMR_SCTRL_OEN_Pos = 0x0
	// Bit mask of OEN field.
	TMR_SCTRL_OEN_Msk = 0x1
	// Bit OEN.
	TMR_SCTRL_OEN = 0x1
	// The external pin is configured as an input.
	TMR_SCTRL_OEN_OEN_0 = 0x0
	// The OFLAG output signal is driven on the external pin. Other timer groups using this external pin as their input see the driven value. The polarity of the signal is determined by OPS.
	TMR_SCTRL_OEN_OEN_1 = 0x1
	// Position of OPS field.
	TMR_SCTRL_OPS_Pos = 0x1
	// Bit mask of OPS field.
	TMR_SCTRL_OPS_Msk = 0x2
	// Bit OPS.
	TMR_SCTRL_OPS = 0x2
	// True polarity.
	TMR_SCTRL_OPS_OPS_0 = 0x0
	// Inverted polarity.
	TMR_SCTRL_OPS_OPS_1 = 0x1
	// Position of FORCE field.
	TMR_SCTRL_FORCE_Pos = 0x2
	// Bit mask of FORCE field.
	TMR_SCTRL_FORCE_Msk = 0x4
	// Bit FORCE.
	TMR_SCTRL_FORCE = 0x4
	// Position of VAL field.
	TMR_SCTRL_VAL_Pos = 0x3
	// Bit mask of VAL field.
	TMR_SCTRL_VAL_Msk = 0x8
	// Bit VAL.
	TMR_SCTRL_VAL = 0x8
	// Position of EEOF field.
	TMR_SCTRL_EEOF_Pos = 0x4
	// Bit mask of EEOF field.
	TMR_SCTRL_EEOF_Msk = 0x10
	// Bit EEOF.
	TMR_SCTRL_EEOF = 0x10
	// Position of MSTR field.
	TMR_SCTRL_MSTR_Pos = 0x5
	// Bit mask of MSTR field.
	TMR_SCTRL_MSTR_Msk = 0x20
	// Bit MSTR.
	TMR_SCTRL_MSTR = 0x20
	// Position of CAPTURE_MODE field.
	TMR_SCTRL_CAPTURE_MODE_Pos = 0x6
	// Bit mask of CAPTURE_MODE field.
	TMR_SCTRL_CAPTURE_MODE_Msk = 0xc0
	// Capture function is disabled
	TMR_SCTRL_CAPTURE_MODE_CAPTURE_MODE_0 = 0x0
	// Load capture register on rising edge (when IPS=0) or falling edge (when IPS=1) of input
	TMR_SCTRL_CAPTURE_MODE_CAPTURE_MODE_1 = 0x1
	// Load capture register on falling edge (when IPS=0) or rising edge (when IPS=1) of input
	TMR_SCTRL_CAPTURE_MODE_CAPTURE_MODE_2 = 0x2
	// Load capture register on both edges of input
	TMR_SCTRL_CAPTURE_MODE_CAPTURE_MODE_3 = 0x3
	// Position of INPUT field.
	TMR_SCTRL_INPUT_Pos = 0x8
	// Bit mask of INPUT field.
	TMR_SCTRL_INPUT_Msk = 0x100
	// Bit INPUT.
	TMR_SCTRL_INPUT = 0x100
	// Position of IPS field.
	TMR_SCTRL_IPS_Pos = 0x9
	// Bit mask of IPS field.
	TMR_SCTRL_IPS_Msk = 0x200
	// Bit IPS.
	TMR_SCTRL_IPS = 0x200
	// Position of IEFIE field.
	TMR_SCTRL_IEFIE_Pos = 0xa
	// Bit mask of IEFIE field.
	TMR_SCTRL_IEFIE_Msk = 0x400
	// Bit IEFIE.
	TMR_SCTRL_IEFIE = 0x400
	// Position of IEF field.
	TMR_SCTRL_IEF_Pos = 0xb
	// Bit mask of IEF field.
	TMR_SCTRL_IEF_Msk = 0x800
	// Bit IEF.
	TMR_SCTRL_IEF = 0x800
	// Position of TOFIE field.
	TMR_SCTRL_TOFIE_Pos = 0xc
	// Bit mask of TOFIE field.
	TMR_SCTRL_TOFIE_Msk = 0x1000
	// Bit TOFIE.
	TMR_SCTRL_TOFIE = 0x1000
	// Position of TOF field.
	TMR_SCTRL_TOF_Pos = 0xd
	// Bit mask of TOF field.
	TMR_SCTRL_TOF_Msk = 0x2000
	// Bit TOF.
	TMR_SCTRL_TOF = 0x2000
	// Position of TCFIE field.
	TMR_SCTRL_TCFIE_Pos = 0xe
	// Bit mask of TCFIE field.
	TMR_SCTRL_TCFIE_Msk = 0x4000
	// Bit TCFIE.
	TMR_SCTRL_TCFIE = 0x4000
	// Position of TCF field.
	TMR_SCTRL_TCF_Pos = 0xf
	// Bit mask of TCF field.
	TMR_SCTRL_TCF_Msk = 0x8000
	// Bit TCF.
	TMR_SCTRL_TCF = 0x8000

	// CMPLD10: Timer Channel Comparator Load Register 1
	// Position of COMPARATOR_LOAD_1 field.
	TMR_CMPLD1_COMPARATOR_LOAD_1_Pos = 0x0
	// Bit mask of COMPARATOR_LOAD_1 field.
	TMR_CMPLD1_COMPARATOR_LOAD_1_Msk = 0xffff

	// CMPLD20: Timer Channel Comparator Load Register 2
	// Position of COMPARATOR_LOAD_2 field.
	TMR_CMPLD2_COMPARATOR_LOAD_2_Pos = 0x0
	// Bit mask of COMPARATOR_LOAD_2 field.
	TMR_CMPLD2_COMPARATOR_LOAD_2_Msk = 0xffff

	// CSCTRL0: Timer Channel Comparator Status and Control Register
	// Position of CL1 field.
	TMR_CSCTRL_CL1_Pos = 0x0
	// Bit mask of CL1 field.
	TMR_CSCTRL_CL1_Msk = 0x3
	// Never preload
	TMR_CSCTRL_CL1_CL1_0 = 0x0
	// Load upon successful compare with the value in COMP1
	TMR_CSCTRL_CL1_CL1_1 = 0x1
	// Load upon successful compare with the value in COMP2
	TMR_CSCTRL_CL1_CL1_2 = 0x2
	// Position of CL2 field.
	TMR_CSCTRL_CL2_Pos = 0x2
	// Bit mask of CL2 field.
	TMR_CSCTRL_CL2_Msk = 0xc
	// Never preload
	TMR_CSCTRL_CL2_CL2_0 = 0x0
	// Load upon successful compare with the value in COMP1
	TMR_CSCTRL_CL2_CL2_1 = 0x1
	// Load upon successful compare with the value in COMP2
	TMR_CSCTRL_CL2_CL2_2 = 0x2
	// Position of TCF1 field.
	TMR_CSCTRL_TCF1_Pos = 0x4
	// Bit mask of TCF1 field.
	TMR_CSCTRL_TCF1_Msk = 0x10
	// Bit TCF1.
	TMR_CSCTRL_TCF1 = 0x10
	// Position of TCF2 field.
	TMR_CSCTRL_TCF2_Pos = 0x5
	// Bit mask of TCF2 field.
	TMR_CSCTRL_TCF2_Msk = 0x20
	// Bit TCF2.
	TMR_CSCTRL_TCF2 = 0x20
	// Position of TCF1EN field.
	TMR_CSCTRL_TCF1EN_Pos = 0x6
	// Bit mask of TCF1EN field.
	TMR_CSCTRL_TCF1EN_Msk = 0x40
	// Bit TCF1EN.
	TMR_CSCTRL_TCF1EN = 0x40
	// Position of TCF2EN field.
	TMR_CSCTRL_TCF2EN_Pos = 0x7
	// Bit mask of TCF2EN field.
	TMR_CSCTRL_TCF2EN_Msk = 0x80
	// Bit TCF2EN.
	TMR_CSCTRL_TCF2EN = 0x80
	// Position of UP field.
	TMR_CSCTRL_UP_Pos = 0x9
	// Bit mask of UP field.
	TMR_CSCTRL_UP_Msk = 0x200
	// Bit UP.
	TMR_CSCTRL_UP = 0x200
	// The last count was in the DOWN direction.
	TMR_CSCTRL_UP_UP_0 = 0x0
	// The last count was in the UP direction.
	TMR_CSCTRL_UP_UP_1 = 0x1
	// Position of TCI field.
	TMR_CSCTRL_TCI_Pos = 0xa
	// Bit mask of TCI field.
	TMR_CSCTRL_TCI_Msk = 0x400
	// Bit TCI.
	TMR_CSCTRL_TCI = 0x400
	// Stop counter upon receiving a second trigger event while still counting from the first trigger event.
	TMR_CSCTRL_TCI_TCI_0 = 0x0
	// Reload the counter upon receiving a second trigger event while still counting from the first trigger event.
	TMR_CSCTRL_TCI_TCI_1 = 0x1
	// Position of ROC field.
	TMR_CSCTRL_ROC_Pos = 0xb
	// Bit mask of ROC field.
	TMR_CSCTRL_ROC_Msk = 0x800
	// Bit ROC.
	TMR_CSCTRL_ROC = 0x800
	// Do not reload the counter on a capture event.
	TMR_CSCTRL_ROC_ROC_0 = 0x0
	// Reload the counter on a capture event.
	TMR_CSCTRL_ROC_ROC_1 = 0x1
	// Position of ALT_LOAD field.
	TMR_CSCTRL_ALT_LOAD_Pos = 0xc
	// Bit mask of ALT_LOAD field.
	TMR_CSCTRL_ALT_LOAD_Msk = 0x1000
	// Bit ALT_LOAD.
	TMR_CSCTRL_ALT_LOAD = 0x1000
	// Counter can be re-initialized only with the LOAD register.
	TMR_CSCTRL_ALT_LOAD_ALT_LOAD_0 = 0x0
	// Counter can be re-initialized with the LOAD or CMPLD2 registers depending on count direction.
	TMR_CSCTRL_ALT_LOAD_ALT_LOAD_1 = 0x1
	// Position of FAULT field.
	TMR_CSCTRL_FAULT_Pos = 0xd
	// Bit mask of FAULT field.
	TMR_CSCTRL_FAULT_Msk = 0x2000
	// Bit FAULT.
	TMR_CSCTRL_FAULT = 0x2000
	// Fault function disabled.
	TMR_CSCTRL_FAULT_FAULT_0 = 0x0
	// Fault function enabled.
	TMR_CSCTRL_FAULT_FAULT_1 = 0x1
	// Position of DBG_EN field.
	TMR_CSCTRL_DBG_EN_Pos = 0xe
	// Bit mask of DBG_EN field.
	TMR_CSCTRL_DBG_EN_Msk = 0xc000
	// Continue with normal operation during debug mode. (default)
	TMR_CSCTRL_DBG_EN_DBG_EN_0 = 0x0
	// Halt TMR counter during debug mode.
	TMR_CSCTRL_DBG_EN_DBG_EN_1 = 0x1
	// Force TMR output to logic 0 (prior to consideration of SCTRL[OPS]).
	TMR_CSCTRL_DBG_EN_DBG_EN_2 = 0x2
	// Both halt counter and force output to 0 during debug mode.
	TMR_CSCTRL_DBG_EN_DBG_EN_3 = 0x3

	// FILT0: Timer Channel Input Filter Register
	// Position of FILT_PER field.
	TMR_FILT_FILT_PER_Pos = 0x0
	// Bit mask of FILT_PER field.
	TMR_FILT_FILT_PER_Msk = 0xff
	// Position of FILT_CNT field.
	TMR_FILT_FILT_CNT_Pos = 0x8
	// Bit mask of FILT_CNT field.
	TMR_FILT_FILT_CNT_Msk = 0x700

	// DMA0: Timer Channel DMA Enable Register
	// Position of IEFDE field.
	TMR_DMA_IEFDE_Pos = 0x0
	// Bit mask of IEFDE field.
	TMR_DMA_IEFDE_Msk = 0x1
	// Bit IEFDE.
	TMR_DMA_IEFDE = 0x1
	// Position of CMPLD1DE field.
	TMR_DMA_CMPLD1DE_Pos = 0x1
	// Bit mask of CMPLD1DE field.
	TMR_DMA_CMPLD1DE_Msk = 0x2
	// Bit CMPLD1DE.
	TMR_DMA_CMPLD1DE = 0x2
	// Position of CMPLD2DE field.
	TMR_DMA_CMPLD2DE_Pos = 0x2
	// Bit mask of CMPLD2DE field.
	TMR_DMA_CMPLD2DE_Msk = 0x4
	// Bit CMPLD2DE.
	TMR_DMA_CMPLD2DE = 0x4

	// ENBL: Timer Channel Enable Register
	// Position of ENBL field.
	TMR_ENBL_ENBL_Pos = 0x0
	// Bit mask of ENBL field.
	TMR_ENBL_ENBL_Msk = 0xf
	// Timer channel is disabled.
	TMR_ENBL_ENBL_ENBL_0 = 0x0
	// Timer channel is enabled. (default)
	TMR_ENBL_ENBL_ENBL_1 = 0x1
)

// Bitfields for GPT1: GPT
const (
	// CR: GPT Control Register
	// Position of EN field.
	GPT_CR_EN_Pos = 0x0
	// Bit mask of EN field.
	GPT_CR_EN_Msk = 0x1
	// Bit EN.
	GPT_CR_EN = 0x1
	// GPT is disabled.
	GPT_CR_EN_EN_0 = 0x0
	// GPT is enabled.
	GPT_CR_EN_EN_1 = 0x1
	// Position of ENMOD field.
	GPT_CR_ENMOD_Pos = 0x1
	// Bit mask of ENMOD field.
	GPT_CR_ENMOD_Msk = 0x2
	// Bit ENMOD.
	GPT_CR_ENMOD = 0x2
	// GPT counter will retain its value when it is disabled.
	GPT_CR_ENMOD_ENMOD_0 = 0x0
	// GPT counter value is reset to 0 when it is disabled.
	GPT_CR_ENMOD_ENMOD_1 = 0x1
	// Position of DBGEN field.
	GPT_CR_DBGEN_Pos = 0x2
	// Bit mask of DBGEN field.
	GPT_CR_DBGEN_Msk = 0x4
	// Bit DBGEN.
	GPT_CR_DBGEN = 0x4
	// GPT is disabled in debug mode.
	GPT_CR_DBGEN_DBGEN_0 = 0x0
	// GPT is enabled in debug mode.
	GPT_CR_DBGEN_DBGEN_1 = 0x1
	// Position of WAITEN field.
	GPT_CR_WAITEN_Pos = 0x3
	// Bit mask of WAITEN field.
	GPT_CR_WAITEN_Msk = 0x8
	// Bit WAITEN.
	GPT_CR_WAITEN = 0x8
	// GPT is disabled in wait mode.
	GPT_CR_WAITEN_WAITEN_0 = 0x0
	// GPT is enabled in wait mode.
	GPT_CR_WAITEN_WAITEN_1 = 0x1
	// Position of DOZEEN field.
	GPT_CR_DOZEEN_Pos = 0x4
	// Bit mask of DOZEEN field.
	GPT_CR_DOZEEN_Msk = 0x10
	// Bit DOZEEN.
	GPT_CR_DOZEEN = 0x10
	// GPT is disabled in doze mode.
	GPT_CR_DOZEEN_DOZEEN_0 = 0x0
	// GPT is enabled in doze mode.
	GPT_CR_DOZEEN_DOZEEN_1 = 0x1
	// Position of STOPEN field.
	GPT_CR_STOPEN_Pos = 0x5
	// Bit mask of STOPEN field.
	GPT_CR_STOPEN_Msk = 0x20
	// Bit STOPEN.
	GPT_CR_STOPEN = 0x20
	// GPT is disabled in Stop mode.
	GPT_CR_STOPEN_STOPEN_0 = 0x0
	// GPT is enabled in Stop mode.
	GPT_CR_STOPEN_STOPEN_1 = 0x1
	// Position of CLKSRC field.
	GPT_CR_CLKSRC_Pos = 0x6
	// Bit mask of CLKSRC field.
	GPT_CR_CLKSRC_Msk = 0x1c0
	// No clock
	GPT_CR_CLKSRC_CLKSRC_0 = 0x0
	// Peripheral Clock (ipg_clk)
	GPT_CR_CLKSRC_CLKSRC_1 = 0x1
	// High Frequency Reference Clock (ipg_clk_highfreq)
	GPT_CR_CLKSRC_CLKSRC_2 = 0x2
	// External Clock
	GPT_CR_CLKSRC_CLKSRC_3 = 0x3
	// Low Frequency Reference Clock (ipg_clk_32k)
	GPT_CR_CLKSRC_CLKSRC_4 = 0x4
	// Crystal oscillator as Reference Clock (ipg_clk_24M)
	GPT_CR_CLKSRC_CLKSRC_5 = 0x5
	// Position of FRR field.
	GPT_CR_FRR_Pos = 0x9
	// Bit mask of FRR field.
	GPT_CR_FRR_Msk = 0x200
	// Bit FRR.
	GPT_CR_FRR = 0x200
	// Restart mode
	GPT_CR_FRR_FRR_0 = 0x0
	// Free-Run mode
	GPT_CR_FRR_FRR_1 = 0x1
	// Position of EN_24M field.
	GPT_CR_EN_24M_Pos = 0xa
	// Bit mask of EN_24M field.
	GPT_CR_EN_24M_Msk = 0x400
	// Bit EN_24M.
	GPT_CR_EN_24M = 0x400
	// 24M clock disabled
	GPT_CR_EN_24M_EN_24M_0 = 0x0
	// 24M clock enabled
	GPT_CR_EN_24M_EN_24M_1 = 0x1
	// Position of SWR field.
	GPT_CR_SWR_Pos = 0xf
	// Bit mask of SWR field.
	GPT_CR_SWR_Msk = 0x8000
	// Bit SWR.
	GPT_CR_SWR = 0x8000
	// GPT is not in reset state
	GPT_CR_SWR_SWR_0 = 0x0
	// GPT is in reset state
	GPT_CR_SWR_SWR_1 = 0x1
	// Position of IM1 field.
	GPT_CR_IM1_Pos = 0x10
	// Bit mask of IM1 field.
	GPT_CR_IM1_Msk = 0x30000
	// Position of IM2 field.
	GPT_CR_IM2_Pos = 0x12
	// Bit mask of IM2 field.
	GPT_CR_IM2_Msk = 0xc0000
	// capture disabled
	GPT_CR_IM2_IM2_0 = 0x0
	// capture on rising edge only
	GPT_CR_IM2_IM2_1 = 0x1
	// capture on falling edge only
	GPT_CR_IM2_IM2_2 = 0x2
	// capture on both edges
	GPT_CR_IM2_IM2_3 = 0x3
	// Position of OM1 field.
	GPT_CR_OM1_Pos = 0x14
	// Bit mask of OM1 field.
	GPT_CR_OM1_Msk = 0x700000
	// Position of OM2 field.
	GPT_CR_OM2_Pos = 0x17
	// Bit mask of OM2 field.
	GPT_CR_OM2_Msk = 0x3800000
	// Position of OM3 field.
	GPT_CR_OM3_Pos = 0x1a
	// Bit mask of OM3 field.
	GPT_CR_OM3_Msk = 0x1c000000
	// Output disconnected. No response on pin.
	GPT_CR_OM3_OM3_0 = 0x0
	// Toggle output pin
	GPT_CR_OM3_OM3_1 = 0x1
	// Clear output pin
	GPT_CR_OM3_OM3_2 = 0x2
	// Set output pin
	GPT_CR_OM3_OM3_3 = 0x3
	// Generate an active low pulse (that is one input clock wide) on the output pin.
	GPT_CR_OM3_OM3_4 = 0x4
	// Position of FO1 field.
	GPT_CR_FO1_Pos = 0x1d
	// Bit mask of FO1 field.
	GPT_CR_FO1_Msk = 0x20000000
	// Bit FO1.
	GPT_CR_FO1 = 0x20000000
	// Position of FO2 field.
	GPT_CR_FO2_Pos = 0x1e
	// Bit mask of FO2 field.
	GPT_CR_FO2_Msk = 0x40000000
	// Bit FO2.
	GPT_CR_FO2 = 0x40000000
	// Position of FO3 field.
	GPT_CR_FO3_Pos = 0x1f
	// Bit mask of FO3 field.
	GPT_CR_FO3_Msk = 0x80000000
	// Bit FO3.
	GPT_CR_FO3 = 0x80000000
	// Writing a 0 has no effect.
	GPT_CR_FO3_FO3_0 = 0x0
	// Causes the programmed pin action on the timer Output Compare n pin; the OFn flag is not set.
	GPT_CR_FO3_FO3_1 = 0x1

	// PR: GPT Prescaler Register
	// Position of PRESCALER field.
	GPT_PR_PRESCALER_Pos = 0x0
	// Bit mask of PRESCALER field.
	GPT_PR_PRESCALER_Msk = 0xfff
	// Divide by 1
	GPT_PR_PRESCALER_PRESCALER_0 = 0x0
	// Divide by 2
	GPT_PR_PRESCALER_PRESCALER_1 = 0x1
	// Divide by 4096
	GPT_PR_PRESCALER_PRESCALER_4095 = 0xfff
	// Position of PRESCALER24M field.
	GPT_PR_PRESCALER24M_Pos = 0xc
	// Bit mask of PRESCALER24M field.
	GPT_PR_PRESCALER24M_Msk = 0xf000
	// Divide by 1
	GPT_PR_PRESCALER24M_PRESCALER24M_0 = 0x0
	// Divide by 2
	GPT_PR_PRESCALER24M_PRESCALER24M_1 = 0x1
	// Divide by 16
	GPT_PR_PRESCALER24M_PRESCALER24M_15 = 0xf

	// SR: GPT Status Register
	// Position of OF1 field.
	GPT_SR_OF1_Pos = 0x0
	// Bit mask of OF1 field.
	GPT_SR_OF1_Msk = 0x1
	// Bit OF1.
	GPT_SR_OF1 = 0x1
	// Position of OF2 field.
	GPT_SR_OF2_Pos = 0x1
	// Bit mask of OF2 field.
	GPT_SR_OF2_Msk = 0x2
	// Bit OF2.
	GPT_SR_OF2 = 0x2
	// Position of OF3 field.
	GPT_SR_OF3_Pos = 0x2
	// Bit mask of OF3 field.
	GPT_SR_OF3_Msk = 0x4
	// Bit OF3.
	GPT_SR_OF3 = 0x4
	// Compare event has not occurred.
	GPT_SR_OF3_OF3_0 = 0x0
	// Compare event has occurred.
	GPT_SR_OF3_OF3_1 = 0x1
	// Position of IF1 field.
	GPT_SR_IF1_Pos = 0x3
	// Bit mask of IF1 field.
	GPT_SR_IF1_Msk = 0x8
	// Bit IF1.
	GPT_SR_IF1 = 0x8
	// Position of IF2 field.
	GPT_SR_IF2_Pos = 0x4
	// Bit mask of IF2 field.
	GPT_SR_IF2_Msk = 0x10
	// Bit IF2.
	GPT_SR_IF2 = 0x10
	// Capture event has not occurred.
	GPT_SR_IF2_IF2_0 = 0x0
	// Capture event has occurred.
	GPT_SR_IF2_IF2_1 = 0x1
	// Position of ROV field.
	GPT_SR_ROV_Pos = 0x5
	// Bit mask of ROV field.
	GPT_SR_ROV_Msk = 0x20
	// Bit ROV.
	GPT_SR_ROV = 0x20
	// Rollover has not occurred.
	GPT_SR_ROV_ROV_0 = 0x0
	// Rollover has occurred.
	GPT_SR_ROV_ROV_1 = 0x1

	// IR: GPT Interrupt Register
	// Position of OF1IE field.
	GPT_IR_OF1IE_Pos = 0x0
	// Bit mask of OF1IE field.
	GPT_IR_OF1IE_Msk = 0x1
	// Bit OF1IE.
	GPT_IR_OF1IE = 0x1
	// Position of OF2IE field.
	GPT_IR_OF2IE_Pos = 0x1
	// Bit mask of OF2IE field.
	GPT_IR_OF2IE_Msk = 0x2
	// Bit OF2IE.
	GPT_IR_OF2IE = 0x2
	// Position of OF3IE field.
	GPT_IR_OF3IE_Pos = 0x2
	// Bit mask of OF3IE field.
	GPT_IR_OF3IE_Msk = 0x4
	// Bit OF3IE.
	GPT_IR_OF3IE = 0x4
	// Output Compare Channel n interrupt is disabled.
	GPT_IR_OF3IE_OF3IE_0 = 0x0
	// Output Compare Channel n interrupt is enabled.
	GPT_IR_OF3IE_OF3IE_1 = 0x1
	// Position of IF1IE field.
	GPT_IR_IF1IE_Pos = 0x3
	// Bit mask of IF1IE field.
	GPT_IR_IF1IE_Msk = 0x8
	// Bit IF1IE.
	GPT_IR_IF1IE = 0x8
	// Position of IF2IE field.
	GPT_IR_IF2IE_Pos = 0x4
	// Bit mask of IF2IE field.
	GPT_IR_IF2IE_Msk = 0x10
	// Bit IF2IE.
	GPT_IR_IF2IE = 0x10
	// IF2IE Input Capture n Interrupt Enable is disabled.
	GPT_IR_IF2IE_IF2IE_0 = 0x0
	// IF2IE Input Capture n Interrupt Enable is enabled.
	GPT_IR_IF2IE_IF2IE_1 = 0x1
	// Position of ROVIE field.
	GPT_IR_ROVIE_Pos = 0x5
	// Bit mask of ROVIE field.
	GPT_IR_ROVIE_Msk = 0x20
	// Bit ROVIE.
	GPT_IR_ROVIE = 0x20
	// Rollover interrupt is disabled.
	GPT_IR_ROVIE_ROVIE_0 = 0x0
	// Rollover interrupt enabled.
	GPT_IR_ROVIE_ROVIE_1 = 0x1

	// OCR1: GPT Output Compare Register 1
	// Position of COMP field.
	GPT_OCR1_COMP_Pos = 0x0
	// Bit mask of COMP field.
	GPT_OCR1_COMP_Msk = 0xffffffff

	// OCR2: GPT Output Compare Register 2
	// Position of COMP field.
	GPT_OCR2_COMP_Pos = 0x0
	// Bit mask of COMP field.
	GPT_OCR2_COMP_Msk = 0xffffffff

	// OCR3: GPT Output Compare Register 3
	// Position of COMP field.
	GPT_OCR3_COMP_Pos = 0x0
	// Bit mask of COMP field.
	GPT_OCR3_COMP_Msk = 0xffffffff

	// ICR1: GPT Input Capture Register 1
	// Position of CAPT field.
	GPT_ICR1_CAPT_Pos = 0x0
	// Bit mask of CAPT field.
	GPT_ICR1_CAPT_Msk = 0xffffffff

	// ICR2: GPT Input Capture Register 2
	// Position of CAPT field.
	GPT_ICR2_CAPT_Pos = 0x0
	// Bit mask of CAPT field.
	GPT_ICR2_CAPT_Msk = 0xffffffff

	// CNT: GPT Counter Register
	// Position of COUNT field.
	GPT_CNT_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	GPT_CNT_COUNT_Msk = 0xffffffff
)

// Bitfields for OCOTP: OCOTP
const (
	// CTRL: OTP Controller Control Register
	// Position of ADDR field.
	OCOTP_CTRL_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	OCOTP_CTRL_ADDR_Msk = 0x3f
	// Position of RSVD0 field.
	OCOTP_CTRL_RSVD0_Pos = 0x6
	// Bit mask of RSVD0 field.
	OCOTP_CTRL_RSVD0_Msk = 0xc0
	// Position of BUSY field.
	OCOTP_CTRL_BUSY_Pos = 0x8
	// Bit mask of BUSY field.
	OCOTP_CTRL_BUSY_Msk = 0x100
	// Bit BUSY.
	OCOTP_CTRL_BUSY = 0x100
	// Position of ERROR field.
	OCOTP_CTRL_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	OCOTP_CTRL_ERROR_Msk = 0x200
	// Bit ERROR.
	OCOTP_CTRL_ERROR = 0x200
	// Position of RELOAD_SHADOWS field.
	OCOTP_CTRL_RELOAD_SHADOWS_Pos = 0xa
	// Bit mask of RELOAD_SHADOWS field.
	OCOTP_CTRL_RELOAD_SHADOWS_Msk = 0x400
	// Bit RELOAD_SHADOWS.
	OCOTP_CTRL_RELOAD_SHADOWS = 0x400
	// Position of CRC_TEST field.
	OCOTP_CTRL_CRC_TEST_Pos = 0xb
	// Bit mask of CRC_TEST field.
	OCOTP_CTRL_CRC_TEST_Msk = 0x800
	// Bit CRC_TEST.
	OCOTP_CTRL_CRC_TEST = 0x800
	// Position of CRC_FAIL field.
	OCOTP_CTRL_CRC_FAIL_Pos = 0xc
	// Bit mask of CRC_FAIL field.
	OCOTP_CTRL_CRC_FAIL_Msk = 0x1000
	// Bit CRC_FAIL.
	OCOTP_CTRL_CRC_FAIL = 0x1000
	// Position of RSVD1 field.
	OCOTP_CTRL_RSVD1_Pos = 0xd
	// Bit mask of RSVD1 field.
	OCOTP_CTRL_RSVD1_Msk = 0xe000
	// Position of WR_UNLOCK field.
	OCOTP_CTRL_WR_UNLOCK_Pos = 0x10
	// Bit mask of WR_UNLOCK field.
	OCOTP_CTRL_WR_UNLOCK_Msk = 0xffff0000
	// Key needed to unlock HW_OCOTP_DATA register.
	OCOTP_CTRL_WR_UNLOCK_KEY = 0x3e77

	// CTRL_SET: OTP Controller Control Register
	// Position of ADDR field.
	OCOTP_CTRL_SET_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	OCOTP_CTRL_SET_ADDR_Msk = 0x3f
	// Position of RSVD0 field.
	OCOTP_CTRL_SET_RSVD0_Pos = 0x6
	// Bit mask of RSVD0 field.
	OCOTP_CTRL_SET_RSVD0_Msk = 0xc0
	// Position of BUSY field.
	OCOTP_CTRL_SET_BUSY_Pos = 0x8
	// Bit mask of BUSY field.
	OCOTP_CTRL_SET_BUSY_Msk = 0x100
	// Bit BUSY.
	OCOTP_CTRL_SET_BUSY = 0x100
	// Position of ERROR field.
	OCOTP_CTRL_SET_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	OCOTP_CTRL_SET_ERROR_Msk = 0x200
	// Bit ERROR.
	OCOTP_CTRL_SET_ERROR = 0x200
	// Position of RELOAD_SHADOWS field.
	OCOTP_CTRL_SET_RELOAD_SHADOWS_Pos = 0xa
	// Bit mask of RELOAD_SHADOWS field.
	OCOTP_CTRL_SET_RELOAD_SHADOWS_Msk = 0x400
	// Bit RELOAD_SHADOWS.
	OCOTP_CTRL_SET_RELOAD_SHADOWS = 0x400
	// Position of CRC_TEST field.
	OCOTP_CTRL_SET_CRC_TEST_Pos = 0xb
	// Bit mask of CRC_TEST field.
	OCOTP_CTRL_SET_CRC_TEST_Msk = 0x800
	// Bit CRC_TEST.
	OCOTP_CTRL_SET_CRC_TEST = 0x800
	// Position of CRC_FAIL field.
	OCOTP_CTRL_SET_CRC_FAIL_Pos = 0xc
	// Bit mask of CRC_FAIL field.
	OCOTP_CTRL_SET_CRC_FAIL_Msk = 0x1000
	// Bit CRC_FAIL.
	OCOTP_CTRL_SET_CRC_FAIL = 0x1000
	// Position of RSVD1 field.
	OCOTP_CTRL_SET_RSVD1_Pos = 0xd
	// Bit mask of RSVD1 field.
	OCOTP_CTRL_SET_RSVD1_Msk = 0xe000
	// Position of WR_UNLOCK field.
	OCOTP_CTRL_SET_WR_UNLOCK_Pos = 0x10
	// Bit mask of WR_UNLOCK field.
	OCOTP_CTRL_SET_WR_UNLOCK_Msk = 0xffff0000

	// CTRL_CLR: OTP Controller Control Register
	// Position of ADDR field.
	OCOTP_CTRL_CLR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	OCOTP_CTRL_CLR_ADDR_Msk = 0x3f
	// Position of RSVD0 field.
	OCOTP_CTRL_CLR_RSVD0_Pos = 0x6
	// Bit mask of RSVD0 field.
	OCOTP_CTRL_CLR_RSVD0_Msk = 0xc0
	// Position of BUSY field.
	OCOTP_CTRL_CLR_BUSY_Pos = 0x8
	// Bit mask of BUSY field.
	OCOTP_CTRL_CLR_BUSY_Msk = 0x100
	// Bit BUSY.
	OCOTP_CTRL_CLR_BUSY = 0x100
	// Position of ERROR field.
	OCOTP_CTRL_CLR_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	OCOTP_CTRL_CLR_ERROR_Msk = 0x200
	// Bit ERROR.
	OCOTP_CTRL_CLR_ERROR = 0x200
	// Position of RELOAD_SHADOWS field.
	OCOTP_CTRL_CLR_RELOAD_SHADOWS_Pos = 0xa
	// Bit mask of RELOAD_SHADOWS field.
	OCOTP_CTRL_CLR_RELOAD_SHADOWS_Msk = 0x400
	// Bit RELOAD_SHADOWS.
	OCOTP_CTRL_CLR_RELOAD_SHADOWS = 0x400
	// Position of CRC_TEST field.
	OCOTP_CTRL_CLR_CRC_TEST_Pos = 0xb
	// Bit mask of CRC_TEST field.
	OCOTP_CTRL_CLR_CRC_TEST_Msk = 0x800
	// Bit CRC_TEST.
	OCOTP_CTRL_CLR_CRC_TEST = 0x800
	// Position of CRC_FAIL field.
	OCOTP_CTRL_CLR_CRC_FAIL_Pos = 0xc
	// Bit mask of CRC_FAIL field.
	OCOTP_CTRL_CLR_CRC_FAIL_Msk = 0x1000
	// Bit CRC_FAIL.
	OCOTP_CTRL_CLR_CRC_FAIL = 0x1000
	// Position of RSVD1 field.
	OCOTP_CTRL_CLR_RSVD1_Pos = 0xd
	// Bit mask of RSVD1 field.
	OCOTP_CTRL_CLR_RSVD1_Msk = 0xe000
	// Position of WR_UNLOCK field.
	OCOTP_CTRL_CLR_WR_UNLOCK_Pos = 0x10
	// Bit mask of WR_UNLOCK field.
	OCOTP_CTRL_CLR_WR_UNLOCK_Msk = 0xffff0000

	// CTRL_TOG: OTP Controller Control Register
	// Position of ADDR field.
	OCOTP_CTRL_TOG_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	OCOTP_CTRL_TOG_ADDR_Msk = 0x3f
	// Position of RSVD0 field.
	OCOTP_CTRL_TOG_RSVD0_Pos = 0x6
	// Bit mask of RSVD0 field.
	OCOTP_CTRL_TOG_RSVD0_Msk = 0xc0
	// Position of BUSY field.
	OCOTP_CTRL_TOG_BUSY_Pos = 0x8
	// Bit mask of BUSY field.
	OCOTP_CTRL_TOG_BUSY_Msk = 0x100
	// Bit BUSY.
	OCOTP_CTRL_TOG_BUSY = 0x100
	// Position of ERROR field.
	OCOTP_CTRL_TOG_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	OCOTP_CTRL_TOG_ERROR_Msk = 0x200
	// Bit ERROR.
	OCOTP_CTRL_TOG_ERROR = 0x200
	// Position of RELOAD_SHADOWS field.
	OCOTP_CTRL_TOG_RELOAD_SHADOWS_Pos = 0xa
	// Bit mask of RELOAD_SHADOWS field.
	OCOTP_CTRL_TOG_RELOAD_SHADOWS_Msk = 0x400
	// Bit RELOAD_SHADOWS.
	OCOTP_CTRL_TOG_RELOAD_SHADOWS = 0x400
	// Position of CRC_TEST field.
	OCOTP_CTRL_TOG_CRC_TEST_Pos = 0xb
	// Bit mask of CRC_TEST field.
	OCOTP_CTRL_TOG_CRC_TEST_Msk = 0x800
	// Bit CRC_TEST.
	OCOTP_CTRL_TOG_CRC_TEST = 0x800
	// Position of CRC_FAIL field.
	OCOTP_CTRL_TOG_CRC_FAIL_Pos = 0xc
	// Bit mask of CRC_FAIL field.
	OCOTP_CTRL_TOG_CRC_FAIL_Msk = 0x1000
	// Bit CRC_FAIL.
	OCOTP_CTRL_TOG_CRC_FAIL = 0x1000
	// Position of RSVD1 field.
	OCOTP_CTRL_TOG_RSVD1_Pos = 0xd
	// Bit mask of RSVD1 field.
	OCOTP_CTRL_TOG_RSVD1_Msk = 0xe000
	// Position of WR_UNLOCK field.
	OCOTP_CTRL_TOG_WR_UNLOCK_Pos = 0x10
	// Bit mask of WR_UNLOCK field.
	OCOTP_CTRL_TOG_WR_UNLOCK_Msk = 0xffff0000

	// TIMING: OTP Controller Timing Register
	// Position of STROBE_PROG field.
	OCOTP_TIMING_STROBE_PROG_Pos = 0x0
	// Bit mask of STROBE_PROG field.
	OCOTP_TIMING_STROBE_PROG_Msk = 0xfff
	// Position of RELAX field.
	OCOTP_TIMING_RELAX_Pos = 0xc
	// Bit mask of RELAX field.
	OCOTP_TIMING_RELAX_Msk = 0xf000
	// Position of STROBE_READ field.
	OCOTP_TIMING_STROBE_READ_Pos = 0x10
	// Bit mask of STROBE_READ field.
	OCOTP_TIMING_STROBE_READ_Msk = 0x3f0000
	// Position of WAIT field.
	OCOTP_TIMING_WAIT_Pos = 0x16
	// Bit mask of WAIT field.
	OCOTP_TIMING_WAIT_Msk = 0xfc00000
	// Position of RSRVD0 field.
	OCOTP_TIMING_RSRVD0_Pos = 0x1c
	// Bit mask of RSRVD0 field.
	OCOTP_TIMING_RSRVD0_Msk = 0xf0000000

	// DATA: OTP Controller Write Data Register
	// Position of DATA field.
	OCOTP_DATA_DATA_Pos = 0x0
	// Bit mask of DATA field.
	OCOTP_DATA_DATA_Msk = 0xffffffff

	// READ_CTRL: OTP Controller Write Data Register
	// Position of READ_FUSE field.
	OCOTP_READ_CTRL_READ_FUSE_Pos = 0x0
	// Bit mask of READ_FUSE field.
	OCOTP_READ_CTRL_READ_FUSE_Msk = 0x1
	// Bit READ_FUSE.
	OCOTP_READ_CTRL_READ_FUSE = 0x1
	// Position of RSVD0 field.
	OCOTP_READ_CTRL_RSVD0_Pos = 0x1
	// Bit mask of RSVD0 field.
	OCOTP_READ_CTRL_RSVD0_Msk = 0xfffffffe

	// READ_FUSE_DATA: OTP Controller Read Data Register
	// Position of DATA field.
	OCOTP_READ_FUSE_DATA_DATA_Pos = 0x0
	// Bit mask of DATA field.
	OCOTP_READ_FUSE_DATA_DATA_Msk = 0xffffffff

	// SW_STICKY: Sticky bit Register
	// Position of BLOCK_DTCP_KEY field.
	OCOTP_SW_STICKY_BLOCK_DTCP_KEY_Pos = 0x0
	// Bit mask of BLOCK_DTCP_KEY field.
	OCOTP_SW_STICKY_BLOCK_DTCP_KEY_Msk = 0x1
	// Bit BLOCK_DTCP_KEY.
	OCOTP_SW_STICKY_BLOCK_DTCP_KEY = 0x1
	// Position of SRK_REVOKE_LOCK field.
	OCOTP_SW_STICKY_SRK_REVOKE_LOCK_Pos = 0x1
	// Bit mask of SRK_REVOKE_LOCK field.
	OCOTP_SW_STICKY_SRK_REVOKE_LOCK_Msk = 0x2
	// Bit SRK_REVOKE_LOCK.
	OCOTP_SW_STICKY_SRK_REVOKE_LOCK = 0x2
	// Position of FIELD_RETURN_LOCK field.
	OCOTP_SW_STICKY_FIELD_RETURN_LOCK_Pos = 0x2
	// Bit mask of FIELD_RETURN_LOCK field.
	OCOTP_SW_STICKY_FIELD_RETURN_LOCK_Msk = 0x4
	// Bit FIELD_RETURN_LOCK.
	OCOTP_SW_STICKY_FIELD_RETURN_LOCK = 0x4
	// Position of BLOCK_ROM_PART field.
	OCOTP_SW_STICKY_BLOCK_ROM_PART_Pos = 0x3
	// Bit mask of BLOCK_ROM_PART field.
	OCOTP_SW_STICKY_BLOCK_ROM_PART_Msk = 0x8
	// Bit BLOCK_ROM_PART.
	OCOTP_SW_STICKY_BLOCK_ROM_PART = 0x8
	// Position of JTAG_BLOCK_RELEASE field.
	OCOTP_SW_STICKY_JTAG_BLOCK_RELEASE_Pos = 0x4
	// Bit mask of JTAG_BLOCK_RELEASE field.
	OCOTP_SW_STICKY_JTAG_BLOCK_RELEASE_Msk = 0x10
	// Bit JTAG_BLOCK_RELEASE.
	OCOTP_SW_STICKY_JTAG_BLOCK_RELEASE = 0x10
	// Position of RSVD0 field.
	OCOTP_SW_STICKY_RSVD0_Pos = 0x5
	// Bit mask of RSVD0 field.
	OCOTP_SW_STICKY_RSVD0_Msk = 0xffffffe0

	// SCS: Software Controllable Signals Register
	// Position of HAB_JDE field.
	OCOTP_SCS_HAB_JDE_Pos = 0x0
	// Bit mask of HAB_JDE field.
	OCOTP_SCS_HAB_JDE_Msk = 0x1
	// Bit HAB_JDE.
	OCOTP_SCS_HAB_JDE = 0x1
	// Position of SPARE field.
	OCOTP_SCS_SPARE_Pos = 0x1
	// Bit mask of SPARE field.
	OCOTP_SCS_SPARE_Msk = 0x7ffffffe
	// Position of LOCK field.
	OCOTP_SCS_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	OCOTP_SCS_LOCK_Msk = 0x80000000
	// Bit LOCK.
	OCOTP_SCS_LOCK = 0x80000000

	// SCS_SET: Software Controllable Signals Register
	// Position of HAB_JDE field.
	OCOTP_SCS_SET_HAB_JDE_Pos = 0x0
	// Bit mask of HAB_JDE field.
	OCOTP_SCS_SET_HAB_JDE_Msk = 0x1
	// Bit HAB_JDE.
	OCOTP_SCS_SET_HAB_JDE = 0x1
	// Position of SPARE field.
	OCOTP_SCS_SET_SPARE_Pos = 0x1
	// Bit mask of SPARE field.
	OCOTP_SCS_SET_SPARE_Msk = 0x7ffffffe
	// Position of LOCK field.
	OCOTP_SCS_SET_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	OCOTP_SCS_SET_LOCK_Msk = 0x80000000
	// Bit LOCK.
	OCOTP_SCS_SET_LOCK = 0x80000000

	// SCS_CLR: Software Controllable Signals Register
	// Position of HAB_JDE field.
	OCOTP_SCS_CLR_HAB_JDE_Pos = 0x0
	// Bit mask of HAB_JDE field.
	OCOTP_SCS_CLR_HAB_JDE_Msk = 0x1
	// Bit HAB_JDE.
	OCOTP_SCS_CLR_HAB_JDE = 0x1
	// Position of SPARE field.
	OCOTP_SCS_CLR_SPARE_Pos = 0x1
	// Bit mask of SPARE field.
	OCOTP_SCS_CLR_SPARE_Msk = 0x7ffffffe
	// Position of LOCK field.
	OCOTP_SCS_CLR_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	OCOTP_SCS_CLR_LOCK_Msk = 0x80000000
	// Bit LOCK.
	OCOTP_SCS_CLR_LOCK = 0x80000000

	// SCS_TOG: Software Controllable Signals Register
	// Position of HAB_JDE field.
	OCOTP_SCS_TOG_HAB_JDE_Pos = 0x0
	// Bit mask of HAB_JDE field.
	OCOTP_SCS_TOG_HAB_JDE_Msk = 0x1
	// Bit HAB_JDE.
	OCOTP_SCS_TOG_HAB_JDE = 0x1
	// Position of SPARE field.
	OCOTP_SCS_TOG_SPARE_Pos = 0x1
	// Bit mask of SPARE field.
	OCOTP_SCS_TOG_SPARE_Msk = 0x7ffffffe
	// Position of LOCK field.
	OCOTP_SCS_TOG_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	OCOTP_SCS_TOG_LOCK_Msk = 0x80000000
	// Bit LOCK.
	OCOTP_SCS_TOG_LOCK = 0x80000000

	// CRC_ADDR: OTP Controller CRC test address
	// Position of DATA_START_ADDR field.
	OCOTP_CRC_ADDR_DATA_START_ADDR_Pos = 0x0
	// Bit mask of DATA_START_ADDR field.
	OCOTP_CRC_ADDR_DATA_START_ADDR_Msk = 0xff
	// Position of DATA_END_ADDR field.
	OCOTP_CRC_ADDR_DATA_END_ADDR_Pos = 0x8
	// Bit mask of DATA_END_ADDR field.
	OCOTP_CRC_ADDR_DATA_END_ADDR_Msk = 0xff00
	// Position of CRC_ADDR field.
	OCOTP_CRC_ADDR_CRC_ADDR_Pos = 0x10
	// Bit mask of CRC_ADDR field.
	OCOTP_CRC_ADDR_CRC_ADDR_Msk = 0xff0000
	// Position of OTPMK_CRC field.
	OCOTP_CRC_ADDR_OTPMK_CRC_Pos = 0x18
	// Bit mask of OTPMK_CRC field.
	OCOTP_CRC_ADDR_OTPMK_CRC_Msk = 0x1000000
	// Bit OTPMK_CRC.
	OCOTP_CRC_ADDR_OTPMK_CRC = 0x1000000
	// Position of RSVD0 field.
	OCOTP_CRC_ADDR_RSVD0_Pos = 0x19
	// Bit mask of RSVD0 field.
	OCOTP_CRC_ADDR_RSVD0_Msk = 0xfe000000

	// CRC_VALUE: OTP Controller CRC Value Register
	// Position of DATA field.
	OCOTP_CRC_VALUE_DATA_Pos = 0x0
	// Bit mask of DATA field.
	OCOTP_CRC_VALUE_DATA_Msk = 0xffffffff

	// VERSION: OTP Controller Version Register
	// Position of STEP field.
	OCOTP_VERSION_STEP_Pos = 0x0
	// Bit mask of STEP field.
	OCOTP_VERSION_STEP_Msk = 0xffff
	// Position of MINOR field.
	OCOTP_VERSION_MINOR_Pos = 0x10
	// Bit mask of MINOR field.
	OCOTP_VERSION_MINOR_Msk = 0xff0000
	// Position of MAJOR field.
	OCOTP_VERSION_MAJOR_Pos = 0x18
	// Bit mask of MAJOR field.
	OCOTP_VERSION_MAJOR_Msk = 0xff000000

	// TIMING2: OTP Controller Timing Register
	// Position of RELAX_PROG field.
	OCOTP_TIMING2_RELAX_PROG_Pos = 0x0
	// Bit mask of RELAX_PROG field.
	OCOTP_TIMING2_RELAX_PROG_Msk = 0xfff
	// Position of RSRVD0 field.
	OCOTP_TIMING2_RSRVD0_Pos = 0xc
	// Bit mask of RSRVD0 field.
	OCOTP_TIMING2_RSRVD0_Msk = 0xf000
	// Position of RELAX_READ field.
	OCOTP_TIMING2_RELAX_READ_Pos = 0x10
	// Bit mask of RELAX_READ field.
	OCOTP_TIMING2_RELAX_READ_Msk = 0x3f0000
	// Position of RSRVD1 field.
	OCOTP_TIMING2_RSRVD1_Pos = 0x16
	// Bit mask of RSRVD1 field.
	OCOTP_TIMING2_RSRVD1_Msk = 0xffc00000

	// LOCK: Value of OTP Bank0 Word0 (Lock controls)
	// Position of TESTER field.
	OCOTP_LOCK_TESTER_Pos = 0x0
	// Bit mask of TESTER field.
	OCOTP_LOCK_TESTER_Msk = 0x3
	// Position of BOOT_CFG field.
	OCOTP_LOCK_BOOT_CFG_Pos = 0x2
	// Bit mask of BOOT_CFG field.
	OCOTP_LOCK_BOOT_CFG_Msk = 0xc
	// Position of MEM_TRIM field.
	OCOTP_LOCK_MEM_TRIM_Pos = 0x4
	// Bit mask of MEM_TRIM field.
	OCOTP_LOCK_MEM_TRIM_Msk = 0x30
	// Position of SJC_RESP field.
	OCOTP_LOCK_SJC_RESP_Pos = 0x6
	// Bit mask of SJC_RESP field.
	OCOTP_LOCK_SJC_RESP_Msk = 0x40
	// Bit SJC_RESP.
	OCOTP_LOCK_SJC_RESP = 0x40
	// Position of GP4_RLOCK field.
	OCOTP_LOCK_GP4_RLOCK_Pos = 0x7
	// Bit mask of GP4_RLOCK field.
	OCOTP_LOCK_GP4_RLOCK_Msk = 0x80
	// Bit GP4_RLOCK.
	OCOTP_LOCK_GP4_RLOCK = 0x80
	// Position of MAC_ADDR field.
	OCOTP_LOCK_MAC_ADDR_Pos = 0x8
	// Bit mask of MAC_ADDR field.
	OCOTP_LOCK_MAC_ADDR_Msk = 0x300
	// Position of GP1 field.
	OCOTP_LOCK_GP1_Pos = 0xa
	// Bit mask of GP1 field.
	OCOTP_LOCK_GP1_Msk = 0xc00
	// Position of GP2 field.
	OCOTP_LOCK_GP2_Pos = 0xc
	// Bit mask of GP2 field.
	OCOTP_LOCK_GP2_Msk = 0x3000
	// Position of ROM_PATCH field.
	OCOTP_LOCK_ROM_PATCH_Pos = 0xf
	// Bit mask of ROM_PATCH field.
	OCOTP_LOCK_ROM_PATCH_Msk = 0x8000
	// Bit ROM_PATCH.
	OCOTP_LOCK_ROM_PATCH = 0x8000
	// Position of SW_GP1 field.
	OCOTP_LOCK_SW_GP1_Pos = 0x10
	// Bit mask of SW_GP1 field.
	OCOTP_LOCK_SW_GP1_Msk = 0x10000
	// Bit SW_GP1.
	OCOTP_LOCK_SW_GP1 = 0x10000
	// Position of OTPMK field.
	OCOTP_LOCK_OTPMK_Pos = 0x11
	// Bit mask of OTPMK field.
	OCOTP_LOCK_OTPMK_Msk = 0x20000
	// Bit OTPMK.
	OCOTP_LOCK_OTPMK = 0x20000
	// Position of ANALOG field.
	OCOTP_LOCK_ANALOG_Pos = 0x12
	// Bit mask of ANALOG field.
	OCOTP_LOCK_ANALOG_Msk = 0xc0000
	// Position of OTPMK_CRC field.
	OCOTP_LOCK_OTPMK_CRC_Pos = 0x14
	// Bit mask of OTPMK_CRC field.
	OCOTP_LOCK_OTPMK_CRC_Msk = 0x100000
	// Bit OTPMK_CRC.
	OCOTP_LOCK_OTPMK_CRC = 0x100000
	// Position of SW_GP2_LOCK field.
	OCOTP_LOCK_SW_GP2_LOCK_Pos = 0x15
	// Bit mask of SW_GP2_LOCK field.
	OCOTP_LOCK_SW_GP2_LOCK_Msk = 0x200000
	// Bit SW_GP2_LOCK.
	OCOTP_LOCK_SW_GP2_LOCK = 0x200000
	// Position of MISC_CONF field.
	OCOTP_LOCK_MISC_CONF_Pos = 0x16
	// Bit mask of MISC_CONF field.
	OCOTP_LOCK_MISC_CONF_Msk = 0x400000
	// Bit MISC_CONF.
	OCOTP_LOCK_MISC_CONF = 0x400000
	// Position of SW_GP2_RLOCK field.
	OCOTP_LOCK_SW_GP2_RLOCK_Pos = 0x17
	// Bit mask of SW_GP2_RLOCK field.
	OCOTP_LOCK_SW_GP2_RLOCK_Msk = 0x800000
	// Bit SW_GP2_RLOCK.
	OCOTP_LOCK_SW_GP2_RLOCK = 0x800000
	// Position of GP4 field.
	OCOTP_LOCK_GP4_Pos = 0x18
	// Bit mask of GP4 field.
	OCOTP_LOCK_GP4_Msk = 0x3000000
	// Position of GP3 field.
	OCOTP_LOCK_GP3_Pos = 0x1a
	// Bit mask of GP3 field.
	OCOTP_LOCK_GP3_Msk = 0xc000000
	// Position of FIELD_RETURN field.
	OCOTP_LOCK_FIELD_RETURN_Pos = 0x1c
	// Bit mask of FIELD_RETURN field.
	OCOTP_LOCK_FIELD_RETURN_Msk = 0xf0000000

	// CFG0: Value of OTP Bank0 Word1 (Configuration and Manufacturing Info.)
	// Position of BITS field.
	OCOTP_CFG0_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_CFG0_BITS_Msk = 0xffffffff

	// CFG1: Value of OTP Bank0 Word2 (Configuration and Manufacturing Info.)
	// Position of BITS field.
	OCOTP_CFG1_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_CFG1_BITS_Msk = 0xffffffff

	// CFG2: Value of OTP Bank0 Word3 (Configuration and Manufacturing Info.)
	// Position of BITS field.
	OCOTP_CFG2_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_CFG2_BITS_Msk = 0xffffffff

	// CFG3: Value of OTP Bank0 Word4 (Configuration and Manufacturing Info.)
	// Position of BITS field.
	OCOTP_CFG3_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_CFG3_BITS_Msk = 0xffffffff

	// CFG4: Value of OTP Bank0 Word5 (Configuration and Manufacturing Info.)
	// Position of BITS field.
	OCOTP_CFG4_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_CFG4_BITS_Msk = 0xffffffff

	// CFG5: Value of OTP Bank0 Word6 (Configuration and Manufacturing Info.)
	// Position of BITS field.
	OCOTP_CFG5_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_CFG5_BITS_Msk = 0xffffffff

	// CFG6: Value of OTP Bank0 Word7 (Configuration and Manufacturing Info.)
	// Position of BITS field.
	OCOTP_CFG6_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_CFG6_BITS_Msk = 0xffffffff

	// MEM0: Value of OTP Bank1 Word0 (Memory Related Info.)
	// Position of BITS field.
	OCOTP_MEM0_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_MEM0_BITS_Msk = 0xffffffff

	// MEM1: Value of OTP Bank1 Word1 (Memory Related Info.)
	// Position of BITS field.
	OCOTP_MEM1_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_MEM1_BITS_Msk = 0xffffffff

	// MEM2: Value of OTP Bank1 Word2 (Memory Related Info.)
	// Position of BITS field.
	OCOTP_MEM2_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_MEM2_BITS_Msk = 0xffffffff

	// MEM3: Value of OTP Bank1 Word3 (Memory Related Info.)
	// Position of BITS field.
	OCOTP_MEM3_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_MEM3_BITS_Msk = 0xffffffff

	// MEM4: Value of OTP Bank1 Word4 (Memory Related Info.)
	// Position of BITS field.
	OCOTP_MEM4_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_MEM4_BITS_Msk = 0xffffffff

	// ANA0: Value of OTP Bank1 Word5 (Memory Related Info.)
	// Position of BITS field.
	OCOTP_ANA0_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_ANA0_BITS_Msk = 0xffffffff

	// ANA1: Value of OTP Bank1 Word6 (General Purpose Customer Defined Info.)
	// Position of BITS field.
	OCOTP_ANA1_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_ANA1_BITS_Msk = 0xffffffff

	// ANA2: Value of OTP Bank1 Word7 (General Purpose Customer Defined Info.)
	// Position of BITS field.
	OCOTP_ANA2_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_ANA2_BITS_Msk = 0xffffffff

	// OTPMK0: Value of OTP Bank2 Word0 (OTPMK Key)
	// Position of BITS field.
	OCOTP_OTPMK0_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_OTPMK0_BITS_Msk = 0xffffffff

	// OTPMK1: Value of OTP Bank2 Word1 (OTPMK Key)
	// Position of BITS field.
	OCOTP_OTPMK1_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_OTPMK1_BITS_Msk = 0xffffffff

	// OTPMK2: Value of OTP Bank2 Word2 (OTPMK Key)
	// Position of BITS field.
	OCOTP_OTPMK2_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_OTPMK2_BITS_Msk = 0xffffffff

	// OTPMK3: Value of OTP Bank2 Word3 (OTPMK Key)
	// Position of BITS field.
	OCOTP_OTPMK3_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_OTPMK3_BITS_Msk = 0xffffffff

	// OTPMK4: Value of OTP Bank2 Word4 (OTPMK Key)
	// Position of BITS field.
	OCOTP_OTPMK4_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_OTPMK4_BITS_Msk = 0xffffffff

	// OTPMK5: Value of OTP Bank2 Word5 (OTPMK Key)
	// Position of BITS field.
	OCOTP_OTPMK5_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_OTPMK5_BITS_Msk = 0xffffffff

	// OTPMK6: Value of OTP Bank2 Word6 (OTPMK Key)
	// Position of BITS field.
	OCOTP_OTPMK6_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_OTPMK6_BITS_Msk = 0xffffffff

	// OTPMK7: Value of OTP Bank2 Word7 (OTPMK Key)
	// Position of BITS field.
	OCOTP_OTPMK7_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_OTPMK7_BITS_Msk = 0xffffffff

	// SRK0: Shadow Register for OTP Bank3 Word0 (SRK Hash)
	// Position of BITS field.
	OCOTP_SRK0_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_SRK0_BITS_Msk = 0xffffffff

	// SRK1: Shadow Register for OTP Bank3 Word1 (SRK Hash)
	// Position of BITS field.
	OCOTP_SRK1_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_SRK1_BITS_Msk = 0xffffffff

	// SRK2: Shadow Register for OTP Bank3 Word2 (SRK Hash)
	// Position of BITS field.
	OCOTP_SRK2_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_SRK2_BITS_Msk = 0xffffffff

	// SRK3: Shadow Register for OTP Bank3 Word3 (SRK Hash)
	// Position of BITS field.
	OCOTP_SRK3_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_SRK3_BITS_Msk = 0xffffffff

	// SRK4: Shadow Register for OTP Bank3 Word4 (SRK Hash)
	// Position of BITS field.
	OCOTP_SRK4_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_SRK4_BITS_Msk = 0xffffffff

	// SRK5: Shadow Register for OTP Bank3 Word5 (SRK Hash)
	// Position of BITS field.
	OCOTP_SRK5_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_SRK5_BITS_Msk = 0xffffffff

	// SRK6: Shadow Register for OTP Bank3 Word6 (SRK Hash)
	// Position of BITS field.
	OCOTP_SRK6_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_SRK6_BITS_Msk = 0xffffffff

	// SRK7: Shadow Register for OTP Bank3 Word7 (SRK Hash)
	// Position of BITS field.
	OCOTP_SRK7_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_SRK7_BITS_Msk = 0xffffffff

	// SJC_RESP0: Value of OTP Bank4 Word0 (Secure JTAG Response Field)
	// Position of BITS field.
	OCOTP_SJC_RESP0_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_SJC_RESP0_BITS_Msk = 0xffffffff

	// SJC_RESP1: Value of OTP Bank4 Word1 (Secure JTAG Response Field)
	// Position of BITS field.
	OCOTP_SJC_RESP1_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_SJC_RESP1_BITS_Msk = 0xffffffff

	// MAC0: Value of OTP Bank4 Word2 (MAC Address)
	// Position of BITS field.
	OCOTP_MAC0_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_MAC0_BITS_Msk = 0xffffffff

	// MAC1: Value of OTP Bank4 Word3 (MAC Address)
	// Position of BITS field.
	OCOTP_MAC1_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_MAC1_BITS_Msk = 0xffffffff

	// MAC2: Value of OTP Bank4 Word4 (MAC2 Address)
	// Position of BITS field.
	OCOTP_MAC2_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_MAC2_BITS_Msk = 0xffffffff

	// OTPMK_CRC32: Value of OTP Bank4 Word5 (CRC Key)
	// Position of BITS field.
	OCOTP_OTPMK_CRC32_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_OTPMK_CRC32_BITS_Msk = 0xffffffff

	// GP1: Value of OTP Bank4 Word6 (General Purpose Customer Defined Info)
	// Position of BITS field.
	OCOTP_GP1_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_GP1_BITS_Msk = 0xffffffff

	// GP2: Value of OTP Bank4 Word7 (General Purpose Customer Defined Info)
	// Position of BITS field.
	OCOTP_GP2_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_GP2_BITS_Msk = 0xffffffff

	// SW_GP1: Value of OTP Bank5 Word0 (SW GP1)
	// Position of BITS field.
	OCOTP_SW_GP1_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_SW_GP1_BITS_Msk = 0xffffffff

	// SW_GP20: Value of OTP Bank5 Word1 (SW GP2)
	// Position of BITS field.
	OCOTP_SW_GP20_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_SW_GP20_BITS_Msk = 0xffffffff

	// SW_GP21: Value of OTP Bank5 Word2 (SW GP2)
	// Position of BITS field.
	OCOTP_SW_GP21_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_SW_GP21_BITS_Msk = 0xffffffff

	// SW_GP22: Value of OTP Bank5 Word3 (SW GP2)
	// Position of BITS field.
	OCOTP_SW_GP22_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_SW_GP22_BITS_Msk = 0xffffffff

	// SW_GP23: Value of OTP Bank5 Word4 (SW GP2)
	// Position of BITS field.
	OCOTP_SW_GP23_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_SW_GP23_BITS_Msk = 0xffffffff

	// MISC_CONF0: Value of OTP Bank5 Word5 (Misc Conf)
	// Position of BITS field.
	OCOTP_MISC_CONF0_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_MISC_CONF0_BITS_Msk = 0xffffffff

	// MISC_CONF1: Value of OTP Bank5 Word6 (Misc Conf)
	// Position of BITS field.
	OCOTP_MISC_CONF1_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_MISC_CONF1_BITS_Msk = 0xffffffff

	// SRK_REVOKE: Value of OTP Bank5 Word7 (SRK Revoke)
	// Position of BITS field.
	OCOTP_SRK_REVOKE_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_SRK_REVOKE_BITS_Msk = 0xffffffff

	// ROM_PATCH0: Value of OTP Bank6 Word0 (ROM Patch)
	// Position of BITS field.
	OCOTP_ROM_PATCH0_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_ROM_PATCH0_BITS_Msk = 0xffffffff

	// ROM_PATCH1: Value of OTP Bank6 Word1 (ROM Patch)
	// Position of BITS field.
	OCOTP_ROM_PATCH1_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_ROM_PATCH1_BITS_Msk = 0xffffffff

	// ROM_PATCH2: Value of OTP Bank6 Word2 (ROM Patch)
	// Position of BITS field.
	OCOTP_ROM_PATCH2_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_ROM_PATCH2_BITS_Msk = 0xffffffff

	// ROM_PATCH3: Value of OTP Bank6 Word3 (ROM Patch)
	// Position of BITS field.
	OCOTP_ROM_PATCH3_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_ROM_PATCH3_BITS_Msk = 0xffffffff

	// ROM_PATCH4: Value of OTP Bank6 Word4 (ROM Patch)
	// Position of BITS field.
	OCOTP_ROM_PATCH4_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_ROM_PATCH4_BITS_Msk = 0xffffffff

	// ROM_PATCH5: Value of OTP Bank6 Word5 (ROM Patch)
	// Position of BITS field.
	OCOTP_ROM_PATCH5_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_ROM_PATCH5_BITS_Msk = 0xffffffff

	// ROM_PATCH6: Value of OTP Bank6 Word6 (ROM Patch)
	// Position of BITS field.
	OCOTP_ROM_PATCH6_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_ROM_PATCH6_BITS_Msk = 0xffffffff

	// ROM_PATCH7: Value of OTP Bank6 Word7 (ROM Patch)
	// Position of BITS field.
	OCOTP_ROM_PATCH7_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_ROM_PATCH7_BITS_Msk = 0xffffffff

	// GP30: Value of OTP Bank7 Word0 (GP3)
	// Position of BITS field.
	OCOTP_GP30_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_GP30_BITS_Msk = 0xffffffff

	// GP31: Value of OTP Bank7 Word1 (GP3)
	// Position of BITS field.
	OCOTP_GP31_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_GP31_BITS_Msk = 0xffffffff

	// GP32: Value of OTP Bank7 Word2 (GP3)
	// Position of BITS field.
	OCOTP_GP32_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_GP32_BITS_Msk = 0xffffffff

	// GP33: Value of OTP Bank7 Word3 (GP3)
	// Position of BITS field.
	OCOTP_GP33_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_GP33_BITS_Msk = 0xffffffff

	// GP40: Value of OTP Bank7 Word4 (GP4)
	// Position of BITS field.
	OCOTP_GP40_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_GP40_BITS_Msk = 0xffffffff

	// GP41: Value of OTP Bank7 Word5 (GP4)
	// Position of BITS field.
	OCOTP_GP41_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_GP41_BITS_Msk = 0xffffffff

	// GP42: Value of OTP Bank7 Word6 (GP4)
	// Position of BITS field.
	OCOTP_GP42_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_GP42_BITS_Msk = 0xffffffff

	// GP43: Value of OTP Bank7 Word7 (GP4)
	// Position of BITS field.
	OCOTP_GP43_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_GP43_BITS_Msk = 0xffffffff
)

// Bitfields for IOMUXC: IOMUXC
const (
	// SW_MUX_CTL_PAD_GPIO_EMC_00: SW_MUX_CTL_PAD_GPIO_EMC_00 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_00_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_00_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: SEMC_DATA00 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_00_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM4_PWMA00 of instance: flexpwm4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_00_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPSPI2_SCK of instance: lpspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_00_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: XBAR1_XBAR_IN02 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_00_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO1_FLEXIO00 of instance: flexio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_00_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO4_IO00 of instance: gpio4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_00_MUX_MODE_ALT5 = 0x5
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_00_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_00_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_00_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_00_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_00
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_00_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_EMC_01: SW_MUX_CTL_PAD_GPIO_EMC_01 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_01_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_01_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: SEMC_DATA01 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_01_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM4_PWMB00 of instance: flexpwm4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_01_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPSPI2_PCS0 of instance: lpspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_01_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: XBAR1_IN03 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_01_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO1_FLEXIO01 of instance: flexio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_01_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO4_IO01 of instance: gpio4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_01_MUX_MODE_ALT5 = 0x5
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_01_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_01_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_01_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_01_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_01
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_01_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_EMC_02: SW_MUX_CTL_PAD_GPIO_EMC_02 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_02_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_02_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: SEMC_DATA02 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_02_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM4_PWMA01 of instance: flexpwm4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_02_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPSPI2_SDO of instance: lpspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_02_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: XBAR1_INOUT04 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_02_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO1_FLEXIO02 of instance: flexio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_02_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO4_IO02 of instance: gpio4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_02_MUX_MODE_ALT5 = 0x5
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_02_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_02_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_02_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_02_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_02
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_02_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_EMC_03: SW_MUX_CTL_PAD_GPIO_EMC_03 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_03_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_03_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: SEMC_DATA03 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_03_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM4_PWMB01 of instance: flexpwm4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_03_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPSPI2_SDI of instance: lpspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_03_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: XBAR1_INOUT05 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_03_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO1_FLEXIO03 of instance: flexio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_03_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO4_IO03 of instance: gpio4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_03_MUX_MODE_ALT5 = 0x5
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_03_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_03_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_03_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_03_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_03
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_03_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_EMC_04: SW_MUX_CTL_PAD_GPIO_EMC_04 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_04_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_04_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: SEMC_DATA04 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_04_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM4_PWMA02 of instance: flexpwm4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_04_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: SAI2_TX_DATA of instance: sai2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_04_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: XBAR1_INOUT06 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_04_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO1_FLEXIO04 of instance: flexio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_04_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO4_IO04 of instance: gpio4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_04_MUX_MODE_ALT5 = 0x5
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_04_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_04_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_04_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_04_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_04
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_04_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_EMC_05: SW_MUX_CTL_PAD_GPIO_EMC_05 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_05_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_05_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: SEMC_DATA05 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_05_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM4_PWMB02 of instance: flexpwm4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_05_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: SAI2_TX_SYNC of instance: sai2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_05_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: XBAR1_INOUT07 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_05_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO1_FLEXIO05 of instance: flexio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_05_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO4_IO05 of instance: gpio4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_05_MUX_MODE_ALT5 = 0x5
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_05_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_05_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_05_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_05_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_05
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_05_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_EMC_06: SW_MUX_CTL_PAD_GPIO_EMC_06 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_06_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_06_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: SEMC_DATA06 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_06_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM2_PWMA00 of instance: flexpwm2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_06_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: SAI2_TX_BCLK of instance: sai2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_06_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: XBAR1_INOUT08 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_06_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO1_FLEXIO06 of instance: flexio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_06_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO4_IO06 of instance: gpio4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_06_MUX_MODE_ALT5 = 0x5
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_06_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_06_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_06_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_06_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_06
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_06_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_EMC_07: SW_MUX_CTL_PAD_GPIO_EMC_07 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_07_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_07_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: SEMC_DATA07 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_07_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM2_PWMB00 of instance: flexpwm2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_07_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: SAI2_MCLK of instance: sai2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_07_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: XBAR1_INOUT09 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_07_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO1_FLEXIO07 of instance: flexio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_07_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO4_IO07 of instance: gpio4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_07_MUX_MODE_ALT5 = 0x5
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_07_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_07_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_07_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_07_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_07
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_07_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_EMC_08: SW_MUX_CTL_PAD_GPIO_EMC_08 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_08_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_08_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: SEMC_DM00 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_08_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM2_PWMA01 of instance: flexpwm2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_08_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: SAI2_RX_DATA of instance: sai2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_08_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: XBAR1_INOUT17 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_08_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO1_FLEXIO08 of instance: flexio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_08_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO4_IO08 of instance: gpio4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_08_MUX_MODE_ALT5 = 0x5
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_08_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_08_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_08_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_08_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_08
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_08_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_EMC_09: SW_MUX_CTL_PAD_GPIO_EMC_09 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_09_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_09_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: SEMC_ADDR00 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_09_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM2_PWMB01 of instance: flexpwm2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_09_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: SAI2_RX_SYNC of instance: sai2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_09_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: FLEXCAN2_TX of instance: flexcan2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_09_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO1_FLEXIO09 of instance: flexio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_09_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO4_IO09 of instance: gpio4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_09_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT8 mux port: FLEXSPI2_B_SS1_B of instance: flexspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_09_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_09_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_09_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_09_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_09_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_09
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_09_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_EMC_10: SW_MUX_CTL_PAD_GPIO_EMC_10 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_10_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_10_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: SEMC_ADDR01 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_10_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM2_PWMA02 of instance: flexpwm2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_10_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: SAI2_RX_BCLK of instance: sai2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_10_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: FLEXCAN2_RX of instance: flexcan2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_10_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO1_FLEXIO10 of instance: flexio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_10_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO4_IO10 of instance: gpio4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_10_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT8 mux port: FLEXSPI2_B_SS0_B of instance: flexspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_10_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_10_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_10_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_10_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_10_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_10
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_10_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_EMC_11: SW_MUX_CTL_PAD_GPIO_EMC_11 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_11_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_11_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: SEMC_ADDR02 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_11_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM2_PWMB02 of instance: flexpwm2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_11_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPI2C4_SDA of instance: lpi2c4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_11_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: USDHC2_RESET_B of instance: usdhc2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_11_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO1_FLEXIO11 of instance: flexio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_11_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO4_IO11 of instance: gpio4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_11_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT8 mux port: FLEXSPI2_B_DQS of instance: flexspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_11_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_11_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_11_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_11_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_11_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_11
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_11_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_EMC_12: SW_MUX_CTL_PAD_GPIO_EMC_12 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_12_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_12_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: SEMC_ADDR03 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_12_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: XBAR1_IN24 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_12_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPI2C4_SCL of instance: lpi2c4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_12_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: USDHC1_WP of instance: usdhc1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_12_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXPWM1_PWMA03 of instance: flexpwm1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_12_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO4_IO12 of instance: gpio4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_12_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT8 mux port: FLEXSPI2_B_SCLK of instance: flexspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_12_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_12_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_12_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_12_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_12_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_12
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_12_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_EMC_13: SW_MUX_CTL_PAD_GPIO_EMC_13 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_13_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_13_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: SEMC_ADDR04 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_13_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: XBAR1_IN25 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_13_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART3_TX of instance: lpuart3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_13_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: MQS_RIGHT of instance: mqs
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_13_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXPWM1_PWMB03 of instance: flexpwm1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_13_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO4_IO13 of instance: gpio4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_13_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT8 mux port: FLEXSPI2_B_DATA00 of instance: flexspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_13_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_13_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_13_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_13_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_13_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_13
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_13_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_EMC_14: SW_MUX_CTL_PAD_GPIO_EMC_14 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_14_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_14_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: SEMC_ADDR05 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_14_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: XBAR1_INOUT19 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_14_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART3_RX of instance: lpuart3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_14_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: MQS_LEFT of instance: mqs
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_14_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: LPSPI2_PCS1 of instance: lpspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_14_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO4_IO14 of instance: gpio4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_14_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT8 mux port: FLEXSPI2_B_DATA01 of instance: flexspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_14_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_14_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_14_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_14_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_14_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_14
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_14_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_EMC_15: SW_MUX_CTL_PAD_GPIO_EMC_15 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_15_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_15_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: SEMC_ADDR06 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_15_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: XBAR1_IN20 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_15_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART3_CTS_B of instance: lpuart3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_15_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SPDIF_OUT of instance: spdif
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_15_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: QTIMER3_TIMER0 of instance: qtimer3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_15_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO4_IO15 of instance: gpio4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_15_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT8 mux port: FLEXSPI2_B_DATA02 of instance: flexspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_15_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_15_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_15_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_15_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_15_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_15
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_15_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_EMC_16: SW_MUX_CTL_PAD_GPIO_EMC_16 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_16_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_16_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: SEMC_ADDR07 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_16_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: XBAR1_IN21 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_16_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART3_RTS_B of instance: lpuart3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_16_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SPDIF_IN of instance: spdif
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_16_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: QTIMER3_TIMER1 of instance: qtimer3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_16_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO4_IO16 of instance: gpio4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_16_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT8 mux port: FLEXSPI2_B_DATA03 of instance: flexspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_16_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_16_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_16_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_16_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_16_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_16
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_16_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_EMC_17: SW_MUX_CTL_PAD_GPIO_EMC_17 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_17_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_17_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: SEMC_ADDR08 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_17_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM4_PWMA03 of instance: flexpwm4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_17_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART4_CTS_B of instance: lpuart4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_17_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: FLEXCAN1_TX of instance: flexcan1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_17_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: QTIMER3_TIMER2 of instance: qtimer3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_17_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO4_IO17 of instance: gpio4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_17_MUX_MODE_ALT5 = 0x5
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_17_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_17_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_17_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_17_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_17
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_17_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_EMC_18: SW_MUX_CTL_PAD_GPIO_EMC_18 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_18_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_18_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: SEMC_ADDR09 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_18_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM4_PWMB03 of instance: flexpwm4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_18_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART4_RTS_B of instance: lpuart4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_18_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: FLEXCAN1_RX of instance: flexcan1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_18_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: QTIMER3_TIMER3 of instance: qtimer3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_18_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO4_IO18 of instance: gpio4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_18_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: SNVS_VIO_5_CTL of instance: snvs_hp
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_18_MUX_MODE_ALT6 = 0x6
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_18_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_18_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_18_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_18_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_18
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_18_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_EMC_19: SW_MUX_CTL_PAD_GPIO_EMC_19 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_19_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_19_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: SEMC_ADDR11 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_19_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM2_PWMA03 of instance: flexpwm2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_19_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART4_TX of instance: lpuart4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_19_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: ENET_RDATA01 of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_19_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: QTIMER2_TIMER0 of instance: qtimer2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_19_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO4_IO19 of instance: gpio4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_19_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: SNVS_VIO_5 of instance: snvs_hp
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_19_MUX_MODE_ALT6 = 0x6
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_19_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_19_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_19_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_19_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_19
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_19_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_EMC_20: SW_MUX_CTL_PAD_GPIO_EMC_20 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_20_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_20_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: SEMC_ADDR12 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_20_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM2_PWMB03 of instance: flexpwm2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_20_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART4_RX of instance: lpuart4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_20_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: ENET_RDATA00 of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_20_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: QTIMER2_TIMER1 of instance: qtimer2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_20_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO4_IO20 of instance: gpio4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_20_MUX_MODE_ALT5 = 0x5
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_20_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_20_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_20_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_20_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_20
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_20_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_EMC_21: SW_MUX_CTL_PAD_GPIO_EMC_21 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_21_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_21_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: SEMC_BA0 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_21_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM3_PWMA03 of instance: flexpwm3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_21_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPI2C3_SDA of instance: lpi2c3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_21_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: ENET_TDATA01 of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_21_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: QTIMER2_TIMER2 of instance: qtimer2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_21_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO4_IO21 of instance: gpio4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_21_MUX_MODE_ALT5 = 0x5
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_21_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_21_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_21_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_21_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_21
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_21_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_EMC_22: SW_MUX_CTL_PAD_GPIO_EMC_22 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_22_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_22_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: SEMC_BA1 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_22_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM3_PWMB03 of instance: flexpwm3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_22_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPI2C3_SCL of instance: lpi2c3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_22_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: ENET_TDATA00 of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_22_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: QTIMER2_TIMER3 of instance: qtimer2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_22_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO4_IO22 of instance: gpio4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_22_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT8 mux port: FLEXSPI2_A_SS1_B of instance: flexspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_22_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_22_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_22_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_22_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_22_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_22
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_22_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_EMC_23: SW_MUX_CTL_PAD_GPIO_EMC_23 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_23_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_23_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: SEMC_ADDR10 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_23_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM1_PWMA00 of instance: flexpwm1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_23_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART5_TX of instance: lpuart5
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_23_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: ENET_RX_EN of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_23_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: GPT1_CAPTURE2 of instance: gpt1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_23_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO4_IO23 of instance: gpio4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_23_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT8 mux port: FLEXSPI2_A_DQS of instance: flexspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_23_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_23_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_23_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_23_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_23_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_23
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_23_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_EMC_24: SW_MUX_CTL_PAD_GPIO_EMC_24 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_24_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_24_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: SEMC_CAS of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_24_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM1_PWMB00 of instance: flexpwm1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_24_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART5_RX of instance: lpuart5
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_24_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: ENET_TX_EN of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_24_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: GPT1_CAPTURE1 of instance: gpt1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_24_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO4_IO24 of instance: gpio4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_24_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT8 mux port: FLEXSPI2_A_SS0_B of instance: flexspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_24_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_24_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_24_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_24_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_24_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_24
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_24_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_EMC_25: SW_MUX_CTL_PAD_GPIO_EMC_25 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_25_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_25_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: SEMC_RAS of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_25_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM1_PWMA01 of instance: flexpwm1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_25_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART6_TX of instance: lpuart6
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_25_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: ENET_TX_CLK of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_25_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: ENET_REF_CLK of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_25_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO4_IO25 of instance: gpio4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_25_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT8 mux port: FLEXSPI2_A_SCLK of instance: flexspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_25_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_25_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_25_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_25_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_25_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_25
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_25_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_EMC_26: SW_MUX_CTL_PAD_GPIO_EMC_26 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_26_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_26_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: SEMC_CLK of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_26_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM1_PWMB01 of instance: flexpwm1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_26_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART6_RX of instance: lpuart6
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_26_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: ENET_RX_ER of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_26_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO1_FLEXIO12 of instance: flexio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_26_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO4_IO26 of instance: gpio4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_26_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT8 mux port: FLEXSPI2_A_DATA00 of instance: flexspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_26_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_26_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_26_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_26_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_26_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_26
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_26_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_EMC_27: SW_MUX_CTL_PAD_GPIO_EMC_27 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_27_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_27_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: SEMC_CKE of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_27_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM1_PWMA02 of instance: flexpwm1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_27_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART5_RTS_B of instance: lpuart5
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_27_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: LPSPI1_SCK of instance: lpspi1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_27_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO1_FLEXIO13 of instance: flexio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_27_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO4_IO27 of instance: gpio4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_27_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT8 mux port: FLEXSPI2_A_DATA01 of instance: flexspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_27_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_27_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_27_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_27_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_27_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_27
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_27_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_EMC_28: SW_MUX_CTL_PAD_GPIO_EMC_28 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_28_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_28_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: SEMC_WE of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_28_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM1_PWMB02 of instance: flexpwm1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_28_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART5_CTS_B of instance: lpuart5
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_28_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: LPSPI1_SDO of instance: lpspi1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_28_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO1_FLEXIO14 of instance: flexio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_28_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO4_IO28 of instance: gpio4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_28_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT8 mux port: FLEXSPI2_A_DATA02 of instance: flexspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_28_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_28_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_28_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_28_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_28_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_28
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_28_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_EMC_29: SW_MUX_CTL_PAD_GPIO_EMC_29 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_29_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_29_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: SEMC_CS0 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_29_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM3_PWMA00 of instance: flexpwm3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_29_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART6_RTS_B of instance: lpuart6
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_29_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: LPSPI1_SDI of instance: lpspi1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_29_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO1_FLEXIO15 of instance: flexio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_29_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO4_IO29 of instance: gpio4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_29_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT8 mux port: FLEXSPI2_A_DATA03 of instance: flexspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_29_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_29_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_29_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_29_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_29_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_29
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_29_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_EMC_30: SW_MUX_CTL_PAD_GPIO_EMC_30 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_30_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_30_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: SEMC_DATA08 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_30_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM3_PWMB00 of instance: flexpwm3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_30_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART6_CTS_B of instance: lpuart6
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_30_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: LPSPI1_PCS0 of instance: lpspi1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_30_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: CSI_DATA23 of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_30_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO4_IO30 of instance: gpio4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_30_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT8 mux port: ENET2_TDATA00 of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_30_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_30_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_30_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_30_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_30_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_30
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_30_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_EMC_31: SW_MUX_CTL_PAD_GPIO_EMC_31 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_31_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_31_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: SEMC_DATA09 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_31_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM3_PWMA01 of instance: flexpwm3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_31_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART7_TX of instance: lpuart7
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_31_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: LPSPI1_PCS1 of instance: lpspi1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_31_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: CSI_DATA22 of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_31_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO4_IO31 of instance: gpio4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_31_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT8 mux port: ENET2_TDATA01 of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_31_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_31_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_31_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_31_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_31_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_31
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_31_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_EMC_32: SW_MUX_CTL_PAD_GPIO_EMC_32 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_32_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_32_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: SEMC_DATA10 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_32_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM3_PWMB01 of instance: flexpwm3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_32_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART7_RX of instance: lpuart7
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_32_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: CCM_PMIC_RDY of instance: ccm
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_32_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: CSI_DATA21 of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_32_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO3_IO18 of instance: gpio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_32_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT8 mux port: ENET2_TX_EN of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_32_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_32_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_32_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_32_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_32_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_32
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_32_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_EMC_33: SW_MUX_CTL_PAD_GPIO_EMC_33 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_33_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_33_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: SEMC_DATA11 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_33_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM3_PWMA02 of instance: flexpwm3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_33_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: USDHC1_RESET_B of instance: usdhc1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_33_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SAI3_RX_DATA of instance: sai3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_33_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: CSI_DATA20 of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_33_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO3_IO19 of instance: gpio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_33_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT8 mux port: ENET2_TX_CLK of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_33_MUX_MODE_ALT8 = 0x8
	// Select mux mode: ALT9 mux port: ENET2_REF_CLK2 of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_33_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_33_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_33_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_33_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_33_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_33
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_33_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_EMC_34: SW_MUX_CTL_PAD_GPIO_EMC_34 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_34_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_34_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: SEMC_DATA12 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_34_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM3_PWMB02 of instance: flexpwm3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_34_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: USDHC1_VSELECT of instance: usdhc1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_34_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SAI3_RX_SYNC of instance: sai3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_34_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: CSI_DATA19 of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_34_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO3_IO20 of instance: gpio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_34_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT8 mux port: ENET2_RX_ER of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_34_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_34_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_34_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_34_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_34_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_34
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_34_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_EMC_35: SW_MUX_CTL_PAD_GPIO_EMC_35 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_35_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_35_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: SEMC_DATA13 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_35_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: XBAR1_INOUT18 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_35_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: GPT1_COMPARE1 of instance: gpt1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_35_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SAI3_RX_BCLK of instance: sai3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_35_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: CSI_DATA18 of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_35_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO3_IO21 of instance: gpio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_35_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: USDHC1_CD_B of instance: usdhc1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_35_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT8 mux port: ENET2_RDATA00 of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_35_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_35_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_35_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_35_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_35_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_35
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_35_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_EMC_36: SW_MUX_CTL_PAD_GPIO_EMC_36 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_36_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_36_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: SEMC_DATA14 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_36_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: XBAR1_IN22 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_36_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: GPT1_COMPARE2 of instance: gpt1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_36_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SAI3_TX_DATA of instance: sai3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_36_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: CSI_DATA17 of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_36_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO3_IO22 of instance: gpio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_36_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: USDHC1_WP of instance: usdhc1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_36_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT8 mux port: ENET2_RDATA01 of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_36_MUX_MODE_ALT8 = 0x8
	// Select mux mode: ALT9 mux port: FLEXCAN3_TX of instance: flexcan3/canfd
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_36_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_36_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_36_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_36_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_36_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_36
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_36_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_EMC_37: SW_MUX_CTL_PAD_GPIO_EMC_37 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_37_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_37_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: SEMC_DATA15 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_37_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: XBAR1_IN23 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_37_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: GPT1_COMPARE3 of instance: gpt1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_37_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SAI3_MCLK of instance: sai3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_37_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: CSI_DATA16 of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_37_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO3_IO23 of instance: gpio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_37_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: USDHC2_WP of instance: usdhc2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_37_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT8 mux port: ENET2_RX_EN of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_37_MUX_MODE_ALT8 = 0x8
	// Select mux mode: ALT9 mux port: FLEXCAN3_RX of instance: flexcan3/canfd
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_37_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_37_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_37_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_37_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_37_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_37
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_37_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_EMC_38: SW_MUX_CTL_PAD_GPIO_EMC_38 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_38_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_38_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: SEMC_DM01 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_38_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM1_PWMA03 of instance: flexpwm1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_38_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART8_TX of instance: lpuart8
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_38_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SAI3_TX_BCLK of instance: sai3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_38_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: CSI_FIELD of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_38_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO3_IO24 of instance: gpio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_38_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: USDHC2_VSELECT of instance: usdhc2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_38_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT8 mux port: ENET2_MDC of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_38_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_38_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_38_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_38_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_38_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_38
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_38_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_EMC_39: SW_MUX_CTL_PAD_GPIO_EMC_39 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_39_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_39_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: SEMC_DQS of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_39_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM1_PWMB03 of instance: flexpwm1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_39_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART8_RX of instance: lpuart8
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_39_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SAI3_TX_SYNC of instance: sai3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_39_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: WDOG1_WDOG_B of instance: wdog1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_39_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO3_IO25 of instance: gpio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_39_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: USDHC2_CD_B of instance: usdhc2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_39_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT8 mux port: ENET2_MDIO of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_39_MUX_MODE_ALT8 = 0x8
	// Select mux mode: ALT9 mux port: SEMC_DQS4 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_39_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_39_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_39_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_39_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_39_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_39
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_39_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_EMC_40: SW_MUX_CTL_PAD_GPIO_EMC_40 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_40_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_40_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: SEMC_RDY of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_40_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: GPT2_CAPTURE2 of instance: gpt2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_40_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPSPI1_PCS2 of instance: lpspi1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_40_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: USB_OTG2_OC of instance: usb
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_40_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: ENET_MDC of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_40_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO3_IO26 of instance: gpio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_40_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: USDHC2_RESET_B of instance: usdhc2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_40_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT9 mux port: SEMC_CLK5 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_40_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_40_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_40_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_40_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_40_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_40
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_40_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_EMC_41: SW_MUX_CTL_PAD_GPIO_EMC_41 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_41_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_41_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: SEMC_CSX00 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_41_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: GPT2_CAPTURE1 of instance: gpt2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_41_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPSPI1_PCS3 of instance: lpspi1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_41_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: USB_OTG2_PWR of instance: usb
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_41_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: ENET_MDIO of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_41_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO3_IO27 of instance: gpio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_41_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: USDHC1_VSELECT of instance: usdhc1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_41_MUX_MODE_ALT6 = 0x6
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_41_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_41_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_41_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_41_SION_DISABLED = 0x0
	// Force input path of pad GPIO_EMC_41
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_41_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_B0_00: SW_MUX_CTL_PAD_GPIO_AD_B0_00 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_00_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_00_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: FLEXPWM2_PWMA03 of instance: flexpwm2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_00_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: XBAR1_INOUT14 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_00_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: REF_CLK_32K of instance: xtalosc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_00_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: USB_OTG2_ID of instance: usb
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_00_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: LPI2C1_SCLS of instance: lpi2c1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_00_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO1_IO00 of instance: gpio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_00_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: USDHC1_RESET_B of instance: usdhc1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_00_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: LPSPI3_SCK of instance: lpspi3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_00_MUX_MODE_ALT7 = 0x7
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_00_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_00_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_00_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_00_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_B0_00
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_00_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_B0_01: SW_MUX_CTL_PAD_GPIO_AD_B0_01 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_01_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_01_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: FLEXPWM2_PWMB03 of instance: flexpwm2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_01_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: XBAR1_INOUT15 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_01_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: REF_CLK_24M of instance: anatop
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_01_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: USB_OTG1_ID of instance: anatop
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_01_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: LPI2C1_SDAS of instance: lpi2c1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_01_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO1_IO01 of instance: gpio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_01_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: EWM_OUT_B of instance: ewm
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_01_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: LPSPI3_SDO of instance: lpspi3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_01_MUX_MODE_ALT7 = 0x7
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_01_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_01_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_01_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_01_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_B0_01
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_01_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_B0_02: SW_MUX_CTL_PAD_GPIO_AD_B0_02 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_02_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_02_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: FLEXCAN2_TX of instance: flexcan2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_02_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: XBAR1_INOUT16 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_02_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART6_TX of instance: lpuart6
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_02_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: USB_OTG1_PWR of instance: usb
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_02_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXPWM1_PWMX00 of instance: flexpwm1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_02_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO1_IO02 of instance: gpio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_02_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: LPI2C1_HREQ of instance: lpi2c1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_02_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: LPSPI3_SDI of instance: lpspi3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_02_MUX_MODE_ALT7 = 0x7
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_02_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_02_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_02_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_02_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_B0_02
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_02_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_B0_03: SW_MUX_CTL_PAD_GPIO_AD_B0_03 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_03_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_03_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: FLEXCAN2_RX of instance: flexcan2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_03_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: XBAR1_INOUT17 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_03_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART6_RX of instance: lpuart6
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_03_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: USB_OTG1_OC of instance: usb
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_03_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXPWM1_PWMX01 of instance: flexpwm1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_03_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO1_IO03 of instance: gpio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_03_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: REF_CLK_24M of instance: anatop
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_03_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: LPSPI3_PCS0 of instance: lpspi3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_03_MUX_MODE_ALT7 = 0x7
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_03_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_03_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_03_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_03_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_B0_03
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_03_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_B0_04: SW_MUX_CTL_PAD_GPIO_AD_B0_04 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_04_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_04_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: SRC_BOOT_MODE00 of instance: src
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_04_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: MQS_RIGHT of instance: mqs
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_04_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: ENET_TX_DATA03 of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_04_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SAI2_TX_SYNC of instance: sai2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_04_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: CSI_DATA09 of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_04_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO1_IO04 of instance: gpio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_04_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: PIT_TRIGGER00 of instance: pit
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_04_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: LPSPI3_PCS1 of instance: lpspi3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_04_MUX_MODE_ALT7 = 0x7
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_04_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_04_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_04_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_04_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_B0_04
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_04_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_B0_05: SW_MUX_CTL_PAD_GPIO_AD_B0_05 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_05_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_05_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: SRC_BOOT_MODE01 of instance: src
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_05_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: MQS_LEFT of instance: mqs
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_05_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: ENET_TX_DATA02 of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_05_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SAI2_TX_BCLK of instance: sai2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_05_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: CSI_DATA08 of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_05_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO1_IO05 of instance: gpio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_05_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: XBAR1_INOUT17 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_05_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: LPSPI3_PCS2 of instance: lpspi3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_05_MUX_MODE_ALT7 = 0x7
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_05_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_05_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_05_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_05_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_B0_05
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_05_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_B0_06: SW_MUX_CTL_PAD_GPIO_AD_B0_06 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_06_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_06_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: JTAG_TMS of instance: jtag_mux
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_06_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: GPT2_COMPARE1 of instance: gpt2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_06_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: ENET_RX_CLK of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_06_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SAI2_RX_BCLK of instance: sai2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_06_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: CSI_DATA07 of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_06_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO1_IO06 of instance: gpio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_06_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: XBAR1_INOUT18 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_06_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: LPSPI3_PCS3 of instance: lpspi3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_06_MUX_MODE_ALT7 = 0x7
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_06_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_06_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_06_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_06_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_B0_06
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_06_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_B0_07: SW_MUX_CTL_PAD_GPIO_AD_B0_07 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_07_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_07_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: JTAG_TCK of instance: jtag_mux
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_07_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: GPT2_COMPARE2 of instance: gpt2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_07_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: ENET_TX_ER of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_07_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SAI2_RX_SYNC of instance: sai2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_07_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: CSI_DATA06 of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_07_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO1_IO07 of instance: gpio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_07_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: XBAR1_INOUT19 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_07_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: ENET_1588_EVENT3_OUT of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_07_MUX_MODE_ALT7 = 0x7
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_07_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_07_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_07_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_07_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_B0_07
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_07_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_B0_08: SW_MUX_CTL_PAD_GPIO_AD_B0_08 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_08_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_08_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: JTAG_MOD of instance: jtag_mux
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_08_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: GPT2_COMPARE3 of instance: gpt2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_08_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: ENET_RX_DATA03 of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_08_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SAI2_RX_DATA of instance: sai2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_08_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: CSI_DATA05 of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_08_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO1_IO08 of instance: gpio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_08_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: XBAR1_IN20 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_08_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: ENET_1588_EVENT3_IN of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_08_MUX_MODE_ALT7 = 0x7
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_08_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_08_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_08_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_08_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_B0_08
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_08_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_B0_09: SW_MUX_CTL_PAD_GPIO_AD_B0_09 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_09_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_09_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: JTAG_TDI of instance: jtag_mux
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_09_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM2_PWMA03 of instance: flexpwm2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_09_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: ENET_RX_DATA02 of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_09_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SAI2_TX_DATA of instance: sai2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_09_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: CSI_DATA04 of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_09_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO1_IO09 of instance: gpio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_09_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: XBAR1_IN21 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_09_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: GPT2_CLK of instance: gpt2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_09_MUX_MODE_ALT7 = 0x7
	// Select mux mode: ALT9 mux port: SEMC_DQS4 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_09_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_09_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_09_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_09_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_09_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_B0_09
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_09_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_B0_10: SW_MUX_CTL_PAD_GPIO_AD_B0_10 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_10_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_10_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: JTAG_TDO of instance: jtag_mux
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_10_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM1_PWMA03 of instance: flexpwm1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_10_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: ENET_CRS of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_10_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SAI2_MCLK of instance: sai2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_10_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: CSI_DATA03 of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_10_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO1_IO10 of instance: gpio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_10_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: XBAR1_IN22 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_10_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: ENET_1588_EVENT0_OUT of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_10_MUX_MODE_ALT7 = 0x7
	// Select mux mode: ALT8 mux port: FLEXCAN3_TX of instance: flexcan3/canfd
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_10_MUX_MODE_ALT8 = 0x8
	// Select mux mode: ALT9 mux port: ARM_TRACE_SWO of instance: cm7_mx6rt
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_10_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_10_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_10_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_10_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_10_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_B0_10
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_10_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_B0_11: SW_MUX_CTL_PAD_GPIO_AD_B0_11 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_11_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_11_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: JTAG_TRSTB of instance: jtag_mux
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_11_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM1_PWMB03 of instance: flexpwm1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_11_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: ENET_COL of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_11_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: WDOG1_WDOG_B of instance: wdog1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_11_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: CSI_DATA02 of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_11_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO1_IO11 of instance: gpio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_11_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: XBAR1_IN23 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_11_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: ENET_1588_EVENT0_IN of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_11_MUX_MODE_ALT7 = 0x7
	// Select mux mode: ALT8 mux port: FLEXCAN3_RX of instance: flexcan3/canfd
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_11_MUX_MODE_ALT8 = 0x8
	// Select mux mode: ALT9 mux port: SEMC_CLK6 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_11_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_11_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_11_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_11_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_11_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_B0_11
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_11_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_B0_12: SW_MUX_CTL_PAD_GPIO_AD_B0_12 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_12_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_12_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: LPI2C4_SCL of instance: lpi2c4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_12_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: CCM_PMIC_READY of instance: ccm
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_12_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART1_TX of instance: lpuart1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_12_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: WDOG2_WDOG_B of instance: wdog2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_12_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXPWM1_PWMX02 of instance: flexpwm1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_12_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO1_IO12 of instance: gpio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_12_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: ENET_1588_EVENT1_OUT of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_12_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: NMI_GLUE_NMI of instance: nmi_glue
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_12_MUX_MODE_ALT7 = 0x7
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_12_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_12_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_12_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_12_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_B0_12
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_12_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_B0_13: SW_MUX_CTL_PAD_GPIO_AD_B0_13 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_13_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_13_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: LPI2C4_SDA of instance: lpi2c4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_13_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: GPT1_CLK of instance: gpt1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_13_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART1_RX of instance: lpuart1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_13_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: EWM_OUT_B of instance: ewm
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_13_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXPWM1_PWMX03 of instance: flexpwm1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_13_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO1_IO13 of instance: gpio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_13_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: ENET_1588_EVENT1_IN of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_13_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: REF_CLK_24M of instance: anatop
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_13_MUX_MODE_ALT7 = 0x7
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_13_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_13_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_13_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_13_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_B0_13
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_13_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_B0_14: SW_MUX_CTL_PAD_GPIO_AD_B0_14 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_14_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_14_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: USB_OTG2_OC of instance: usb
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_14_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: XBAR1_IN24 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_14_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART1_CTS_B of instance: lpuart1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_14_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: ENET_1588_EVENT0_OUT of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_14_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: CSI_VSYNC of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_14_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO1_IO14 of instance: gpio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_14_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: FLEXCAN2_TX of instance: flexcan2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_14_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT8 mux port: FLEXCAN3_TX of instance: flexcan3/canfd
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_14_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_14_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_14_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_14_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_14_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_B0_14
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_14_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_B0_15: SW_MUX_CTL_PAD_GPIO_AD_B0_15 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_15_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_15_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: USB_OTG2_PWR of instance: usb
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_15_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: XBAR1_IN25 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_15_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART1_RTS_B of instance: lpuart1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_15_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: ENET_1588_EVENT0_IN of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_15_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: CSI_HSYNC of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_15_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO1_IO15 of instance: gpio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_15_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: FLEXCAN2_RX of instance: flexcan2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_15_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: WDOG1_WDOG_RST_B_DEB of instance: wdog1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_15_MUX_MODE_ALT7 = 0x7
	// Select mux mode: ALT8 mux port: FLEXCAN3_RX of instance: flexcan3/canfd
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_15_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_15_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_15_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_15_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_15_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_B0_15
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_15_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_B1_00: SW_MUX_CTL_PAD_GPIO_AD_B1_00 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_00_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_00_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: USB_OTG2_ID of instance: anatop
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_00_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: QTIMER3_TIMER0 of instance: qtimer3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_00_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART2_CTS_B of instance: lpuart2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_00_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: LPI2C1_SCL of instance: lpi2c1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_00_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: WDOG1_B of instance: wdog1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_00_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO1_IO16 of instance: gpio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_00_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: USDHC1_WP of instance: usdhc1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_00_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: KPP_ROW07 of instance: kpp
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_00_MUX_MODE_ALT7 = 0x7
	// Select mux mode: ALT8 mux port: ENET2_1588_EVENT0_OUT of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_00_MUX_MODE_ALT8 = 0x8
	// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO00 of instance: flexio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_00_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_00_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_00_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_00_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_00_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_B1_00
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_00_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_B1_01: SW_MUX_CTL_PAD_GPIO_AD_B1_01 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_01_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_01_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: USB_OTG1_PWR of instance: usb
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_01_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: QTIMER3_TIMER1 of instance: qtimer3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_01_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART2_RTS_B of instance: lpuart2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_01_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: LPI2C1_SDA of instance: lpi2c1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_01_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: CCM_PMIC_READY of instance: ccm
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_01_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO1_IO17 of instance: gpio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_01_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: USDHC1_VSELECT of instance: usdhc1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_01_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: KPP_COL07 of instance: kpp
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_01_MUX_MODE_ALT7 = 0x7
	// Select mux mode: ALT8 mux port: ENET2_1588_EVENT0_IN of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_01_MUX_MODE_ALT8 = 0x8
	// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO01 of instance: flexio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_01_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_01_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_01_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_01_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_01_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_B1_01
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_01_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_B1_02: SW_MUX_CTL_PAD_GPIO_AD_B1_02 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_02_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_02_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: USB_OTG1_ID of instance: anatop
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_02_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: QTIMER3_TIMER2 of instance: qtimer3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_02_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART2_TX of instance: lpuart2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_02_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SPDIF_OUT of instance: spdif
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_02_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: ENET_1588_EVENT2_OUT of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_02_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO1_IO18 of instance: gpio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_02_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: USDHC1_CD_B of instance: usdhc1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_02_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: KPP_ROW06 of instance: kpp
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_02_MUX_MODE_ALT7 = 0x7
	// Select mux mode: ALT8 mux port: GPT2_CLK of instance: gpt2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_02_MUX_MODE_ALT8 = 0x8
	// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO02 of instance: flexio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_02_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_02_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_02_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_02_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_02_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_B1_02
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_02_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_B1_03: SW_MUX_CTL_PAD_GPIO_AD_B1_03 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_03_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_03_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: USB_OTG1_OC of instance: usb
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_03_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: QTIMER3_TIMER3 of instance: qtimer3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_03_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART2_RX of instance: lpuart2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_03_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SPDIF_IN of instance: spdif
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_03_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: ENET_1588_EVENT2_IN of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_03_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO1_IO19 of instance: gpio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_03_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: USDHC2_CD_B of instance: usdhc2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_03_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: KPP_COL06 of instance: kpp
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_03_MUX_MODE_ALT7 = 0x7
	// Select mux mode: ALT8 mux port: GPT2_CAPTURE1 of instance: gpt2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_03_MUX_MODE_ALT8 = 0x8
	// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO03 of instance: flexio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_03_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_03_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_03_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_03_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_03_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_B1_03
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_03_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_B1_04: SW_MUX_CTL_PAD_GPIO_AD_B1_04 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_04_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_04_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: FLEXSPIB_DATA03 of instance: flexspi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_04_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: ENET_MDC of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_04_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART3_CTS_B of instance: lpuart3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_04_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SPDIF_SR_CLK of instance: spdif
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_04_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: CSI_PIXCLK of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_04_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO1_IO20 of instance: gpio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_04_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: USDHC2_DATA0 of instance: usdhc2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_04_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: KPP_ROW05 of instance: kpp
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_04_MUX_MODE_ALT7 = 0x7
	// Select mux mode: ALT8 mux port: GPT2_CAPTURE2 of instance: gpt2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_04_MUX_MODE_ALT8 = 0x8
	// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO04 of instance: flexio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_04_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_04_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_04_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_04_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_04_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_B1_04
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_04_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_B1_05: SW_MUX_CTL_PAD_GPIO_AD_B1_05 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_05_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_05_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: FLEXSPIB_DATA02 of instance: flexspi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_05_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: ENET_MDIO of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_05_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART3_RTS_B of instance: lpuart3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_05_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SPDIF_OUT of instance: spdif
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_05_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: CSI_MCLK of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_05_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO1_IO21 of instance: gpio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_05_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: USDHC2_DATA1 of instance: usdhc2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_05_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: KPP_COL05 of instance: kpp
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_05_MUX_MODE_ALT7 = 0x7
	// Select mux mode: ALT8 mux port: GPT2_COMPARE1 of instance: gpt2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_05_MUX_MODE_ALT8 = 0x8
	// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO05 of instance: flexio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_05_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_05_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_05_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_05_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_05_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_B1_05
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_05_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_B1_06: SW_MUX_CTL_PAD_GPIO_AD_B1_06 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_06_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_06_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: FLEXSPIB_DATA01 of instance: flexspi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_06_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: LPI2C3_SDA of instance: lpi2c3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_06_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART3_TX of instance: lpuart3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_06_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SPDIF_LOCK of instance: spdif
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_06_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: CSI_VSYNC of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_06_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO1_IO22 of instance: gpio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_06_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: USDHC2_DATA2 of instance: usdhc2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_06_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: KPP_ROW04 of instance: kpp
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_06_MUX_MODE_ALT7 = 0x7
	// Select mux mode: ALT8 mux port: GPT2_COMPARE2 of instance: gpt2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_06_MUX_MODE_ALT8 = 0x8
	// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO06 of instance: flexio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_06_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_06_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_06_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_06_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_06_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_B1_06
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_06_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_B1_07: SW_MUX_CTL_PAD_GPIO_AD_B1_07 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_07_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_07_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: FLEXSPIB_DATA00 of instance: flexspi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_07_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: LPI2C3_SCL of instance: lpi2c3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_07_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART3_RX of instance: lpuart3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_07_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SPDIF_EXT_CLK of instance: spdif
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_07_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: CSI_HSYNC of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_07_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO1_IO23 of instance: gpio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_07_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: USDHC2_DATA3 of instance: usdhc2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_07_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: KPP_COL04 of instance: kpp
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_07_MUX_MODE_ALT7 = 0x7
	// Select mux mode: ALT8 mux port: GPT2_COMPARE3 of instance: gpt2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_07_MUX_MODE_ALT8 = 0x8
	// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO07 of instance: flexio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_07_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_07_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_07_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_07_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_07_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_B1_07
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_07_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_B1_08: SW_MUX_CTL_PAD_GPIO_AD_B1_08 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_08_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_08_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: FLEXSPIA_SS1_B of instance: flexspi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_08_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM4_PWMA00 of instance: flexpwm4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_08_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: FLEXCAN1_TX of instance: flexcan1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_08_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: CCM_PMIC_READY of instance: ccm
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_08_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: CSI_DATA09 of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_08_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO1_IO24 of instance: gpio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_08_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: USDHC2_CMD of instance: usdhc2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_08_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: KPP_ROW03 of instance: kpp
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_08_MUX_MODE_ALT7 = 0x7
	// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO08 of instance: flexio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_08_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_08_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_08_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_08_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_08_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_B1_08
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_08_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_B1_09: SW_MUX_CTL_PAD_GPIO_AD_B1_09 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_09_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_09_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: FLEXSPIA_DQS of instance: flexspi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_09_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM4_PWMA01 of instance: flexpwm4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_09_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: FLEXCAN1_RX of instance: flexcan1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_09_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SAI1_MCLK of instance: sai1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_09_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: CSI_DATA08 of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_09_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO1_IO25 of instance: gpio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_09_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: USDHC2_CLK of instance: usdhc2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_09_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: KPP_COL03 of instance: kpp
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_09_MUX_MODE_ALT7 = 0x7
	// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO09 of instance: flexio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_09_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_09_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_09_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_09_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_09_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_B1_09
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_09_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_B1_10: SW_MUX_CTL_PAD_GPIO_AD_B1_10 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_10_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_10_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: FLEXSPIA_DATA03 of instance: flexspi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_10_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: WDOG1_B of instance: wdog1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_10_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART8_TX of instance: lpuart8
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_10_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SAI1_RX_SYNC of instance: sai1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_10_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: CSI_DATA07 of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_10_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO1_IO26 of instance: gpio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_10_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: USDHC2_WP of instance: usdhc2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_10_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: KPP_ROW02 of instance: kpp
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_10_MUX_MODE_ALT7 = 0x7
	// Select mux mode: ALT8 mux port: ENET2_1588_EVENT1_OUT of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_10_MUX_MODE_ALT8 = 0x8
	// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO10 of instance: flexio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_10_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_10_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_10_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_10_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_10_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_B1_10
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_10_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_B1_11: SW_MUX_CTL_PAD_GPIO_AD_B1_11 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_11_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_11_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: FLEXSPIA_DATA02 of instance: flexspi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_11_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: EWM_OUT_B of instance: ewm
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_11_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART8_RX of instance: lpuart8
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_11_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SAI1_RX_BCLK of instance: sai1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_11_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: CSI_DATA06 of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_11_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO1_IO27 of instance: gpio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_11_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: USDHC2_RESET_B of instance: usdhc2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_11_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: KPP_COL02 of instance: kpp
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_11_MUX_MODE_ALT7 = 0x7
	// Select mux mode: ALT8 mux port: ENET2_1588_EVENT1_IN of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_11_MUX_MODE_ALT8 = 0x8
	// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO11 of instance: flexio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_11_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_11_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_11_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_11_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_11_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_B1_11
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_11_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_B1_12: SW_MUX_CTL_PAD_GPIO_AD_B1_12 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_12_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_12_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: FLEXSPIA_DATA01 of instance: flexspi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_12_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: ACMP_OUT00 of instance: acmp
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_12_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPSPI3_PCS0 of instance: lpspi3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_12_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SAI1_RX_DATA00 of instance: sai1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_12_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: CSI_DATA05 of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_12_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO1_IO28 of instance: gpio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_12_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: USDHC2_DATA4 of instance: usdhc2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_12_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: KPP_ROW01 of instance: kpp
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_12_MUX_MODE_ALT7 = 0x7
	// Select mux mode: ALT8 mux port: ENET2_1588_EVENT2_OUT of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_12_MUX_MODE_ALT8 = 0x8
	// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO12 of instance: flexio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_12_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_12_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_12_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_12_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_12_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_B1_12
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_12_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_B1_13: SW_MUX_CTL_PAD_GPIO_AD_B1_13 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_13_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_13_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: FLEXSPIA_DATA00 of instance: flexspi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_13_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: ACMP_OUT01 of instance: acmp
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_13_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPSPI3_SDI of instance: lpspi3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_13_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SAI1_TX_DATA00 of instance: sai1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_13_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: CSI_DATA04 of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_13_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO1_IO29 of instance: gpio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_13_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: USDHC2_DATA5 of instance: usdhc2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_13_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: KPP_COL01 of instance: kpp
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_13_MUX_MODE_ALT7 = 0x7
	// Select mux mode: ALT8 mux port: ENET2_1588_EVENT2_IN of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_13_MUX_MODE_ALT8 = 0x8
	// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO13 of instance: flexio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_13_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_13_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_13_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_13_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_13_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_B1_13
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_13_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_B1_14: SW_MUX_CTL_PAD_GPIO_AD_B1_14 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_14_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_14_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: FLEXSPIA_SCLK of instance: flexspi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_14_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: ACMP_OUT02 of instance: acmp
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_14_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPSPI3_SDO of instance: lpspi3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_14_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SAI1_TX_BCLK of instance: sai1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_14_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: CSI_DATA03 of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_14_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO1_IO30 of instance: gpio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_14_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: USDHC2_DATA6 of instance: usdhc2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_14_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: KPP_ROW00 of instance: kpp
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_14_MUX_MODE_ALT7 = 0x7
	// Select mux mode: ALT8 mux port: ENET2_1588_EVENT3_OUT of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_14_MUX_MODE_ALT8 = 0x8
	// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO14 of instance: flexio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_14_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_14_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_14_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_14_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_14_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_B1_14
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_14_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_B1_15: SW_MUX_CTL_PAD_GPIO_AD_B1_15 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_15_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_15_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: FLEXSPIA_SS0_B of instance: flexspi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_15_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: ACMP_OUT03 of instance: acmp
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_15_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPSPI3_SCK of instance: lpspi3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_15_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SAI1_TX_SYNC of instance: sai1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_15_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: CSI_DATA02 of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_15_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO1_IO31 of instance: gpio1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_15_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: USDHC2_DATA7 of instance: usdhc2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_15_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: KPP_COL00 of instance: kpp
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_15_MUX_MODE_ALT7 = 0x7
	// Select mux mode: ALT8 mux port: ENET2_1588_EVENT3_IN of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_15_MUX_MODE_ALT8 = 0x8
	// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO15 of instance: flexio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_15_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_15_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_15_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_15_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_15_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_B1_15
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_15_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_B0_00: SW_MUX_CTL_PAD_GPIO_B0_00 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_00_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_00_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: LCD_CLK of instance: lcdif
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_00_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: QTIMER1_TIMER0 of instance: qtimer1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_00_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: MQS_RIGHT of instance: mqs
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_00_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: LPSPI4_PCS0 of instance: lpspi4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_00_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO00 of instance: flexio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_00_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO00 of instance: gpio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_00_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: SEMC_CSX01 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_00_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT8 mux port: ENET2_MDC of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_00_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_00_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_00_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_00_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_00_SION_DISABLED = 0x0
	// Force input path of pad GPIO_B0_00
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_00_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_B0_01: SW_MUX_CTL_PAD_GPIO_B0_01 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_01_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_01_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: LCD_ENABLE of instance: lcdif
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_01_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: QTIMER1_TIMER1 of instance: qtimer1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_01_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: MQS_LEFT of instance: mqs
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_01_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: LPSPI4_SDI of instance: lpspi4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_01_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO01 of instance: flexio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_01_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO01 of instance: gpio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_01_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: SEMC_CSX02 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_01_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT8 mux port: ENET2_MDIO of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_01_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_01_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_01_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_01_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_01_SION_DISABLED = 0x0
	// Force input path of pad GPIO_B0_01
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_01_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_B0_02: SW_MUX_CTL_PAD_GPIO_B0_02 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_02_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_02_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: LCD_HSYNC of instance: lcdif
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_02_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: QTIMER1_TIMER2 of instance: qtimer1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_02_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: FLEXCAN1_TX of instance: flexcan1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_02_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: LPSPI4_SDO of instance: lpspi4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_02_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO02 of instance: flexio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_02_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO02 of instance: gpio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_02_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: SEMC_CSX03 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_02_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT8 mux port: ENET2_1588_EVENT0_OUT of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_02_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_02_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_02_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_02_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_02_SION_DISABLED = 0x0
	// Force input path of pad GPIO_B0_02
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_02_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_B0_03: SW_MUX_CTL_PAD_GPIO_B0_03 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: LCD_VSYNC of instance: lcdif
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: QTIMER2_TIMER0 of instance: qtimer2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: FLEXCAN1_RX of instance: flexcan1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: LPSPI4_SCK of instance: lpspi4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO03 of instance: flexio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO03 of instance: gpio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: WDOG2_RESET_B_DEB of instance: wdog2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT8 mux port: ENET2_1588_EVENT0_IN of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03_SION_DISABLED = 0x0
	// Force input path of pad GPIO_B0_03
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_B0_04: SW_MUX_CTL_PAD_GPIO_B0_04 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_04_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_04_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: LCD_DATA00 of instance: lcdif
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_04_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: QTIMER2_TIMER1 of instance: qtimer2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_04_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPI2C2_SCL of instance: lpi2c2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_04_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: ARM_TRACE0 of instance: cm7_mx6rt
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_04_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO04 of instance: flexio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_04_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO04 of instance: gpio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_04_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: SRC_BOOT_CFG00 of instance: src
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_04_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT8 mux port: ENET2_TDATA03 of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_04_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_04_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_04_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_04_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_04_SION_DISABLED = 0x0
	// Force input path of pad GPIO_B0_04
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_04_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_B0_05: SW_MUX_CTL_PAD_GPIO_B0_05 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_05_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_05_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: LCD_DATA01 of instance: lcdif
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_05_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: QTIMER2_TIMER2 of instance: qtimer2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_05_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPI2C2_SDA of instance: lpi2c2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_05_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: ARM_TRACE1 of instance: cm7_mx6rt
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_05_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO05 of instance: flexio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_05_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO05 of instance: gpio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_05_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: SRC_BOOT_CFG01 of instance: src
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_05_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT8 mux port: ENET2_TDATA02 of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_05_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_05_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_05_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_05_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_05_SION_DISABLED = 0x0
	// Force input path of pad GPIO_B0_05
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_05_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_B0_06: SW_MUX_CTL_PAD_GPIO_B0_06 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_06_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_06_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: LCD_DATA02 of instance: lcdif
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_06_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: QTIMER3_TIMER0 of instance: qtimer3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_06_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: FLEXPWM2_PWMA00 of instance: flexpwm2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_06_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: ARM_TRACE2 of instance: cm7_mx6rt
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_06_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO06 of instance: flexio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_06_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO06 of instance: gpio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_06_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: SRC_BOOT_CFG02 of instance: src
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_06_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT8 mux port: ENET2_RX_CLK of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_06_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_06_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_06_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_06_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_06_SION_DISABLED = 0x0
	// Force input path of pad GPIO_B0_06
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_06_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_B0_07: SW_MUX_CTL_PAD_GPIO_B0_07 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_07_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_07_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: LCD_DATA03 of instance: lcdif
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_07_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: QTIMER3_TIMER1 of instance: qtimer3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_07_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: FLEXPWM2_PWMB00 of instance: flexpwm2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_07_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: ARM_TRACE3 of instance: cm7_mx6rt
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_07_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO07 of instance: flexio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_07_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO07 of instance: gpio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_07_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: SRC_BOOT_CFG03 of instance: src
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_07_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT8 mux port: ENET2_TX_ER of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_07_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_07_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_07_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_07_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_07_SION_DISABLED = 0x0
	// Force input path of pad GPIO_B0_07
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_07_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_B0_08: SW_MUX_CTL_PAD_GPIO_B0_08 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_08_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_08_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: LCD_DATA04 of instance: lcdif
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_08_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: QTIMER3_TIMER2 of instance: qtimer3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_08_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: FLEXPWM2_PWMA01 of instance: flexpwm2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_08_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: LPUART3_TX of instance: lpuart3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_08_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO08 of instance: flexio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_08_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO08 of instance: gpio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_08_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: SRC_BOOT_CFG04 of instance: src
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_08_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT8 mux port: ENET2_RDATA03 of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_08_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_08_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_08_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_08_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_08_SION_DISABLED = 0x0
	// Force input path of pad GPIO_B0_08
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_08_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_B0_09: SW_MUX_CTL_PAD_GPIO_B0_09 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_09_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_09_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: LCD_DATA05 of instance: lcdif
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_09_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: QTIMER4_TIMER0 of instance: qtimer4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_09_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: FLEXPWM2_PWMB01 of instance: flexpwm2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_09_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: LPUART3_RX of instance: lpuart3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_09_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO09 of instance: flexio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_09_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO09 of instance: gpio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_09_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: SRC_BOOT_CFG05 of instance: src
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_09_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT8 mux port: ENET2_RDATA02 of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_09_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_09_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_09_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_09_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_09_SION_DISABLED = 0x0
	// Force input path of pad GPIO_B0_09
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_09_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_B0_10: SW_MUX_CTL_PAD_GPIO_B0_10 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_10_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_10_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: LCD_DATA06 of instance: lcdif
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_10_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: QTIMER4_TIMER1 of instance: qtimer4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_10_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: FLEXPWM2_PWMA02 of instance: flexpwm2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_10_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SAI1_TX_DATA03 of instance: sai1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_10_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO10 of instance: flexio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_10_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO10 of instance: gpio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_10_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: SRC_BOOT_CFG06 of instance: src
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_10_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT8 mux port: ENET2_CRS of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_10_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_10_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_10_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_10_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_10_SION_DISABLED = 0x0
	// Force input path of pad GPIO_B0_10
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_10_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_B0_11: SW_MUX_CTL_PAD_GPIO_B0_11 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_11_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_11_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: LCD_DATA07 of instance: lcdif
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_11_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: QTIMER4_TIMER2 of instance: qtimer4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_11_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: FLEXPWM2_PWMB02 of instance: flexpwm2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_11_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SAI1_TX_DATA02 of instance: sai1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_11_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO11 of instance: flexio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_11_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO11 of instance: gpio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_11_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: SRC_BOOT_CFG07 of instance: src
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_11_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT8 mux port: ENET2_COL of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_11_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_11_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_11_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_11_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_11_SION_DISABLED = 0x0
	// Force input path of pad GPIO_B0_11
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_11_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_B0_12: SW_MUX_CTL_PAD_GPIO_B0_12 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_12_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_12_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: LCD_DATA08 of instance: lcdif
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_12_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: XBAR1_INOUT10 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_12_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: ARM_TRACE_CLK of instance: cm7_mx6rt
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_12_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SAI1_TX_DATA01 of instance: sai1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_12_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO12 of instance: flexio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_12_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO12 of instance: gpio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_12_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: SRC_BOOT_CFG08 of instance: src
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_12_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT8 mux port: ENET2_TDATA00 of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_12_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_12_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_12_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_12_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_12_SION_DISABLED = 0x0
	// Force input path of pad GPIO_B0_12
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_12_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_B0_13: SW_MUX_CTL_PAD_GPIO_B0_13 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_13_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_13_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: LCD_DATA09 of instance: lcdif
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_13_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: XBAR1_INOUT11 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_13_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: ARM_TRACE_SWO of instance: cm7_mx6rt
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_13_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SAI1_MCLK of instance: sai1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_13_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO13 of instance: flexio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_13_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO13 of instance: gpio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_13_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: SRC_BOOT_CFG09 of instance: src
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_13_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT8 mux port: ENET2_TDATA01 of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_13_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_13_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_13_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_13_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_13_SION_DISABLED = 0x0
	// Force input path of pad GPIO_B0_13
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_13_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_B0_14: SW_MUX_CTL_PAD_GPIO_B0_14 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_14_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_14_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: LCD_DATA10 of instance: lcdif
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_14_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: XBAR1_INOUT12 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_14_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: ARM_TXEV of instance: cm7_mx6rt
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_14_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SAI1_RX_SYNC of instance: sai1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_14_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO14 of instance: flexio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_14_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO14 of instance: gpio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_14_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: SRC_BOOT_CFG10 of instance: src
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_14_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT8 mux port: ENET2_TX_EN of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_14_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_14_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_14_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_14_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_14_SION_DISABLED = 0x0
	// Force input path of pad GPIO_B0_14
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_14_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_B0_15: SW_MUX_CTL_PAD_GPIO_B0_15 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_15_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_15_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: LCD_DATA11 of instance: lcdif
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_15_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: XBAR1_INOUT13 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_15_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: ARM_RXEV of instance: cm7_mx6rt
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_15_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SAI1_RX_BCLK of instance: sai1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_15_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO15 of instance: flexio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_15_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO15 of instance: gpio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_15_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: SRC_BOOT_CFG11 of instance: src
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_15_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT8 mux port: ENET2_TX_CLK of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_15_MUX_MODE_ALT8 = 0x8
	// Select mux mode: ALT9 mux port: ENET2_REF_CLK2 of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_15_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_15_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_15_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_15_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_15_SION_DISABLED = 0x0
	// Force input path of pad GPIO_B0_15
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_15_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_B1_00: SW_MUX_CTL_PAD_GPIO_B1_00 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_00_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_00_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: LCD_DATA12 of instance: lcdif
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_00_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: XBAR1_INOUT14 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_00_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART4_TX of instance: lpuart4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_00_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SAI1_RX_DATA00 of instance: sai1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_00_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO16 of instance: flexio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_00_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO16 of instance: gpio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_00_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: FLEXPWM1_PWMA03 of instance: flexpwm1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_00_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT8 mux port: ENET2_RX_ER of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_00_MUX_MODE_ALT8 = 0x8
	// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO16 of instance: flexio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_00_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_00_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_00_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_00_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_00_SION_DISABLED = 0x0
	// Force input path of pad GPIO_B1_00
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_00_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_B1_01: SW_MUX_CTL_PAD_GPIO_B1_01 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_01_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_01_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: LCD_DATA13 of instance: lcdif
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_01_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: XBAR1_INOUT15 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_01_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART4_RX of instance: lpuart4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_01_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SAI1_TX_DATA00 of instance: sai1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_01_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO17 of instance: flexio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_01_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO17 of instance: gpio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_01_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: FLEXPWM1_PWMB03 of instance: flexpwm1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_01_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT8 mux port: ENET2_RDATA00 of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_01_MUX_MODE_ALT8 = 0x8
	// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO17 of instance: flexio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_01_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_01_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_01_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_01_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_01_SION_DISABLED = 0x0
	// Force input path of pad GPIO_B1_01
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_01_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_B1_02: SW_MUX_CTL_PAD_GPIO_B1_02 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_02_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_02_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: LCD_DATA14 of instance: lcdif
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_02_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: XBAR1_INOUT16 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_02_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPSPI4_PCS2 of instance: lpspi4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_02_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SAI1_TX_BCLK of instance: sai1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_02_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO18 of instance: flexio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_02_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO18 of instance: gpio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_02_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: FLEXPWM2_PWMA03 of instance: flexpwm2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_02_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT8 mux port: ENET2_RDATA01 of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_02_MUX_MODE_ALT8 = 0x8
	// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO18 of instance: flexio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_02_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_02_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_02_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_02_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_02_SION_DISABLED = 0x0
	// Force input path of pad GPIO_B1_02
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_02_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_B1_03: SW_MUX_CTL_PAD_GPIO_B1_03 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_03_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_03_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: LCD_DATA15 of instance: lcdif
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_03_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: XBAR1_INOUT17 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_03_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPSPI4_PCS1 of instance: lpspi4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_03_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SAI1_TX_SYNC of instance: sai1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_03_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO19 of instance: flexio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_03_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO19 of instance: gpio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_03_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: FLEXPWM2_PWMB03 of instance: flexpwm2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_03_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT8 mux port: ENET2_RX_EN of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_03_MUX_MODE_ALT8 = 0x8
	// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO19 of instance: flexio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_03_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_03_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_03_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_03_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_03_SION_DISABLED = 0x0
	// Force input path of pad GPIO_B1_03
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_03_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_B1_04: SW_MUX_CTL_PAD_GPIO_B1_04 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_04_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_04_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: LCD_DATA16 of instance: lcdif
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_04_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: LPSPI4_PCS0 of instance: lpspi4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_04_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: CSI_DATA15 of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_04_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: ENET_RX_DATA00 of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_04_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO20 of instance: flexio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_04_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO20 of instance: gpio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_04_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT8 mux port: GPT1_CLK of instance: gpt1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_04_MUX_MODE_ALT8 = 0x8
	// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO20 of instance: flexio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_04_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_04_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_04_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_04_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_04_SION_DISABLED = 0x0
	// Force input path of pad GPIO_B1_04
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_04_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_B1_05: SW_MUX_CTL_PAD_GPIO_B1_05 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_05_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_05_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: LCD_DATA17 of instance: lcdif
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_05_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: LPSPI4_SDI of instance: lpspi4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_05_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: CSI_DATA14 of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_05_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: ENET_RX_DATA01 of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_05_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO21 of instance: flexio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_05_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO21 of instance: gpio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_05_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT8 mux port: GPT1_CAPTURE1 of instance: gpt1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_05_MUX_MODE_ALT8 = 0x8
	// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO21 of instance: flexio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_05_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_05_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_05_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_05_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_05_SION_DISABLED = 0x0
	// Force input path of pad GPIO_B1_05
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_05_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_B1_06: SW_MUX_CTL_PAD_GPIO_B1_06 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_06_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_06_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: LCD_DATA18 of instance: lcdif
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_06_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: LPSPI4_SDO of instance: lpspi4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_06_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: CSI_DATA13 of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_06_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: ENET_RX_EN of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_06_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO22 of instance: flexio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_06_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO22 of instance: gpio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_06_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT8 mux port: GPT1_CAPTURE2 of instance: gpt1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_06_MUX_MODE_ALT8 = 0x8
	// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO22 of instance: flexio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_06_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_06_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_06_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_06_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_06_SION_DISABLED = 0x0
	// Force input path of pad GPIO_B1_06
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_06_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_B1_07: SW_MUX_CTL_PAD_GPIO_B1_07 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_07_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_07_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: LCD_DATA19 of instance: lcdif
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_07_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: LPSPI4_SCK of instance: lpspi4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_07_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: CSI_DATA12 of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_07_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: ENET_TX_DATA00 of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_07_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO23 of instance: flexio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_07_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO23 of instance: gpio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_07_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT8 mux port: GPT1_COMPARE1 of instance: gpt1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_07_MUX_MODE_ALT8 = 0x8
	// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO23 of instance: flexio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_07_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_07_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_07_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_07_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_07_SION_DISABLED = 0x0
	// Force input path of pad GPIO_B1_07
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_07_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_B1_08: SW_MUX_CTL_PAD_GPIO_B1_08 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_08_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_08_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: LCD_DATA20 of instance: lcdif
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_08_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: QTIMER1_TIMER3 of instance: qtimer1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_08_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: CSI_DATA11 of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_08_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: ENET_TX_DATA01 of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_08_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO24 of instance: flexio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_08_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO24 of instance: gpio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_08_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: FLEXCAN2_TX of instance: flexcan2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_08_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT8 mux port: GPT1_COMPARE2 of instance: gpt1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_08_MUX_MODE_ALT8 = 0x8
	// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO24 of instance: flexio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_08_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_08_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_08_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_08_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_08_SION_DISABLED = 0x0
	// Force input path of pad GPIO_B1_08
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_08_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_B1_09: SW_MUX_CTL_PAD_GPIO_B1_09 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_09_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_09_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: LCD_DATA21 of instance: lcdif
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_09_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: QTIMER2_TIMER3 of instance: qtimer2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_09_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: CSI_DATA10 of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_09_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: ENET_TX_EN of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_09_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO25 of instance: flexio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_09_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO25 of instance: gpio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_09_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: FLEXCAN2_RX of instance: flexcan2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_09_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT8 mux port: GPT1_COMPARE3 of instance: gpt1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_09_MUX_MODE_ALT8 = 0x8
	// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO25 of instance: flexio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_09_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_09_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_09_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_09_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_09_SION_DISABLED = 0x0
	// Force input path of pad GPIO_B1_09
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_09_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_B1_10: SW_MUX_CTL_PAD_GPIO_B1_10 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_10_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_10_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: LCD_DATA22 of instance: lcdif
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_10_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: QTIMER3_TIMER3 of instance: qtimer3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_10_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: CSI_DATA00 of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_10_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: ENET_TX_CLK of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_10_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO26 of instance: flexio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_10_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO26 of instance: gpio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_10_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: ENET_REF_CLK of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_10_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO26 of instance: flexio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_10_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_10_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_10_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_10_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_10_SION_DISABLED = 0x0
	// Force input path of pad GPIO_B1_10
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_10_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_B1_11: SW_MUX_CTL_PAD_GPIO_B1_11 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_11_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_11_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: LCD_DATA23 of instance: lcdif
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_11_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: QTIMER4_TIMER3 of instance: qtimer4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_11_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: CSI_DATA01 of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_11_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: ENET_RX_ER of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_11_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO27 of instance: flexio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_11_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO27 of instance: gpio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_11_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: LPSPI4_PCS3 of instance: lpspi4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_11_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO27 of instance: flexio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_11_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_11_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_11_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_11_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_11_SION_DISABLED = 0x0
	// Force input path of pad GPIO_B1_11
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_11_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_B1_12: SW_MUX_CTL_PAD_GPIO_B1_12 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_12_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_12_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT1 mux port: LPUART5_TX of instance: lpuart5
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_12_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: CSI_PIXCLK of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_12_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: ENET_1588_EVENT0_IN of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_12_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO28 of instance: flexio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_12_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO28 of instance: gpio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_12_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: USDHC1_CD_B of instance: usdhc1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_12_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO28 of instance: flexio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_12_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_12_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_12_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_12_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_12_SION_DISABLED = 0x0
	// Force input path of pad GPIO_B1_12
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_12_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_B1_13: SW_MUX_CTL_PAD_GPIO_B1_13 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_13_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_13_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: WDOG1_B of instance: wdog1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_13_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: LPUART5_RX of instance: lpuart5
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_13_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: CSI_VSYNC of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_13_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: ENET_1588_EVENT0_OUT of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_13_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO29 of instance: flexio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_13_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO29 of instance: gpio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_13_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: USDHC1_WP of instance: usdhc1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_13_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT8 mux port: SEMC_DQS4 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_13_MUX_MODE_ALT8 = 0x8
	// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO29 of instance: flexio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_13_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_13_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_13_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_13_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_13_SION_DISABLED = 0x0
	// Force input path of pad GPIO_B1_13
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_13_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_B1_14: SW_MUX_CTL_PAD_GPIO_B1_14 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_14_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_14_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: ENET_MDC of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_14_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM4_PWMA02 of instance: flexpwm4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_14_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: CSI_HSYNC of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_14_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: XBAR1_IN02 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_14_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO30 of instance: flexio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_14_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO30 of instance: gpio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_14_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: USDHC1_VSELECT of instance: usdhc1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_14_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT8 mux port: ENET2_TDATA00 of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_14_MUX_MODE_ALT8 = 0x8
	// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO30 of instance: flexio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_14_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_14_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_14_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_14_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_14_SION_DISABLED = 0x0
	// Force input path of pad GPIO_B1_14
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_14_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_B1_15: SW_MUX_CTL_PAD_GPIO_B1_15 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_15_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_15_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: ENET_MDIO of instance: enet
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_15_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM4_PWMA03 of instance: flexpwm4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_15_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: CSI_MCLK of instance: csi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_15_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: XBAR1_IN03 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_15_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO2_FLEXIO31 of instance: flexio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_15_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO31 of instance: gpio2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_15_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: USDHC1_RESET_B of instance: usdhc1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_15_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT8 mux port: ENET2_TDATA01 of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_15_MUX_MODE_ALT8 = 0x8
	// Select mux mode: ALT9 mux port: FLEXIO3_FLEXIO31 of instance: flexio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_15_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_15_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_15_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_15_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_15_SION_DISABLED = 0x0
	// Force input path of pad GPIO_B1_15
	IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_15_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SD_B0_00: SW_MUX_CTL_PAD_GPIO_SD_B0_00 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_00_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_00_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: USDHC1_CMD of instance: usdhc1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_00_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM1_PWMA00 of instance: flexpwm1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_00_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPI2C3_SCL of instance: lpi2c3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_00_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: XBAR1_INOUT04 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_00_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: LPSPI1_SCK of instance: lpspi1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_00_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO3_IO12 of instance: gpio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_00_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: FLEXSPIA_SS1_B of instance: flexspi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_00_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT8 mux port: ENET2_TX_EN of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_00_MUX_MODE_ALT8 = 0x8
	// Select mux mode: ALT9 mux port: SEMC_DQS4 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_00_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_00_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_00_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_00_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_00_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SD_B0_00
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_00_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SD_B0_01: SW_MUX_CTL_PAD_GPIO_SD_B0_01 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_01_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_01_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: USDHC1_CLK of instance: usdhc1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_01_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM1_PWMB00 of instance: flexpwm1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_01_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPI2C3_SDA of instance: lpi2c3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_01_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: XBAR1_INOUT05 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_01_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: LPSPI1_PCS0 of instance: lpspi1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_01_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO3_IO13 of instance: gpio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_01_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: FLEXSPIB_SS1_B of instance: flexspi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_01_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT8 mux port: ENET2_TX_CLK of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_01_MUX_MODE_ALT8 = 0x8
	// Select mux mode: ALT9 mux port: ENET2_REF_CLK2 of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_01_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_01_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_01_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_01_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_01_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SD_B0_01
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_01_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SD_B0_02: SW_MUX_CTL_PAD_GPIO_SD_B0_02 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_02_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_02_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: USDHC1_DATA0 of instance: usdhc1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_02_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM1_PWMA01 of instance: flexpwm1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_02_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART8_CTS_B of instance: lpuart8
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_02_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: XBAR1_INOUT06 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_02_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: LPSPI1_SDO of instance: lpspi1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_02_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO3_IO14 of instance: gpio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_02_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT8 mux port: ENET2_RX_ER of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_02_MUX_MODE_ALT8 = 0x8
	// Select mux mode: ALT9 mux port: SEMC_CLK5 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_02_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_02_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_02_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_02_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_02_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SD_B0_02
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_02_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SD_B0_03: SW_MUX_CTL_PAD_GPIO_SD_B0_03 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_03_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_03_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: USDHC1_DATA1 of instance: usdhc1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_03_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM1_PWMB01 of instance: flexpwm1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_03_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART8_RTS_B of instance: lpuart8
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_03_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: XBAR1_INOUT07 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_03_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: LPSPI1_SDI of instance: lpspi1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_03_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO3_IO15 of instance: gpio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_03_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT8 mux port: ENET2_RDATA00 of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_03_MUX_MODE_ALT8 = 0x8
	// Select mux mode: ALT9 mux port: SEMC_CLK6 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_03_MUX_MODE_ALT9 = 0x9
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_03_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_03_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_03_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_03_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SD_B0_03
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_03_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SD_B0_04: SW_MUX_CTL_PAD_GPIO_SD_B0_04 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_04_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_04_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: USDHC1_DATA2 of instance: usdhc1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_04_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM1_PWMA02 of instance: flexpwm1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_04_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART8_TX of instance: lpuart8
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_04_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: XBAR1_INOUT08 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_04_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXSPIB_SS0_B of instance: flexspi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_04_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO3_IO16 of instance: gpio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_04_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: CCM_CLKO1 of instance: ccm
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_04_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT8 mux port: ENET2_RDATA01 of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_04_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_04_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_04_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_04_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_04_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SD_B0_04
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_04_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SD_B0_05: SW_MUX_CTL_PAD_GPIO_SD_B0_05 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_05_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_05_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: USDHC1_DATA3 of instance: usdhc1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_05_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM1_PWMB02 of instance: flexpwm1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_05_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART8_RX of instance: lpuart8
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_05_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: XBAR1_INOUT09 of instance: xbar1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_05_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXSPIB_DQS of instance: flexspi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_05_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO3_IO17 of instance: gpio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_05_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: CCM_CLKO2 of instance: ccm
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_05_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT8 mux port: ENET2_RX_EN of instance: enet2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_05_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_05_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_05_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_05_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_05_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SD_B0_05
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_05_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SD_B1_00: SW_MUX_CTL_PAD_GPIO_SD_B1_00 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_00_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_00_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: USDHC2_DATA3 of instance: usdhc2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_00_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXSPIB_DATA03 of instance: flexspi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_00_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: FLEXPWM1_PWMA03 of instance: flexpwm1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_00_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SAI1_TX_DATA03 of instance: sai1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_00_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: LPUART4_TX of instance: lpuart4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_00_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO3_IO00 of instance: gpio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_00_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT8 mux port: SAI3_RX_DATA of instance: sai3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_00_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_00_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_00_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_00_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_00_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SD_B1_00
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_00_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SD_B1_01: SW_MUX_CTL_PAD_GPIO_SD_B1_01 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_01_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_01_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: USDHC2_DATA2 of instance: usdhc2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_01_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXSPIB_DATA02 of instance: flexspi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_01_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: FLEXPWM1_PWMB03 of instance: flexpwm1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_01_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SAI1_TX_DATA02 of instance: sai1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_01_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: LPUART4_RX of instance: lpuart4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_01_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO3_IO01 of instance: gpio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_01_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT8 mux port: SAI3_TX_DATA of instance: sai3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_01_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_01_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_01_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_01_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_01_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SD_B1_01
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_01_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SD_B1_02: SW_MUX_CTL_PAD_GPIO_SD_B1_02 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_02_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_02_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: USDHC2_DATA1 of instance: usdhc2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_02_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXSPIB_DATA01 of instance: flexspi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_02_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: FLEXPWM2_PWMA03 of instance: flexpwm2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_02_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SAI1_TX_DATA01 of instance: sai1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_02_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXCAN1_TX of instance: flexcan1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_02_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO3_IO02 of instance: gpio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_02_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: CCM_WAIT of instance: ccm
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_02_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT8 mux port: SAI3_TX_SYNC of instance: sai3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_02_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_02_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_02_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_02_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_02_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SD_B1_02
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_02_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SD_B1_03: SW_MUX_CTL_PAD_GPIO_SD_B1_03 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_03_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_03_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: USDHC2_DATA0 of instance: usdhc2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_03_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXSPIB_DATA00 of instance: flexspi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_03_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: FLEXPWM2_PWMB03 of instance: flexpwm2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_03_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SAI1_MCLK of instance: sai1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_03_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXCAN1_RX of instance: flexcan1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_03_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO3_IO03 of instance: gpio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_03_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: CCM_PMIC_READY of instance: ccm
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_03_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT8 mux port: SAI3_TX_BCLK of instance: sai3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_03_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_03_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_03_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_03_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_03_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SD_B1_03
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_03_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SD_B1_04: SW_MUX_CTL_PAD_GPIO_SD_B1_04 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_04_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_04_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: USDHC2_CLK of instance: usdhc2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_04_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXSPIB_SCLK of instance: flexspi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_04_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPI2C1_SCL of instance: lpi2c1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_04_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SAI1_RX_SYNC of instance: sai1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_04_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXSPIA_SS1_B of instance: flexspi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_04_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO3_IO04 of instance: gpio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_04_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: CCM_STOP of instance: ccm
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_04_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT8 mux port: SAI3_MCLK of instance: sai3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_04_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_04_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_04_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_04_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_04_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SD_B1_04
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_04_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SD_B1_05: SW_MUX_CTL_PAD_GPIO_SD_B1_05 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_05_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_05_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: USDHC2_CMD of instance: usdhc2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_05_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXSPIA_DQS of instance: flexspi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_05_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPI2C1_SDA of instance: lpi2c1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_05_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SAI1_RX_BCLK of instance: sai1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_05_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXSPIB_SS0_B of instance: flexspi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_05_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO3_IO05 of instance: gpio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_05_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT8 mux port: SAI3_RX_SYNC of instance: sai3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_05_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_05_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_05_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_05_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_05_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SD_B1_05
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_05_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SD_B1_06: SW_MUX_CTL_PAD_GPIO_SD_B1_06 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_06_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_06_MUX_MODE_Msk = 0xf
	// Select mux mode: ALT0 mux port: USDHC2_RESET_B of instance: usdhc2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_06_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXSPIA_SS0_B of instance: flexspi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_06_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART7_CTS_B of instance: lpuart7
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_06_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SAI1_RX_DATA00 of instance: sai1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_06_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: LPSPI2_PCS0 of instance: lpspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_06_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO3_IO06 of instance: gpio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_06_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT8 mux port: SAI3_RX_BCLK of instance: sai3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_06_MUX_MODE_ALT8 = 0x8
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_06_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_06_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_06_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_06_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SD_B1_06
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_06_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SD_B1_07: SW_MUX_CTL_PAD_GPIO_SD_B1_07 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_07_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_07_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: SEMC_CSX01 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_07_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXSPIA_SCLK of instance: flexspi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_07_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART7_RTS_B of instance: lpuart7
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_07_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SAI1_TX_DATA00 of instance: sai1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_07_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: LPSPI2_SCK of instance: lpspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_07_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO3_IO07 of instance: gpio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_07_MUX_MODE_ALT5 = 0x5
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_07_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_07_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_07_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_07_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SD_B1_07
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_07_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SD_B1_08: SW_MUX_CTL_PAD_GPIO_SD_B1_08 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_08_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_08_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: USDHC2_DATA4 of instance: usdhc2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_08_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXSPIA_DATA00 of instance: flexspi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_08_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART7_TX of instance: lpuart7
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_08_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SAI1_TX_BCLK of instance: sai1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_08_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: LPSPI2_SD0 of instance: lpspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_08_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO3_IO08 of instance: gpio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_08_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: SEMC_CSX02 of instance: semc
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_08_MUX_MODE_ALT6 = 0x6
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_08_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_08_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_08_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_08_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SD_B1_08
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_08_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SD_B1_09: SW_MUX_CTL_PAD_GPIO_SD_B1_09 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_09_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_09_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: USDHC2_DATA5 of instance: usdhc2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_09_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXSPIA_DATA01 of instance: flexspi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_09_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART7_RX of instance: lpuart7
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_09_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: SAI1_TX_SYNC of instance: sai1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_09_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: LPSPI2_SDI of instance: lpspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_09_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO3_IO09 of instance: gpio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_09_MUX_MODE_ALT5 = 0x5
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_09_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_09_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_09_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_09_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SD_B1_09
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_09_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SD_B1_10: SW_MUX_CTL_PAD_GPIO_SD_B1_10 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_10_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_10_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: USDHC2_DATA6 of instance: usdhc2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_10_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXSPIA_DATA02 of instance: flexspi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_10_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART2_RX of instance: lpuart2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_10_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: LPI2C2_SDA of instance: lpi2c2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_10_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: LPSPI2_PCS2 of instance: lpspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_10_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO3_IO10 of instance: gpio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_10_MUX_MODE_ALT5 = 0x5
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_10_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_10_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_10_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_10_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SD_B1_10
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_10_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SD_B1_11: SW_MUX_CTL_PAD_GPIO_SD_B1_11 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_11_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_11_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: USDHC2_DATA7 of instance: usdhc2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_11_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXSPIA_DATA03 of instance: flexspi
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_11_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART2_TX of instance: lpuart2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_11_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: LPI2C2_SCL of instance: lpi2c2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_11_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: LPSPI2_PCS3 of instance: lpspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_11_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO3_IO11 of instance: gpio3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_11_MUX_MODE_ALT5 = 0x5
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_11_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_11_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_11_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_11_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SD_B1_11
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_11_SION_ENABLED = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_00: SW_PAD_CTL_PAD_GPIO_EMC_00 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_01: SW_PAD_CTL_PAD_GPIO_EMC_01 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_02: SW_PAD_CTL_PAD_GPIO_EMC_02 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_03: SW_PAD_CTL_PAD_GPIO_EMC_03 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_04: SW_PAD_CTL_PAD_GPIO_EMC_04 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_05: SW_PAD_CTL_PAD_GPIO_EMC_05 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_06: SW_PAD_CTL_PAD_GPIO_EMC_06 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_07: SW_PAD_CTL_PAD_GPIO_EMC_07 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_08: SW_PAD_CTL_PAD_GPIO_EMC_08 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_09: SW_PAD_CTL_PAD_GPIO_EMC_09 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_10: SW_PAD_CTL_PAD_GPIO_EMC_10 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_11: SW_PAD_CTL_PAD_GPIO_EMC_11 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_12: SW_PAD_CTL_PAD_GPIO_EMC_12 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_13: SW_PAD_CTL_PAD_GPIO_EMC_13 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_14: SW_PAD_CTL_PAD_GPIO_EMC_14 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_15: SW_PAD_CTL_PAD_GPIO_EMC_15 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_16: SW_PAD_CTL_PAD_GPIO_EMC_16 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_17: SW_PAD_CTL_PAD_GPIO_EMC_17 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_18: SW_PAD_CTL_PAD_GPIO_EMC_18 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_19: SW_PAD_CTL_PAD_GPIO_EMC_19 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_20: SW_PAD_CTL_PAD_GPIO_EMC_20 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_21: SW_PAD_CTL_PAD_GPIO_EMC_21 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_22: SW_PAD_CTL_PAD_GPIO_EMC_22 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_23: SW_PAD_CTL_PAD_GPIO_EMC_23 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_24: SW_PAD_CTL_PAD_GPIO_EMC_24 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_25: SW_PAD_CTL_PAD_GPIO_EMC_25 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_26: SW_PAD_CTL_PAD_GPIO_EMC_26 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_27: SW_PAD_CTL_PAD_GPIO_EMC_27 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_28: SW_PAD_CTL_PAD_GPIO_EMC_28 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_29: SW_PAD_CTL_PAD_GPIO_EMC_29 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_30: SW_PAD_CTL_PAD_GPIO_EMC_30 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_31: SW_PAD_CTL_PAD_GPIO_EMC_31 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_32: SW_PAD_CTL_PAD_GPIO_EMC_32 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_33: SW_PAD_CTL_PAD_GPIO_EMC_33 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_34: SW_PAD_CTL_PAD_GPIO_EMC_34 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_35: SW_PAD_CTL_PAD_GPIO_EMC_35 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_36: SW_PAD_CTL_PAD_GPIO_EMC_36 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_37: SW_PAD_CTL_PAD_GPIO_EMC_37 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_38: SW_PAD_CTL_PAD_GPIO_EMC_38 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_39: SW_PAD_CTL_PAD_GPIO_EMC_39 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_40: SW_PAD_CTL_PAD_GPIO_EMC_40 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_EMC_41: SW_PAD_CTL_PAD_GPIO_EMC_41 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_B0_00: SW_PAD_CTL_PAD_GPIO_AD_B0_00 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_B0_01: SW_PAD_CTL_PAD_GPIO_AD_B0_01 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_B0_02: SW_PAD_CTL_PAD_GPIO_AD_B0_02 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_B0_03: SW_PAD_CTL_PAD_GPIO_AD_B0_03 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_B0_04: SW_PAD_CTL_PAD_GPIO_AD_B0_04 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_B0_05: SW_PAD_CTL_PAD_GPIO_AD_B0_05 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_B0_06: SW_PAD_CTL_PAD_GPIO_AD_B0_06 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_B0_07: SW_PAD_CTL_PAD_GPIO_AD_B0_07 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_B0_08: SW_PAD_CTL_PAD_GPIO_AD_B0_08 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_B0_09: SW_PAD_CTL_PAD_GPIO_AD_B0_09 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_B0_10: SW_PAD_CTL_PAD_GPIO_AD_B0_10 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_B0_11: SW_PAD_CTL_PAD_GPIO_AD_B0_11 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_B0_12: SW_PAD_CTL_PAD_GPIO_AD_B0_12 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_B0_13: SW_PAD_CTL_PAD_GPIO_AD_B0_13 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_B0_14: SW_PAD_CTL_PAD_GPIO_AD_B0_14 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_B0_15: SW_PAD_CTL_PAD_GPIO_AD_B0_15 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_B1_00: SW_PAD_CTL_PAD_GPIO_AD_B1_00 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_B1_01: SW_PAD_CTL_PAD_GPIO_AD_B1_01 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_B1_02: SW_PAD_CTL_PAD_GPIO_AD_B1_02 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_B1_03: SW_PAD_CTL_PAD_GPIO_AD_B1_03 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_B1_04: SW_PAD_CTL_PAD_GPIO_AD_B1_04 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_B1_05: SW_PAD_CTL_PAD_GPIO_AD_B1_05 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_B1_06: SW_PAD_CTL_PAD_GPIO_AD_B1_06 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_B1_07: SW_PAD_CTL_PAD_GPIO_AD_B1_07 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_B1_08: SW_PAD_CTL_PAD_GPIO_AD_B1_08 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_B1_09: SW_PAD_CTL_PAD_GPIO_AD_B1_09 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_B1_10: SW_PAD_CTL_PAD_GPIO_AD_B1_10 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_B1_11: SW_PAD_CTL_PAD_GPIO_AD_B1_11 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_B1_12: SW_PAD_CTL_PAD_GPIO_AD_B1_12 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_B1_13: SW_PAD_CTL_PAD_GPIO_AD_B1_13 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_B1_14: SW_PAD_CTL_PAD_GPIO_AD_B1_14 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_B1_15: SW_PAD_CTL_PAD_GPIO_AD_B1_15 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_B0_00: SW_PAD_CTL_PAD_GPIO_B0_00 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_B0_01: SW_PAD_CTL_PAD_GPIO_B0_01 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_B0_02: SW_PAD_CTL_PAD_GPIO_B0_02 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_B0_03: SW_PAD_CTL_PAD_GPIO_B0_03 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_B0_04: SW_PAD_CTL_PAD_GPIO_B0_04 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_B0_05: SW_PAD_CTL_PAD_GPIO_B0_05 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_B0_06: SW_PAD_CTL_PAD_GPIO_B0_06 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_B0_07: SW_PAD_CTL_PAD_GPIO_B0_07 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_B0_08: SW_PAD_CTL_PAD_GPIO_B0_08 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_B0_09: SW_PAD_CTL_PAD_GPIO_B0_09 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_B0_10: SW_PAD_CTL_PAD_GPIO_B0_10 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_B0_11: SW_PAD_CTL_PAD_GPIO_B0_11 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_B0_12: SW_PAD_CTL_PAD_GPIO_B0_12 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_B0_13: SW_PAD_CTL_PAD_GPIO_B0_13 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_B0_14: SW_PAD_CTL_PAD_GPIO_B0_14 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_B0_15: SW_PAD_CTL_PAD_GPIO_B0_15 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_B1_00: SW_PAD_CTL_PAD_GPIO_B1_00 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_B1_01: SW_PAD_CTL_PAD_GPIO_B1_01 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_B1_02: SW_PAD_CTL_PAD_GPIO_B1_02 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_B1_03: SW_PAD_CTL_PAD_GPIO_B1_03 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_B1_04: SW_PAD_CTL_PAD_GPIO_B1_04 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_B1_05: SW_PAD_CTL_PAD_GPIO_B1_05 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_B1_06: SW_PAD_CTL_PAD_GPIO_B1_06 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_B1_07: SW_PAD_CTL_PAD_GPIO_B1_07 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_B1_08: SW_PAD_CTL_PAD_GPIO_B1_08 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_B1_09: SW_PAD_CTL_PAD_GPIO_B1_09 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_B1_10: SW_PAD_CTL_PAD_GPIO_B1_10 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_B1_11: SW_PAD_CTL_PAD_GPIO_B1_11 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_B1_12: SW_PAD_CTL_PAD_GPIO_B1_12 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_B1_13: SW_PAD_CTL_PAD_GPIO_B1_13 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_B1_14: SW_PAD_CTL_PAD_GPIO_B1_14 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_B1_15: SW_PAD_CTL_PAD_GPIO_B1_15 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SD_B0_00: SW_PAD_CTL_PAD_GPIO_SD_B0_00 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SD_B0_01: SW_PAD_CTL_PAD_GPIO_SD_B0_01 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SD_B0_02: SW_PAD_CTL_PAD_GPIO_SD_B0_02 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SD_B0_03: SW_PAD_CTL_PAD_GPIO_SD_B0_03 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SD_B0_04: SW_PAD_CTL_PAD_GPIO_SD_B0_04 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SD_B0_05: SW_PAD_CTL_PAD_GPIO_SD_B0_05 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SD_B1_00: SW_PAD_CTL_PAD_GPIO_SD_B1_00 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SD_B1_01: SW_PAD_CTL_PAD_GPIO_SD_B1_01 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SD_B1_02: SW_PAD_CTL_PAD_GPIO_SD_B1_02 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SD_B1_03: SW_PAD_CTL_PAD_GPIO_SD_B1_03 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SD_B1_04: SW_PAD_CTL_PAD_GPIO_SD_B1_04 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SD_B1_05: SW_PAD_CTL_PAD_GPIO_SD_B1_05 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SD_B1_06: SW_PAD_CTL_PAD_GPIO_SD_B1_06 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SD_B1_07: SW_PAD_CTL_PAD_GPIO_SD_B1_07 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SD_B1_08: SW_PAD_CTL_PAD_GPIO_SD_B1_08 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SD_B1_09: SW_PAD_CTL_PAD_GPIO_SD_B1_09 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SD_B1_10: SW_PAD_CTL_PAD_GPIO_SD_B1_10 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SD_B1_11: SW_PAD_CTL_PAD_GPIO_SD_B1_11 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_DSE_DSE_0_output_driver_disabled = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_DSE_DSE_1_R0_150_Ohm_3_3V_260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_SPEED_SPEED_1_medium_100MHz = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_SPEED_SPEED_2_medium_100MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// ANATOP_USB_OTG1_ID_SELECT_INPUT: ANATOP_USB_OTG1_ID_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_ANATOP_USB_OTG1_ID_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_ANATOP_USB_OTG1_ID_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_ANATOP_USB_OTG1_ID_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_AD_B0_01 for Mode: ALT3
	IOMUXC_ANATOP_USB_OTG1_ID_SELECT_INPUT_DAISY_GPIO_AD_B0_01_ALT3 = 0x0
	// Selecting Pad: GPIO_AD_B1_02 for Mode: ALT0
	IOMUXC_ANATOP_USB_OTG1_ID_SELECT_INPUT_DAISY_GPIO_AD_B1_02_ALT0 = 0x1

	// ANATOP_USB_OTG2_ID_SELECT_INPUT: ANATOP_USB_OTG2_ID_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_ANATOP_USB_OTG2_ID_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_ANATOP_USB_OTG2_ID_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_ANATOP_USB_OTG2_ID_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_AD_B0_00 for Mode: ALT3
	IOMUXC_ANATOP_USB_OTG2_ID_SELECT_INPUT_DAISY_GPIO_AD_B0_00_ALT3 = 0x0
	// Selecting Pad: GPIO_AD_B1_00 for Mode: ALT0
	IOMUXC_ANATOP_USB_OTG2_ID_SELECT_INPUT_DAISY_GPIO_AD_B1_00_ALT0 = 0x1

	// CCM_PMIC_READY_SELECT_INPUT: CCM_PMIC_READY_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_CCM_PMIC_READY_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_CCM_PMIC_READY_SELECT_INPUT_DAISY_Msk = 0x7
	// Selecting Pad: GPIO_SD_B1_03 for Mode: ALT6
	IOMUXC_CCM_PMIC_READY_SELECT_INPUT_DAISY_GPIO_SD_B1_03_ALT6 = 0x0
	// Selecting Pad: GPIO_AD_B0_12 for Mode: ALT1
	IOMUXC_CCM_PMIC_READY_SELECT_INPUT_DAISY_GPIO_AD_B0_12_ALT1 = 0x1
	// Selecting Pad: GPIO_AD_B1_01 for Mode: ALT4
	IOMUXC_CCM_PMIC_READY_SELECT_INPUT_DAISY_GPIO_AD_B1_01_ALT4 = 0x2
	// Selecting Pad: GPIO_AD_B1_08 for Mode: ALT3
	IOMUXC_CCM_PMIC_READY_SELECT_INPUT_DAISY_GPIO_AD_B1_08_ALT3 = 0x3
	// Selecting Pad: GPIO_EMC_32 for Mode: ALT3
	IOMUXC_CCM_PMIC_READY_SELECT_INPUT_DAISY_GPIO_EMC_32_ALT3 = 0x4

	// CSI_DATA02_SELECT_INPUT: CSI_DATA02_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_CSI_DATA02_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_CSI_DATA02_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_CSI_DATA02_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_AD_B1_15 for Mode: ALT4
	IOMUXC_CSI_DATA02_SELECT_INPUT_DAISY_GPIO_AD_B1_15_ALT4 = 0x0
	// Selecting Pad: GPIO_AD_B0_11 for Mode: ALT4
	IOMUXC_CSI_DATA02_SELECT_INPUT_DAISY_GPIO_AD_B0_11_ALT4 = 0x1

	// CSI_DATA03_SELECT_INPUT: CSI_DATA03_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_CSI_DATA03_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_CSI_DATA03_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_CSI_DATA03_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_AD_B1_14 for Mode: ALT4
	IOMUXC_CSI_DATA03_SELECT_INPUT_DAISY_GPIO_AD_B1_14_ALT4 = 0x0
	// Selecting Pad: GPIO_AD_B0_10 for Mode: ALT4
	IOMUXC_CSI_DATA03_SELECT_INPUT_DAISY_GPIO_AD_B0_10_ALT4 = 0x1

	// CSI_DATA04_SELECT_INPUT: CSI_DATA04_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_CSI_DATA04_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_CSI_DATA04_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_CSI_DATA04_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_AD_B1_13 for Mode: ALT4
	IOMUXC_CSI_DATA04_SELECT_INPUT_DAISY_GPIO_AD_B1_13_ALT4 = 0x0
	// Selecting Pad: GPIO_AD_B0_09 for Mode: ALT4
	IOMUXC_CSI_DATA04_SELECT_INPUT_DAISY_GPIO_AD_B0_09_ALT4 = 0x1

	// CSI_DATA05_SELECT_INPUT: CSI_DATA05_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_CSI_DATA05_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_CSI_DATA05_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_CSI_DATA05_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_AD_B1_12 for Mode: ALT4
	IOMUXC_CSI_DATA05_SELECT_INPUT_DAISY_GPIO_AD_B1_12_ALT4 = 0x0
	// Selecting Pad: GPIO_AD_B0_08 for Mode: ALT4
	IOMUXC_CSI_DATA05_SELECT_INPUT_DAISY_GPIO_AD_B0_08_ALT4 = 0x1

	// CSI_DATA06_SELECT_INPUT: CSI_DATA06_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_CSI_DATA06_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_CSI_DATA06_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_CSI_DATA06_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_AD_B1_11 for Mode: ALT4
	IOMUXC_CSI_DATA06_SELECT_INPUT_DAISY_GPIO_AD_B1_11_ALT4 = 0x0
	// Selecting Pad: GPIO_AD_B0_07 for Mode: ALT4
	IOMUXC_CSI_DATA06_SELECT_INPUT_DAISY_GPIO_AD_B0_07_ALT4 = 0x1

	// CSI_DATA07_SELECT_INPUT: CSI_DATA07_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_CSI_DATA07_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_CSI_DATA07_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_CSI_DATA07_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_AD_B1_10 for Mode: ALT4
	IOMUXC_CSI_DATA07_SELECT_INPUT_DAISY_GPIO_AD_B1_10_ALT4 = 0x0
	// Selecting Pad: GPIO_AD_B0_06 for Mode: ALT4
	IOMUXC_CSI_DATA07_SELECT_INPUT_DAISY_GPIO_AD_B0_06_ALT4 = 0x1

	// CSI_DATA08_SELECT_INPUT: CSI_DATA08_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_CSI_DATA08_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_CSI_DATA08_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_CSI_DATA08_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_AD_B1_09 for Mode: ALT4
	IOMUXC_CSI_DATA08_SELECT_INPUT_DAISY_GPIO_AD_B1_09_ALT4 = 0x0
	// Selecting Pad: GPIO_AD_B0_05 for Mode: ALT4
	IOMUXC_CSI_DATA08_SELECT_INPUT_DAISY_GPIO_AD_B0_05_ALT4 = 0x1

	// CSI_DATA09_SELECT_INPUT: CSI_DATA09_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_CSI_DATA09_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_CSI_DATA09_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_CSI_DATA09_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_AD_B1_08 for Mode: ALT4
	IOMUXC_CSI_DATA09_SELECT_INPUT_DAISY_GPIO_AD_B1_08_ALT4 = 0x0
	// Selecting Pad: GPIO_AD_B0_04 for Mode: ALT4
	IOMUXC_CSI_DATA09_SELECT_INPUT_DAISY_GPIO_AD_B0_04_ALT4 = 0x1

	// CSI_HSYNC_SELECT_INPUT: CSI_HSYNC_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_CSI_HSYNC_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_CSI_HSYNC_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_AD_B0_15 for Mode: ALT4
	IOMUXC_CSI_HSYNC_SELECT_INPUT_DAISY_GPIO_AD_B0_15_ALT4 = 0x0
	// Selecting Pad: GPIO_AD_B1_07 for Mode: ALT4
	IOMUXC_CSI_HSYNC_SELECT_INPUT_DAISY_GPIO_AD_B1_07_ALT4 = 0x1
	// Selecting Pad: GPIO_B1_14 for Mode: ALT2
	IOMUXC_CSI_HSYNC_SELECT_INPUT_DAISY_GPIO_B1_14_ALT2 = 0x2

	// CSI_PIXCLK_SELECT_INPUT: CSI_PIXCLK_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_CSI_PIXCLK_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_CSI_PIXCLK_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_CSI_PIXCLK_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_AD_B1_04 for Mode: ALT4
	IOMUXC_CSI_PIXCLK_SELECT_INPUT_DAISY_GPIO_AD_B1_04_ALT4 = 0x0
	// Selecting Pad: GPIO_B1_12 for Mode: ALT2
	IOMUXC_CSI_PIXCLK_SELECT_INPUT_DAISY_GPIO_B1_12_ALT2 = 0x1

	// CSI_VSYNC_SELECT_INPUT: CSI_VSYNC_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_CSI_VSYNC_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_CSI_VSYNC_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_AD_B0_14 for Mode: ALT4
	IOMUXC_CSI_VSYNC_SELECT_INPUT_DAISY_GPIO_AD_B0_14_ALT4 = 0x0
	// Selecting Pad: GPIO_AD_B1_06 for Mode: ALT4
	IOMUXC_CSI_VSYNC_SELECT_INPUT_DAISY_GPIO_AD_B1_06_ALT4 = 0x1
	// Selecting Pad: GPIO_B1_13 for Mode: ALT2
	IOMUXC_CSI_VSYNC_SELECT_INPUT_DAISY_GPIO_B1_13_ALT2 = 0x2

	// ENET_IPG_CLK_RMII_SELECT_INPUT: ENET_IPG_CLK_RMII_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_ENET_IPG_CLK_RMII_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_ENET_IPG_CLK_RMII_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_ENET_IPG_CLK_RMII_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_25 for Mode: ALT4
	IOMUXC_ENET_IPG_CLK_RMII_SELECT_INPUT_DAISY_GPIO_EMC_25_ALT4 = 0x0
	// Selecting Pad: GPIO_B1_10 for Mode: ALT6
	IOMUXC_ENET_IPG_CLK_RMII_SELECT_INPUT_DAISY_GPIO_B1_10_ALT6 = 0x1

	// ENET_MDIO_SELECT_INPUT: ENET_MDIO_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_ENET_MDIO_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_ENET_MDIO_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_AD_B1_05 for Mode: ALT1
	IOMUXC_ENET_MDIO_SELECT_INPUT_DAISY_GPIO_AD_B1_05_ALT1 = 0x0
	// Selecting Pad: GPIO_EMC_41 for Mode: ALT4
	IOMUXC_ENET_MDIO_SELECT_INPUT_DAISY_GPIO_EMC_41_ALT4 = 0x1
	// Selecting Pad: GPIO_B1_15 for Mode: ALT0
	IOMUXC_ENET_MDIO_SELECT_INPUT_DAISY_GPIO_B1_15_ALT0 = 0x2

	// ENET0_RXDATA_SELECT_INPUT: ENET0_RXDATA_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_ENET0_RXDATA_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_ENET0_RXDATA_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_ENET0_RXDATA_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_20 for Mode: ALT3
	IOMUXC_ENET0_RXDATA_SELECT_INPUT_DAISY_GPIO_EMC_20_ALT3 = 0x0
	// Selecting Pad: GPIO_B1_04 for Mode: ALT3
	IOMUXC_ENET0_RXDATA_SELECT_INPUT_DAISY_GPIO_B1_04_ALT3 = 0x1

	// ENET1_RXDATA_SELECT_INPUT: ENET1_RXDATA_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_ENET1_RXDATA_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_ENET1_RXDATA_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_ENET1_RXDATA_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_19 for Mode: ALT3
	IOMUXC_ENET1_RXDATA_SELECT_INPUT_DAISY_GPIO_EMC_19_ALT3 = 0x0
	// Selecting Pad: GPIO_B1_05 for Mode: ALT3
	IOMUXC_ENET1_RXDATA_SELECT_INPUT_DAISY_GPIO_B1_05_ALT3 = 0x1

	// ENET_RXEN_SELECT_INPUT: ENET_RXEN_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_ENET_RXEN_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_ENET_RXEN_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_ENET_RXEN_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_23 for Mode: ALT3
	IOMUXC_ENET_RXEN_SELECT_INPUT_DAISY_GPIO_EMC_23_ALT3 = 0x0
	// Selecting Pad: GPIO_B1_06 for Mode: ALT3
	IOMUXC_ENET_RXEN_SELECT_INPUT_DAISY_GPIO_B1_06_ALT3 = 0x1

	// ENET_RXERR_SELECT_INPUT: ENET_RXERR_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_ENET_RXERR_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_ENET_RXERR_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_ENET_RXERR_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_26 for Mode: ALT3
	IOMUXC_ENET_RXERR_SELECT_INPUT_DAISY_GPIO_EMC_26_ALT3 = 0x0
	// Selecting Pad: GPIO_B1_11 for Mode: ALT3
	IOMUXC_ENET_RXERR_SELECT_INPUT_DAISY_GPIO_B1_11_ALT3 = 0x1

	// ENET0_TIMER_SELECT_INPUT: ENET0_TIMER_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_ENET0_TIMER_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_ENET0_TIMER_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_AD_B0_15 for Mode: ALT3
	IOMUXC_ENET0_TIMER_SELECT_INPUT_DAISY_GPIO_AD_B0_15_ALT3 = 0x0
	// Selecting Pad: GPIO_AD_B0_11 for Mode: ALT7
	IOMUXC_ENET0_TIMER_SELECT_INPUT_DAISY_GPIO_AD_B0_11_ALT7 = 0x1
	// Selecting Pad: GPIO_B1_12 for Mode: ALT3
	IOMUXC_ENET0_TIMER_SELECT_INPUT_DAISY_GPIO_B1_12_ALT3 = 0x2

	// ENET_TXCLK_SELECT_INPUT: ENET_TXCLK_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_ENET_TXCLK_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_ENET_TXCLK_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_ENET_TXCLK_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_25 for Mode: ALT3
	IOMUXC_ENET_TXCLK_SELECT_INPUT_DAISY_GPIO_EMC_25_ALT3 = 0x0
	// Selecting Pad: GPIO_B1_10 for Mode: ALT3
	IOMUXC_ENET_TXCLK_SELECT_INPUT_DAISY_GPIO_B1_10_ALT3 = 0x1

	// FLEXCAN1_RX_SELECT_INPUT: FLEXCAN1_RX_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXCAN1_RX_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXCAN1_RX_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_SD_B1_03 for Mode: ALT4
	IOMUXC_FLEXCAN1_RX_SELECT_INPUT_DAISY_GPIO_SD_B1_03_ALT4 = 0x0
	// Selecting Pad: GPIO_EMC_18 for Mode: ALT3
	IOMUXC_FLEXCAN1_RX_SELECT_INPUT_DAISY_GPIO_EMC_18_ALT3 = 0x1
	// Selecting Pad: GPIO_AD_B1_09 for Mode: ALT2
	IOMUXC_FLEXCAN1_RX_SELECT_INPUT_DAISY_GPIO_AD_B1_09_ALT2 = 0x2
	// Selecting Pad: GPIO_B0_03 for Mode: ALT2
	IOMUXC_FLEXCAN1_RX_SELECT_INPUT_DAISY_GPIO_B0_03_ALT2 = 0x3

	// FLEXCAN2_RX_SELECT_INPUT: FLEXCAN2_RX_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXCAN2_RX_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXCAN2_RX_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_EMC_10 for Mode: ALT3
	IOMUXC_FLEXCAN2_RX_SELECT_INPUT_DAISY_GPIO_EMC_10_ALT3 = 0x0
	// Selecting Pad: GPIO_AD_B0_03 for Mode: ALT0
	IOMUXC_FLEXCAN2_RX_SELECT_INPUT_DAISY_GPIO_AD_B0_03_ALT0 = 0x1
	// Selecting Pad: GPIO_AD_B0_15 for Mode: ALT6
	IOMUXC_FLEXCAN2_RX_SELECT_INPUT_DAISY_GPIO_AD_B0_15_ALT6 = 0x2
	// Selecting Pad: GPIO_B1_09 for Mode: ALT6
	IOMUXC_FLEXCAN2_RX_SELECT_INPUT_DAISY_GPIO_B1_09_ALT6 = 0x3

	// FLEXPWM1_PWMA3_SELECT_INPUT: FLEXPWM1_PWMA3_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXPWM1_PWMA3_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXPWM1_PWMA3_SELECT_INPUT_DAISY_Msk = 0x7
	// Selecting Pad: GPIO_SD_B1_00 for Mode: ALT2
	IOMUXC_FLEXPWM1_PWMA3_SELECT_INPUT_DAISY_GPIO_SD_B1_00_ALT2 = 0x0
	// Selecting Pad: GPIO_EMC_12 for Mode: ALT4
	IOMUXC_FLEXPWM1_PWMA3_SELECT_INPUT_DAISY_GPIO_EMC_12_ALT4 = 0x1
	// Selecting Pad: GPIO_EMC_38 for Mode: ALT1
	IOMUXC_FLEXPWM1_PWMA3_SELECT_INPUT_DAISY_GPIO_EMC_38_ALT1 = 0x2
	// Selecting Pad: GPIO_AD_B0_10 for Mode: ALT1
	IOMUXC_FLEXPWM1_PWMA3_SELECT_INPUT_DAISY_GPIO_AD_B0_10_ALT1 = 0x3
	// Selecting Pad: GPIO_B1_00 for Mode: ALT6
	IOMUXC_FLEXPWM1_PWMA3_SELECT_INPUT_DAISY_GPIO_B1_00_ALT6 = 0x4

	// FLEXPWM1_PWMA0_SELECT_INPUT: FLEXPWM1_PWMA0_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXPWM1_PWMA0_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXPWM1_PWMA0_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_FLEXPWM1_PWMA0_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_23 for Mode: ALT1
	IOMUXC_FLEXPWM1_PWMA0_SELECT_INPUT_DAISY_GPIO_EMC_23_ALT1 = 0x0
	// Selecting Pad: GPIO_SD_B0_00 for Mode: ALT1
	IOMUXC_FLEXPWM1_PWMA0_SELECT_INPUT_DAISY_GPIO_SD_B0_00_ALT1 = 0x1

	// FLEXPWM1_PWMA1_SELECT_INPUT: FLEXPWM1_PWMA1_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXPWM1_PWMA1_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXPWM1_PWMA1_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_FLEXPWM1_PWMA1_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_25 for Mode: ALT1
	IOMUXC_FLEXPWM1_PWMA1_SELECT_INPUT_DAISY_GPIO_EMC_25_ALT1 = 0x0
	// Selecting Pad: GPIO_SD_B0_02 for Mode: ALT1
	IOMUXC_FLEXPWM1_PWMA1_SELECT_INPUT_DAISY_GPIO_SD_B0_02_ALT1 = 0x1

	// FLEXPWM1_PWMA2_SELECT_INPUT: FLEXPWM1_PWMA2_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXPWM1_PWMA2_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXPWM1_PWMA2_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_FLEXPWM1_PWMA2_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_27 for Mode: ALT1
	IOMUXC_FLEXPWM1_PWMA2_SELECT_INPUT_DAISY_GPIO_EMC_27_ALT1 = 0x0
	// Selecting Pad: GPIO_SD_B0_04 for Mode: ALT1
	IOMUXC_FLEXPWM1_PWMA2_SELECT_INPUT_DAISY_GPIO_SD_B0_04_ALT1 = 0x1

	// FLEXPWM1_PWMB3_SELECT_INPUT: FLEXPWM1_PWMB3_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXPWM1_PWMB3_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXPWM1_PWMB3_SELECT_INPUT_DAISY_Msk = 0x7
	// Selecting Pad: GPIO_SD_B1_01 for Mode: ALT2
	IOMUXC_FLEXPWM1_PWMB3_SELECT_INPUT_DAISY_GPIO_SD_B1_01_ALT2 = 0x0
	// Selecting Pad: GPIO_EMC_13 for Mode: ALT4
	IOMUXC_FLEXPWM1_PWMB3_SELECT_INPUT_DAISY_GPIO_EMC_13_ALT4 = 0x1
	// Selecting Pad: GPIO_EMC_39 for Mode: ALT1
	IOMUXC_FLEXPWM1_PWMB3_SELECT_INPUT_DAISY_GPIO_EMC_39_ALT1 = 0x2
	// Selecting Pad: GPIO_AD_B0_11 for Mode: ALT1
	IOMUXC_FLEXPWM1_PWMB3_SELECT_INPUT_DAISY_GPIO_AD_B0_11_ALT1 = 0x3
	// Selecting Pad: GPIO_B1_01 for Mode: ALT6
	IOMUXC_FLEXPWM1_PWMB3_SELECT_INPUT_DAISY_GPIO_B1_01_ALT6 = 0x4

	// FLEXPWM1_PWMB0_SELECT_INPUT: FLEXPWM1_PWMB0_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXPWM1_PWMB0_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXPWM1_PWMB0_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_FLEXPWM1_PWMB0_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_24 for Mode: ALT1
	IOMUXC_FLEXPWM1_PWMB0_SELECT_INPUT_DAISY_GPIO_EMC_24_ALT1 = 0x0
	// Selecting Pad: GPIO_SD_B0_01 for Mode: ALT1
	IOMUXC_FLEXPWM1_PWMB0_SELECT_INPUT_DAISY_GPIO_SD_B0_01_ALT1 = 0x1

	// FLEXPWM1_PWMB1_SELECT_INPUT: FLEXPWM1_PWMB1_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXPWM1_PWMB1_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXPWM1_PWMB1_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_FLEXPWM1_PWMB1_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_26 for Mode: ALT1
	IOMUXC_FLEXPWM1_PWMB1_SELECT_INPUT_DAISY_GPIO_EMC_26_ALT1 = 0x0
	// Selecting Pad: GPIO_SD_B0_03 for Mode: ALT1
	IOMUXC_FLEXPWM1_PWMB1_SELECT_INPUT_DAISY_GPIO_SD_B0_03_ALT1 = 0x1

	// FLEXPWM1_PWMB2_SELECT_INPUT: FLEXPWM1_PWMB2_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXPWM1_PWMB2_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXPWM1_PWMB2_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_FLEXPWM1_PWMB2_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_28 for Mode: ALT1
	IOMUXC_FLEXPWM1_PWMB2_SELECT_INPUT_DAISY_GPIO_EMC_28_ALT1 = 0x0
	// Selecting Pad: GPIO_SD_B0_05 for Mode: ALT1
	IOMUXC_FLEXPWM1_PWMB2_SELECT_INPUT_DAISY_GPIO_SD_B0_05_ALT1 = 0x1

	// FLEXPWM2_PWMA3_SELECT_INPUT: FLEXPWM2_PWMA3_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXPWM2_PWMA3_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXPWM2_PWMA3_SELECT_INPUT_DAISY_Msk = 0x7
	// Selecting Pad: GPIO_SD_B1_02 for Mode: ALT2
	IOMUXC_FLEXPWM2_PWMA3_SELECT_INPUT_DAISY_GPIO_SD_B1_02_ALT2 = 0x0
	// Selecting Pad: GPIO_EMC_19 for Mode: ALT1
	IOMUXC_FLEXPWM2_PWMA3_SELECT_INPUT_DAISY_GPIO_EMC_19_ALT1 = 0x1
	// Selecting Pad: GPIO_AD_B0_00 for Mode: ALT0
	IOMUXC_FLEXPWM2_PWMA3_SELECT_INPUT_DAISY_GPIO_AD_B0_00_ALT0 = 0x2
	// Selecting Pad: GPIO_AD_B0_09 for Mode: ALT1
	IOMUXC_FLEXPWM2_PWMA3_SELECT_INPUT_DAISY_GPIO_AD_B0_09_ALT1 = 0x3
	// Selecting Pad: GPIO_B1_02 for Mode: ALT6
	IOMUXC_FLEXPWM2_PWMA3_SELECT_INPUT_DAISY_GPIO_B1_02_ALT6 = 0x4

	// FLEXPWM2_PWMA0_SELECT_INPUT: FLEXPWM2_PWMA0_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXPWM2_PWMA0_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXPWM2_PWMA0_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_FLEXPWM2_PWMA0_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_06 for Mode: ALT1
	IOMUXC_FLEXPWM2_PWMA0_SELECT_INPUT_DAISY_GPIO_EMC_06_ALT1 = 0x0
	// Selecting Pad: GPIO_B0_06 for Mode: ALT2
	IOMUXC_FLEXPWM2_PWMA0_SELECT_INPUT_DAISY_GPIO_B0_06_ALT2 = 0x1

	// FLEXPWM2_PWMA1_SELECT_INPUT: FLEXPWM2_PWMA1_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXPWM2_PWMA1_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXPWM2_PWMA1_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_FLEXPWM2_PWMA1_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_08 for Mode: ALT1
	IOMUXC_FLEXPWM2_PWMA1_SELECT_INPUT_DAISY_GPIO_EMC_08_ALT1 = 0x0
	// Selecting Pad: GPIO_B0_08 for Mode: ALT2
	IOMUXC_FLEXPWM2_PWMA1_SELECT_INPUT_DAISY_GPIO_B0_08_ALT2 = 0x1

	// FLEXPWM2_PWMA2_SELECT_INPUT: FLEXPWM2_PWMA2_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXPWM2_PWMA2_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXPWM2_PWMA2_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_FLEXPWM2_PWMA2_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_10 for Mode: ALT1
	IOMUXC_FLEXPWM2_PWMA2_SELECT_INPUT_DAISY_GPIO_EMC_10_ALT1 = 0x0
	// Selecting Pad: GPIO_B0_10 for Mode: ALT2
	IOMUXC_FLEXPWM2_PWMA2_SELECT_INPUT_DAISY_GPIO_B0_10_ALT2 = 0x1

	// FLEXPWM2_PWMB3_SELECT_INPUT: FLEXPWM2_PWMB3_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXPWM2_PWMB3_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXPWM2_PWMB3_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_SD_B1_03 for Mode: ALT2
	IOMUXC_FLEXPWM2_PWMB3_SELECT_INPUT_DAISY_GPIO_SD_B1_03_ALT2 = 0x0
	// Selecting Pad: GPIO_EMC_20 for Mode: ALT1
	IOMUXC_FLEXPWM2_PWMB3_SELECT_INPUT_DAISY_GPIO_EMC_20_ALT1 = 0x1
	// Selecting Pad: GPIO_AD_B0_01 for Mode: ALT0
	IOMUXC_FLEXPWM2_PWMB3_SELECT_INPUT_DAISY_GPIO_AD_B0_01_ALT0 = 0x2
	// Selecting Pad: GPIO_B1_03 for Mode: ALT6
	IOMUXC_FLEXPWM2_PWMB3_SELECT_INPUT_DAISY_GPIO_B1_03_ALT6 = 0x3

	// FLEXPWM2_PWMB0_SELECT_INPUT: FLEXPWM2_PWMB0_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXPWM2_PWMB0_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXPWM2_PWMB0_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_FLEXPWM2_PWMB0_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_07 for Mode: ALT1
	IOMUXC_FLEXPWM2_PWMB0_SELECT_INPUT_DAISY_GPIO_EMC_07_ALT1 = 0x0
	// Selecting Pad: GPIO_B0_07 for Mode: ALT2
	IOMUXC_FLEXPWM2_PWMB0_SELECT_INPUT_DAISY_GPIO_B0_07_ALT2 = 0x1

	// FLEXPWM2_PWMB1_SELECT_INPUT: FLEXPWM2_PWMB1_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXPWM2_PWMB1_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXPWM2_PWMB1_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_FLEXPWM2_PWMB1_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_09 for Mode: ALT1
	IOMUXC_FLEXPWM2_PWMB1_SELECT_INPUT_DAISY_GPIO_EMC_09_ALT1 = 0x0
	// Selecting Pad: GPIO_B0_09 for Mode: ALT2
	IOMUXC_FLEXPWM2_PWMB1_SELECT_INPUT_DAISY_GPIO_B0_09_ALT2 = 0x1

	// FLEXPWM2_PWMB2_SELECT_INPUT: FLEXPWM2_PWMB2_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXPWM2_PWMB2_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXPWM2_PWMB2_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_FLEXPWM2_PWMB2_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_11 for Mode: ALT1
	IOMUXC_FLEXPWM2_PWMB2_SELECT_INPUT_DAISY_GPIO_EMC_11_ALT1 = 0x0
	// Selecting Pad: GPIO_B0_11 for Mode: ALT2
	IOMUXC_FLEXPWM2_PWMB2_SELECT_INPUT_DAISY_GPIO_B0_11_ALT2 = 0x1

	// FLEXPWM4_PWMA0_SELECT_INPUT: FLEXPWM4_PWMA0_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXPWM4_PWMA0_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXPWM4_PWMA0_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_FLEXPWM4_PWMA0_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_00 for Mode: ALT1
	IOMUXC_FLEXPWM4_PWMA0_SELECT_INPUT_DAISY_GPIO_EMC_00_ALT1 = 0x0
	// Selecting Pad: GPIO_AD_B1_08 for Mode: ALT1
	IOMUXC_FLEXPWM4_PWMA0_SELECT_INPUT_DAISY_GPIO_AD_B1_08_ALT1 = 0x1

	// FLEXPWM4_PWMA1_SELECT_INPUT: FLEXPWM4_PWMA1_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXPWM4_PWMA1_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXPWM4_PWMA1_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_FLEXPWM4_PWMA1_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_02 for Mode: ALT1
	IOMUXC_FLEXPWM4_PWMA1_SELECT_INPUT_DAISY_GPIO_EMC_02_ALT1 = 0x0
	// Selecting Pad: GPIO_AD_B1_09 for Mode: ALT1
	IOMUXC_FLEXPWM4_PWMA1_SELECT_INPUT_DAISY_GPIO_AD_B1_09_ALT1 = 0x1

	// FLEXPWM4_PWMA2_SELECT_INPUT: FLEXPWM4_PWMA2_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXPWM4_PWMA2_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXPWM4_PWMA2_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_FLEXPWM4_PWMA2_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_04 for Mode: ALT1
	IOMUXC_FLEXPWM4_PWMA2_SELECT_INPUT_DAISY_GPIO_EMC_04_ALT1 = 0x0
	// Selecting Pad: GPIO_B1_14 for Mode: ALT1
	IOMUXC_FLEXPWM4_PWMA2_SELECT_INPUT_DAISY_GPIO_B1_14_ALT1 = 0x1

	// FLEXPWM4_PWMA3_SELECT_INPUT: FLEXPWM4_PWMA3_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXPWM4_PWMA3_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXPWM4_PWMA3_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_FLEXPWM4_PWMA3_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_17 for Mode: ALT1
	IOMUXC_FLEXPWM4_PWMA3_SELECT_INPUT_DAISY_GPIO_EMC_17_ALT1 = 0x0
	// Selecting Pad: GPIO_B1_15 for Mode: ALT1
	IOMUXC_FLEXPWM4_PWMA3_SELECT_INPUT_DAISY_GPIO_B1_15_ALT1 = 0x1

	// FLEXSPIA_DQS_SELECT_INPUT: FLEXSPIA_DQS_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXSPIA_DQS_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXSPIA_DQS_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_FLEXSPIA_DQS_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_SD_B1_05 for Mode: ALT1
	IOMUXC_FLEXSPIA_DQS_SELECT_INPUT_DAISY_GPIO_SD_B1_05_ALT1 = 0x0
	// Selecting Pad: GPIO_AD_B1_09 for Mode: ALT0
	IOMUXC_FLEXSPIA_DQS_SELECT_INPUT_DAISY_GPIO_AD_B1_09_ALT0 = 0x1

	// FLEXSPIA_DATA0_SELECT_INPUT: FLEXSPIA_DATA0_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXSPIA_DATA0_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXSPIA_DATA0_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_FLEXSPIA_DATA0_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_SD_B1_08 for Mode: ALT1
	IOMUXC_FLEXSPIA_DATA0_SELECT_INPUT_DAISY_GPIO_SD_B1_08_ALT1 = 0x0
	// Selecting Pad: GPIO_AD_B1_13 for Mode: ALT0
	IOMUXC_FLEXSPIA_DATA0_SELECT_INPUT_DAISY_GPIO_AD_B1_13_ALT0 = 0x1

	// FLEXSPIA_DATA1_SELECT_INPUT: FLEXSPIA_DATA1_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXSPIA_DATA1_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXSPIA_DATA1_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_FLEXSPIA_DATA1_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_SD_B1_09 for Mode: ALT1
	IOMUXC_FLEXSPIA_DATA1_SELECT_INPUT_DAISY_GPIO_SD_B1_09_ALT1 = 0x0
	// Selecting Pad: GPIO_AD_B1_12 for Mode: ALT0
	IOMUXC_FLEXSPIA_DATA1_SELECT_INPUT_DAISY_GPIO_AD_B1_12_ALT0 = 0x1

	// FLEXSPIA_DATA2_SELECT_INPUT: FLEXSPIA_DATA2_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXSPIA_DATA2_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXSPIA_DATA2_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_FLEXSPIA_DATA2_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_SD_B1_10 for Mode: ALT1
	IOMUXC_FLEXSPIA_DATA2_SELECT_INPUT_DAISY_GPIO_SD_B1_10_ALT1 = 0x0
	// Selecting Pad: GPIO_AD_B1_11 for Mode: ALT0
	IOMUXC_FLEXSPIA_DATA2_SELECT_INPUT_DAISY_GPIO_AD_B1_11_ALT0 = 0x1

	// FLEXSPIA_DATA3_SELECT_INPUT: FLEXSPIA_DATA3_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXSPIA_DATA3_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXSPIA_DATA3_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_FLEXSPIA_DATA3_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_SD_B1_11 for Mode: ALT1
	IOMUXC_FLEXSPIA_DATA3_SELECT_INPUT_DAISY_GPIO_SD_B1_11_ALT1 = 0x0
	// Selecting Pad: GPIO_AD_B1_10 for Mode: ALT0
	IOMUXC_FLEXSPIA_DATA3_SELECT_INPUT_DAISY_GPIO_AD_B1_10_ALT0 = 0x1

	// FLEXSPIB_DATA0_SELECT_INPUT: FLEXSPIB_DATA0_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXSPIB_DATA0_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXSPIB_DATA0_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_FLEXSPIB_DATA0_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_SD_B1_03 for Mode: ALT1
	IOMUXC_FLEXSPIB_DATA0_SELECT_INPUT_DAISY_GPIO_SD_B1_03_ALT1 = 0x0
	// Selecting Pad: GPIO_AD_B1_07 for Mode: ALT0
	IOMUXC_FLEXSPIB_DATA0_SELECT_INPUT_DAISY_GPIO_AD_B1_07_ALT0 = 0x1

	// FLEXSPIB_DATA1_SELECT_INPUT: FLEXSPIB_DATA1_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXSPIB_DATA1_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXSPIB_DATA1_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_FLEXSPIB_DATA1_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_SD_B1_02 for Mode: ALT1
	IOMUXC_FLEXSPIB_DATA1_SELECT_INPUT_DAISY_GPIO_SD_B1_02_ALT1 = 0x0
	// Selecting Pad: GPIO_AD_B1_06 for Mode: ALT0
	IOMUXC_FLEXSPIB_DATA1_SELECT_INPUT_DAISY_GPIO_AD_B1_06_ALT0 = 0x1

	// FLEXSPIB_DATA2_SELECT_INPUT: FLEXSPIB_DATA2_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXSPIB_DATA2_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXSPIB_DATA2_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_FLEXSPIB_DATA2_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_SD_B1_01 for Mode: ALT1
	IOMUXC_FLEXSPIB_DATA2_SELECT_INPUT_DAISY_GPIO_SD_B1_01_ALT1 = 0x0
	// Selecting Pad: GPIO_AD_B1_05 for Mode: ALT0
	IOMUXC_FLEXSPIB_DATA2_SELECT_INPUT_DAISY_GPIO_AD_B1_05_ALT0 = 0x1

	// FLEXSPIB_DATA3_SELECT_INPUT: FLEXSPIB_DATA3_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXSPIB_DATA3_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXSPIB_DATA3_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_FLEXSPIB_DATA3_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_SD_B1_00 for Mode: ALT1
	IOMUXC_FLEXSPIB_DATA3_SELECT_INPUT_DAISY_GPIO_SD_B1_00_ALT1 = 0x0
	// Selecting Pad: GPIO_AD_B1_04 for Mode: ALT0
	IOMUXC_FLEXSPIB_DATA3_SELECT_INPUT_DAISY_GPIO_AD_B1_04_ALT0 = 0x1

	// FLEXSPIA_SCK_SELECT_INPUT: FLEXSPIA_SCK_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXSPIA_SCK_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXSPIA_SCK_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_FLEXSPIA_SCK_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_SD_B1_07 for Mode: ALT1
	IOMUXC_FLEXSPIA_SCK_SELECT_INPUT_DAISY_GPIO_SD_B1_07_ALT1 = 0x0
	// Selecting Pad: GPIO_AD_B1_14 for Mode: ALT0
	IOMUXC_FLEXSPIA_SCK_SELECT_INPUT_DAISY_GPIO_AD_B1_14_ALT0 = 0x1

	// LPI2C1_SCL_SELECT_INPUT: LPI2C1_SCL_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPI2C1_SCL_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPI2C1_SCL_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPI2C1_SCL_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_SD_B1_04 for Mode: ALT2
	IOMUXC_LPI2C1_SCL_SELECT_INPUT_DAISY_GPIO_SD_B1_04_ALT2 = 0x0
	// Selecting Pad: GPIO_AD_B1_00 for Mode: ALT3
	IOMUXC_LPI2C1_SCL_SELECT_INPUT_DAISY_GPIO_AD_B1_00_ALT3 = 0x1

	// LPI2C1_SDA_SELECT_INPUT: LPI2C1_SDA_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPI2C1_SDA_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPI2C1_SDA_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPI2C1_SDA_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_SD_B1_05 for Mode: ALT2
	IOMUXC_LPI2C1_SDA_SELECT_INPUT_DAISY_GPIO_SD_B1_05_ALT2 = 0x0
	// Selecting Pad: GPIO_AD_B1_01 for Mode: ALT3
	IOMUXC_LPI2C1_SDA_SELECT_INPUT_DAISY_GPIO_AD_B1_01_ALT3 = 0x1

	// LPI2C2_SCL_SELECT_INPUT: LPI2C2_SCL_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPI2C2_SCL_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPI2C2_SCL_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPI2C2_SCL_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_SD_B1_11 for Mode: ALT3
	IOMUXC_LPI2C2_SCL_SELECT_INPUT_DAISY_GPIO_SD_B1_11_ALT3 = 0x0
	// Selecting Pad: GPIO_B0_04 for Mode: ALT2
	IOMUXC_LPI2C2_SCL_SELECT_INPUT_DAISY_GPIO_B0_04_ALT2 = 0x1

	// LPI2C2_SDA_SELECT_INPUT: LPI2C2_SDA_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPI2C2_SDA_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPI2C2_SDA_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPI2C2_SDA_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_SD_B1_10 for Mode: ALT3
	IOMUXC_LPI2C2_SDA_SELECT_INPUT_DAISY_GPIO_SD_B1_10_ALT3 = 0x0
	// Selecting Pad: GPIO_B0_05 for Mode: ALT2
	IOMUXC_LPI2C2_SDA_SELECT_INPUT_DAISY_GPIO_B0_05_ALT2 = 0x1

	// LPI2C3_SCL_SELECT_INPUT: LPI2C3_SCL_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPI2C3_SCL_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPI2C3_SCL_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_EMC_22 for Mode: ALT2
	IOMUXC_LPI2C3_SCL_SELECT_INPUT_DAISY_GPIO_EMC_22_ALT2 = 0x0
	// Selecting Pad: GPIO_SD_B0_00 for Mode: ALT2
	IOMUXC_LPI2C3_SCL_SELECT_INPUT_DAISY_GPIO_SD_B0_00_ALT2 = 0x1
	// Selecting Pad: GPIO_AD_B1_07 for Mode: ALT1
	IOMUXC_LPI2C3_SCL_SELECT_INPUT_DAISY_GPIO_AD_B1_07_ALT1 = 0x2

	// LPI2C3_SDA_SELECT_INPUT: LPI2C3_SDA_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPI2C3_SDA_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPI2C3_SDA_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_EMC_21 for Mode: ALT2
	IOMUXC_LPI2C3_SDA_SELECT_INPUT_DAISY_GPIO_EMC_21_ALT2 = 0x0
	// Selecting Pad: GPIO_SD_B0_01 for Mode: ALT2
	IOMUXC_LPI2C3_SDA_SELECT_INPUT_DAISY_GPIO_SD_B0_01_ALT2 = 0x1
	// Selecting Pad: GPIO_AD_B1_06 for Mode: ALT1
	IOMUXC_LPI2C3_SDA_SELECT_INPUT_DAISY_GPIO_AD_B1_06_ALT1 = 0x2

	// LPI2C4_SCL_SELECT_INPUT: LPI2C4_SCL_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPI2C4_SCL_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPI2C4_SCL_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPI2C4_SCL_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_12 for Mode: ALT2
	IOMUXC_LPI2C4_SCL_SELECT_INPUT_DAISY_GPIO_EMC_12_ALT2 = 0x0
	// Selecting Pad: GPIO_AD_B0_12 for Mode: ALT0
	IOMUXC_LPI2C4_SCL_SELECT_INPUT_DAISY_GPIO_AD_B0_12_ALT0 = 0x1

	// LPI2C4_SDA_SELECT_INPUT: LPI2C4_SDA_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPI2C4_SDA_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPI2C4_SDA_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPI2C4_SDA_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_11 for Mode: ALT2
	IOMUXC_LPI2C4_SDA_SELECT_INPUT_DAISY_GPIO_EMC_11_ALT2 = 0x0
	// Selecting Pad: GPIO_AD_B0_13 for Mode: ALT0
	IOMUXC_LPI2C4_SDA_SELECT_INPUT_DAISY_GPIO_AD_B0_13_ALT0 = 0x1

	// LPSPI1_PCS0_SELECT_INPUT: LPSPI1_PCS0_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPSPI1_PCS0_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPSPI1_PCS0_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPSPI1_PCS0_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_SD_B0_01 for Mode: ALT4
	IOMUXC_LPSPI1_PCS0_SELECT_INPUT_DAISY_GPIO_SD_B0_01_ALT4 = 0x0
	// Selecting Pad: GPIO_EMC_30 for Mode: ALT3
	IOMUXC_LPSPI1_PCS0_SELECT_INPUT_DAISY_GPIO_EMC_30_ALT3 = 0x1

	// LPSPI1_SCK_SELECT_INPUT: LPSPI1_SCK_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPSPI1_SCK_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPSPI1_SCK_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPSPI1_SCK_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_27 for Mode: ALT3
	IOMUXC_LPSPI1_SCK_SELECT_INPUT_DAISY_GPIO_EMC_27_ALT3 = 0x0
	// Selecting Pad: GPIO_SD_B0_00 for Mode: ALT4
	IOMUXC_LPSPI1_SCK_SELECT_INPUT_DAISY_GPIO_SD_B0_00_ALT4 = 0x1

	// LPSPI1_SDI_SELECT_INPUT: LPSPI1_SDI_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPSPI1_SDI_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPSPI1_SDI_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPSPI1_SDI_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_29 for Mode: ALT3
	IOMUXC_LPSPI1_SDI_SELECT_INPUT_DAISY_GPIO_EMC_29_ALT3 = 0x0
	// Selecting Pad: GPIO_AD_B0_03 for Mode: ALT4
	IOMUXC_LPSPI1_SDI_SELECT_INPUT_DAISY_GPIO_SD_B0_03_ALT4 = 0x1

	// LPSPI1_SDO_SELECT_INPUT: LPSPI1_SDO_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPSPI1_SDO_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPSPI1_SDO_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPSPI1_SDO_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_28 for Mode: ALT3
	IOMUXC_LPSPI1_SDO_SELECT_INPUT_DAISY_GPIO_EMC_28_ALT3 = 0x0
	// Selecting Pad: GPIO_SD_B0_02 for Mode: ALT4
	IOMUXC_LPSPI1_SDO_SELECT_INPUT_DAISY_GPIO_SD_B0_02_ALT4 = 0x1

	// LPSPI2_PCS0_SELECT_INPUT: LPSPI2_PCS0_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPSPI2_PCS0_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPSPI2_PCS0_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPSPI2_PCS0_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_SD_B1_06 for Mode: ALT4
	IOMUXC_LPSPI2_PCS0_SELECT_INPUT_DAISY_GPIO_SD_B1_06_ALT4 = 0x0
	// Selecting Pad: GPIO_EMC_01 for Mode: ALT2
	IOMUXC_LPSPI2_PCS0_SELECT_INPUT_DAISY_GPIO_EMC_01_ALT2 = 0x1

	// LPSPI2_SCK_SELECT_INPUT: LPSPI2_SCK_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPSPI2_SCK_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPSPI2_SCK_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPSPI2_SCK_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_SD_B1_07 for Mode: ALT4
	IOMUXC_LPSPI2_SCK_SELECT_INPUT_DAISY_GPIO_SD_B1_07_ALT4 = 0x0
	// Selecting Pad: GPIO_EMC_00 for Mode: ALT2
	IOMUXC_LPSPI2_SCK_SELECT_INPUT_DAISY_GPIO_EMC_00_ALT2 = 0x1

	// LPSPI2_SDI_SELECT_INPUT: LPSPI2_SDI_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPSPI2_SDI_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPSPI2_SDI_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPSPI2_SDI_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_SD_B1_09 for Mode: ALT4
	IOMUXC_LPSPI2_SDI_SELECT_INPUT_DAISY_GPIO_SD_B1_09_ALT4 = 0x0
	// Selecting Pad: GPIO_EMC_03 for Mode: ALT2
	IOMUXC_LPSPI2_SDI_SELECT_INPUT_DAISY_GPIO_EMC_03_ALT2 = 0x1

	// LPSPI2_SDO_SELECT_INPUT: LPSPI2_SDO_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPSPI2_SDO_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPSPI2_SDO_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPSPI2_SDO_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_SD_B1_08 for Mode: ALT4
	IOMUXC_LPSPI2_SDO_SELECT_INPUT_DAISY_GPIO_SD_B1_08_ALT4 = 0x0
	// Selecting Pad: GPIO_EMC_02 for Mode: ALT2
	IOMUXC_LPSPI2_SDO_SELECT_INPUT_DAISY_GPIO_EMC_02_ALT2 = 0x1

	// LPSPI3_PCS0_SELECT_INPUT: LPSPI3_PCS0_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPSPI3_PCS0_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPSPI3_PCS0_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPSPI3_PCS0_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_AD_B0_03 for Mode: ALT7
	IOMUXC_LPSPI3_PCS0_SELECT_INPUT_DAISY_GPIO_AD_B0_03_ALT7 = 0x0
	// Selecting Pad: GPIO_AD_B1_12 for Mode: ALT2
	IOMUXC_LPSPI3_PCS0_SELECT_INPUT_DAISY_GPIO_AD_B1_12_ALT2 = 0x1

	// LPSPI3_SCK_SELECT_INPUT: LPSPI3_SCK_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPSPI3_SCK_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPSPI3_SCK_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPSPI3_SCK_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_AD_B0_00 for Mode: ALT7
	IOMUXC_LPSPI3_SCK_SELECT_INPUT_DAISY_GPIO_AD_B0_00_ALT7 = 0x0
	// Selecting Pad: GPIO_AD_B1_15 for Mode: ALT2
	IOMUXC_LPSPI3_SCK_SELECT_INPUT_DAISY_GPIO_AD_B1_15 = 0x1

	// LPSPI3_SDI_SELECT_INPUT: LPSPI3_SDI_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPSPI3_SDI_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPSPI3_SDI_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPSPI3_SDI_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_AD_B0_02 for Mode: ALT7
	IOMUXC_LPSPI3_SDI_SELECT_INPUT_DAISY_GPIO_AD_B0_02_ALT7 = 0x0
	// Selecting Pad: GPIO_AD_B1_13 for Mode: ALT2
	IOMUXC_LPSPI3_SDI_SELECT_INPUT_DAISY_GPIO_AD_B1_13_ALT2 = 0x1

	// LPSPI3_SDO_SELECT_INPUT: LPSPI3_SDO_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPSPI3_SDO_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPSPI3_SDO_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPSPI3_SDO_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_AD_B0_01 for Mode: ALT7
	IOMUXC_LPSPI3_SDO_SELECT_INPUT_DAISY_GPIO_AD_B0_01_ALT7 = 0x0
	// Selecting Pad: GPIO_AD_B1_14 for Mode: ALT2
	IOMUXC_LPSPI3_SDO_SELECT_INPUT_DAISY_GPIO_AD_B1_14_ALT2 = 0x1

	// LPSPI4_PCS0_SELECT_INPUT: LPSPI4_PCS0_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPSPI4_PCS0_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPSPI4_PCS0_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPSPI4_PCS0_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_B0_00 for Mode: ALT3
	IOMUXC_LPSPI4_PCS0_SELECT_INPUT_DAISY_GPIO_B0_00_ALT3 = 0x0
	// Selecting Pad:GPIO_B1_04 for Mode: ALT1
	IOMUXC_LPSPI4_PCS0_SELECT_INPUT_DAISY_GPIO_B1_04_ALT1 = 0x1

	// LPSPI4_SCK_SELECT_INPUT: LPSPI4_SCK_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPSPI4_SCK_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPSPI4_SCK_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPSPI4_SCK_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_B0_03 for Mode: ALT3
	IOMUXC_LPSPI4_SCK_SELECT_INPUT_DAISY_GPIO_B0_03_ALT3 = 0x0
	// Selecting Pad: GPIO_B1_07 for Mode: ALT1
	IOMUXC_LPSPI4_SCK_SELECT_INPUT_DAISY_GPIO_B1_07_ALT1 = 0x1

	// LPSPI4_SDI_SELECT_INPUT: LPSPI4_SDI_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPSPI4_SDI_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPSPI4_SDI_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPSPI4_SDI_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_B0_01 for Mode: ALT3
	IOMUXC_LPSPI4_SDI_SELECT_INPUT_DAISY_GPIO_B0_01_ALT3 = 0x0
	// Selecting Pad: GPIO_B1_05 for Mode: ALT1
	IOMUXC_LPSPI4_SDI_SELECT_INPUT_DAISY_GPIO_B1_05_ALT1 = 0x1

	// LPSPI4_SDO_SELECT_INPUT: LPSPI4_SDO_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPSPI4_SDO_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPSPI4_SDO_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPSPI4_SDO_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_B0_02 for Mode: ALT3
	IOMUXC_LPSPI4_SDO_SELECT_INPUT_DAISY_GPIO_B0_02_ALT3 = 0x0
	// Selecting Pad: GPIO_B1_06 for Mode: ALT1
	IOMUXC_LPSPI4_SDO_SELECT_INPUT_DAISY_GPIO_B1_06_ALT1 = 0x1

	// LPUART2_RX_SELECT_INPUT: LPUART2_RX_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPUART2_RX_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPUART2_RX_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPUART2_RX_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_SD_B1_10 for Mode: ALT2
	IOMUXC_LPUART2_RX_SELECT_INPUT_DAISY_GPIO_SD_B1_10_ALT2 = 0x0
	// Selecting Pad: GPIO_AD_B1_03 for Mode: ALT2
	IOMUXC_LPUART2_RX_SELECT_INPUT_DAISY_GPIO_AD_B1_03_ALT2 = 0x1

	// LPUART2_TX_SELECT_INPUT: LPUART2_TX_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPUART2_TX_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPUART2_TX_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPUART2_TX_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_SD_B1_11 for Mode: ALT2
	IOMUXC_LPUART2_TX_SELECT_INPUT_DAISY_GPIO_SD_B1_11_ALT2 = 0x0
	// Selecting Pad: GPIO_AD_B1_02 for Mode: ALT2
	IOMUXC_LPUART2_TX_SELECT_INPUT_DAISY_GPIO_AD_B1_02_ALT2 = 0x1

	// LPUART3_CTS_B_SELECT_INPUT: LPUART3_CTS_B_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPUART3_CTS_B_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPUART3_CTS_B_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPUART3_CTS_B_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_15 for Mode: ALT2
	IOMUXC_LPUART3_CTS_B_SELECT_INPUT_DAISY_GPIO_EMC_15_ALT2 = 0x0
	// Selecting Pad: GPIO_AD_B1_04 for Mode: ALT2
	IOMUXC_LPUART3_CTS_B_SELECT_INPUT_DAISY_GPIO_AD_B1_04_ALT2 = 0x1

	// LPUART3_RX_SELECT_INPUT: LPUART3_RX_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPUART3_RX_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPUART3_RX_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_AD_B1_07 for Mode: ALT2
	IOMUXC_LPUART3_RX_SELECT_INPUT_DAISY_GPIO_AD_B1_07_ALT2 = 0x0
	// Selecting Pad: GPIO_EMC_14 for Mode: ALT2
	IOMUXC_LPUART3_RX_SELECT_INPUT_DAISY_GPIO_EMC_14_ALT2 = 0x1
	// Selecting Pad: GPIO_B0_09 for Mode: ALT3
	IOMUXC_LPUART3_RX_SELECT_INPUT_DAISY_GPIO_B0_09_ALT3 = 0x2

	// LPUART3_TX_SELECT_INPUT: LPUART3_TX_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPUART3_TX_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPUART3_TX_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_AD_B1_06 for Mode: ALT2
	IOMUXC_LPUART3_TX_SELECT_INPUT_DAISY_GPIO_AD_B1_06_ALT2 = 0x0
	// Selecting Pad: GPIO_EMC_13 for Mode: ALT2
	IOMUXC_LPUART3_TX_SELECT_INPUT_DAISY_GPIO_EMC_13_ALT2 = 0x1
	// Selecting Pad: GPIO_B0_08 for Mode: ALT3
	IOMUXC_LPUART3_TX_SELECT_INPUT_DAISY_GPIO_B0_08_ALT3 = 0x2

	// LPUART4_RX_SELECT_INPUT: LPUART4_RX_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPUART4_RX_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPUART4_RX_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_SD_B1_01 for Mode: ALT4
	IOMUXC_LPUART4_RX_SELECT_INPUT_DAISY_GPIO_SD_B1_01_ALT4 = 0x0
	// Selecting Pad: GPIO_EMC_20 for Mode: ALT2
	IOMUXC_LPUART4_RX_SELECT_INPUT_DAISY_GPIO_EMC_20_ALT2 = 0x1
	// Selecting Pad: GPIO_B1_01 for Mode: ALT2
	IOMUXC_LPUART4_RX_SELECT_INPUT_DAISY_GPIO_B1_01_ALT2 = 0x2

	// LPUART4_TX_SELECT_INPUT: LPUART4_TX_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPUART4_TX_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPUART4_TX_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_SD_B1_00 for Mode: ALT4
	IOMUXC_LPUART4_TX_SELECT_INPUT_DAISY_GPIO_SD_B1_00_ALT4 = 0x0
	// Selecting Pad: GPIO_EMC_19 for Mode: ALT2
	IOMUXC_LPUART4_TX_SELECT_INPUT_DAISY_GPIO_EMC_19_ALT2 = 0x1
	// Selecting Pad: GPIO_B1_00 for Mode: ALT2
	IOMUXC_LPUART4_TX_SELECT_INPUT_DAISY_GPIO_B1_00_ALT2 = 0x2

	// LPUART5_RX_SELECT_INPUT: LPUART5_RX_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPUART5_RX_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPUART5_RX_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPUART5_RX_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_24 for Mode: ALT2
	IOMUXC_LPUART5_RX_SELECT_INPUT_DAISY_GPIO_EMC_24_ALT2 = 0x0
	// Selecting Pad: GPIO_B1_13 for Mode: ALT1
	IOMUXC_LPUART5_RX_SELECT_INPUT_DAISY_GPIO_B1_13_ALT1 = 0x1

	// LPUART5_TX_SELECT_INPUT: LPUART5_TX_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPUART5_TX_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPUART5_TX_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPUART5_TX_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_23 for Mode: ALT2
	IOMUXC_LPUART5_TX_SELECT_INPUT_DAISY_GPIO_EMC_23_ALT2 = 0x0
	// Selecting Pad: GPIO_B1_12 for Mode: ALT1
	IOMUXC_LPUART5_TX_SELECT_INPUT_DAISY_GPIO_B1_12_ALT1 = 0x1

	// LPUART6_RX_SELECT_INPUT: LPUART6_RX_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPUART6_RX_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPUART6_RX_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPUART6_RX_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_26 for Mode: ALT2
	IOMUXC_LPUART6_RX_SELECT_INPUT_DAISY_GPIO_EMC_26_ALT2 = 0x0
	// Selecting Pad: GPIO_AD_B0_03 for Mode: ALT2
	IOMUXC_LPUART6_RX_SELECT_INPUT_DAISY_GPIO_AD_B0_03_ALT2 = 0x1

	// LPUART6_TX_SELECT_INPUT: LPUART6_TX_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPUART6_TX_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPUART6_TX_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPUART6_TX_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_25 for Mode: ALT2
	IOMUXC_LPUART6_TX_SELECT_INPUT_DAISY_GPIO_EMC_25_ALT2 = 0x0
	// Selecting Pad: GPIO_AD_B0_02 for Mode: ALT2
	IOMUXC_LPUART6_TX_SELECT_INPUT_DAISY_GPIO_AD_B0_02_ALT2 = 0x1

	// LPUART7_RX_SELECT_INPUT: LPUART7_RX_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPUART7_RX_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPUART7_RX_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPUART7_RX_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_SD_B1_09 for Mode: ALT2
	IOMUXC_LPUART7_RX_SELECT_INPUT_DAISY_GPIO_SD_B1_09_ALT2 = 0x0
	// Selecting Pad: GPIO_EMC_32 for Mode: ALT2
	IOMUXC_LPUART7_RX_SELECT_INPUT_DAISY_GPIO_EMC_32_ALT2 = 0x1

	// LPUART7_TX_SELECT_INPUT: LPUART7_TX_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPUART7_TX_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPUART7_TX_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPUART7_TX_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_SD_B1_08 for Mode: ALT2
	IOMUXC_LPUART7_TX_SELECT_INPUT_DAISY_GPIO_SD_B1_08_ALT2 = 0x0
	// Selecting Pad:GPIO_EMC_31 for Mode: ALT2
	IOMUXC_LPUART7_TX_SELECT_INPUT_DAISY_GPIO_EMC_31_ALT2 = 0x1

	// LPUART8_RX_SELECT_INPUT: LPUART8_RX_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPUART8_RX_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPUART8_RX_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_SD_B0_05 for Mode: ALT2
	IOMUXC_LPUART8_RX_SELECT_INPUT_DAISY_GPIO_SD_B0_05_ALT2 = 0x0
	// Selecting Pad: GPIO_AD_B1_11 for Mode: ALT2
	IOMUXC_LPUART8_RX_SELECT_INPUT_DAISY_GPIO_AD_B1_11_ALT2 = 0x1
	// Selecting Pad: GPIO_EMC_39 for Mode: ALT2
	IOMUXC_LPUART8_RX_SELECT_INPUT_DAISY_GPIO_EMC_39_ALT2 = 0x2

	// LPUART8_TX_SELECT_INPUT: LPUART8_TX_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPUART8_TX_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPUART8_TX_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_SD_B0_04 for Mode: ALT2
	IOMUXC_LPUART8_TX_SELECT_INPUT_DAISY_GPIO_SD_B0_04_ALT2 = 0x0
	// Selecting Pad: GPIO_AD_B1_10 for Mode: ALT2
	IOMUXC_LPUART8_TX_SELECT_INPUT_DAISY_GPIO_AD_B1_10_ALT2 = 0x1
	// Selecting Pad: GPIO_EMC_38 for Mode: ALT2
	IOMUXC_LPUART8_TX_SELECT_INPUT_DAISY_GPIO_EMC_38_ALT2 = 0x2

	// NMI_SELECT_INPUT: NMI_GLUE_NMI_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_NMI_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_NMI_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_NMI_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_AD_B0_12 for Mode: ALT7
	IOMUXC_NMI_SELECT_INPUT_DAISY_GPIO_AD_B0_12_ALT7 = 0x0
	// Selecting Pad: WAKEUP for Mode: ALT7
	IOMUXC_NMI_SELECT_INPUT_DAISY_WAKEUP_ALT7 = 0x1

	// QTIMER2_TIMER0_SELECT_INPUT: QTIMER2_TIMER0_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_QTIMER2_TIMER0_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_QTIMER2_TIMER0_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_QTIMER2_TIMER0_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_19 for Mode: ALT4
	IOMUXC_QTIMER2_TIMER0_SELECT_INPUT_DAISY_GPIO_EMC_19_ALT4 = 0x0
	// Selecting Pad: GPIO_B0_03 for Mode: ALT1
	IOMUXC_QTIMER2_TIMER0_SELECT_INPUT_DAISY_GPIO_B0_03_ALT1 = 0x1

	// QTIMER2_TIMER1_SELECT_INPUT: QTIMER2_TIMER1_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_QTIMER2_TIMER1_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_QTIMER2_TIMER1_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_QTIMER2_TIMER1_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_20 for Mode: ALT4
	IOMUXC_QTIMER2_TIMER1_SELECT_INPUT_DAISY_GPIO_EMC_20_ALT4 = 0x0
	// Selecting Pad: GPIO_B0_04 for Mode: ALT1
	IOMUXC_QTIMER2_TIMER1_SELECT_INPUT_DAISY_GPIO_B0_04_ALT1 = 0x1

	// QTIMER2_TIMER2_SELECT_INPUT: QTIMER2_TIMER2_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_QTIMER2_TIMER2_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_QTIMER2_TIMER2_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_QTIMER2_TIMER2_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_21 for Mode: ALT4
	IOMUXC_QTIMER2_TIMER2_SELECT_INPUT_DAISY_GPIO_EMC_21_ALT4 = 0x0
	// Selecting Pad: GPIO_B0_05 for Mode: ALT1
	IOMUXC_QTIMER2_TIMER2_SELECT_INPUT_DAISY_GPIO_B0_05_ALT1 = 0x1

	// QTIMER2_TIMER3_SELECT_INPUT: QTIMER2_TIMER3_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_QTIMER2_TIMER3_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_QTIMER2_TIMER3_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_QTIMER2_TIMER3_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_22 for Mode: ALT4
	IOMUXC_QTIMER2_TIMER3_SELECT_INPUT_DAISY_GPIO_EMC_22_ALT4 = 0x0
	// Selecting Pad: GPIO_B1_09 for Mode: ALT1
	IOMUXC_QTIMER2_TIMER3_SELECT_INPUT_DAISY_GPIO_B1_09_ALT1 = 0x1

	// QTIMER3_TIMER0_SELECT_INPUT: QTIMER3_TIMER0_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_QTIMER3_TIMER0_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_QTIMER3_TIMER0_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_EMC_15 for Mode: ALT4
	IOMUXC_QTIMER3_TIMER0_SELECT_INPUT_DAISY_GPIO_EMC_15_ALT4 = 0x0
	// Selecting Pad: GPIO_AD_B1_00 for Mode: ALT1
	IOMUXC_QTIMER3_TIMER0_SELECT_INPUT_DAISY_GPIO_AD_B1_00_ALT1 = 0x1
	// Selecting Pad: GPIO_B0_06 for Mode: ALT1
	IOMUXC_QTIMER3_TIMER0_SELECT_INPUT_DAISY_GPIO_B0_06_ALT1 = 0x2

	// QTIMER3_TIMER1_SELECT_INPUT: QTIMER3_TIMER1_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_QTIMER3_TIMER1_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_QTIMER3_TIMER1_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_AD_B1_01 for Mode: ALT1
	IOMUXC_QTIMER3_TIMER1_SELECT_INPUT_DAISY_GPIO_AD_B1_01_ALT1 = 0x0
	// Selecting Pad: GPIO_EMC_16 for Mode: ALT4
	IOMUXC_QTIMER3_TIMER1_SELECT_INPUT_DAISY_GPIO_EMC_16_ALT4 = 0x1
	// Selecting Pad: GPIO_B0_07 for Mode: ALT1
	IOMUXC_QTIMER3_TIMER1_SELECT_INPUT_DAISY_GPIO_B0_07_ALT1 = 0x2

	// QTIMER3_TIMER2_SELECT_INPUT: QTIMER3_TIMER2_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_QTIMER3_TIMER2_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_QTIMER3_TIMER2_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_EMC_17 for Mode: ALT4
	IOMUXC_QTIMER3_TIMER2_SELECT_INPUT_DAISY_GPIO_EMC_17_ALT4 = 0x0
	// Selecting Pad: GPIO_AD_B1_02 for Mode: ALT1
	IOMUXC_QTIMER3_TIMER2_SELECT_INPUT_DAISY_GPIO_AD_B1_02_ALT1 = 0x1
	// Selecting Pad: GPIO_B0_08 for Mode: ALT1
	IOMUXC_QTIMER3_TIMER2_SELECT_INPUT_DAISY_GPIO_B0_08_ALT1 = 0x2

	// QTIMER3_TIMER3_SELECT_INPUT: QTIMER3_TIMER3_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_QTIMER3_TIMER3_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_QTIMER3_TIMER3_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_EMC_18 for Mode: ALT4
	IOMUXC_QTIMER3_TIMER3_SELECT_INPUT_DAISY_GPIO_EMC_18_ALT4 = 0x0
	// Selecting Pad: GPIO_AD_B1_03 for Mode: ALT1
	IOMUXC_QTIMER3_TIMER3_SELECT_INPUT_DAISY_GPIO_AD_B1_03_ALT1 = 0x1
	// Selecting Pad: GPIO_B1_10 for Mode: ALT1
	IOMUXC_QTIMER3_TIMER3_SELECT_INPUT_DAISY_GPIO_B1_10_ALT1 = 0x2

	// SAI1_MCLK2_SELECT_INPUT: SAI1_MCLK2_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_SAI1_MCLK2_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_SAI1_MCLK2_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_SD_B1_03 for Mode: ALT3
	IOMUXC_SAI1_MCLK2_SELECT_INPUT_DAISY_GPIO_SD_B1_03_ALT3 = 0x0
	// Selecting Pad: GPIO_AD_B1_09 for Mode: ALT3
	IOMUXC_SAI1_MCLK2_SELECT_INPUT_DAISY_GPIO_AD_B1_09_ALT3 = 0x1
	// Selecting Pad: GPIO_B0_13 for Mode: ALT3
	IOMUXC_SAI1_MCLK2_SELECT_INPUT_DAISY_GPIO_B0_13_ALT3 = 0x2

	// SAI1_RX_BCLK_SELECT_INPUT: SAI1_RX_BCLK_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_SAI1_RX_BCLK_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_SAI1_RX_BCLK_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_SD_B1_05 for Mode: ALT3
	IOMUXC_SAI1_RX_BCLK_SELECT_INPUT_DAISY_GPIO_SD_B1_05_ALT3 = 0x0
	// Selecting Pad: GPIO_AD_B1_11 for Mode: ALT3
	IOMUXC_SAI1_RX_BCLK_SELECT_INPUT_DAISY_GPIO_AD_B1_11_ALT3 = 0x1
	// Selecting Pad: GPIO_B0_15 for Mode: ALT3
	IOMUXC_SAI1_RX_BCLK_SELECT_INPUT_DAISY_GPIO_B0_15_ALT3 = 0x2

	// SAI1_RX_DATA0_SELECT_INPUT: SAI1_RX_DATA0_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_SAI1_RX_DATA0_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_SAI1_RX_DATA0_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_SD_B1_06 for Mode: ALT3
	IOMUXC_SAI1_RX_DATA0_SELECT_INPUT_DAISY_GPIO_SD_B1_06_ALT3 = 0x0
	// Selecting Pad: GPIO_AD_B1_12 for Mode: ALT3
	IOMUXC_SAI1_RX_DATA0_SELECT_INPUT_DAISY_GPIO_AD_B1_12_ALT3 = 0x1
	// Selecting Pad: GPIO_B1_00 for Mode: ALT3
	IOMUXC_SAI1_RX_DATA0_SELECT_INPUT_DAISY_GPIO_B1_00_ALT3 = 0x2

	// SAI1_RX_DATA1_SELECT_INPUT: SAI1_RX_DATA1_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_SAI1_RX_DATA1_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_SAI1_RX_DATA1_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_SAI1_RX_DATA1_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_SD_B1_00 for Mode: ALT3
	IOMUXC_SAI1_RX_DATA1_SELECT_INPUT_DAISY_GPIO_SD_B1_00_ALT3 = 0x0
	// Selecting Pad: GPIO_B0_10 for Mode: ALT3
	IOMUXC_SAI1_RX_DATA1_SELECT_INPUT_DAISY_GPIO_B0_10_ALT3 = 0x1

	// SAI1_RX_DATA2_SELECT_INPUT: SAI1_RX_DATA2_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_SAI1_RX_DATA2_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_SAI1_RX_DATA2_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_SAI1_RX_DATA2_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_SD_B1_01 for Mode: ALT3
	IOMUXC_SAI1_RX_DATA2_SELECT_INPUT_DAISY_GPIO_SD_B1_01_ALT3 = 0x0
	// Selecting Pad: GPIO_B0_11 for Mode: ALT3
	IOMUXC_SAI1_RX_DATA2_SELECT_INPUT_DAISY_GPIO_B0_11_ALT3 = 0x1

	// SAI1_RX_DATA3_SELECT_INPUT: SAI1_RX_DATA3_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_SAI1_RX_DATA3_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_SAI1_RX_DATA3_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_SAI1_RX_DATA3_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_SD_B1_02 for Mode: ALT3
	IOMUXC_SAI1_RX_DATA3_SELECT_INPUT_DAISY_GPIO_SD_B1_02_ALT3 = 0x0
	// Selecting Pad: GPIO_B0_12 for Mode: ALT3
	IOMUXC_SAI1_RX_DATA3_SELECT_INPUT_DAISY_GPIO_B0_12_ALT3 = 0x1

	// SAI1_RX_SYNC_SELECT_INPUT: SAI1_RX_SYNC_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_SAI1_RX_SYNC_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_SAI1_RX_SYNC_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_SD_B1_04 for Mode: ALT3
	IOMUXC_SAI1_RX_SYNC_SELECT_INPUT_DAISY_GPIO_SD_B1_04_ALT3 = 0x0
	// Selecting Pad: GPIO_AD_B1_10 for Mode: ALT3
	IOMUXC_SAI1_RX_SYNC_SELECT_INPUT_DAISY_GPIO_AD_B1_10_ALT3 = 0x1
	// Selecting Pad: GPIO_B0_14 for Mode: ALT3
	IOMUXC_SAI1_RX_SYNC_SELECT_INPUT_DAISY_GPIO_B0_14_ALT3 = 0x2

	// SAI1_TX_BCLK_SELECT_INPUT: SAI1_TX_BCLK_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_SAI1_TX_BCLK_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_SAI1_TX_BCLK_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_SD_B1_08 for Mode: ALT3
	IOMUXC_SAI1_TX_BCLK_SELECT_INPUT_DAISY_GPIO_SD_B1_08_ALT3 = 0x0
	// Selecting Pad: GPIO_AD_B1_14 for Mode: ALT3
	IOMUXC_SAI1_TX_BCLK_SELECT_INPUT_DAISY_GPIO_AD_B1_14_ALT3 = 0x1
	// Selecting Pad: GPIO_B1_02 for Mode: ALT3
	IOMUXC_SAI1_TX_BCLK_SELECT_INPUT_DAISY_GPIO_B1_02_ALT3 = 0x2

	// SAI1_TX_SYNC_SELECT_INPUT: SAI1_TX_SYNC_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_SAI1_TX_SYNC_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_SAI1_TX_SYNC_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_SD_B1_09 for Mode: ALT3
	IOMUXC_SAI1_TX_SYNC_SELECT_INPUT_DAISY_GPIO_SD_B1_09_ALT3 = 0x0
	// Selecting Pad: GPIO_AD_B1_15 for Mode: ALT3
	IOMUXC_SAI1_TX_SYNC_SELECT_INPUT_DAISY_GPIO_AD_B1_15_ALT3 = 0x1
	// Selecting Pad: GPIO_B1_03 for Mode: ALT3
	IOMUXC_SAI1_TX_SYNC_SELECT_INPUT_DAISY_GPIO_B1_03_ALT3 = 0x2

	// SAI2_MCLK2_SELECT_INPUT: SAI2_MCLK2_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_SAI2_MCLK2_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_SAI2_MCLK2_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_SAI2_MCLK2_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_07 for Mode: ALT2
	IOMUXC_SAI2_MCLK2_SELECT_INPUT_DAISY_GPIO_EMC_07_ALT2 = 0x0
	// Selecting Pad: GPIO_AD_B0_10 for Mode: ALT3
	IOMUXC_SAI2_MCLK2_SELECT_INPUT_DAISY_GPIO_AD_B0_10_ALT3 = 0x1

	// SAI2_RX_BCLK_SELECT_INPUT: SAI2_RX_BCLK_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_SAI2_RX_BCLK_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_SAI2_RX_BCLK_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_SAI2_RX_BCLK_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_10 for Mode: ALT2
	IOMUXC_SAI2_RX_BCLK_SELECT_INPUT_DAISY_GPIO_EMC_10_ALT2 = 0x0
	// Selecting Pad: GPIO_AD_B0_06 for Mode: ALT3
	IOMUXC_SAI2_RX_BCLK_SELECT_INPUT_DAISY_GPIO_AD_B0_06_ALT3 = 0x1

	// SAI2_RX_DATA0_SELECT_INPUT: SAI2_RX_DATA0_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_SAI2_RX_DATA0_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_SAI2_RX_DATA0_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_SAI2_RX_DATA0_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_08 for Mode: ALT2
	IOMUXC_SAI2_RX_DATA0_SELECT_INPUT_DAISY_GPIO_EMC_08_ALT2 = 0x0
	// Selecting Pad: GPIO_AD_B0_08 for Mode: ALT3
	IOMUXC_SAI2_RX_DATA0_SELECT_INPUT_DAISY_GPIO_AD_B0_08_ALT3 = 0x1

	// SAI2_RX_SYNC_SELECT_INPUT: SAI2_RX_SYNC_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_SAI2_RX_SYNC_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_SAI2_RX_SYNC_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_SAI2_RX_SYNC_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_09 for Mode: ALT2
	IOMUXC_SAI2_RX_SYNC_SELECT_INPUT_DAISY_GPIO_EMC_09_ALT2 = 0x0
	// Selecting Pad: GPIO_AD_B0_07 for Mode: ALT3
	IOMUXC_SAI2_RX_SYNC_SELECT_INPUT_DAISY_GPIO_AD_B0_07_ALT3 = 0x1

	// SAI2_TX_BCLK_SELECT_INPUT: SAI2_TX_BCLK_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_SAI2_TX_BCLK_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_SAI2_TX_BCLK_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_SAI2_TX_BCLK_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_06 for Mode: ALT2
	IOMUXC_SAI2_TX_BCLK_SELECT_INPUT_DAISY_GPIO_EMC_06_ALT2 = 0x0
	// Selecting Pad: GPIO_AD_B0_05 for Mode: ALT3
	IOMUXC_SAI2_TX_BCLK_SELECT_INPUT_DAISY_GPIO_AD_B0_05_ALT3 = 0x1

	// SAI2_TX_SYNC_SELECT_INPUT: SAI2_TX_SYNC_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_SAI2_TX_SYNC_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_SAI2_TX_SYNC_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_SAI2_TX_SYNC_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_05 for Mode: ALT2
	IOMUXC_SAI2_TX_SYNC_SELECT_INPUT_DAISY_GPIO_EMC_05_ALT2 = 0x0
	// Selecting Pad: GPIO_AD_B0_04 for Mode: ALT3
	IOMUXC_SAI2_TX_SYNC_SELECT_INPUT_DAISY_GPIO_AD_B0_04_ALT3 = 0x1

	// SPDIF_IN_SELECT_INPUT: SPDIF_IN_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_SPDIF_IN_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_SPDIF_IN_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_SPDIF_IN_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_AD_B1_03 for Mode: ALT3
	IOMUXC_SPDIF_IN_SELECT_INPUT_DAISY_GPIO_AD_B1_03_ALT3 = 0x0
	// Selecting Pad: GPIO_EMC_16 for Mode: ALT3
	IOMUXC_SPDIF_IN_SELECT_INPUT_DAISY_GPIO_EMC_16_ALT3 = 0x1

	// USB_OTG2_OC_SELECT_INPUT: USB_OTG2_OC_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_USB_OTG2_OC_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_USB_OTG2_OC_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_USB_OTG2_OC_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_AD_B0_14 for Mode: ALT0
	IOMUXC_USB_OTG2_OC_SELECT_INPUT_DAISY_GPIO_AD_B0_14_ALT0 = 0x0
	// Selecting Pad: GPIO_EMC_40 for Mode: ALT3
	IOMUXC_USB_OTG2_OC_SELECT_INPUT_DAISY_GPIO_EMC_40_ALT3 = 0x1

	// USB_OTG1_OC_SELECT_INPUT: USB_OTG1_OC_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_USB_OTG1_OC_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_USB_OTG1_OC_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_USB_OTG1_OC_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_AD_B0_03 for Mode: ALT3
	IOMUXC_USB_OTG1_OC_SELECT_INPUT_DAISY_GPIO_AD_B0_03_ALT3 = 0x0
	// Selecting Pad: GPIO_AD_B1_03 for Mode: ALT0
	IOMUXC_USB_OTG1_OC_SELECT_INPUT_DAISY_GPIO_AD_B1_03_ALT0 = 0x1

	// USDHC1_CD_B_SELECT_INPUT: USDHC1_CD_B_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_USDHC1_CD_B_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_USDHC1_CD_B_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_EMC_35 for Mode: ALT6
	IOMUXC_USDHC1_CD_B_SELECT_INPUT_DAISY_GPIO_EMC_35_ALT6 = 0x0
	// Selecting Pad: GPIO_AD_B1_02 for Mode: ALT6
	IOMUXC_USDHC1_CD_B_SELECT_INPUT_DAISY_GPIO_AD_B1_02_ALT6 = 0x1
	// Selecting Pad: GPIO_B1_12 for Mode: ALT6
	IOMUXC_USDHC1_CD_B_SELECT_INPUT_DAISY_GPIO_B1_12_ALT6 = 0x2

	// USDHC1_WP_SELECT_INPUT: USDHC1_WP_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_USDHC1_WP_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_USDHC1_WP_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_EMC_12 for Mode: ALT3
	IOMUXC_USDHC1_WP_SELECT_INPUT_DAISY_GPIO_EMC_12_ALT3 = 0x0
	// Selecting Pad: GPIO_EMC_36for Mode: ALT6
	IOMUXC_USDHC1_WP_SELECT_INPUT_DAISY_GPIO_EMC_36_ALT6 = 0x1
	// Selecting Pad:GPIO_AD_B1_00 for Mode: ALT6
	IOMUXC_USDHC1_WP_SELECT_INPUT_DAISY_GPIO_AD_B1_00_ALT6 = 0x2
	// Selecting Pad: GPIO_B1_13 for Mode: ALT6
	IOMUXC_USDHC1_WP_SELECT_INPUT_DAISY_GPIO_B1_13_ALT6 = 0x3

	// USDHC2_CLK_SELECT_INPUT: USDHC2_CLK_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_USDHC2_CLK_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_USDHC2_CLK_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_USDHC2_CLK_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_SD_B1_04 for Mode: ALT0
	IOMUXC_USDHC2_CLK_SELECT_INPUT_DAISY_GPIO_SD_B1_04_ALT0 = 0x0
	// Selecting Pad: GPIO_AD_B1_09 for Mode: ALT6
	IOMUXC_USDHC2_CLK_SELECT_INPUT_DAISY_GPIO_AD_B1_09_ALT6 = 0x1

	// USDHC2_CD_B_SELECT_INPUT: USDHC2_CD_B_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_USDHC2_CD_B_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_USDHC2_CD_B_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_USDHC2_CD_B_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad:GPIO_AD_B1_03 for Mode: ALT6
	IOMUXC_USDHC2_CD_B_SELECT_INPUT_DAISY_GPIO_AD_B1_03_ALT6 = 0x0
	// Selecting Pad: GPIO_EMC_39 for Mode: ALT6
	IOMUXC_USDHC2_CD_B_SELECT_INPUT_DAISY_GPIO_EMC_39_ALT6 = 0x1

	// USDHC2_CMD_SELECT_INPUT: USDHC2_CMD_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_USDHC2_CMD_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_USDHC2_CMD_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_USDHC2_CMD_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_SD_B1_05 for Mode: ALT0
	IOMUXC_USDHC2_CMD_SELECT_INPUT_DAISY_GPIO_SD_B1_05_ALT0 = 0x0
	// Selecting Pad: GPIO_AD_B1_08 for Mode: ALT6
	IOMUXC_USDHC2_CMD_SELECT_INPUT_DAISY_GPIO_AD_B1_08_ALT6 = 0x1

	// USDHC2_DATA0_SELECT_INPUT: USDHC2_DATA0_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_USDHC2_DATA0_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_USDHC2_DATA0_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_USDHC2_DATA0_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_SD_B1_03 for Mode: ALT0
	IOMUXC_USDHC2_DATA0_SELECT_INPUT_DAISY_GPIO_SD_B1_03_ALT0 = 0x0
	// Selecting Pad:GPIO_AD_B1_04 for Mode: ALT6
	IOMUXC_USDHC2_DATA0_SELECT_INPUT_DAISY_GPIO_AD_B1_04_ALT6 = 0x1

	// USDHC2_DATA1_SELECT_INPUT: USDHC2_DATA1_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_USDHC2_DATA1_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_USDHC2_DATA1_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_USDHC2_DATA1_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_SD_B1_02 for Mode: ALT0
	IOMUXC_USDHC2_DATA1_SELECT_INPUT_DAISY_GPIO_SD_B1_02_ALT0 = 0x0
	// Selecting Pad: GPIO_AD_B1_05 for Mode: ALT6
	IOMUXC_USDHC2_DATA1_SELECT_INPUT_DAISY_GPIO_AD_B1_05_ALT6 = 0x1

	// USDHC2_DATA2_SELECT_INPUT: USDHC2_DATA2_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_USDHC2_DATA2_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_USDHC2_DATA2_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_USDHC2_DATA2_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_SD_B1_01 for Mode: ALT0
	IOMUXC_USDHC2_DATA2_SELECT_INPUT_DAISY_GPIO_SD_B1_01_ALT0 = 0x0
	// Selecting Pad: GPIO_AD_B1_06 for Mode: ALT6
	IOMUXC_USDHC2_DATA2_SELECT_INPUT_DAISY_GPIO_AD_B1_06_ALT6 = 0x1

	// USDHC2_DATA3_SELECT_INPUT: USDHC2_DATA3_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_USDHC2_DATA3_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_USDHC2_DATA3_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_USDHC2_DATA3_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_SD_B1_00 for Mode: ALT0
	IOMUXC_USDHC2_DATA3_SELECT_INPUT_DAISY_GPIO_SD_B1_00_ALT0 = 0x0
	// Selecting Pad: GPIO_AD_B1_07 for Mode: ALT6
	IOMUXC_USDHC2_DATA3_SELECT_INPUT_DAISY_GPIO_AD_B1_07_ALT6 = 0x1

	// USDHC2_DATA4_SELECT_INPUT: USDHC2_DATA4_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_USDHC2_DATA4_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_USDHC2_DATA4_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_USDHC2_DATA4_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_SD_B1_08 for Mode: ALT0
	IOMUXC_USDHC2_DATA4_SELECT_INPUT_DAISY_GPIO_SD_B1_08_ALT0 = 0x0
	// Selecting Pad: GPIO_AD_B1_12 for Mode: ALT6
	IOMUXC_USDHC2_DATA4_SELECT_INPUT_DAISY_GPIO_AD_B1_12_ALT6 = 0x1

	// USDHC2_DATA5_SELECT_INPUT: USDHC2_DATA5_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_USDHC2_DATA5_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_USDHC2_DATA5_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_USDHC2_DATA5_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_SD_B1_09 for Mode: ALT0
	IOMUXC_USDHC2_DATA5_SELECT_INPUT_DAISY_GPIO_SD_B1_09_ALT0 = 0x0
	// Selecting Pad: GPIO_AD_B1_13 for Mode: ALT6
	IOMUXC_USDHC2_DATA5_SELECT_INPUT_DAISY_GPIO_AD_B1_13_ALT6 = 0x1

	// USDHC2_DATA6_SELECT_INPUT: USDHC2_DATA6_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_USDHC2_DATA6_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_USDHC2_DATA6_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_USDHC2_DATA6_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_SD_B1_10 for Mode: ALT0
	IOMUXC_USDHC2_DATA6_SELECT_INPUT_DAISY_GPIO_SD_B1_10_ALT0 = 0x0
	// Selecting Pad: GPIO_AD_B1_14 for Mode: ALT6
	IOMUXC_USDHC2_DATA6_SELECT_INPUT_DAISY_GPIO_AD_B1_14_ALT6 = 0x1

	// USDHC2_DATA7_SELECT_INPUT: USDHC2_DATA7_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_USDHC2_DATA7_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_USDHC2_DATA7_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_USDHC2_DATA7_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_SD_B1_11 for Mode: ALT0
	IOMUXC_USDHC2_DATA7_SELECT_INPUT_DAISY_GPIO_SD_B1_11_ALT0 = 0x0
	// Selecting Pad: GPIO_AD_B1_15 for Mode: ALT6
	IOMUXC_USDHC2_DATA7_SELECT_INPUT_DAISY_GPIO_AD_B1_15_ALT6 = 0x1

	// USDHC2_WP_SELECT_INPUT: USDHC2_WP_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_USDHC2_WP_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_USDHC2_WP_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_USDHC2_WP_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_37 for Mode: ALT6
	IOMUXC_USDHC2_WP_SELECT_INPUT_DAISY_GPIO_EMC_37_ALT6 = 0x0
	// Selecting Pad: GPIO_AD_B1_10 for Mode: ALT6
	IOMUXC_USDHC2_WP_SELECT_INPUT_DAISY_GPIO_AD_B1_10_ALT6 = 0x1

	// XBAR1_IN02_SELECT_INPUT: XBAR1_IN02_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_XBAR1_IN02_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_XBAR1_IN02_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_XBAR1_IN02_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_00 for Mode: ALT3
	IOMUXC_XBAR1_IN02_SELECT_INPUT_DAISY_GPIO_EMC_00_ALT3 = 0x0
	// Selecting Pad: GPIO_B1_14 for Mode: ALT3
	IOMUXC_XBAR1_IN02_SELECT_INPUT_DAISY_GPIO_B1_14_ALT3 = 0x1

	// XBAR1_IN03_SELECT_INPUT: XBAR1_IN03_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_XBAR1_IN03_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_XBAR1_IN03_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_XBAR1_IN03_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_01 for Mode: ALT3
	IOMUXC_XBAR1_IN03_SELECT_INPUT_DAISY_GPIO_EMC_01_ALT3 = 0x0
	// Selecting Pad: GPIO_B1_15 for Mode: ALT3
	IOMUXC_XBAR1_IN03_SELECT_INPUT_DAISY_GPIO_B1_15_ALT3 = 0x1

	// XBAR1_IN04_SELECT_INPUT: XBAR1_IN04_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_XBAR1_IN04_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_XBAR1_IN04_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_XBAR1_IN04_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_02 for Mode: ALT3
	IOMUXC_XBAR1_IN04_SELECT_INPUT_DAISY_GPIO_EMC_02_ALT3 = 0x0
	// Selecting Pad: GPIO_SD_B0_00 for Mode: ALT3
	IOMUXC_XBAR1_IN04_SELECT_INPUT_DAISY_GPIO_SD_B0_00_ALT3 = 0x1

	// XBAR1_IN05_SELECT_INPUT: XBAR1_IN05_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_XBAR1_IN05_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_XBAR1_IN05_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_XBAR1_IN05_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_03 for Mode: ALT3
	IOMUXC_XBAR1_IN05_SELECT_INPUT_DAISY_GPIO_EMC_03_ALT3 = 0x0
	// Selecting Pad: GPIO_SD_B0_01 for Mode: ALT3
	IOMUXC_XBAR1_IN05_SELECT_INPUT_DAISY_GPIO_SD_B0_01_ALT3 = 0x1

	// XBAR1_IN06_SELECT_INPUT: XBAR1_IN06_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_XBAR1_IN06_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_XBAR1_IN06_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_XBAR1_IN06_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_04 for Mode: ALT3
	IOMUXC_XBAR1_IN06_SELECT_INPUT_DAISY_GPIO_EMC_04_ALT3 = 0x0
	// Selecting Pad: GPIO_SD_B0_02 for Mode: ALT3
	IOMUXC_XBAR1_IN06_SELECT_INPUT_DAISY_GPIO_SD_B0_02_ALT3 = 0x1

	// XBAR1_IN07_SELECT_INPUT: XBAR1_IN07_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_XBAR1_IN07_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_XBAR1_IN07_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_XBAR1_IN07_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_05 for Mode: ALT3
	IOMUXC_XBAR1_IN07_SELECT_INPUT_DAISY_GPIO_EMC_05_ALT3 = 0x0
	// Selecting Pad: GPIO_SD_B0_03 for Mode: ALT3
	IOMUXC_XBAR1_IN07_SELECT_INPUT_DAISY_GPIO_SD_B0_03_ALT3 = 0x1

	// XBAR1_IN08_SELECT_INPUT: XBAR1_IN08_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_XBAR1_IN08_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_XBAR1_IN08_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_XBAR1_IN08_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_06 for Mode: ALT3
	IOMUXC_XBAR1_IN08_SELECT_INPUT_DAISY_GPIO_EMC_06_ALT3 = 0x0
	// Selecting Pad: GPIO_SD_B0_04 for Mode: ALT3
	IOMUXC_XBAR1_IN08_SELECT_INPUT_DAISY_GPIO_SD_B0_04_ALT3 = 0x1

	// XBAR1_IN09_SELECT_INPUT: XBAR1_IN09_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_XBAR1_IN09_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_XBAR1_IN09_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_XBAR1_IN09_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_07 for Mode: ALT3
	IOMUXC_XBAR1_IN09_SELECT_INPUT_DAISY_GPIO_EMC_07_ALT3 = 0x0
	// Selecting Pad: GPIO_SD_B0_05 for Mode: ALT3
	IOMUXC_XBAR1_IN09_SELECT_INPUT_DAISY_GPIO_SD_B0_05_ALT3 = 0x1

	// XBAR1_IN17_SELECT_INPUT: XBAR1_IN17_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_XBAR1_IN17_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_XBAR1_IN17_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_EMC_08 for Mode: ALT3
	IOMUXC_XBAR1_IN17_SELECT_INPUT_DAISY_GPIO_EMC_08_ALT3 = 0x0
	// Selecting Pad: GPIO_AD_B0_03 for Mode: ALT1
	IOMUXC_XBAR1_IN17_SELECT_INPUT_DAISY_GPIO_AD_B0_03_ALT1 = 0x1
	// Selecting Pad: GPIO_AD_B0_05 for Mode: ALT6
	IOMUXC_XBAR1_IN17_SELECT_INPUT_DAISY_GPIO_AD_B0_05_ALT6 = 0x2
	// Selecting Pad: GPIO_B1_03 for Mode: ALT1
	IOMUXC_XBAR1_IN17_SELECT_INPUT_DAISY_GPIO_B1_03_ALT1 = 0x3

	// XBAR1_IN18_SELECT_INPUT: XBAR1_IN18_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_XBAR1_IN18_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_XBAR1_IN18_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_XBAR1_IN18_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_35 for Mode: ALT1
	IOMUXC_XBAR1_IN18_SELECT_INPUT_DAISY_GPIO_EMC_35_ALT1 = 0x0
	// Selecting Pad: GPIO_AD_B0_06 for Mode: ALT6
	IOMUXC_XBAR1_IN18_SELECT_INPUT_DAISY_GPIO_AD_B0_06_ALT6 = 0x1

	// XBAR1_IN20_SELECT_INPUT: XBAR1_IN20_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_XBAR1_IN20_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_XBAR1_IN20_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_XBAR1_IN20_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_15 for Mode: ALT1
	IOMUXC_XBAR1_IN20_SELECT_INPUT_DAISY_GPIO_EMC_15_ALT1 = 0x0
	// Selecting Pad: GPIO_AD_B0_08 for Mode: ALT6
	IOMUXC_XBAR1_IN20_SELECT_INPUT_DAISY_GPIO_AD_B0_08_ALT6 = 0x1

	// XBAR1_IN22_SELECT_INPUT: XBAR1_IN22_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_XBAR1_IN22_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_XBAR1_IN22_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_XBAR1_IN22_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_36 for Mode: ALT1
	IOMUXC_XBAR1_IN22_SELECT_INPUT_DAISY_GPIO_EMC_36_ALT1 = 0x0
	// Selecting Pad: GPIO_AD_B0_10 for Mode: ALT6
	IOMUXC_XBAR1_IN22_SELECT_INPUT_DAISY_GPIO_AD_B0_10_ALT6 = 0x1

	// XBAR1_IN23_SELECT_INPUT: XBAR1_IN23_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_XBAR1_IN23_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_XBAR1_IN23_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_XBAR1_IN23_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_37 for Mode: ALT1
	IOMUXC_XBAR1_IN23_SELECT_INPUT_DAISY_GPIO_EMC_37_ALT1 = 0x0
	// Selecting Pad: GPIO_AD_B0_11 for Mode: ALT6
	IOMUXC_XBAR1_IN23_SELECT_INPUT_DAISY_GPIO_AD_B0_11_ALT6 = 0x1

	// XBAR1_IN24_SELECT_INPUT: XBAR1_IN24_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_XBAR1_IN24_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_XBAR1_IN24_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_XBAR1_IN24_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_12 for Mode: ALT1
	IOMUXC_XBAR1_IN24_SELECT_INPUT_DAISY_GPIO_EMC_12_ALT1 = 0x0
	// Selecting Pad: GPIO_AD_B0_14 for Mode: ALT1
	IOMUXC_XBAR1_IN24_SELECT_INPUT_DAISY_GPIO_AD_B0_14_ALT1 = 0x1

	// XBAR1_IN14_SELECT_INPUT: XBAR1_IN14_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_XBAR1_IN14_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_XBAR1_IN14_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_XBAR1_IN14_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_AD_B0_00 for Mode: ALT1
	IOMUXC_XBAR1_IN14_SELECT_INPUT_DAISY_GPIO_AD_B0_00_ALT1 = 0x0
	// Selecting Pad:GPIO_B1_00 for Mode: ALT1
	IOMUXC_XBAR1_IN14_SELECT_INPUT_DAISY_GPIO_B1_00_ALT1 = 0x1

	// XBAR1_IN15_SELECT_INPUT: XBAR1_IN15_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_XBAR1_IN15_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_XBAR1_IN15_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_XBAR1_IN15_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_AD_B0_01 for Mode: ALT1
	IOMUXC_XBAR1_IN15_SELECT_INPUT_DAISY_GPIO_AD_B0_01_ALT1 = 0x0
	// Selecting Pad: GPIO_B1_01 for Mode: ALT1
	IOMUXC_XBAR1_IN15_SELECT_INPUT_DAISY_GPIO_B1_01_ALT1 = 0x1

	// XBAR1_IN16_SELECT_INPUT: XBAR1_IN16_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_XBAR1_IN16_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_XBAR1_IN16_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_XBAR1_IN16_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_AD_B0_02 for Mode: ALT1
	IOMUXC_XBAR1_IN16_SELECT_INPUT_DAISY_GPIO_AD_B0_02_ALT1 = 0x0
	// Selecting Pad: GPIO_B1_02 for Mode: ALT1
	IOMUXC_XBAR1_IN16_SELECT_INPUT_DAISY_GPIO_B1_02_ALT1 = 0x1

	// XBAR1_IN25_SELECT_INPUT: XBAR1_IN25_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_XBAR1_IN25_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_XBAR1_IN25_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_XBAR1_IN25_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_AD_B0_15 for Mode: ALT1
	IOMUXC_XBAR1_IN25_SELECT_INPUT_DAISY_GPIO_AD_B0_15_ALT1 = 0x0
	// Selecting Pad: GPIO_EMC_13 for Mode: ALT1
	IOMUXC_XBAR1_IN25_SELECT_INPUT_DAISY_GPIO_EMC_13_ALT1 = 0x1

	// XBAR1_IN19_SELECT_INPUT: XBAR1_IN19_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_XBAR1_IN19_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_XBAR1_IN19_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_XBAR1_IN19_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_14 for Mode: ALT1
	IOMUXC_XBAR1_IN19_SELECT_INPUT_DAISY_GPIO_EMC_14_ALT1 = 0x0
	// Selecting Pad: GPIO_AD_B0_07 for Mode: ALT6
	IOMUXC_XBAR1_IN19_SELECT_INPUT_DAISY_GPIO_AD_B0_07_ALT6 = 0x1

	// XBAR1_IN21_SELECT_INPUT: XBAR1_IN23_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_XBAR1_IN21_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_XBAR1_IN21_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_XBAR1_IN21_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_16 for Mode: ALT1
	IOMUXC_XBAR1_IN21_SELECT_INPUT_DAISY_GPIO_EMC_16_ALT1 = 0x0
	// Selecting Pad: GPIO_AD_B0_09 for Mode: ALT6
	IOMUXC_XBAR1_IN21_SELECT_INPUT_DAISY_GPIO_AD_B0_09_ALT6 = 0x1

	// SW_MUX_CTL_PAD_GPIO_SPI_B0_00: SW_MUX_CTL_PAD_GPIO_SPI_B0_00 SW MUX Control Register
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_00_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_00_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_00_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_00_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SPI_B0_00
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_00_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SPI_B0_01: SW_MUX_CTL_PAD_GPIO_SPI_B0_01 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_01_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_01_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: FLEXSPI2_B_SCLK of instance: flexspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_01_MUX_MODE_ALT0 = 0x0
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_01_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_01_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_01_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_01_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SPI_B0_01
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_01_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SPI_B0_02: SW_MUX_CTL_PAD_GPIO_SPI_B0_02 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_02_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_02_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: FLEXSPI2_A_DATA00 of instance: flexspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_02_MUX_MODE_ALT0 = 0x0
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_02_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_02_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_02_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_02_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SPI_B0_02
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_02_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SPI_B0_03: SW_MUX_CTL_PAD_GPIO_SPI_B0_03 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_03_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_03_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: FLEXSPI2_B_DATA02 of instance: flexspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_03_MUX_MODE_ALT0 = 0x0
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_03_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_03_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_03_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_03_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SPI_B0_03
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_03_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SPI_B0_04: SW_MUX_CTL_PAD_GPIO_SPI_B0_04 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_04_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_04_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: FLEXSPI2_B_DATA03 of instance: flexspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_04_MUX_MODE_ALT0 = 0x0
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_04_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_04_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_04_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_04_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SPI_B0_04
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_04_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SPI_B0_05: SW_MUX_CTL_PAD_GPIO_SPI_B0_05 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_05_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_05_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: FLEXSPI2_A_SS0_B of instance: flexspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_05_MUX_MODE_ALT0 = 0x0
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_05_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_05_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_05_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_05_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SPI_B0_05
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_05_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SPI_B0_06: SW_MUX_CTL_PAD_GPIO_SPI_B0_06 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_06_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_06_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: FLEXSPI2_A_DATA02 of instance: flexspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_06_MUX_MODE_ALT0 = 0x0
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_06_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_06_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_06_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_06_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SPI_B0_06
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_06_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SPI_B0_07: SW_MUX_CTL_PAD_GPIO_SPI_B0_07 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_07_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_07_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: FLEXSPI2_B_DATA01 of instance: flexspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_07_MUX_MODE_ALT0 = 0x0
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_07_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_07_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_07_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_07_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SPI_B0_07
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_07_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SPI_B0_08: SW_MUX_CTL_PAD_GPIO_SPI_B0_08 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_08_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_08_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: FLEXSPI2_A_SCLK of instance: flexspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_08_MUX_MODE_ALT0 = 0x0
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_08_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_08_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_08_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_08_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SPI_B0_08
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_08_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SPI_B0_09: SW_MUX_CTL_PAD_GPIO_SPI_B0_09 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_09_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_09_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: FLEXSPI2_A_DQS of instance: flexspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_09_MUX_MODE_ALT0 = 0x0
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_09_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_09_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_09_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_09_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SPI_B0_09
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_09_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SPI_B0_10: SW_MUX_CTL_PAD_GPIO_SPI_B0_10 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_10_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_10_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: FLEXSPI2_A_DATA03 of instance: flexspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_10_MUX_MODE_ALT0 = 0x0
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_10_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_10_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_10_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_10_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SPI_B0_10
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_10_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SPI_B0_11: SW_MUX_CTL_PAD_GPIO_SPI_B0_11 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_11_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_11_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: FLEXSPI2_B_DATA00 of instance: flexspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_11_MUX_MODE_ALT0 = 0x0
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_11_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_11_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_11_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_11_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SPI_B0_11
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_11_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SPI_B0_12: SW_MUX_CTL_PAD_GPIO_SPI_B0_12 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_12_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_12_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: FLEXSPI2_A_DATA01 of instance: flexspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_12_MUX_MODE_ALT0 = 0x0
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_12_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_12_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_12_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_12_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SPI_B0_12
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_12_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SPI_B0_13: SW_MUX_CTL_PAD_GPIO_SPI_B0_13 SW MUX Control Register
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_13_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_13_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_13_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_13_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SPI_B0_13
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_13_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SPI_B1_00: SW_MUX_CTL_PAD_GPIO_SPI_B1_00 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_00_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_00_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: FLEXSPI2_A_DQS of instance: flexspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_00_MUX_MODE_ALT0 = 0x0
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_00_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_00_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_00_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_00_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SPI_B1_00
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_00_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SPI_B1_01: SW_MUX_CTL_PAD_GPIO_SPI_B1_01 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_01_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_01_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: FLEXSPI2_A_DATA03 of instance: flexspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_01_MUX_MODE_ALT0 = 0x0
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_01_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_01_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_01_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_01_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SPI_B1_01
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_01_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SPI_B1_02: SW_MUX_CTL_PAD_GPIO_SPI_B1_02 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_02_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_02_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: FLEXSPI2_A_DATA02 of instance: flexspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_02_MUX_MODE_ALT0 = 0x0
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_02_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_02_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_02_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_02_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SPI_B1_02
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_02_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SPI_B1_03: SW_MUX_CTL_PAD_GPIO_SPI_B1_03 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_03_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_03_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: FLEXSPI2_A_DATA01 of instance: flexspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_03_MUX_MODE_ALT0 = 0x0
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_03_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_03_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_03_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_03_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SPI_B1_03
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_03_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SPI_B1_04: SW_MUX_CTL_PAD_GPIO_SPI_B1_04 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_04_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_04_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: FLEXSPI2_A_DATA00 of instance: flexspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_04_MUX_MODE_ALT0 = 0x0
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_04_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_04_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_04_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_04_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SPI_B1_04
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_04_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SPI_B1_05: SW_MUX_CTL_PAD_GPIO_SPI_B1_05 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_05_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_05_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: FLEXSPI2_A_SCLK of instance: flexspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_05_MUX_MODE_ALT0 = 0x0
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_05_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_05_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_05_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_05_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SPI_B1_05
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_05_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SPI_B1_06: SW_MUX_CTL_PAD_GPIO_SPI_B1_06 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_06_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_06_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: FLEXSPI2_A_SS0_B of instance: flexspi2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_06_MUX_MODE_ALT0 = 0x0
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_06_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_06_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_06_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_06_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SPI_B1_06
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_06_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SPI_B1_07: SW_MUX_CTL_PAD_GPIO_SPI_B1_07 SW MUX Control Register
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_07_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_07_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_07_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_07_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SPI_B1_07
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_07_SION_ENABLED = 0x1

	// SW_PAD_CTL_PAD_GPIO_SPI_B0_00: SW_PAD_CTL_PAD_GPIO_SPI_B0_00 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_SPEED_SPEED_0_low_50MHz_ = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_SPEED_SPEED_1_medium_100MHz_ = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_SPEED_SPEED_2_medium_100MHz_ = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_SPEED_SPEED_3_max_200MHz_ = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SPI_B0_01: SW_PAD_CTL_PAD_GPIO_SPI_B0_01 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_SPEED_SPEED_0_low_50MHz_ = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_SPEED_SPEED_1_medium_100MHz_ = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_SPEED_SPEED_2_medium_100MHz_ = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_SPEED_SPEED_3_max_200MHz_ = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SPI_B0_02: SW_PAD_CTL_PAD_GPIO_SPI_B0_02 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_SPEED_SPEED_0_low_50MHz_ = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_SPEED_SPEED_1_medium_100MHz_ = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_SPEED_SPEED_2_medium_100MHz_ = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_SPEED_SPEED_3_max_200MHz_ = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SPI_B0_03: SW_PAD_CTL_PAD_GPIO_SPI_B0_03 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_SPEED_SPEED_0_low_50MHz_ = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_SPEED_SPEED_1_medium_100MHz_ = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_SPEED_SPEED_2_medium_100MHz_ = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_SPEED_SPEED_3_max_200MHz_ = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SPI_B0_04: SW_PAD_CTL_PAD_GPIO_SPI_B0_04 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_SPEED_SPEED_0_low_50MHz_ = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_SPEED_SPEED_1_medium_100MHz_ = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_SPEED_SPEED_2_medium_100MHz_ = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_SPEED_SPEED_3_max_200MHz_ = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SPI_B0_05: SW_PAD_CTL_PAD_GPIO_SPI_B0_05 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_SPEED_SPEED_0_low_50MHz_ = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_SPEED_SPEED_1_medium_100MHz_ = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_SPEED_SPEED_2_medium_100MHz_ = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_SPEED_SPEED_3_max_200MHz_ = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SPI_B0_06: SW_PAD_CTL_PAD_GPIO_SPI_B0_06 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_SPEED_SPEED_0_low_50MHz_ = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_SPEED_SPEED_1_medium_100MHz_ = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_SPEED_SPEED_2_medium_100MHz_ = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_SPEED_SPEED_3_max_200MHz_ = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SPI_B0_07: SW_PAD_CTL_PAD_GPIO_SPI_B0_07 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_SPEED_SPEED_0_low_50MHz_ = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_SPEED_SPEED_1_medium_100MHz_ = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_SPEED_SPEED_2_medium_100MHz_ = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_SPEED_SPEED_3_max_200MHz_ = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SPI_B0_08: SW_PAD_CTL_PAD_GPIO_SPI_B0_08 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_SPEED_SPEED_0_low_50MHz_ = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_SPEED_SPEED_1_medium_100MHz_ = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_SPEED_SPEED_2_medium_100MHz_ = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_SPEED_SPEED_3_max_200MHz_ = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SPI_B0_09: SW_PAD_CTL_PAD_GPIO_SPI_B0_09 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_SPEED_SPEED_0_low_50MHz_ = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_SPEED_SPEED_1_medium_100MHz_ = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_SPEED_SPEED_2_medium_100MHz_ = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_SPEED_SPEED_3_max_200MHz_ = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SPI_B0_10: SW_PAD_CTL_PAD_GPIO_SPI_B0_10 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_SPEED_SPEED_0_low_50MHz_ = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_SPEED_SPEED_1_medium_100MHz_ = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_SPEED_SPEED_2_medium_100MHz_ = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_SPEED_SPEED_3_max_200MHz_ = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SPI_B0_11: SW_PAD_CTL_PAD_GPIO_SPI_B0_11 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_SPEED_SPEED_0_low_50MHz_ = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_SPEED_SPEED_1_medium_100MHz_ = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_SPEED_SPEED_2_medium_100MHz_ = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_SPEED_SPEED_3_max_200MHz_ = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SPI_B0_12: SW_PAD_CTL_PAD_GPIO_SPI_B0_12 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_SPEED_SPEED_0_low_50MHz_ = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_SPEED_SPEED_1_medium_100MHz_ = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_SPEED_SPEED_2_medium_100MHz_ = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_SPEED_SPEED_3_max_200MHz_ = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SPI_B0_13: SW_PAD_CTL_PAD_GPIO_SPI_B0_13 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_SPEED_SPEED_0_low_50MHz_ = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_SPEED_SPEED_1_medium_100MHz_ = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_SPEED_SPEED_2_medium_100MHz_ = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_SPEED_SPEED_3_max_200MHz_ = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SPI_B1_00: SW_PAD_CTL_PAD_GPIO_SPI_B1_00 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_SPEED_SPEED_0_low_50MHz_ = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_SPEED_SPEED_1_medium_100MHz_ = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_SPEED_SPEED_2_medium_100MHz_ = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_SPEED_SPEED_3_max_200MHz_ = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SPI_B1_01: SW_PAD_CTL_PAD_GPIO_SPI_B1_01 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_SPEED_SPEED_0_low_50MHz_ = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_SPEED_SPEED_1_medium_100MHz_ = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_SPEED_SPEED_2_medium_100MHz_ = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_SPEED_SPEED_3_max_200MHz_ = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SPI_B1_02: SW_PAD_CTL_PAD_GPIO_SPI_B1_02 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_SPEED_SPEED_0_low_50MHz_ = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_SPEED_SPEED_1_medium_100MHz_ = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_SPEED_SPEED_2_medium_100MHz_ = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_SPEED_SPEED_3_max_200MHz_ = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SPI_B1_03: SW_PAD_CTL_PAD_GPIO_SPI_B1_03 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_SPEED_SPEED_0_low_50MHz_ = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_SPEED_SPEED_1_medium_100MHz_ = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_SPEED_SPEED_2_medium_100MHz_ = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_SPEED_SPEED_3_max_200MHz_ = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SPI_B1_04: SW_PAD_CTL_PAD_GPIO_SPI_B1_04 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_SPEED_SPEED_0_low_50MHz_ = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_SPEED_SPEED_1_medium_100MHz_ = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_SPEED_SPEED_2_medium_100MHz_ = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_SPEED_SPEED_3_max_200MHz_ = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SPI_B1_05: SW_PAD_CTL_PAD_GPIO_SPI_B1_05 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_SPEED_SPEED_0_low_50MHz_ = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_SPEED_SPEED_1_medium_100MHz_ = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_SPEED_SPEED_2_medium_100MHz_ = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_SPEED_SPEED_3_max_200MHz_ = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SPI_B1_06: SW_PAD_CTL_PAD_GPIO_SPI_B1_06 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_SPEED_SPEED_0_low_50MHz_ = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_SPEED_SPEED_1_medium_100MHz_ = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_SPEED_SPEED_2_medium_100MHz_ = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_SPEED_SPEED_3_max_200MHz_ = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SPI_B1_07: SW_PAD_CTL_PAD_GPIO_SPI_B1_07 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_SPEED_SPEED_0_low_50MHz_ = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_SPEED_SPEED_1_medium_100MHz_ = 0x1
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_SPEED_SPEED_2_medium_100MHz_ = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_SPEED_SPEED_3_max_200MHz_ = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// ENET2_IPG_CLK_RMII_SELECT_INPUT: ENET2_IPG_CLK_RMII_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_ENET2_IPG_CLK_RMII_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_ENET2_IPG_CLK_RMII_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_EMC_33 for Mode: ALT9
	IOMUXC_ENET2_IPG_CLK_RMII_SELECT_INPUT_DAISY_GPIO_EMC_33_ALT9 = 0x0
	// Selecting Pad: GPIO_SD_B0_01 for Mode: ALT9
	IOMUXC_ENET2_IPG_CLK_RMII_SELECT_INPUT_DAISY_GPIO_SD_B0_01_ALT9 = 0x1
	// Selecting Pad: GPIO_B0_15 for Mode: ALT9
	IOMUXC_ENET2_IPG_CLK_RMII_SELECT_INPUT_DAISY_GPIO_B0_15_ALT9 = 0x2

	// ENET2_IPP_IND_MAC0_MDIO_SELECT_INPUT: ENET2_IPP_IND_MAC0_MDIO_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_ENET2_IPP_IND_MAC0_MDIO_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_ENET2_IPP_IND_MAC0_MDIO_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_ENET2_IPP_IND_MAC0_MDIO_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_39 for Mode: ALT8
	IOMUXC_ENET2_IPP_IND_MAC0_MDIO_SELECT_INPUT_DAISY_GPIO_EMC_39_ALT8 = 0x0
	// Selecting Pad: GPIO_B0_01 for Mode: ALT8
	IOMUXC_ENET2_IPP_IND_MAC0_MDIO_SELECT_INPUT_DAISY_GPIO_B0_01_ALT8 = 0x1

	// ENET2_IPP_IND_MAC0_RXDATA_SELECT_INPUT_0: ENET2_IPP_IND_MAC0_RXDATA_SELECT_INPUT_0 DAISY Register
	// Position of DAISY field.
	IOMUXC_ENET2_IPP_IND_MAC0_RXDATA_SELECT_INPUT_0_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_ENET2_IPP_IND_MAC0_RXDATA_SELECT_INPUT_0_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_EMC_35 for Mode: ALT8
	IOMUXC_ENET2_IPP_IND_MAC0_RXDATA_SELECT_INPUT_0_DAISY_GPIO_EMC_35_ALT8 = 0x0
	// Selecting Pad: GPIO_SD_B0_03 for Mode: ALT8
	IOMUXC_ENET2_IPP_IND_MAC0_RXDATA_SELECT_INPUT_0_DAISY_GPIO_SD_B0_03_ALT8 = 0x1
	// Selecting Pad: GPIO_B1_01 for Mode: ALT8
	IOMUXC_ENET2_IPP_IND_MAC0_RXDATA_SELECT_INPUT_0_DAISY_GPIO_B1_01_ALT8 = 0x2

	// ENET2_IPP_IND_MAC0_RXDATA_SELECT_INPUT_1: ENET2_IPP_IND_MAC0_RXDATA_SELECT_INPUT_1 DAISY Register
	// Position of DAISY field.
	IOMUXC_ENET2_IPP_IND_MAC0_RXDATA_SELECT_INPUT_1_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_ENET2_IPP_IND_MAC0_RXDATA_SELECT_INPUT_1_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_EMC_36 for Mode: ALT8
	IOMUXC_ENET2_IPP_IND_MAC0_RXDATA_SELECT_INPUT_1_DAISY_GPIO_EMC_36_ALT8 = 0x0
	// Selecting Pad: GPIO_SD_B0_04 for Mode: ALT8
	IOMUXC_ENET2_IPP_IND_MAC0_RXDATA_SELECT_INPUT_1_DAISY_GPIO_SD_B0_04_ALT8 = 0x1
	// Selecting Pad: GPIO_B1_02 for Mode: ALT8
	IOMUXC_ENET2_IPP_IND_MAC0_RXDATA_SELECT_INPUT_1_DAISY_GPIO_B1_02_ALT8 = 0x2

	// ENET2_IPP_IND_MAC0_RXEN_SELECT_INPUT: ENET2_IPP_IND_MAC0_RXEN_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_ENET2_IPP_IND_MAC0_RXEN_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_ENET2_IPP_IND_MAC0_RXEN_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_EMC_37 for Mode: ALT8
	IOMUXC_ENET2_IPP_IND_MAC0_RXEN_SELECT_INPUT_DAISY_GPIO_EMC_37_ALT8 = 0x0
	// Selecting Pad: GPIO_SD_B0_05 for Mode: ALT8
	IOMUXC_ENET2_IPP_IND_MAC0_RXEN_SELECT_INPUT_DAISY_GPIO_SD_B0_05_ALT8 = 0x1
	// Selecting Pad: GPIO_B1_03 for Mode: ALT8
	IOMUXC_ENET2_IPP_IND_MAC0_RXEN_SELECT_INPUT_DAISY_GPIO_B1_03_ALT8 = 0x2

	// ENET2_IPP_IND_MAC0_RXERR_SELECT_INPUT: ENET2_IPP_IND_MAC0_RXERR_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_ENET2_IPP_IND_MAC0_RXERR_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_ENET2_IPP_IND_MAC0_RXERR_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_EMC_34 for Mode: ALT8
	IOMUXC_ENET2_IPP_IND_MAC0_RXERR_SELECT_INPUT_DAISY_GPIO_EMC_34_ALT8 = 0x0
	// Selecting Pad: GPIO_SD_B0_02 for Mode: ALT8
	IOMUXC_ENET2_IPP_IND_MAC0_RXERR_SELECT_INPUT_DAISY_GPIO_SD_B0_02_ALT8 = 0x1
	// Selecting Pad: GPIO_B1_00 for Mode: ALT8
	IOMUXC_ENET2_IPP_IND_MAC0_RXERR_SELECT_INPUT_DAISY_GPIO_B1_00_ALT8 = 0x2

	// ENET2_IPP_IND_MAC0_TIMER_SELECT_INPUT_0: ENET2_IPP_IND_MAC0_TIMER_SELECT_INPUT_0 DAISY Register
	// Position of DAISY field.
	IOMUXC_ENET2_IPP_IND_MAC0_TIMER_SELECT_INPUT_0_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_ENET2_IPP_IND_MAC0_TIMER_SELECT_INPUT_0_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_ENET2_IPP_IND_MAC0_TIMER_SELECT_INPUT_0_DAISY = 0x1
	// Selecting Pad: GPIO_AD_B1_01 for Mode: ALT8
	IOMUXC_ENET2_IPP_IND_MAC0_TIMER_SELECT_INPUT_0_DAISY_GPIO_AD_B1_01_ALT8 = 0x0
	// Selecting Pad: GPIO_B0_03 for Mode: ALT8
	IOMUXC_ENET2_IPP_IND_MAC0_TIMER_SELECT_INPUT_0_DAISY_GPIO_B0_03_ALT8 = 0x1

	// ENET2_IPP_IND_MAC0_TXCLK_SELECT_INPUT: ENET2_IPP_IND_MAC0_TXCLK_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_ENET2_IPP_IND_MAC0_TXCLK_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_ENET2_IPP_IND_MAC0_TXCLK_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_EMC_33 for Mode: ALT8
	IOMUXC_ENET2_IPP_IND_MAC0_TXCLK_SELECT_INPUT_DAISY_GPIO_EMC_33_ALT8 = 0x0
	// Selecting Pad: GPIO_SD_B0_01 for Mode: ALT8
	IOMUXC_ENET2_IPP_IND_MAC0_TXCLK_SELECT_INPUT_DAISY_GPIO_SD_B0_01_ALT8 = 0x1
	// Selecting Pad: GPIO_B0_15 for Mode: ALT8
	IOMUXC_ENET2_IPP_IND_MAC0_TXCLK_SELECT_INPUT_DAISY_GPIO_B0_15_ALT8 = 0x2

	// FLEXSPI2_IPP_IND_DQS_FA_SELECT_INPUT: FLEXSPI2_IPP_IND_DQS_FA_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXSPI2_IPP_IND_DQS_FA_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXSPI2_IPP_IND_DQS_FA_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_SPI_B1_00 for Mode: ALT0
	IOMUXC_FLEXSPI2_IPP_IND_DQS_FA_SELECT_INPUT_DAISY_GPIO_SPI_B1_00_ALT0 = 0x0
	// Selecting Pad: GPIO_EMC_23 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_DQS_FA_SELECT_INPUT_DAISY_GPIO_EMC_23_ALT8 = 0x1
	// Selecting Pad: GPIO_SPI_B0_09 for Mode: ALT0
	IOMUXC_FLEXSPI2_IPP_IND_DQS_FA_SELECT_INPUT_DAISY_GPIO_SPI_B0_09_ALT0 = 0x2

	// FLEXSPI2_IPP_IND_IO_FA_BIT0_SELECT_INPUT: FLEXSPI2_IPP_IND_IO_FA_BIT0_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT0_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT0_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_SPI_B1_04 for Mode: ALT0
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT0_SELECT_INPUT_DAISY_GPIO_SPI_B1_04_ALT0 = 0x0
	// Selecting Pad: GPIO_EMC_26 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT0_SELECT_INPUT_DAISY_GPIO_EMC_26_ALT8 = 0x1
	// Selecting Pad: GPIO_SPI_B0_02 for Mode: ALT0
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT0_SELECT_INPUT_DAISY_GPIO_SPI_B0_02_ALT0 = 0x2

	// FLEXSPI2_IPP_IND_IO_FA_BIT1_SELECT_INPUT: FLEXSPI2_IPP_IND_IO_FA_BIT1_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT1_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT1_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_SPI_B1_03 for Mode: ALT0
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT1_SELECT_INPUT_DAISY_GPIO_SPI_B1_03_ALT0 = 0x0
	// Selecting Pad: GPIO_EMC_27 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT1_SELECT_INPUT_DAISY_GPIO_EMC_27_ALT8 = 0x1
	// Selecting Pad: GPIO_SPI_B0_12 for Mode: ALT0
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT1_SELECT_INPUT_DAISY_GPIO_SPI_B0_12_ALT0 = 0x2

	// FLEXSPI2_IPP_IND_IO_FA_BIT2_SELECT_INPUT: FLEXSPI2_IPP_IND_IO_FA_BIT2_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT2_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT2_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_SPI_B1_02 for Mode: ALT0
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT2_SELECT_INPUT_DAISY_GPIO_SPI_B1_02_ALT0 = 0x0
	// Selecting Pad: GPIO_EMC_28 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT2_SELECT_INPUT_DAISY_GPIO_EMC_28_ALT8 = 0x1
	// Selecting Pad: GPIO_SPI_B0_06 for Mode: ALT0
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT2_SELECT_INPUT_DAISY_GPIO_SPI_B0_06_ALT0 = 0x2

	// FLEXSPI2_IPP_IND_IO_FA_BIT3_SELECT_INPUT: FLEXSPI2_IPP_IND_IO_FA_BIT3_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT3_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT3_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_SPI_B1_01 for Mode: ALT0
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT3_SELECT_INPUT_DAISY_GPIO_SPI_B1_01_ALT0 = 0x0
	// Selecting Pad: GPIO_EMC_29 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT3_SELECT_INPUT_DAISY_GPIO_EMC_29_ALT8 = 0x1
	// Selecting Pad: GPIO_SPI_B0_10 for Mode: ALT0
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT3_SELECT_INPUT_DAISY_GPIO_SPI_B0_10_ALT0 = 0x2

	// FLEXSPI2_IPP_IND_IO_FB_BIT0_SELECT_INPUT: FLEXSPI2_IPP_IND_IO_FB_BIT0_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXSPI2_IPP_IND_IO_FB_BIT0_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXSPI2_IPP_IND_IO_FB_BIT0_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_FLEXSPI2_IPP_IND_IO_FB_BIT0_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_13 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_IO_FB_BIT0_SELECT_INPUT_DAISY_GPIO_EMC_13_ALT8 = 0x0
	// Selecting Pad: GPIO_SPI_B0_11 for Mode: ALT0
	IOMUXC_FLEXSPI2_IPP_IND_IO_FB_BIT0_SELECT_INPUT_DAISY_GPIO_SPI_B0_11_ALT0 = 0x1

	// FLEXSPI2_IPP_IND_IO_FB_BIT1_SELECT_INPUT: FLEXSPI2_IPP_IND_IO_FB_BIT1_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXSPI2_IPP_IND_IO_FB_BIT1_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXSPI2_IPP_IND_IO_FB_BIT1_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_FLEXSPI2_IPP_IND_IO_FB_BIT1_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_14 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_IO_FB_BIT1_SELECT_INPUT_DAISY_GPIO_EMC_14_ALT8 = 0x0
	// Selecting Pad: GPIO_SPI_B0_07 for Mode: ALT0
	IOMUXC_FLEXSPI2_IPP_IND_IO_FB_BIT1_SELECT_INPUT_DAISY_GPIO_SPI_B0_07_ALT0 = 0x1

	// FLEXSPI2_IPP_IND_IO_FB_BIT2_SELECT_INPUT: FLEXSPI2_IPP_IND_IO_FB_BIT2_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXSPI2_IPP_IND_IO_FB_BIT2_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXSPI2_IPP_IND_IO_FB_BIT2_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_FLEXSPI2_IPP_IND_IO_FB_BIT2_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_15 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_IO_FB_BIT2_SELECT_INPUT_DAISY_GPIO_EMC_15_ALT8 = 0x0
	// Selecting Pad: GPIO_SPI_B0_03 for Mode: ALT0
	IOMUXC_FLEXSPI2_IPP_IND_IO_FB_BIT2_SELECT_INPUT_DAISY_GPIO_SPI_B0_03_ALT0 = 0x1

	// FLEXSPI2_IPP_IND_IO_FB_BIT3_SELECT_INPUT: FLEXSPI2_IPP_IND_IO_FB_BIT3_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXSPI2_IPP_IND_IO_FB_BIT3_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXSPI2_IPP_IND_IO_FB_BIT3_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_FLEXSPI2_IPP_IND_IO_FB_BIT3_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_16 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_IO_FB_BIT3_SELECT_INPUT_DAISY_GPIO_EMC_16_ALT8 = 0x0
	// Selecting Pad: GPIO_SPI_B0_04 for Mode: ALT0
	IOMUXC_FLEXSPI2_IPP_IND_IO_FB_BIT3_SELECT_INPUT_DAISY_GPIO_SPI_B0_04_ALT0 = 0x1

	// FLEXSPI2_IPP_IND_SCK_FA_SELECT_INPUT: FLEXSPI2_IPP_IND_SCK_FA_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXSPI2_IPP_IND_SCK_FA_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXSPI2_IPP_IND_SCK_FA_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_SPI_B1_05 for Mode: ALT0
	IOMUXC_FLEXSPI2_IPP_IND_SCK_FA_SELECT_INPUT_DAISY_GPIO_SPI_B1_05_ALT0 = 0x0
	// Selecting Pad: GPIO_EMC_25 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_SCK_FA_SELECT_INPUT_DAISY_GPIO_EMC_25_ALT8 = 0x1
	// Selecting Pad: GPIO_SPI_B0_08 for Mode: ALT0
	IOMUXC_FLEXSPI2_IPP_IND_SCK_FA_SELECT_INPUT_DAISY_GPIO_SPI_B0_08_ALT0 = 0x2

	// FLEXSPI2_IPP_IND_SCK_FB_SELECT_INPUT: FLEXSPI2_IPP_IND_SCK_FB_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXSPI2_IPP_IND_SCK_FB_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXSPI2_IPP_IND_SCK_FB_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_FLEXSPI2_IPP_IND_SCK_FB_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_12 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_SCK_FB_SELECT_INPUT_DAISY_GPIO_EMC_12_ALT8 = 0x0
	// Selecting Pad: GPIO_SPI_B0_01 for Mode: ALT0
	IOMUXC_FLEXSPI2_IPP_IND_SCK_FB_SELECT_INPUT_DAISY_GPIO_SPI_B0_01_ALT0 = 0x1

	// GPT1_IPP_IND_CAPIN1_SELECT_INPUT: GPT1_IPP_IND_CAPIN1_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_GPT1_IPP_IND_CAPIN1_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_GPT1_IPP_IND_CAPIN1_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_GPT1_IPP_IND_CAPIN1_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_24 for Mode: ALT4
	IOMUXC_GPT1_IPP_IND_CAPIN1_SELECT_INPUT_DAISY_GPIO_EMC_24_ALT4 = 0x0
	// Selecting Pad: GPIO_B1_05 for Mode: ALT8
	IOMUXC_GPT1_IPP_IND_CAPIN1_SELECT_INPUT_DAISY_GPIO_B1_05_ALT8 = 0x1

	// GPT1_IPP_IND_CAPIN2_SELECT_INPUT: GPT1_IPP_IND_CAPIN2_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_GPT1_IPP_IND_CAPIN2_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_GPT1_IPP_IND_CAPIN2_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_GPT1_IPP_IND_CAPIN2_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_23 for Mode: ALT4
	IOMUXC_GPT1_IPP_IND_CAPIN2_SELECT_INPUT_DAISY_GPIO_EMC_23_ALT4 = 0x0
	// Selecting Pad: GPIO_B1_06 for Mode: ALT8
	IOMUXC_GPT1_IPP_IND_CAPIN2_SELECT_INPUT_DAISY_GPIO_B1_06_ALT8 = 0x1

	// GPT1_IPP_IND_CLKIN_SELECT_INPUT: GPT1_IPP_IND_CLKIN_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_GPT1_IPP_IND_CLKIN_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_GPT1_IPP_IND_CLKIN_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_GPT1_IPP_IND_CLKIN_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_AD_B0_13 for Mode: ALT1
	IOMUXC_GPT1_IPP_IND_CLKIN_SELECT_INPUT_DAISY_GPIO_AD_B0_13_ALT1 = 0x0
	// Selecting Pad: GPIO_B1_04 for Mode: ALT8
	IOMUXC_GPT1_IPP_IND_CLKIN_SELECT_INPUT_DAISY_GPIO_B1_04_ALT8 = 0x1

	// GPT2_IPP_IND_CAPIN1_SELECT_INPUT: GPT2_IPP_IND_CAPIN1_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_GPT2_IPP_IND_CAPIN1_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_GPT2_IPP_IND_CAPIN1_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_GPT2_IPP_IND_CAPIN1_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_41 for Mode: ALT1
	IOMUXC_GPT2_IPP_IND_CAPIN1_SELECT_INPUT_DAISY_GPIO_EMC_41_ALT1 = 0x0
	// Selecting Pad: GPIO_AD_B1_03 for Mode: ALT8
	IOMUXC_GPT2_IPP_IND_CAPIN1_SELECT_INPUT_DAISY_GPIO_AD_B1_03_ALT8 = 0x1

	// GPT2_IPP_IND_CAPIN2_SELECT_INPUT: GPT2_IPP_IND_CAPIN2_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_GPT2_IPP_IND_CAPIN2_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_GPT2_IPP_IND_CAPIN2_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_GPT2_IPP_IND_CAPIN2_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_40 for Mode: ALT1
	IOMUXC_GPT2_IPP_IND_CAPIN2_SELECT_INPUT_DAISY_GPIO_EMC_40_ALT1 = 0x0
	// Selecting Pad: GPIO_AD_B1_04 for Mode: ALT8
	IOMUXC_GPT2_IPP_IND_CAPIN2_SELECT_INPUT_DAISY_GPIO_AD_B1_04_ALT8 = 0x1

	// GPT2_IPP_IND_CLKIN_SELECT_INPUT: GPT2_IPP_IND_CLKIN_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_GPT2_IPP_IND_CLKIN_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_GPT2_IPP_IND_CLKIN_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_GPT2_IPP_IND_CLKIN_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_AD_B0_09 for Mode: ALT7
	IOMUXC_GPT2_IPP_IND_CLKIN_SELECT_INPUT_DAISY_GPIO_AD_B0_09_ALT7 = 0x0
	// Selecting Pad: GPIO_AD_B1_02 for Mode: ALT8
	IOMUXC_GPT2_IPP_IND_CLKIN_SELECT_INPUT_DAISY_GPIO_AD_B1_02_ALT8 = 0x1

	// SAI3_IPG_CLK_SAI_MCLK_SELECT_INPUT_2: SAI3_IPG_CLK_SAI_MCLK_SELECT_INPUT_2 DAISY Register
	// Position of DAISY field.
	IOMUXC_SAI3_IPG_CLK_SAI_MCLK_SELECT_INPUT_2_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_SAI3_IPG_CLK_SAI_MCLK_SELECT_INPUT_2_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_SAI3_IPG_CLK_SAI_MCLK_SELECT_INPUT_2_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_37 for Mode: ALT3
	IOMUXC_SAI3_IPG_CLK_SAI_MCLK_SELECT_INPUT_2_DAISY_GPIO_EMC_37_ALT3 = 0x0
	// Selecting Pad: GPIO_SD_B1_04 for Mode: ALT8
	IOMUXC_SAI3_IPG_CLK_SAI_MCLK_SELECT_INPUT_2_DAISY_GPIO_SD_B1_04_ALT8 = 0x1

	// SAI3_IPP_IND_SAI_RXBCLK_SELECT_INPUT: SAI3_IPP_IND_SAI_RXBCLK_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_SAI3_IPP_IND_SAI_RXBCLK_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_SAI3_IPP_IND_SAI_RXBCLK_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_SAI3_IPP_IND_SAI_RXBCLK_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_35 for Mode: ALT3
	IOMUXC_SAI3_IPP_IND_SAI_RXBCLK_SELECT_INPUT_DAISY_GPIO_EMC_35_ALT3 = 0x0
	// Selecting Pad: GPIO_SD_B1_06 for Mode: ALT8
	IOMUXC_SAI3_IPP_IND_SAI_RXBCLK_SELECT_INPUT_DAISY_GPIO_SD_B1_06_ALT8 = 0x1

	// SAI3_IPP_IND_SAI_RXDATA_SELECT_INPUT_0: SAI3_IPP_IND_SAI_RXDATA_SELECT_INPUT_0 DAISY Register
	// Position of DAISY field.
	IOMUXC_SAI3_IPP_IND_SAI_RXDATA_SELECT_INPUT_0_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_SAI3_IPP_IND_SAI_RXDATA_SELECT_INPUT_0_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_SAI3_IPP_IND_SAI_RXDATA_SELECT_INPUT_0_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_33 for Mode: ALT3
	IOMUXC_SAI3_IPP_IND_SAI_RXDATA_SELECT_INPUT_0_DAISY_GPIO_EMC_33_ALT3 = 0x0
	// Selecting Pad: GPIO_SD_B1_00 for Mode: ALT8
	IOMUXC_SAI3_IPP_IND_SAI_RXDATA_SELECT_INPUT_0_DAISY_GPIO_SD_B1_00_ALT8 = 0x1

	// SAI3_IPP_IND_SAI_RXSYNC_SELECT_INPUT: SAI3_IPP_IND_SAI_RXSYNC_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_SAI3_IPP_IND_SAI_RXSYNC_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_SAI3_IPP_IND_SAI_RXSYNC_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_SAI3_IPP_IND_SAI_RXSYNC_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_34 for Mode: ALT3
	IOMUXC_SAI3_IPP_IND_SAI_RXSYNC_SELECT_INPUT_DAISY_GPIO_EMC_34_ALT3 = 0x0
	// Selecting Pad: GPIO_SD_B1_05 for Mode: ALT8
	IOMUXC_SAI3_IPP_IND_SAI_RXSYNC_SELECT_INPUT_DAISY_GPIO_SD_B1_05_ALT8 = 0x1

	// SAI3_IPP_IND_SAI_TXBCLK_SELECT_INPUT: SAI3_IPP_IND_SAI_TXBCLK_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_SAI3_IPP_IND_SAI_TXBCLK_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_SAI3_IPP_IND_SAI_TXBCLK_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_SAI3_IPP_IND_SAI_TXBCLK_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_38 for Mode: ALT3
	IOMUXC_SAI3_IPP_IND_SAI_TXBCLK_SELECT_INPUT_DAISY_GPIO_EMC_38_ALT3 = 0x0
	// Selecting Pad: GPIO_SD_B1_03 for Mode: ALT8
	IOMUXC_SAI3_IPP_IND_SAI_TXBCLK_SELECT_INPUT_DAISY_GPIO_SD_B1_03_ALT8 = 0x1

	// SAI3_IPP_IND_SAI_TXSYNC_SELECT_INPUT: SAI3_IPP_IND_SAI_TXSYNC_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_SAI3_IPP_IND_SAI_TXSYNC_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_SAI3_IPP_IND_SAI_TXSYNC_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_SAI3_IPP_IND_SAI_TXSYNC_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_EMC_39 for Mode: ALT3
	IOMUXC_SAI3_IPP_IND_SAI_TXSYNC_SELECT_INPUT_DAISY_GPIO_EMC_39_ALT3 = 0x0
	// Selecting Pad: GPIO_SD_B1_02 for Mode: ALT8
	IOMUXC_SAI3_IPP_IND_SAI_TXSYNC_SELECT_INPUT_DAISY_GPIO_SD_B1_02_ALT8 = 0x1

	// SEMC_I_IPP_IND_DQS4_SELECT_INPUT: SEMC_I_IPP_IND_DQS4_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_SEMC_I_IPP_IND_DQS4_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_SEMC_I_IPP_IND_DQS4_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_SD_B0_00 for Mode: ALT9
	IOMUXC_SEMC_I_IPP_IND_DQS4_SELECT_INPUT_DAISY_GPIO_SD_B0_00_ALT9 = 0x0
	// Selecting Pad: GPIO_EMC_39 for Mode: ALT9
	IOMUXC_SEMC_I_IPP_IND_DQS4_SELECT_INPUT_DAISY_GPIO_EMC_39_ALT9 = 0x1
	// Selecting Pad: GPIO_AD_B0_09 for Mode: ALT9
	IOMUXC_SEMC_I_IPP_IND_DQS4_SELECT_INPUT_DAISY_GPIO_AD_B0_09_ALT9 = 0x2
	// Selecting Pad: GPIO_B1_13 for Mode: ALT8
	IOMUXC_SEMC_I_IPP_IND_DQS4_SELECT_INPUT_DAISY_GPIO_B1_13_ALT8 = 0x3

	// CANFD_IPP_IND_CANRX_SELECT_INPUT: CANFD_IPP_IND_CANRX_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_CANFD_IPP_IND_CANRX_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_CANFD_IPP_IND_CANRX_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_EMC_37 for Mode: ALT9
	IOMUXC_CANFD_IPP_IND_CANRX_SELECT_INPUT_DAISY_GPIO_EMC_37_ALT9 = 0x0
	// Selecting Pad: GPIO_AD_B0_15 for Mode: ALT8
	IOMUXC_CANFD_IPP_IND_CANRX_SELECT_INPUT_DAISY_GPIO_AD_B0_15_ALT8 = 0x1
	// Selecting Pad: GPIO_AD_B0_11 for Mode: ALT8
	IOMUXC_CANFD_IPP_IND_CANRX_SELECT_INPUT_DAISY_GPIO_AD_B0_11_ALT8 = 0x2
)

// Bitfields for KPP: KPP Registers
const (
	// KPCR: Keypad Control Register
	// Position of KRE field.
	KPP_KPCR_KRE_Pos = 0x0
	// Bit mask of KRE field.
	KPP_KPCR_KRE_Msk = 0xff
	// Row is not included in the keypad key press detect.
	KPP_KPCR_KRE_KRE_0 = 0x0
	// Row is included in the keypad key press detect.
	KPP_KPCR_KRE_KRE_1 = 0x1
	// Position of KCO field.
	KPP_KPCR_KCO_Pos = 0x8
	// Bit mask of KCO field.
	KPP_KPCR_KCO_Msk = 0xff00
	// Column strobe output is totem pole drive.
	KPP_KPCR_KCO_TOTEM_POLE = 0x0
	// Column strobe output is open drain.
	KPP_KPCR_KCO_OPEN_DRAIN = 0x1

	// KPSR: Keypad Status Register
	// Position of KPKD field.
	KPP_KPSR_KPKD_Pos = 0x0
	// Bit mask of KPKD field.
	KPP_KPSR_KPKD_Msk = 0x1
	// Bit KPKD.
	KPP_KPSR_KPKD = 0x1
	// No key presses detected
	KPP_KPSR_KPKD_KPKD_0 = 0x0
	// A key has been depressed
	KPP_KPSR_KPKD_KPKD_1 = 0x1
	// Position of KPKR field.
	KPP_KPSR_KPKR_Pos = 0x1
	// Bit mask of KPKR field.
	KPP_KPSR_KPKR_Msk = 0x2
	// Bit KPKR.
	KPP_KPSR_KPKR = 0x2
	// No key release detected
	KPP_KPSR_KPKR_KPKR_0 = 0x0
	// All keys have been released
	KPP_KPSR_KPKR_KPKR_1 = 0x1
	// Position of KDSC field.
	KPP_KPSR_KDSC_Pos = 0x2
	// Bit mask of KDSC field.
	KPP_KPSR_KDSC_Msk = 0x4
	// Bit KDSC.
	KPP_KPSR_KDSC = 0x4
	// No effect
	KPP_KPSR_KDSC_KDSC_0 = 0x0
	// Set bits that clear the keypad depress synchronizer chain
	KPP_KPSR_KDSC_KDSC_1 = 0x1
	// Position of KRSS field.
	KPP_KPSR_KRSS_Pos = 0x3
	// Bit mask of KRSS field.
	KPP_KPSR_KRSS_Msk = 0x8
	// Bit KRSS.
	KPP_KPSR_KRSS = 0x8
	// No effect
	KPP_KPSR_KRSS_KRSS_0 = 0x0
	// Set bits which sets keypad release synchronizer chain
	KPP_KPSR_KRSS_KRSS_1 = 0x1
	// Position of KDIE field.
	KPP_KPSR_KDIE_Pos = 0x8
	// Bit mask of KDIE field.
	KPP_KPSR_KDIE_Msk = 0x100
	// Bit KDIE.
	KPP_KPSR_KDIE = 0x100
	// No interrupt request is generated when KPKD is set.
	KPP_KPSR_KDIE_KDIE_0 = 0x0
	// An interrupt request is generated when KPKD is set.
	KPP_KPSR_KDIE_KDIE_1 = 0x1
	// Position of KRIE field.
	KPP_KPSR_KRIE_Pos = 0x9
	// Bit mask of KRIE field.
	KPP_KPSR_KRIE_Msk = 0x200
	// Bit KRIE.
	KPP_KPSR_KRIE = 0x200
	// No interrupt request is generated when KPKR is set.
	KPP_KPSR_KRIE_KRIE_0 = 0x0
	// An interrupt request is generated when KPKR is set.
	KPP_KPSR_KRIE_KRIE_1 = 0x1

	// KDDR: Keypad Data Direction Register
	// Position of KRDD field.
	KPP_KDDR_KRDD_Pos = 0x0
	// Bit mask of KRDD field.
	KPP_KDDR_KRDD_Msk = 0xff
	// ROWn pin configured as an input.
	KPP_KDDR_KRDD_INPUT = 0x0
	// ROWn pin configured as an output.
	KPP_KDDR_KRDD_OUTPUT = 0x1
	// Position of KCDD field.
	KPP_KDDR_KCDD_Pos = 0x8
	// Bit mask of KCDD field.
	KPP_KDDR_KCDD_Msk = 0xff00
	// COLn pin is configured as an input.
	KPP_KDDR_KCDD_INPUT = 0x0
	// COLn pin is configured as an output.
	KPP_KDDR_KCDD_OUTPUT = 0x1

	// KPDR: Keypad Data Register
	// Position of KRD field.
	KPP_KPDR_KRD_Pos = 0x0
	// Bit mask of KRD field.
	KPP_KPDR_KRD_Msk = 0xff
	// Position of KCD field.
	KPP_KPDR_KCD_Pos = 0x8
	// Bit mask of KCD field.
	KPP_KPDR_KCD_Msk = 0xff00
)

// Bitfields for FLEXSPI: FlexSPI
const (
	// MCR0: Module Control Register 0
	// Position of SWRESET field.
	FlexSPI_MCR0_SWRESET_Pos = 0x0
	// Bit mask of SWRESET field.
	FlexSPI_MCR0_SWRESET_Msk = 0x1
	// Bit SWRESET.
	FlexSPI_MCR0_SWRESET = 0x1
	// Position of MDIS field.
	FlexSPI_MCR0_MDIS_Pos = 0x1
	// Bit mask of MDIS field.
	FlexSPI_MCR0_MDIS_Msk = 0x2
	// Bit MDIS.
	FlexSPI_MCR0_MDIS = 0x2
	// Position of RXCLKSRC field.
	FlexSPI_MCR0_RXCLKSRC_Pos = 0x4
	// Bit mask of RXCLKSRC field.
	FlexSPI_MCR0_RXCLKSRC_Msk = 0x30
	// Dummy Read strobe generated by FlexSPI Controller and loopback internally.
	FlexSPI_MCR0_RXCLKSRC_RXCLKSRC_0 = 0x0
	// Dummy Read strobe generated by FlexSPI Controller and loopback from DQS pad.
	FlexSPI_MCR0_RXCLKSRC_RXCLKSRC_1 = 0x1
	// Flash provided Read strobe and input from DQS pad
	FlexSPI_MCR0_RXCLKSRC_RXCLKSRC_3 = 0x3
	// Position of ARDFEN field.
	FlexSPI_MCR0_ARDFEN_Pos = 0x6
	// Bit mask of ARDFEN field.
	FlexSPI_MCR0_ARDFEN_Msk = 0x40
	// Bit ARDFEN.
	FlexSPI_MCR0_ARDFEN = 0x40
	// IP RX FIFO should be read by IP Bus. AHB Bus read access to IP RX FIFO memory space will get bus error response.
	FlexSPI_MCR0_ARDFEN_ARDFEN_0 = 0x0
	// IP RX FIFO should be read by AHB Bus. IP Bus read access to IP RX FIFO memory space will always return data zero but no bus error response.
	FlexSPI_MCR0_ARDFEN_ARDFEN_1 = 0x1
	// Position of ATDFEN field.
	FlexSPI_MCR0_ATDFEN_Pos = 0x7
	// Bit mask of ATDFEN field.
	FlexSPI_MCR0_ATDFEN_Msk = 0x80
	// Bit ATDFEN.
	FlexSPI_MCR0_ATDFEN = 0x80
	// IP TX FIFO should be written by IP Bus. AHB Bus write access to IP TX FIFO memory space will get bus error response.
	FlexSPI_MCR0_ATDFEN_ATDFEN_0 = 0x0
	// IP TX FIFO should be written by AHB Bus. IP Bus write access to IP TX FIFO memory space will be ignored but no bus error response.
	FlexSPI_MCR0_ATDFEN_ATDFEN_1 = 0x1
	// Position of HSEN field.
	FlexSPI_MCR0_HSEN_Pos = 0xb
	// Bit mask of HSEN field.
	FlexSPI_MCR0_HSEN_Msk = 0x800
	// Bit HSEN.
	FlexSPI_MCR0_HSEN = 0x800
	// Disable divide by 2 of serial flash clock for half speed commands.
	FlexSPI_MCR0_HSEN_HSEN_0 = 0x0
	// Enable divide by 2 of serial flash clock for half speed commands.
	FlexSPI_MCR0_HSEN_HSEN_1 = 0x1
	// Position of DOZEEN field.
	FlexSPI_MCR0_DOZEEN_Pos = 0xc
	// Bit mask of DOZEEN field.
	FlexSPI_MCR0_DOZEEN_Msk = 0x1000
	// Bit DOZEEN.
	FlexSPI_MCR0_DOZEEN = 0x1000
	// Doze mode support disabled. AHB clock and serial clock will not be gated off when there is doze mode request from system.
	FlexSPI_MCR0_DOZEEN_DOZEEN_0 = 0x0
	// Doze mode support enabled. AHB clock and serial clock will be gated off when there is doze mode request from system.
	FlexSPI_MCR0_DOZEEN_DOZEEN_1 = 0x1
	// Position of COMBINATIONEN field.
	FlexSPI_MCR0_COMBINATIONEN_Pos = 0xd
	// Bit mask of COMBINATIONEN field.
	FlexSPI_MCR0_COMBINATIONEN_Msk = 0x2000
	// Bit COMBINATIONEN.
	FlexSPI_MCR0_COMBINATIONEN = 0x2000
	// Disable.
	FlexSPI_MCR0_COMBINATIONEN_COMBINATIONEN_0 = 0x0
	// Enable.
	FlexSPI_MCR0_COMBINATIONEN_COMBINATIONEN_1 = 0x1
	// Position of SCKFREERUNEN field.
	FlexSPI_MCR0_SCKFREERUNEN_Pos = 0xe
	// Bit mask of SCKFREERUNEN field.
	FlexSPI_MCR0_SCKFREERUNEN_Msk = 0x4000
	// Bit SCKFREERUNEN.
	FlexSPI_MCR0_SCKFREERUNEN = 0x4000
	// Disable.
	FlexSPI_MCR0_SCKFREERUNEN_SCKFREERUNEN_0 = 0x0
	// Enable.
	FlexSPI_MCR0_SCKFREERUNEN_SCKFREERUNEN_1 = 0x1
	// Position of IPGRANTWAIT field.
	FlexSPI_MCR0_IPGRANTWAIT_Pos = 0x10
	// Bit mask of IPGRANTWAIT field.
	FlexSPI_MCR0_IPGRANTWAIT_Msk = 0xff0000
	// Position of AHBGRANTWAIT field.
	FlexSPI_MCR0_AHBGRANTWAIT_Pos = 0x18
	// Bit mask of AHBGRANTWAIT field.
	FlexSPI_MCR0_AHBGRANTWAIT_Msk = 0xff000000

	// MCR1: Module Control Register 1
	// Position of AHBBUSWAIT field.
	FlexSPI_MCR1_AHBBUSWAIT_Pos = 0x0
	// Bit mask of AHBBUSWAIT field.
	FlexSPI_MCR1_AHBBUSWAIT_Msk = 0xffff
	// Position of SEQWAIT field.
	FlexSPI_MCR1_SEQWAIT_Pos = 0x10
	// Bit mask of SEQWAIT field.
	FlexSPI_MCR1_SEQWAIT_Msk = 0xffff0000

	// MCR2: Module Control Register 2
	// Position of CLRAHBBUFOPT field.
	FlexSPI_MCR2_CLRAHBBUFOPT_Pos = 0xb
	// Bit mask of CLRAHBBUFOPT field.
	FlexSPI_MCR2_CLRAHBBUFOPT_Msk = 0x800
	// Bit CLRAHBBUFOPT.
	FlexSPI_MCR2_CLRAHBBUFOPT = 0x800
	// AHB RX/TX Buffer will not be cleaned automatically when FlexSPI return Stop mode ACK.
	FlexSPI_MCR2_CLRAHBBUFOPT_CLRAHBBUFOPT_0 = 0x0
	// AHB RX/TX Buffer will be cleaned automatically when FlexSPI return Stop mode ACK.
	FlexSPI_MCR2_CLRAHBBUFOPT_CLRAHBBUFOPT_1 = 0x1
	// Position of CLRLEARNPHASE field.
	FlexSPI_MCR2_CLRLEARNPHASE_Pos = 0xe
	// Bit mask of CLRLEARNPHASE field.
	FlexSPI_MCR2_CLRLEARNPHASE_Msk = 0x4000
	// Bit CLRLEARNPHASE.
	FlexSPI_MCR2_CLRLEARNPHASE = 0x4000
	// Position of SAMEDEVICEEN field.
	FlexSPI_MCR2_SAMEDEVICEEN_Pos = 0xf
	// Bit mask of SAMEDEVICEEN field.
	FlexSPI_MCR2_SAMEDEVICEEN_Msk = 0x8000
	// Bit SAMEDEVICEEN.
	FlexSPI_MCR2_SAMEDEVICEEN = 0x8000
	// In Individual mode, FLSHA1CRx/FLSHA2CRx/FLSHB1CRx/FLSHB2CRx register setting will be applied to Flash A1/A2/B1/B2 seperately. In Parallel mode, FLSHA1CRx register setting will be applied to Flash A1 and B1, FLSHA2CRx register setting will be applied to Flash A2 and B2. FLSHB1CRx/FLSHB2CRx register settings will be ignored.
	FlexSPI_MCR2_SAMEDEVICEEN_SAMEDEVICEEN_0 = 0x0
	// FLSHA1CR0/FLSHA1CR1/FLSHA1CR2 register settings will be applied to Flash A1/A2/B1/B2. FLSHA2CRx/FLSHB1CRx/FLSHB2CRx will be ignored.
	FlexSPI_MCR2_SAMEDEVICEEN_SAMEDEVICEEN_1 = 0x1
	// Position of SCKBDIFFOPT field.
	FlexSPI_MCR2_SCKBDIFFOPT_Pos = 0x13
	// Bit mask of SCKBDIFFOPT field.
	FlexSPI_MCR2_SCKBDIFFOPT_Msk = 0x80000
	// Bit SCKBDIFFOPT.
	FlexSPI_MCR2_SCKBDIFFOPT = 0x80000
	// SCKB pad is used as port B SCK clock output. Port B flash access is available.
	FlexSPI_MCR2_SCKBDIFFOPT_SCKBDIFFOPT_0 = 0x0
	// SCKB pad is used as port A SCK inverted clock output (Differential clock to SCKA). Port B flash access is not available.
	FlexSPI_MCR2_SCKBDIFFOPT_SCKBDIFFOPT_1 = 0x1
	// Position of RESUMEWAIT field.
	FlexSPI_MCR2_RESUMEWAIT_Pos = 0x18
	// Bit mask of RESUMEWAIT field.
	FlexSPI_MCR2_RESUMEWAIT_Msk = 0xff000000

	// AHBCR: AHB Bus Control Register
	// Position of APAREN field.
	FlexSPI_AHBCR_APAREN_Pos = 0x0
	// Bit mask of APAREN field.
	FlexSPI_AHBCR_APAREN_Msk = 0x1
	// Bit APAREN.
	FlexSPI_AHBCR_APAREN = 0x1
	// Flash will be accessed in Individual mode.
	FlexSPI_AHBCR_APAREN_APAREN_0 = 0x0
	// Flash will be accessed in Parallel mode.
	FlexSPI_AHBCR_APAREN_APAREN_1 = 0x1
	// Position of CACHABLEEN field.
	FlexSPI_AHBCR_CACHABLEEN_Pos = 0x3
	// Bit mask of CACHABLEEN field.
	FlexSPI_AHBCR_CACHABLEEN_Msk = 0x8
	// Bit CACHABLEEN.
	FlexSPI_AHBCR_CACHABLEEN = 0x8
	// Disabled. When there is AHB bus cachable read access, FlexSPI will not check whether it hit AHB TX Buffer.
	FlexSPI_AHBCR_CACHABLEEN_CACHABLEEN_0 = 0x0
	// Enabled. When there is AHB bus cachable read access, FlexSPI will check whether it hit AHB TX Buffer first.
	FlexSPI_AHBCR_CACHABLEEN_CACHABLEEN_1 = 0x1
	// Position of BUFFERABLEEN field.
	FlexSPI_AHBCR_BUFFERABLEEN_Pos = 0x4
	// Bit mask of BUFFERABLEEN field.
	FlexSPI_AHBCR_BUFFERABLEEN_Msk = 0x10
	// Bit BUFFERABLEEN.
	FlexSPI_AHBCR_BUFFERABLEEN = 0x10
	// Disabled. For all AHB write access (no matter bufferable or non-bufferable ), FlexSPI will return AHB Bus ready after all data is transmitted to External device and AHB command finished.
	FlexSPI_AHBCR_BUFFERABLEEN_BUFFERABLEEN_0 = 0x0
	// Enabled. For AHB bufferable write access, FlexSPI will return AHB Bus ready when the AHB command is granted by arbitrator and will not wait for AHB command finished.
	FlexSPI_AHBCR_BUFFERABLEEN_BUFFERABLEEN_1 = 0x1
	// Position of PREFETCHEN field.
	FlexSPI_AHBCR_PREFETCHEN_Pos = 0x5
	// Bit mask of PREFETCHEN field.
	FlexSPI_AHBCR_PREFETCHEN_Msk = 0x20
	// Bit PREFETCHEN.
	FlexSPI_AHBCR_PREFETCHEN = 0x20
	// Position of READADDROPT field.
	FlexSPI_AHBCR_READADDROPT_Pos = 0x6
	// Bit mask of READADDROPT field.
	FlexSPI_AHBCR_READADDROPT_Msk = 0x40
	// Bit READADDROPT.
	FlexSPI_AHBCR_READADDROPT = 0x40
	// There is AHB read burst start address alignment limitation when flash is accessed in parallel mode or flash is wordaddressable.
	FlexSPI_AHBCR_READADDROPT_READADDROPT_0 = 0x0
	// There is no AHB read burst start address alignment limitation. FlexSPI will fetch more datas than AHB burst required to meet the alignment requirement.
	FlexSPI_AHBCR_READADDROPT_READADDROPT_1 = 0x1

	// INTEN: Interrupt Enable Register
	// Position of IPCMDDONEEN field.
	FlexSPI_INTEN_IPCMDDONEEN_Pos = 0x0
	// Bit mask of IPCMDDONEEN field.
	FlexSPI_INTEN_IPCMDDONEEN_Msk = 0x1
	// Bit IPCMDDONEEN.
	FlexSPI_INTEN_IPCMDDONEEN = 0x1
	// Position of IPCMDGEEN field.
	FlexSPI_INTEN_IPCMDGEEN_Pos = 0x1
	// Bit mask of IPCMDGEEN field.
	FlexSPI_INTEN_IPCMDGEEN_Msk = 0x2
	// Bit IPCMDGEEN.
	FlexSPI_INTEN_IPCMDGEEN = 0x2
	// Position of AHBCMDGEEN field.
	FlexSPI_INTEN_AHBCMDGEEN_Pos = 0x2
	// Bit mask of AHBCMDGEEN field.
	FlexSPI_INTEN_AHBCMDGEEN_Msk = 0x4
	// Bit AHBCMDGEEN.
	FlexSPI_INTEN_AHBCMDGEEN = 0x4
	// Position of IPCMDERREN field.
	FlexSPI_INTEN_IPCMDERREN_Pos = 0x3
	// Bit mask of IPCMDERREN field.
	FlexSPI_INTEN_IPCMDERREN_Msk = 0x8
	// Bit IPCMDERREN.
	FlexSPI_INTEN_IPCMDERREN = 0x8
	// Position of AHBCMDERREN field.
	FlexSPI_INTEN_AHBCMDERREN_Pos = 0x4
	// Bit mask of AHBCMDERREN field.
	FlexSPI_INTEN_AHBCMDERREN_Msk = 0x10
	// Bit AHBCMDERREN.
	FlexSPI_INTEN_AHBCMDERREN = 0x10
	// Position of IPRXWAEN field.
	FlexSPI_INTEN_IPRXWAEN_Pos = 0x5
	// Bit mask of IPRXWAEN field.
	FlexSPI_INTEN_IPRXWAEN_Msk = 0x20
	// Bit IPRXWAEN.
	FlexSPI_INTEN_IPRXWAEN = 0x20
	// Position of IPTXWEEN field.
	FlexSPI_INTEN_IPTXWEEN_Pos = 0x6
	// Bit mask of IPTXWEEN field.
	FlexSPI_INTEN_IPTXWEEN_Msk = 0x40
	// Bit IPTXWEEN.
	FlexSPI_INTEN_IPTXWEEN = 0x40
	// Position of SCKSTOPBYRDEN field.
	FlexSPI_INTEN_SCKSTOPBYRDEN_Pos = 0x8
	// Bit mask of SCKSTOPBYRDEN field.
	FlexSPI_INTEN_SCKSTOPBYRDEN_Msk = 0x100
	// Bit SCKSTOPBYRDEN.
	FlexSPI_INTEN_SCKSTOPBYRDEN = 0x100
	// Position of SCKSTOPBYWREN field.
	FlexSPI_INTEN_SCKSTOPBYWREN_Pos = 0x9
	// Bit mask of SCKSTOPBYWREN field.
	FlexSPI_INTEN_SCKSTOPBYWREN_Msk = 0x200
	// Bit SCKSTOPBYWREN.
	FlexSPI_INTEN_SCKSTOPBYWREN = 0x200
	// Position of AHBBUSTIMEOUTEN field.
	FlexSPI_INTEN_AHBBUSTIMEOUTEN_Pos = 0xa
	// Bit mask of AHBBUSTIMEOUTEN field.
	FlexSPI_INTEN_AHBBUSTIMEOUTEN_Msk = 0x400
	// Bit AHBBUSTIMEOUTEN.
	FlexSPI_INTEN_AHBBUSTIMEOUTEN = 0x400
	// Position of SEQTIMEOUTEN field.
	FlexSPI_INTEN_SEQTIMEOUTEN_Pos = 0xb
	// Bit mask of SEQTIMEOUTEN field.
	FlexSPI_INTEN_SEQTIMEOUTEN_Msk = 0x800
	// Bit SEQTIMEOUTEN.
	FlexSPI_INTEN_SEQTIMEOUTEN = 0x800

	// INTR: Interrupt Register
	// Position of IPCMDDONE field.
	FlexSPI_INTR_IPCMDDONE_Pos = 0x0
	// Bit mask of IPCMDDONE field.
	FlexSPI_INTR_IPCMDDONE_Msk = 0x1
	// Bit IPCMDDONE.
	FlexSPI_INTR_IPCMDDONE = 0x1
	// Position of IPCMDGE field.
	FlexSPI_INTR_IPCMDGE_Pos = 0x1
	// Bit mask of IPCMDGE field.
	FlexSPI_INTR_IPCMDGE_Msk = 0x2
	// Bit IPCMDGE.
	FlexSPI_INTR_IPCMDGE = 0x2
	// Position of AHBCMDGE field.
	FlexSPI_INTR_AHBCMDGE_Pos = 0x2
	// Bit mask of AHBCMDGE field.
	FlexSPI_INTR_AHBCMDGE_Msk = 0x4
	// Bit AHBCMDGE.
	FlexSPI_INTR_AHBCMDGE = 0x4
	// Position of IPCMDERR field.
	FlexSPI_INTR_IPCMDERR_Pos = 0x3
	// Bit mask of IPCMDERR field.
	FlexSPI_INTR_IPCMDERR_Msk = 0x8
	// Bit IPCMDERR.
	FlexSPI_INTR_IPCMDERR = 0x8
	// Position of AHBCMDERR field.
	FlexSPI_INTR_AHBCMDERR_Pos = 0x4
	// Bit mask of AHBCMDERR field.
	FlexSPI_INTR_AHBCMDERR_Msk = 0x10
	// Bit AHBCMDERR.
	FlexSPI_INTR_AHBCMDERR = 0x10
	// Position of IPRXWA field.
	FlexSPI_INTR_IPRXWA_Pos = 0x5
	// Bit mask of IPRXWA field.
	FlexSPI_INTR_IPRXWA_Msk = 0x20
	// Bit IPRXWA.
	FlexSPI_INTR_IPRXWA = 0x20
	// Position of IPTXWE field.
	FlexSPI_INTR_IPTXWE_Pos = 0x6
	// Bit mask of IPTXWE field.
	FlexSPI_INTR_IPTXWE_Msk = 0x40
	// Bit IPTXWE.
	FlexSPI_INTR_IPTXWE = 0x40
	// Position of SCKSTOPBYRD field.
	FlexSPI_INTR_SCKSTOPBYRD_Pos = 0x8
	// Bit mask of SCKSTOPBYRD field.
	FlexSPI_INTR_SCKSTOPBYRD_Msk = 0x100
	// Bit SCKSTOPBYRD.
	FlexSPI_INTR_SCKSTOPBYRD = 0x100
	// Position of SCKSTOPBYWR field.
	FlexSPI_INTR_SCKSTOPBYWR_Pos = 0x9
	// Bit mask of SCKSTOPBYWR field.
	FlexSPI_INTR_SCKSTOPBYWR_Msk = 0x200
	// Bit SCKSTOPBYWR.
	FlexSPI_INTR_SCKSTOPBYWR = 0x200
	// Position of AHBBUSTIMEOUT field.
	FlexSPI_INTR_AHBBUSTIMEOUT_Pos = 0xa
	// Bit mask of AHBBUSTIMEOUT field.
	FlexSPI_INTR_AHBBUSTIMEOUT_Msk = 0x400
	// Bit AHBBUSTIMEOUT.
	FlexSPI_INTR_AHBBUSTIMEOUT = 0x400
	// Position of SEQTIMEOUT field.
	FlexSPI_INTR_SEQTIMEOUT_Pos = 0xb
	// Bit mask of SEQTIMEOUT field.
	FlexSPI_INTR_SEQTIMEOUT_Msk = 0x800
	// Bit SEQTIMEOUT.
	FlexSPI_INTR_SEQTIMEOUT = 0x800

	// LUTKEY: LUT Key Register
	// Position of KEY field.
	FlexSPI_LUTKEY_KEY_Pos = 0x0
	// Bit mask of KEY field.
	FlexSPI_LUTKEY_KEY_Msk = 0xffffffff

	// LUTCR: LUT Control Register
	// Position of LOCK field.
	FlexSPI_LUTCR_LOCK_Pos = 0x0
	// Bit mask of LOCK field.
	FlexSPI_LUTCR_LOCK_Msk = 0x1
	// Bit LOCK.
	FlexSPI_LUTCR_LOCK = 0x1
	// Position of UNLOCK field.
	FlexSPI_LUTCR_UNLOCK_Pos = 0x1
	// Bit mask of UNLOCK field.
	FlexSPI_LUTCR_UNLOCK_Msk = 0x2
	// Bit UNLOCK.
	FlexSPI_LUTCR_UNLOCK = 0x2

	// AHBRXBUF0CR0: AHB RX Buffer 0 Control Register 0
	// Position of BUFSZ field.
	FlexSPI_AHBRXBUF0CR0_BUFSZ_Pos = 0x0
	// Bit mask of BUFSZ field.
	FlexSPI_AHBRXBUF0CR0_BUFSZ_Msk = 0xff
	// Position of MSTRID field.
	FlexSPI_AHBRXBUF0CR0_MSTRID_Pos = 0x10
	// Bit mask of MSTRID field.
	FlexSPI_AHBRXBUF0CR0_MSTRID_Msk = 0xf0000
	// Position of PRIORITY field.
	FlexSPI_AHBRXBUF0CR0_PRIORITY_Pos = 0x18
	// Bit mask of PRIORITY field.
	FlexSPI_AHBRXBUF0CR0_PRIORITY_Msk = 0x3000000
	// Position of PREFETCHEN field.
	FlexSPI_AHBRXBUF0CR0_PREFETCHEN_Pos = 0x1f
	// Bit mask of PREFETCHEN field.
	FlexSPI_AHBRXBUF0CR0_PREFETCHEN_Msk = 0x80000000
	// Bit PREFETCHEN.
	FlexSPI_AHBRXBUF0CR0_PREFETCHEN = 0x80000000

	// AHBRXBUF1CR0: AHB RX Buffer 1 Control Register 0
	// Position of BUFSZ field.
	FlexSPI_AHBRXBUF1CR0_BUFSZ_Pos = 0x0
	// Bit mask of BUFSZ field.
	FlexSPI_AHBRXBUF1CR0_BUFSZ_Msk = 0xff
	// Position of MSTRID field.
	FlexSPI_AHBRXBUF1CR0_MSTRID_Pos = 0x10
	// Bit mask of MSTRID field.
	FlexSPI_AHBRXBUF1CR0_MSTRID_Msk = 0xf0000
	// Position of PRIORITY field.
	FlexSPI_AHBRXBUF1CR0_PRIORITY_Pos = 0x18
	// Bit mask of PRIORITY field.
	FlexSPI_AHBRXBUF1CR0_PRIORITY_Msk = 0x3000000
	// Position of PREFETCHEN field.
	FlexSPI_AHBRXBUF1CR0_PREFETCHEN_Pos = 0x1f
	// Bit mask of PREFETCHEN field.
	FlexSPI_AHBRXBUF1CR0_PREFETCHEN_Msk = 0x80000000
	// Bit PREFETCHEN.
	FlexSPI_AHBRXBUF1CR0_PREFETCHEN = 0x80000000

	// AHBRXBUF2CR0: AHB RX Buffer 2 Control Register 0
	// Position of BUFSZ field.
	FlexSPI_AHBRXBUF2CR0_BUFSZ_Pos = 0x0
	// Bit mask of BUFSZ field.
	FlexSPI_AHBRXBUF2CR0_BUFSZ_Msk = 0xff
	// Position of MSTRID field.
	FlexSPI_AHBRXBUF2CR0_MSTRID_Pos = 0x10
	// Bit mask of MSTRID field.
	FlexSPI_AHBRXBUF2CR0_MSTRID_Msk = 0xf0000
	// Position of PRIORITY field.
	FlexSPI_AHBRXBUF2CR0_PRIORITY_Pos = 0x18
	// Bit mask of PRIORITY field.
	FlexSPI_AHBRXBUF2CR0_PRIORITY_Msk = 0x3000000
	// Position of PREFETCHEN field.
	FlexSPI_AHBRXBUF2CR0_PREFETCHEN_Pos = 0x1f
	// Bit mask of PREFETCHEN field.
	FlexSPI_AHBRXBUF2CR0_PREFETCHEN_Msk = 0x80000000
	// Bit PREFETCHEN.
	FlexSPI_AHBRXBUF2CR0_PREFETCHEN = 0x80000000

	// AHBRXBUF3CR0: AHB RX Buffer 3 Control Register 0
	// Position of BUFSZ field.
	FlexSPI_AHBRXBUF3CR0_BUFSZ_Pos = 0x0
	// Bit mask of BUFSZ field.
	FlexSPI_AHBRXBUF3CR0_BUFSZ_Msk = 0xff
	// Position of MSTRID field.
	FlexSPI_AHBRXBUF3CR0_MSTRID_Pos = 0x10
	// Bit mask of MSTRID field.
	FlexSPI_AHBRXBUF3CR0_MSTRID_Msk = 0xf0000
	// Position of PRIORITY field.
	FlexSPI_AHBRXBUF3CR0_PRIORITY_Pos = 0x18
	// Bit mask of PRIORITY field.
	FlexSPI_AHBRXBUF3CR0_PRIORITY_Msk = 0x3000000
	// Position of PREFETCHEN field.
	FlexSPI_AHBRXBUF3CR0_PREFETCHEN_Pos = 0x1f
	// Bit mask of PREFETCHEN field.
	FlexSPI_AHBRXBUF3CR0_PREFETCHEN_Msk = 0x80000000
	// Bit PREFETCHEN.
	FlexSPI_AHBRXBUF3CR0_PREFETCHEN = 0x80000000

	// FLSHA1CR0: Flash A1 Control Register 0
	// Position of FLSHSZ field.
	FlexSPI_FLSHA1CR0_FLSHSZ_Pos = 0x0
	// Bit mask of FLSHSZ field.
	FlexSPI_FLSHA1CR0_FLSHSZ_Msk = 0x7fffff

	// FLSHA2CR0: Flash A2 Control Register 0
	// Position of FLSHSZ field.
	FlexSPI_FLSHA2CR0_FLSHSZ_Pos = 0x0
	// Bit mask of FLSHSZ field.
	FlexSPI_FLSHA2CR0_FLSHSZ_Msk = 0x7fffff

	// FLSHB1CR0: Flash B1 Control Register 0
	// Position of FLSHSZ field.
	FlexSPI_FLSHB1CR0_FLSHSZ_Pos = 0x0
	// Bit mask of FLSHSZ field.
	FlexSPI_FLSHB1CR0_FLSHSZ_Msk = 0x7fffff

	// FLSHB2CR0: Flash B2 Control Register 0
	// Position of FLSHSZ field.
	FlexSPI_FLSHB2CR0_FLSHSZ_Pos = 0x0
	// Bit mask of FLSHSZ field.
	FlexSPI_FLSHB2CR0_FLSHSZ_Msk = 0x7fffff

	// FLSHCR1A1: Flash A1 Control Register 1
	// Position of TCSS field.
	FlexSPI_FLSHCR1_TCSS_Pos = 0x0
	// Bit mask of TCSS field.
	FlexSPI_FLSHCR1_TCSS_Msk = 0x1f
	// Position of TCSH field.
	FlexSPI_FLSHCR1_TCSH_Pos = 0x5
	// Bit mask of TCSH field.
	FlexSPI_FLSHCR1_TCSH_Msk = 0x3e0
	// Position of WA field.
	FlexSPI_FLSHCR1_WA_Pos = 0xa
	// Bit mask of WA field.
	FlexSPI_FLSHCR1_WA_Msk = 0x400
	// Bit WA.
	FlexSPI_FLSHCR1_WA = 0x400
	// Position of CAS field.
	FlexSPI_FLSHCR1_CAS_Pos = 0xb
	// Bit mask of CAS field.
	FlexSPI_FLSHCR1_CAS_Msk = 0x7800
	// Position of CSINTERVALUNIT field.
	FlexSPI_FLSHCR1_CSINTERVALUNIT_Pos = 0xf
	// Bit mask of CSINTERVALUNIT field.
	FlexSPI_FLSHCR1_CSINTERVALUNIT_Msk = 0x8000
	// Bit CSINTERVALUNIT.
	FlexSPI_FLSHCR1_CSINTERVALUNIT = 0x8000
	// The CS interval unit is 1 serial clock cycle
	FlexSPI_FLSHCR1_CSINTERVALUNIT_CSINTERVALUNIT_0 = 0x0
	// The CS interval unit is 256 serial clock cycle
	FlexSPI_FLSHCR1_CSINTERVALUNIT_CSINTERVALUNIT_1 = 0x1
	// Position of CSINTERVAL field.
	FlexSPI_FLSHCR1_CSINTERVAL_Pos = 0x10
	// Bit mask of CSINTERVAL field.
	FlexSPI_FLSHCR1_CSINTERVAL_Msk = 0xffff0000

	// FLSHCR2A1: Flash A1 Control Register 2
	// Position of ARDSEQID field.
	FlexSPI_FLSHCR2_ARDSEQID_Pos = 0x0
	// Bit mask of ARDSEQID field.
	FlexSPI_FLSHCR2_ARDSEQID_Msk = 0xf
	// Position of ARDSEQNUM field.
	FlexSPI_FLSHCR2_ARDSEQNUM_Pos = 0x5
	// Bit mask of ARDSEQNUM field.
	FlexSPI_FLSHCR2_ARDSEQNUM_Msk = 0xe0
	// Position of AWRSEQID field.
	FlexSPI_FLSHCR2_AWRSEQID_Pos = 0x8
	// Bit mask of AWRSEQID field.
	FlexSPI_FLSHCR2_AWRSEQID_Msk = 0xf00
	// Position of AWRSEQNUM field.
	FlexSPI_FLSHCR2_AWRSEQNUM_Pos = 0xd
	// Bit mask of AWRSEQNUM field.
	FlexSPI_FLSHCR2_AWRSEQNUM_Msk = 0xe000
	// Position of AWRWAIT field.
	FlexSPI_FLSHCR2_AWRWAIT_Pos = 0x10
	// Bit mask of AWRWAIT field.
	FlexSPI_FLSHCR2_AWRWAIT_Msk = 0xfff0000
	// Position of AWRWAITUNIT field.
	FlexSPI_FLSHCR2_AWRWAITUNIT_Pos = 0x1c
	// Bit mask of AWRWAITUNIT field.
	FlexSPI_FLSHCR2_AWRWAITUNIT_Msk = 0x70000000
	// The AWRWAIT unit is 2 ahb clock cycle
	FlexSPI_FLSHCR2_AWRWAITUNIT_AWRWAITUNIT_0 = 0x0
	// The AWRWAIT unit is 8 ahb clock cycle
	FlexSPI_FLSHCR2_AWRWAITUNIT_AWRWAITUNIT_1 = 0x1
	// The AWRWAIT unit is 32 ahb clock cycle
	FlexSPI_FLSHCR2_AWRWAITUNIT_AWRWAITUNIT_2 = 0x2
	// The AWRWAIT unit is 128 ahb clock cycle
	FlexSPI_FLSHCR2_AWRWAITUNIT_AWRWAITUNIT_3 = 0x3
	// The AWRWAIT unit is 512 ahb clock cycle
	FlexSPI_FLSHCR2_AWRWAITUNIT_AWRWAITUNIT_4 = 0x4
	// The AWRWAIT unit is 2048 ahb clock cycle
	FlexSPI_FLSHCR2_AWRWAITUNIT_AWRWAITUNIT_5 = 0x5
	// The AWRWAIT unit is 8192 ahb clock cycle
	FlexSPI_FLSHCR2_AWRWAITUNIT_AWRWAITUNIT_6 = 0x6
	// The AWRWAIT unit is 32768 ahb clock cycle
	FlexSPI_FLSHCR2_AWRWAITUNIT_AWRWAITUNIT_7 = 0x7
	// Position of CLRINSTRPTR field.
	FlexSPI_FLSHCR2_CLRINSTRPTR_Pos = 0x1f
	// Bit mask of CLRINSTRPTR field.
	FlexSPI_FLSHCR2_CLRINSTRPTR_Msk = 0x80000000
	// Bit CLRINSTRPTR.
	FlexSPI_FLSHCR2_CLRINSTRPTR = 0x80000000

	// FLSHCR4: Flash Control Register 4
	// Position of WMOPT1 field.
	FlexSPI_FLSHCR4_WMOPT1_Pos = 0x0
	// Bit mask of WMOPT1 field.
	FlexSPI_FLSHCR4_WMOPT1_Msk = 0x1
	// Bit WMOPT1.
	FlexSPI_FLSHCR4_WMOPT1 = 0x1
	// DQS pin will be used as Write Mask when writing to external device. There is no limitation on AHB write burst start address alignment when flash is accessed in individual mode.
	FlexSPI_FLSHCR4_WMOPT1_WMOPT1_0 = 0x0
	// DQS pin will not be used as Write Mask when writing to external device. There is limitation on AHB write burst start address alignment when flash is accessed in individual mode.
	FlexSPI_FLSHCR4_WMOPT1_WMOPT1_1 = 0x1
	// Position of WMENA field.
	FlexSPI_FLSHCR4_WMENA_Pos = 0x2
	// Bit mask of WMENA field.
	FlexSPI_FLSHCR4_WMENA_Msk = 0x4
	// Bit WMENA.
	FlexSPI_FLSHCR4_WMENA = 0x4
	// Write mask is disabled, DQS(RWDS) pin will be un-driven when writing to external device.
	FlexSPI_FLSHCR4_WMENA_WMENA_0 = 0x0
	// Write mask is enabled, DQS(RWDS) pin will be driven by FlexSPI as write mask output when writing to external device.
	FlexSPI_FLSHCR4_WMENA_WMENA_1 = 0x1
	// Position of WMENB field.
	FlexSPI_FLSHCR4_WMENB_Pos = 0x3
	// Bit mask of WMENB field.
	FlexSPI_FLSHCR4_WMENB_Msk = 0x8
	// Bit WMENB.
	FlexSPI_FLSHCR4_WMENB = 0x8
	// Write mask is disabled, DQS(RWDS) pin will be un-driven when writing to external device.
	FlexSPI_FLSHCR4_WMENB_WMENB_0 = 0x0
	// Write mask is enabled, DQS(RWDS) pin will be driven by FlexSPI as write mask output when writing to external device.
	FlexSPI_FLSHCR4_WMENB_WMENB_1 = 0x1

	// IPCR0: IP Control Register 0
	// Position of SFAR field.
	FlexSPI_IPCR0_SFAR_Pos = 0x0
	// Bit mask of SFAR field.
	FlexSPI_IPCR0_SFAR_Msk = 0xffffffff

	// IPCR1: IP Control Register 1
	// Position of IDATSZ field.
	FlexSPI_IPCR1_IDATSZ_Pos = 0x0
	// Bit mask of IDATSZ field.
	FlexSPI_IPCR1_IDATSZ_Msk = 0xffff
	// Position of ISEQID field.
	FlexSPI_IPCR1_ISEQID_Pos = 0x10
	// Bit mask of ISEQID field.
	FlexSPI_IPCR1_ISEQID_Msk = 0xf0000
	// Position of ISEQNUM field.
	FlexSPI_IPCR1_ISEQNUM_Pos = 0x18
	// Bit mask of ISEQNUM field.
	FlexSPI_IPCR1_ISEQNUM_Msk = 0x7000000
	// Position of IPAREN field.
	FlexSPI_IPCR1_IPAREN_Pos = 0x1f
	// Bit mask of IPAREN field.
	FlexSPI_IPCR1_IPAREN_Msk = 0x80000000
	// Bit IPAREN.
	FlexSPI_IPCR1_IPAREN = 0x80000000
	// Flash will be accessed in Individual mode.
	FlexSPI_IPCR1_IPAREN_IPAREN_0 = 0x0
	// Flash will be accessed in Parallel mode.
	FlexSPI_IPCR1_IPAREN_IPAREN_1 = 0x1

	// IPCMD: IP Command Register
	// Position of TRG field.
	FlexSPI_IPCMD_TRG_Pos = 0x0
	// Bit mask of TRG field.
	FlexSPI_IPCMD_TRG_Msk = 0x1
	// Bit TRG.
	FlexSPI_IPCMD_TRG = 0x1

	// IPRXFCR: IP RX FIFO Control Register
	// Position of CLRIPRXF field.
	FlexSPI_IPRXFCR_CLRIPRXF_Pos = 0x0
	// Bit mask of CLRIPRXF field.
	FlexSPI_IPRXFCR_CLRIPRXF_Msk = 0x1
	// Bit CLRIPRXF.
	FlexSPI_IPRXFCR_CLRIPRXF = 0x1
	// Position of RXDMAEN field.
	FlexSPI_IPRXFCR_RXDMAEN_Pos = 0x1
	// Bit mask of RXDMAEN field.
	FlexSPI_IPRXFCR_RXDMAEN_Msk = 0x2
	// Bit RXDMAEN.
	FlexSPI_IPRXFCR_RXDMAEN = 0x2
	// IP RX FIFO would be read by processor.
	FlexSPI_IPRXFCR_RXDMAEN_RXDMAEN_0 = 0x0
	// IP RX FIFO would be read by DMA.
	FlexSPI_IPRXFCR_RXDMAEN_RXDMAEN_1 = 0x1
	// Position of RXWMRK field.
	FlexSPI_IPRXFCR_RXWMRK_Pos = 0x2
	// Bit mask of RXWMRK field.
	FlexSPI_IPRXFCR_RXWMRK_Msk = 0x3c

	// IPTXFCR: IP TX FIFO Control Register
	// Position of CLRIPTXF field.
	FlexSPI_IPTXFCR_CLRIPTXF_Pos = 0x0
	// Bit mask of CLRIPTXF field.
	FlexSPI_IPTXFCR_CLRIPTXF_Msk = 0x1
	// Bit CLRIPTXF.
	FlexSPI_IPTXFCR_CLRIPTXF = 0x1
	// Position of TXDMAEN field.
	FlexSPI_IPTXFCR_TXDMAEN_Pos = 0x1
	// Bit mask of TXDMAEN field.
	FlexSPI_IPTXFCR_TXDMAEN_Msk = 0x2
	// Bit TXDMAEN.
	FlexSPI_IPTXFCR_TXDMAEN = 0x2
	// IP TX FIFO would be filled by processor.
	FlexSPI_IPTXFCR_TXDMAEN_TXDMAEN_0 = 0x0
	// IP TX FIFO would be filled by DMA.
	FlexSPI_IPTXFCR_TXDMAEN_TXDMAEN_1 = 0x1
	// Position of TXWMRK field.
	FlexSPI_IPTXFCR_TXWMRK_Pos = 0x2
	// Bit mask of TXWMRK field.
	FlexSPI_IPTXFCR_TXWMRK_Msk = 0x3c

	// DLLCRA: DLL Control Register 0
	// Position of DLLEN field.
	FlexSPI_DLLCR_DLLEN_Pos = 0x0
	// Bit mask of DLLEN field.
	FlexSPI_DLLCR_DLLEN_Msk = 0x1
	// Bit DLLEN.
	FlexSPI_DLLCR_DLLEN = 0x1
	// Position of DLLRESET field.
	FlexSPI_DLLCR_DLLRESET_Pos = 0x1
	// Bit mask of DLLRESET field.
	FlexSPI_DLLCR_DLLRESET_Msk = 0x2
	// Bit DLLRESET.
	FlexSPI_DLLCR_DLLRESET = 0x2
	// Position of SLVDLYTARGET field.
	FlexSPI_DLLCR_SLVDLYTARGET_Pos = 0x3
	// Bit mask of SLVDLYTARGET field.
	FlexSPI_DLLCR_SLVDLYTARGET_Msk = 0x78
	// Position of OVRDEN field.
	FlexSPI_DLLCR_OVRDEN_Pos = 0x8
	// Bit mask of OVRDEN field.
	FlexSPI_DLLCR_OVRDEN_Msk = 0x100
	// Bit OVRDEN.
	FlexSPI_DLLCR_OVRDEN = 0x100
	// Position of OVRDVAL field.
	FlexSPI_DLLCR_OVRDVAL_Pos = 0x9
	// Bit mask of OVRDVAL field.
	FlexSPI_DLLCR_OVRDVAL_Msk = 0x7e00

	// STS0: Status Register 0
	// Position of SEQIDLE field.
	FlexSPI_STS0_SEQIDLE_Pos = 0x0
	// Bit mask of SEQIDLE field.
	FlexSPI_STS0_SEQIDLE_Msk = 0x1
	// Bit SEQIDLE.
	FlexSPI_STS0_SEQIDLE = 0x1
	// Position of ARBIDLE field.
	FlexSPI_STS0_ARBIDLE_Pos = 0x1
	// Bit mask of ARBIDLE field.
	FlexSPI_STS0_ARBIDLE_Msk = 0x2
	// Bit ARBIDLE.
	FlexSPI_STS0_ARBIDLE = 0x2
	// Position of ARBCMDSRC field.
	FlexSPI_STS0_ARBCMDSRC_Pos = 0x2
	// Bit mask of ARBCMDSRC field.
	FlexSPI_STS0_ARBCMDSRC_Msk = 0xc
	// Triggered by AHB read command (triggered by AHB read).
	FlexSPI_STS0_ARBCMDSRC_ARBCMDSRC_0 = 0x0
	// Triggered by AHB write command (triggered by AHB Write).
	FlexSPI_STS0_ARBCMDSRC_ARBCMDSRC_1 = 0x1
	// Triggered by IP command (triggered by setting register bit IPCMD.TRG).
	FlexSPI_STS0_ARBCMDSRC_ARBCMDSRC_2 = 0x2
	// Triggered by suspended command (resumed).
	FlexSPI_STS0_ARBCMDSRC_ARBCMDSRC_3 = 0x3

	// STS1: Status Register 1
	// Position of AHBCMDERRID field.
	FlexSPI_STS1_AHBCMDERRID_Pos = 0x0
	// Bit mask of AHBCMDERRID field.
	FlexSPI_STS1_AHBCMDERRID_Msk = 0xf
	// Position of AHBCMDERRCODE field.
	FlexSPI_STS1_AHBCMDERRCODE_Pos = 0x8
	// Bit mask of AHBCMDERRCODE field.
	FlexSPI_STS1_AHBCMDERRCODE_Msk = 0xf00
	// No error.
	FlexSPI_STS1_AHBCMDERRCODE_AHBCMDERRCODE_0 = 0x0
	// AHB Write command with JMP_ON_CS instruction used in the sequence.
	FlexSPI_STS1_AHBCMDERRCODE_AHBCMDERRCODE_2 = 0x2
	// There is unknown instruction opcode in the sequence.
	FlexSPI_STS1_AHBCMDERRCODE_AHBCMDERRCODE_3 = 0x3
	// Instruction DUMMY_SDR/DUMMY_RWDS_SDR used in DDR sequence.
	FlexSPI_STS1_AHBCMDERRCODE_AHBCMDERRCODE_4 = 0x4
	// Instruction DUMMY_DDR/DUMMY_RWDS_DDR used in SDR sequence.
	FlexSPI_STS1_AHBCMDERRCODE_AHBCMDERRCODE_5 = 0x5
	// Sequence execution timeout.
	FlexSPI_STS1_AHBCMDERRCODE_AHBCMDERRCODE_14 = 0xe
	// Position of IPCMDERRID field.
	FlexSPI_STS1_IPCMDERRID_Pos = 0x10
	// Bit mask of IPCMDERRID field.
	FlexSPI_STS1_IPCMDERRID_Msk = 0xf0000
	// Position of IPCMDERRCODE field.
	FlexSPI_STS1_IPCMDERRCODE_Pos = 0x18
	// Bit mask of IPCMDERRCODE field.
	FlexSPI_STS1_IPCMDERRCODE_Msk = 0xf000000
	// No error.
	FlexSPI_STS1_IPCMDERRCODE_IPCMDERRCODE_0 = 0x0
	// IP command with JMP_ON_CS instruction used in the sequence.
	FlexSPI_STS1_IPCMDERRCODE_IPCMDERRCODE_2 = 0x2
	// There is unknown instruction opcode in the sequence.
	FlexSPI_STS1_IPCMDERRCODE_IPCMDERRCODE_3 = 0x3
	// Instruction DUMMY_SDR/DUMMY_RWDS_SDR used in DDR sequence.
	FlexSPI_STS1_IPCMDERRCODE_IPCMDERRCODE_4 = 0x4
	// Instruction DUMMY_DDR/DUMMY_RWDS_DDR used in SDR sequence.
	FlexSPI_STS1_IPCMDERRCODE_IPCMDERRCODE_5 = 0x5
	// Flash access start address exceed the whole flash address range (A1/A2/B1/B2).
	FlexSPI_STS1_IPCMDERRCODE_IPCMDERRCODE_6 = 0x6
	// Sequence execution timeout.
	FlexSPI_STS1_IPCMDERRCODE_IPCMDERRCODE_14 = 0xe
	// Flash boundary crossed.
	FlexSPI_STS1_IPCMDERRCODE_IPCMDERRCODE_15 = 0xf

	// STS2: Status Register 2
	// Position of ASLVLOCK field.
	FlexSPI_STS2_ASLVLOCK_Pos = 0x0
	// Bit mask of ASLVLOCK field.
	FlexSPI_STS2_ASLVLOCK_Msk = 0x1
	// Bit ASLVLOCK.
	FlexSPI_STS2_ASLVLOCK = 0x1
	// Position of AREFLOCK field.
	FlexSPI_STS2_AREFLOCK_Pos = 0x1
	// Bit mask of AREFLOCK field.
	FlexSPI_STS2_AREFLOCK_Msk = 0x2
	// Bit AREFLOCK.
	FlexSPI_STS2_AREFLOCK = 0x2
	// Position of ASLVSEL field.
	FlexSPI_STS2_ASLVSEL_Pos = 0x2
	// Bit mask of ASLVSEL field.
	FlexSPI_STS2_ASLVSEL_Msk = 0xfc
	// Position of AREFSEL field.
	FlexSPI_STS2_AREFSEL_Pos = 0x8
	// Bit mask of AREFSEL field.
	FlexSPI_STS2_AREFSEL_Msk = 0x3f00
	// Position of BSLVLOCK field.
	FlexSPI_STS2_BSLVLOCK_Pos = 0x10
	// Bit mask of BSLVLOCK field.
	FlexSPI_STS2_BSLVLOCK_Msk = 0x10000
	// Bit BSLVLOCK.
	FlexSPI_STS2_BSLVLOCK = 0x10000
	// Position of BREFLOCK field.
	FlexSPI_STS2_BREFLOCK_Pos = 0x11
	// Bit mask of BREFLOCK field.
	FlexSPI_STS2_BREFLOCK_Msk = 0x20000
	// Bit BREFLOCK.
	FlexSPI_STS2_BREFLOCK = 0x20000
	// Position of BSLVSEL field.
	FlexSPI_STS2_BSLVSEL_Pos = 0x12
	// Bit mask of BSLVSEL field.
	FlexSPI_STS2_BSLVSEL_Msk = 0xfc0000
	// Position of BREFSEL field.
	FlexSPI_STS2_BREFSEL_Pos = 0x18
	// Bit mask of BREFSEL field.
	FlexSPI_STS2_BREFSEL_Msk = 0x3f000000

	// AHBSPNDSTS: AHB Suspend Status Register
	// Position of ACTIVE field.
	FlexSPI_AHBSPNDSTS_ACTIVE_Pos = 0x0
	// Bit mask of ACTIVE field.
	FlexSPI_AHBSPNDSTS_ACTIVE_Msk = 0x1
	// Bit ACTIVE.
	FlexSPI_AHBSPNDSTS_ACTIVE = 0x1
	// Position of BUFID field.
	FlexSPI_AHBSPNDSTS_BUFID_Pos = 0x1
	// Bit mask of BUFID field.
	FlexSPI_AHBSPNDSTS_BUFID_Msk = 0xe
	// Position of DATLFT field.
	FlexSPI_AHBSPNDSTS_DATLFT_Pos = 0x10
	// Bit mask of DATLFT field.
	FlexSPI_AHBSPNDSTS_DATLFT_Msk = 0xffff0000

	// IPRXFSTS: IP RX FIFO Status Register
	// Position of FILL field.
	FlexSPI_IPRXFSTS_FILL_Pos = 0x0
	// Bit mask of FILL field.
	FlexSPI_IPRXFSTS_FILL_Msk = 0xff
	// Position of RDCNTR field.
	FlexSPI_IPRXFSTS_RDCNTR_Pos = 0x10
	// Bit mask of RDCNTR field.
	FlexSPI_IPRXFSTS_RDCNTR_Msk = 0xffff0000

	// IPTXFSTS: IP TX FIFO Status Register
	// Position of FILL field.
	FlexSPI_IPTXFSTS_FILL_Pos = 0x0
	// Bit mask of FILL field.
	FlexSPI_IPTXFSTS_FILL_Msk = 0xff
	// Position of WRCNTR field.
	FlexSPI_IPTXFSTS_WRCNTR_Pos = 0x10
	// Bit mask of WRCNTR field.
	FlexSPI_IPTXFSTS_WRCNTR_Msk = 0xffff0000

	// RFDR: IP RX FIFO Data Register 0
	// Position of RXDATA field.
	FlexSPI_RFDR_RXDATA_Pos = 0x0
	// Bit mask of RXDATA field.
	FlexSPI_RFDR_RXDATA_Msk = 0xffffffff

	// TFDR: IP TX FIFO Data Register 0
	// Position of TXDATA field.
	FlexSPI_TFDR_TXDATA_Pos = 0x0
	// Bit mask of TXDATA field.
	FlexSPI_TFDR_TXDATA_Msk = 0xffffffff

	// LUT: LUT 0
	// Position of OPERAND0 field.
	FlexSPI_LUT_OPERAND0_Pos = 0x0
	// Bit mask of OPERAND0 field.
	FlexSPI_LUT_OPERAND0_Msk = 0xff
	// Position of NUM_PADS0 field.
	FlexSPI_LUT_NUM_PADS0_Pos = 0x8
	// Bit mask of NUM_PADS0 field.
	FlexSPI_LUT_NUM_PADS0_Msk = 0x300
	// Position of OPCODE0 field.
	FlexSPI_LUT_OPCODE0_Pos = 0xa
	// Bit mask of OPCODE0 field.
	FlexSPI_LUT_OPCODE0_Msk = 0xfc00
	// Position of OPERAND1 field.
	FlexSPI_LUT_OPERAND1_Pos = 0x10
	// Bit mask of OPERAND1 field.
	FlexSPI_LUT_OPERAND1_Msk = 0xff0000
	// Position of NUM_PADS1 field.
	FlexSPI_LUT_NUM_PADS1_Pos = 0x18
	// Bit mask of NUM_PADS1 field.
	FlexSPI_LUT_NUM_PADS1_Msk = 0x3000000
	// Position of OPCODE1 field.
	FlexSPI_LUT_OPCODE1_Pos = 0x1a
	// Bit mask of OPCODE1 field.
	FlexSPI_LUT_OPCODE1_Msk = 0xfc000000
)

// Bitfields for PXP: PXP v2.0 Register Reference Index
const (
	// CTRL: Control Register 0
	// Position of ENABLE field.
	PXP_CTRL_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	PXP_CTRL_ENABLE_Msk = 0x1
	// Bit ENABLE.
	PXP_CTRL_ENABLE = 0x1
	// Position of IRQ_ENABLE field.
	PXP_CTRL_IRQ_ENABLE_Pos = 0x1
	// Bit mask of IRQ_ENABLE field.
	PXP_CTRL_IRQ_ENABLE_Msk = 0x2
	// Bit IRQ_ENABLE.
	PXP_CTRL_IRQ_ENABLE = 0x2
	// Position of NEXT_IRQ_ENABLE field.
	PXP_CTRL_NEXT_IRQ_ENABLE_Pos = 0x2
	// Bit mask of NEXT_IRQ_ENABLE field.
	PXP_CTRL_NEXT_IRQ_ENABLE_Msk = 0x4
	// Bit NEXT_IRQ_ENABLE.
	PXP_CTRL_NEXT_IRQ_ENABLE = 0x4
	// Position of ENABLE_LCD_HANDSHAKE field.
	PXP_CTRL_ENABLE_LCD_HANDSHAKE_Pos = 0x4
	// Bit mask of ENABLE_LCD_HANDSHAKE field.
	PXP_CTRL_ENABLE_LCD_HANDSHAKE_Msk = 0x10
	// Bit ENABLE_LCD_HANDSHAKE.
	PXP_CTRL_ENABLE_LCD_HANDSHAKE = 0x10
	// Position of RSVD0 field.
	PXP_CTRL_RSVD0_Pos = 0x5
	// Bit mask of RSVD0 field.
	PXP_CTRL_RSVD0_Msk = 0xe0
	// Position of ROTATE field.
	PXP_CTRL_ROTATE_Pos = 0x8
	// Bit mask of ROTATE field.
	PXP_CTRL_ROTATE_Msk = 0x300
	// ROT_0
	PXP_CTRL_ROTATE_ROT_0 = 0x0
	// ROT_90
	PXP_CTRL_ROTATE_ROT_90 = 0x1
	// ROT_180
	PXP_CTRL_ROTATE_ROT_180 = 0x2
	// ROT_270
	PXP_CTRL_ROTATE_ROT_270 = 0x3
	// Position of HFLIP field.
	PXP_CTRL_HFLIP_Pos = 0xa
	// Bit mask of HFLIP field.
	PXP_CTRL_HFLIP_Msk = 0x400
	// Bit HFLIP.
	PXP_CTRL_HFLIP = 0x400
	// Position of VFLIP field.
	PXP_CTRL_VFLIP_Pos = 0xb
	// Bit mask of VFLIP field.
	PXP_CTRL_VFLIP_Msk = 0x800
	// Bit VFLIP.
	PXP_CTRL_VFLIP = 0x800
	// Position of RSVD1 field.
	PXP_CTRL_RSVD1_Pos = 0xc
	// Bit mask of RSVD1 field.
	PXP_CTRL_RSVD1_Msk = 0x3ff000
	// Position of ROT_POS field.
	PXP_CTRL_ROT_POS_Pos = 0x16
	// Bit mask of ROT_POS field.
	PXP_CTRL_ROT_POS_Msk = 0x400000
	// Bit ROT_POS.
	PXP_CTRL_ROT_POS = 0x400000
	// Position of BLOCK_SIZE field.
	PXP_CTRL_BLOCK_SIZE_Pos = 0x17
	// Bit mask of BLOCK_SIZE field.
	PXP_CTRL_BLOCK_SIZE_Msk = 0x800000
	// Bit BLOCK_SIZE.
	PXP_CTRL_BLOCK_SIZE = 0x800000
	// Process 8x8 pixel blocks.
	PXP_CTRL_BLOCK_SIZE_8X8 = 0x0
	// Process 16x16 pixel blocks.
	PXP_CTRL_BLOCK_SIZE_16X16 = 0x1
	// Position of RSVD3 field.
	PXP_CTRL_RSVD3_Pos = 0x18
	// Bit mask of RSVD3 field.
	PXP_CTRL_RSVD3_Msk = 0xf000000
	// Position of EN_REPEAT field.
	PXP_CTRL_EN_REPEAT_Pos = 0x1c
	// Bit mask of EN_REPEAT field.
	PXP_CTRL_EN_REPEAT_Msk = 0x10000000
	// Bit EN_REPEAT.
	PXP_CTRL_EN_REPEAT = 0x10000000
	// Position of RSVD4 field.
	PXP_CTRL_RSVD4_Pos = 0x1d
	// Bit mask of RSVD4 field.
	PXP_CTRL_RSVD4_Msk = 0x20000000
	// Bit RSVD4.
	PXP_CTRL_RSVD4 = 0x20000000
	// Position of CLKGATE field.
	PXP_CTRL_CLKGATE_Pos = 0x1e
	// Bit mask of CLKGATE field.
	PXP_CTRL_CLKGATE_Msk = 0x40000000
	// Bit CLKGATE.
	PXP_CTRL_CLKGATE = 0x40000000
	// Position of SFTRST field.
	PXP_CTRL_SFTRST_Pos = 0x1f
	// Bit mask of SFTRST field.
	PXP_CTRL_SFTRST_Msk = 0x80000000
	// Bit SFTRST.
	PXP_CTRL_SFTRST = 0x80000000

	// CTRL_SET: Control Register 0
	// Position of ENABLE field.
	PXP_CTRL_SET_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	PXP_CTRL_SET_ENABLE_Msk = 0x1
	// Bit ENABLE.
	PXP_CTRL_SET_ENABLE = 0x1
	// Position of IRQ_ENABLE field.
	PXP_CTRL_SET_IRQ_ENABLE_Pos = 0x1
	// Bit mask of IRQ_ENABLE field.
	PXP_CTRL_SET_IRQ_ENABLE_Msk = 0x2
	// Bit IRQ_ENABLE.
	PXP_CTRL_SET_IRQ_ENABLE = 0x2
	// Position of NEXT_IRQ_ENABLE field.
	PXP_CTRL_SET_NEXT_IRQ_ENABLE_Pos = 0x2
	// Bit mask of NEXT_IRQ_ENABLE field.
	PXP_CTRL_SET_NEXT_IRQ_ENABLE_Msk = 0x4
	// Bit NEXT_IRQ_ENABLE.
	PXP_CTRL_SET_NEXT_IRQ_ENABLE = 0x4
	// Position of ENABLE_LCD_HANDSHAKE field.
	PXP_CTRL_SET_ENABLE_LCD_HANDSHAKE_Pos = 0x4
	// Bit mask of ENABLE_LCD_HANDSHAKE field.
	PXP_CTRL_SET_ENABLE_LCD_HANDSHAKE_Msk = 0x10
	// Bit ENABLE_LCD_HANDSHAKE.
	PXP_CTRL_SET_ENABLE_LCD_HANDSHAKE = 0x10
	// Position of RSVD0 field.
	PXP_CTRL_SET_RSVD0_Pos = 0x5
	// Bit mask of RSVD0 field.
	PXP_CTRL_SET_RSVD0_Msk = 0xe0
	// Position of ROTATE field.
	PXP_CTRL_SET_ROTATE_Pos = 0x8
	// Bit mask of ROTATE field.
	PXP_CTRL_SET_ROTATE_Msk = 0x300
	// ROT_0
	PXP_CTRL_SET_ROTATE_ROT_0 = 0x0
	// ROT_90
	PXP_CTRL_SET_ROTATE_ROT_90 = 0x1
	// ROT_180
	PXP_CTRL_SET_ROTATE_ROT_180 = 0x2
	// ROT_270
	PXP_CTRL_SET_ROTATE_ROT_270 = 0x3
	// Position of HFLIP field.
	PXP_CTRL_SET_HFLIP_Pos = 0xa
	// Bit mask of HFLIP field.
	PXP_CTRL_SET_HFLIP_Msk = 0x400
	// Bit HFLIP.
	PXP_CTRL_SET_HFLIP = 0x400
	// Position of VFLIP field.
	PXP_CTRL_SET_VFLIP_Pos = 0xb
	// Bit mask of VFLIP field.
	PXP_CTRL_SET_VFLIP_Msk = 0x800
	// Bit VFLIP.
	PXP_CTRL_SET_VFLIP = 0x800
	// Position of RSVD1 field.
	PXP_CTRL_SET_RSVD1_Pos = 0xc
	// Bit mask of RSVD1 field.
	PXP_CTRL_SET_RSVD1_Msk = 0x3ff000
	// Position of ROT_POS field.
	PXP_CTRL_SET_ROT_POS_Pos = 0x16
	// Bit mask of ROT_POS field.
	PXP_CTRL_SET_ROT_POS_Msk = 0x400000
	// Bit ROT_POS.
	PXP_CTRL_SET_ROT_POS = 0x400000
	// Position of BLOCK_SIZE field.
	PXP_CTRL_SET_BLOCK_SIZE_Pos = 0x17
	// Bit mask of BLOCK_SIZE field.
	PXP_CTRL_SET_BLOCK_SIZE_Msk = 0x800000
	// Bit BLOCK_SIZE.
	PXP_CTRL_SET_BLOCK_SIZE = 0x800000
	// Process 8x8 pixel blocks.
	PXP_CTRL_SET_BLOCK_SIZE_8X8 = 0x0
	// Process 16x16 pixel blocks.
	PXP_CTRL_SET_BLOCK_SIZE_16X16 = 0x1
	// Position of RSVD3 field.
	PXP_CTRL_SET_RSVD3_Pos = 0x18
	// Bit mask of RSVD3 field.
	PXP_CTRL_SET_RSVD3_Msk = 0xf000000
	// Position of EN_REPEAT field.
	PXP_CTRL_SET_EN_REPEAT_Pos = 0x1c
	// Bit mask of EN_REPEAT field.
	PXP_CTRL_SET_EN_REPEAT_Msk = 0x10000000
	// Bit EN_REPEAT.
	PXP_CTRL_SET_EN_REPEAT = 0x10000000
	// Position of RSVD4 field.
	PXP_CTRL_SET_RSVD4_Pos = 0x1d
	// Bit mask of RSVD4 field.
	PXP_CTRL_SET_RSVD4_Msk = 0x20000000
	// Bit RSVD4.
	PXP_CTRL_SET_RSVD4 = 0x20000000
	// Position of CLKGATE field.
	PXP_CTRL_SET_CLKGATE_Pos = 0x1e
	// Bit mask of CLKGATE field.
	PXP_CTRL_SET_CLKGATE_Msk = 0x40000000
	// Bit CLKGATE.
	PXP_CTRL_SET_CLKGATE = 0x40000000
	// Position of SFTRST field.
	PXP_CTRL_SET_SFTRST_Pos = 0x1f
	// Bit mask of SFTRST field.
	PXP_CTRL_SET_SFTRST_Msk = 0x80000000
	// Bit SFTRST.
	PXP_CTRL_SET_SFTRST = 0x80000000

	// CTRL_CLR: Control Register 0
	// Position of ENABLE field.
	PXP_CTRL_CLR_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	PXP_CTRL_CLR_ENABLE_Msk = 0x1
	// Bit ENABLE.
	PXP_CTRL_CLR_ENABLE = 0x1
	// Position of IRQ_ENABLE field.
	PXP_CTRL_CLR_IRQ_ENABLE_Pos = 0x1
	// Bit mask of IRQ_ENABLE field.
	PXP_CTRL_CLR_IRQ_ENABLE_Msk = 0x2
	// Bit IRQ_ENABLE.
	PXP_CTRL_CLR_IRQ_ENABLE = 0x2
	// Position of NEXT_IRQ_ENABLE field.
	PXP_CTRL_CLR_NEXT_IRQ_ENABLE_Pos = 0x2
	// Bit mask of NEXT_IRQ_ENABLE field.
	PXP_CTRL_CLR_NEXT_IRQ_ENABLE_Msk = 0x4
	// Bit NEXT_IRQ_ENABLE.
	PXP_CTRL_CLR_NEXT_IRQ_ENABLE = 0x4
	// Position of ENABLE_LCD_HANDSHAKE field.
	PXP_CTRL_CLR_ENABLE_LCD_HANDSHAKE_Pos = 0x4
	// Bit mask of ENABLE_LCD_HANDSHAKE field.
	PXP_CTRL_CLR_ENABLE_LCD_HANDSHAKE_Msk = 0x10
	// Bit ENABLE_LCD_HANDSHAKE.
	PXP_CTRL_CLR_ENABLE_LCD_HANDSHAKE = 0x10
	// Position of RSVD0 field.
	PXP_CTRL_CLR_RSVD0_Pos = 0x5
	// Bit mask of RSVD0 field.
	PXP_CTRL_CLR_RSVD0_Msk = 0xe0
	// Position of ROTATE field.
	PXP_CTRL_CLR_ROTATE_Pos = 0x8
	// Bit mask of ROTATE field.
	PXP_CTRL_CLR_ROTATE_Msk = 0x300
	// ROT_0
	PXP_CTRL_CLR_ROTATE_ROT_0 = 0x0
	// ROT_90
	PXP_CTRL_CLR_ROTATE_ROT_90 = 0x1
	// ROT_180
	PXP_CTRL_CLR_ROTATE_ROT_180 = 0x2
	// ROT_270
	PXP_CTRL_CLR_ROTATE_ROT_270 = 0x3
	// Position of HFLIP field.
	PXP_CTRL_CLR_HFLIP_Pos = 0xa
	// Bit mask of HFLIP field.
	PXP_CTRL_CLR_HFLIP_Msk = 0x400
	// Bit HFLIP.
	PXP_CTRL_CLR_HFLIP = 0x400
	// Position of VFLIP field.
	PXP_CTRL_CLR_VFLIP_Pos = 0xb
	// Bit mask of VFLIP field.
	PXP_CTRL_CLR_VFLIP_Msk = 0x800
	// Bit VFLIP.
	PXP_CTRL_CLR_VFLIP = 0x800
	// Position of RSVD1 field.
	PXP_CTRL_CLR_RSVD1_Pos = 0xc
	// Bit mask of RSVD1 field.
	PXP_CTRL_CLR_RSVD1_Msk = 0x3ff000
	// Position of ROT_POS field.
	PXP_CTRL_CLR_ROT_POS_Pos = 0x16
	// Bit mask of ROT_POS field.
	PXP_CTRL_CLR_ROT_POS_Msk = 0x400000
	// Bit ROT_POS.
	PXP_CTRL_CLR_ROT_POS = 0x400000
	// Position of BLOCK_SIZE field.
	PXP_CTRL_CLR_BLOCK_SIZE_Pos = 0x17
	// Bit mask of BLOCK_SIZE field.
	PXP_CTRL_CLR_BLOCK_SIZE_Msk = 0x800000
	// Bit BLOCK_SIZE.
	PXP_CTRL_CLR_BLOCK_SIZE = 0x800000
	// Process 8x8 pixel blocks.
	PXP_CTRL_CLR_BLOCK_SIZE_8X8 = 0x0
	// Process 16x16 pixel blocks.
	PXP_CTRL_CLR_BLOCK_SIZE_16X16 = 0x1
	// Position of RSVD3 field.
	PXP_CTRL_CLR_RSVD3_Pos = 0x18
	// Bit mask of RSVD3 field.
	PXP_CTRL_CLR_RSVD3_Msk = 0xf000000
	// Position of EN_REPEAT field.
	PXP_CTRL_CLR_EN_REPEAT_Pos = 0x1c
	// Bit mask of EN_REPEAT field.
	PXP_CTRL_CLR_EN_REPEAT_Msk = 0x10000000
	// Bit EN_REPEAT.
	PXP_CTRL_CLR_EN_REPEAT = 0x10000000
	// Position of RSVD4 field.
	PXP_CTRL_CLR_RSVD4_Pos = 0x1d
	// Bit mask of RSVD4 field.
	PXP_CTRL_CLR_RSVD4_Msk = 0x20000000
	// Bit RSVD4.
	PXP_CTRL_CLR_RSVD4 = 0x20000000
	// Position of CLKGATE field.
	PXP_CTRL_CLR_CLKGATE_Pos = 0x1e
	// Bit mask of CLKGATE field.
	PXP_CTRL_CLR_CLKGATE_Msk = 0x40000000
	// Bit CLKGATE.
	PXP_CTRL_CLR_CLKGATE = 0x40000000
	// Position of SFTRST field.
	PXP_CTRL_CLR_SFTRST_Pos = 0x1f
	// Bit mask of SFTRST field.
	PXP_CTRL_CLR_SFTRST_Msk = 0x80000000
	// Bit SFTRST.
	PXP_CTRL_CLR_SFTRST = 0x80000000

	// CTRL_TOG: Control Register 0
	// Position of ENABLE field.
	PXP_CTRL_TOG_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	PXP_CTRL_TOG_ENABLE_Msk = 0x1
	// Bit ENABLE.
	PXP_CTRL_TOG_ENABLE = 0x1
	// Position of IRQ_ENABLE field.
	PXP_CTRL_TOG_IRQ_ENABLE_Pos = 0x1
	// Bit mask of IRQ_ENABLE field.
	PXP_CTRL_TOG_IRQ_ENABLE_Msk = 0x2
	// Bit IRQ_ENABLE.
	PXP_CTRL_TOG_IRQ_ENABLE = 0x2
	// Position of NEXT_IRQ_ENABLE field.
	PXP_CTRL_TOG_NEXT_IRQ_ENABLE_Pos = 0x2
	// Bit mask of NEXT_IRQ_ENABLE field.
	PXP_CTRL_TOG_NEXT_IRQ_ENABLE_Msk = 0x4
	// Bit NEXT_IRQ_ENABLE.
	PXP_CTRL_TOG_NEXT_IRQ_ENABLE = 0x4
	// Position of ENABLE_LCD_HANDSHAKE field.
	PXP_CTRL_TOG_ENABLE_LCD_HANDSHAKE_Pos = 0x4
	// Bit mask of ENABLE_LCD_HANDSHAKE field.
	PXP_CTRL_TOG_ENABLE_LCD_HANDSHAKE_Msk = 0x10
	// Bit ENABLE_LCD_HANDSHAKE.
	PXP_CTRL_TOG_ENABLE_LCD_HANDSHAKE = 0x10
	// Position of RSVD0 field.
	PXP_CTRL_TOG_RSVD0_Pos = 0x5
	// Bit mask of RSVD0 field.
	PXP_CTRL_TOG_RSVD0_Msk = 0xe0
	// Position of ROTATE field.
	PXP_CTRL_TOG_ROTATE_Pos = 0x8
	// Bit mask of ROTATE field.
	PXP_CTRL_TOG_ROTATE_Msk = 0x300
	// ROT_0
	PXP_CTRL_TOG_ROTATE_ROT_0 = 0x0
	// ROT_90
	PXP_CTRL_TOG_ROTATE_ROT_90 = 0x1
	// ROT_180
	PXP_CTRL_TOG_ROTATE_ROT_180 = 0x2
	// ROT_270
	PXP_CTRL_TOG_ROTATE_ROT_270 = 0x3
	// Position of HFLIP field.
	PXP_CTRL_TOG_HFLIP_Pos = 0xa
	// Bit mask of HFLIP field.
	PXP_CTRL_TOG_HFLIP_Msk = 0x400
	// Bit HFLIP.
	PXP_CTRL_TOG_HFLIP = 0x400
	// Position of VFLIP field.
	PXP_CTRL_TOG_VFLIP_Pos = 0xb
	// Bit mask of VFLIP field.
	PXP_CTRL_TOG_VFLIP_Msk = 0x800
	// Bit VFLIP.
	PXP_CTRL_TOG_VFLIP = 0x800
	// Position of RSVD1 field.
	PXP_CTRL_TOG_RSVD1_Pos = 0xc
	// Bit mask of RSVD1 field.
	PXP_CTRL_TOG_RSVD1_Msk = 0x3ff000
	// Position of ROT_POS field.
	PXP_CTRL_TOG_ROT_POS_Pos = 0x16
	// Bit mask of ROT_POS field.
	PXP_CTRL_TOG_ROT_POS_Msk = 0x400000
	// Bit ROT_POS.
	PXP_CTRL_TOG_ROT_POS = 0x400000
	// Position of BLOCK_SIZE field.
	PXP_CTRL_TOG_BLOCK_SIZE_Pos = 0x17
	// Bit mask of BLOCK_SIZE field.
	PXP_CTRL_TOG_BLOCK_SIZE_Msk = 0x800000
	// Bit BLOCK_SIZE.
	PXP_CTRL_TOG_BLOCK_SIZE = 0x800000
	// Process 8x8 pixel blocks.
	PXP_CTRL_TOG_BLOCK_SIZE_8X8 = 0x0
	// Process 16x16 pixel blocks.
	PXP_CTRL_TOG_BLOCK_SIZE_16X16 = 0x1
	// Position of RSVD3 field.
	PXP_CTRL_TOG_RSVD3_Pos = 0x18
	// Bit mask of RSVD3 field.
	PXP_CTRL_TOG_RSVD3_Msk = 0xf000000
	// Position of EN_REPEAT field.
	PXP_CTRL_TOG_EN_REPEAT_Pos = 0x1c
	// Bit mask of EN_REPEAT field.
	PXP_CTRL_TOG_EN_REPEAT_Msk = 0x10000000
	// Bit EN_REPEAT.
	PXP_CTRL_TOG_EN_REPEAT = 0x10000000
	// Position of RSVD4 field.
	PXP_CTRL_TOG_RSVD4_Pos = 0x1d
	// Bit mask of RSVD4 field.
	PXP_CTRL_TOG_RSVD4_Msk = 0x20000000
	// Bit RSVD4.
	PXP_CTRL_TOG_RSVD4 = 0x20000000
	// Position of CLKGATE field.
	PXP_CTRL_TOG_CLKGATE_Pos = 0x1e
	// Bit mask of CLKGATE field.
	PXP_CTRL_TOG_CLKGATE_Msk = 0x40000000
	// Bit CLKGATE.
	PXP_CTRL_TOG_CLKGATE = 0x40000000
	// Position of SFTRST field.
	PXP_CTRL_TOG_SFTRST_Pos = 0x1f
	// Bit mask of SFTRST field.
	PXP_CTRL_TOG_SFTRST_Msk = 0x80000000
	// Bit SFTRST.
	PXP_CTRL_TOG_SFTRST = 0x80000000

	// STAT: Status Register
	// Position of IRQ field.
	PXP_STAT_IRQ_Pos = 0x0
	// Bit mask of IRQ field.
	PXP_STAT_IRQ_Msk = 0x1
	// Bit IRQ.
	PXP_STAT_IRQ = 0x1
	// Position of AXI_WRITE_ERROR field.
	PXP_STAT_AXI_WRITE_ERROR_Pos = 0x1
	// Bit mask of AXI_WRITE_ERROR field.
	PXP_STAT_AXI_WRITE_ERROR_Msk = 0x2
	// Bit AXI_WRITE_ERROR.
	PXP_STAT_AXI_WRITE_ERROR = 0x2
	// Position of AXI_READ_ERROR field.
	PXP_STAT_AXI_READ_ERROR_Pos = 0x2
	// Bit mask of AXI_READ_ERROR field.
	PXP_STAT_AXI_READ_ERROR_Msk = 0x4
	// Bit AXI_READ_ERROR.
	PXP_STAT_AXI_READ_ERROR = 0x4
	// Position of NEXT_IRQ field.
	PXP_STAT_NEXT_IRQ_Pos = 0x3
	// Bit mask of NEXT_IRQ field.
	PXP_STAT_NEXT_IRQ_Msk = 0x8
	// Bit NEXT_IRQ.
	PXP_STAT_NEXT_IRQ = 0x8
	// Position of AXI_ERROR_ID field.
	PXP_STAT_AXI_ERROR_ID_Pos = 0x4
	// Bit mask of AXI_ERROR_ID field.
	PXP_STAT_AXI_ERROR_ID_Msk = 0xf0
	// Position of LUT_DMA_LOAD_DONE_IRQ field.
	PXP_STAT_LUT_DMA_LOAD_DONE_IRQ_Pos = 0x8
	// Bit mask of LUT_DMA_LOAD_DONE_IRQ field.
	PXP_STAT_LUT_DMA_LOAD_DONE_IRQ_Msk = 0x100
	// Bit LUT_DMA_LOAD_DONE_IRQ.
	PXP_STAT_LUT_DMA_LOAD_DONE_IRQ = 0x100
	// Position of RSVD2 field.
	PXP_STAT_RSVD2_Pos = 0x9
	// Bit mask of RSVD2 field.
	PXP_STAT_RSVD2_Msk = 0xfe00
	// Position of BLOCKY field.
	PXP_STAT_BLOCKY_Pos = 0x10
	// Bit mask of BLOCKY field.
	PXP_STAT_BLOCKY_Msk = 0xff0000
	// Position of BLOCKX field.
	PXP_STAT_BLOCKX_Pos = 0x18
	// Bit mask of BLOCKX field.
	PXP_STAT_BLOCKX_Msk = 0xff000000

	// STAT_SET: Status Register
	// Position of IRQ field.
	PXP_STAT_SET_IRQ_Pos = 0x0
	// Bit mask of IRQ field.
	PXP_STAT_SET_IRQ_Msk = 0x1
	// Bit IRQ.
	PXP_STAT_SET_IRQ = 0x1
	// Position of AXI_WRITE_ERROR field.
	PXP_STAT_SET_AXI_WRITE_ERROR_Pos = 0x1
	// Bit mask of AXI_WRITE_ERROR field.
	PXP_STAT_SET_AXI_WRITE_ERROR_Msk = 0x2
	// Bit AXI_WRITE_ERROR.
	PXP_STAT_SET_AXI_WRITE_ERROR = 0x2
	// Position of AXI_READ_ERROR field.
	PXP_STAT_SET_AXI_READ_ERROR_Pos = 0x2
	// Bit mask of AXI_READ_ERROR field.
	PXP_STAT_SET_AXI_READ_ERROR_Msk = 0x4
	// Bit AXI_READ_ERROR.
	PXP_STAT_SET_AXI_READ_ERROR = 0x4
	// Position of NEXT_IRQ field.
	PXP_STAT_SET_NEXT_IRQ_Pos = 0x3
	// Bit mask of NEXT_IRQ field.
	PXP_STAT_SET_NEXT_IRQ_Msk = 0x8
	// Bit NEXT_IRQ.
	PXP_STAT_SET_NEXT_IRQ = 0x8
	// Position of AXI_ERROR_ID field.
	PXP_STAT_SET_AXI_ERROR_ID_Pos = 0x4
	// Bit mask of AXI_ERROR_ID field.
	PXP_STAT_SET_AXI_ERROR_ID_Msk = 0xf0
	// Position of LUT_DMA_LOAD_DONE_IRQ field.
	PXP_STAT_SET_LUT_DMA_LOAD_DONE_IRQ_Pos = 0x8
	// Bit mask of LUT_DMA_LOAD_DONE_IRQ field.
	PXP_STAT_SET_LUT_DMA_LOAD_DONE_IRQ_Msk = 0x100
	// Bit LUT_DMA_LOAD_DONE_IRQ.
	PXP_STAT_SET_LUT_DMA_LOAD_DONE_IRQ = 0x100
	// Position of RSVD2 field.
	PXP_STAT_SET_RSVD2_Pos = 0x9
	// Bit mask of RSVD2 field.
	PXP_STAT_SET_RSVD2_Msk = 0xfe00
	// Position of BLOCKY field.
	PXP_STAT_SET_BLOCKY_Pos = 0x10
	// Bit mask of BLOCKY field.
	PXP_STAT_SET_BLOCKY_Msk = 0xff0000
	// Position of BLOCKX field.
	PXP_STAT_SET_BLOCKX_Pos = 0x18
	// Bit mask of BLOCKX field.
	PXP_STAT_SET_BLOCKX_Msk = 0xff000000

	// STAT_CLR: Status Register
	// Position of IRQ field.
	PXP_STAT_CLR_IRQ_Pos = 0x0
	// Bit mask of IRQ field.
	PXP_STAT_CLR_IRQ_Msk = 0x1
	// Bit IRQ.
	PXP_STAT_CLR_IRQ = 0x1
	// Position of AXI_WRITE_ERROR field.
	PXP_STAT_CLR_AXI_WRITE_ERROR_Pos = 0x1
	// Bit mask of AXI_WRITE_ERROR field.
	PXP_STAT_CLR_AXI_WRITE_ERROR_Msk = 0x2
	// Bit AXI_WRITE_ERROR.
	PXP_STAT_CLR_AXI_WRITE_ERROR = 0x2
	// Position of AXI_READ_ERROR field.
	PXP_STAT_CLR_AXI_READ_ERROR_Pos = 0x2
	// Bit mask of AXI_READ_ERROR field.
	PXP_STAT_CLR_AXI_READ_ERROR_Msk = 0x4
	// Bit AXI_READ_ERROR.
	PXP_STAT_CLR_AXI_READ_ERROR = 0x4
	// Position of NEXT_IRQ field.
	PXP_STAT_CLR_NEXT_IRQ_Pos = 0x3
	// Bit mask of NEXT_IRQ field.
	PXP_STAT_CLR_NEXT_IRQ_Msk = 0x8
	// Bit NEXT_IRQ.
	PXP_STAT_CLR_NEXT_IRQ = 0x8
	// Position of AXI_ERROR_ID field.
	PXP_STAT_CLR_AXI_ERROR_ID_Pos = 0x4
	// Bit mask of AXI_ERROR_ID field.
	PXP_STAT_CLR_AXI_ERROR_ID_Msk = 0xf0
	// Position of LUT_DMA_LOAD_DONE_IRQ field.
	PXP_STAT_CLR_LUT_DMA_LOAD_DONE_IRQ_Pos = 0x8
	// Bit mask of LUT_DMA_LOAD_DONE_IRQ field.
	PXP_STAT_CLR_LUT_DMA_LOAD_DONE_IRQ_Msk = 0x100
	// Bit LUT_DMA_LOAD_DONE_IRQ.
	PXP_STAT_CLR_LUT_DMA_LOAD_DONE_IRQ = 0x100
	// Position of RSVD2 field.
	PXP_STAT_CLR_RSVD2_Pos = 0x9
	// Bit mask of RSVD2 field.
	PXP_STAT_CLR_RSVD2_Msk = 0xfe00
	// Position of BLOCKY field.
	PXP_STAT_CLR_BLOCKY_Pos = 0x10
	// Bit mask of BLOCKY field.
	PXP_STAT_CLR_BLOCKY_Msk = 0xff0000
	// Position of BLOCKX field.
	PXP_STAT_CLR_BLOCKX_Pos = 0x18
	// Bit mask of BLOCKX field.
	PXP_STAT_CLR_BLOCKX_Msk = 0xff000000

	// STAT_TOG: Status Register
	// Position of IRQ field.
	PXP_STAT_TOG_IRQ_Pos = 0x0
	// Bit mask of IRQ field.
	PXP_STAT_TOG_IRQ_Msk = 0x1
	// Bit IRQ.
	PXP_STAT_TOG_IRQ = 0x1
	// Position of AXI_WRITE_ERROR field.
	PXP_STAT_TOG_AXI_WRITE_ERROR_Pos = 0x1
	// Bit mask of AXI_WRITE_ERROR field.
	PXP_STAT_TOG_AXI_WRITE_ERROR_Msk = 0x2
	// Bit AXI_WRITE_ERROR.
	PXP_STAT_TOG_AXI_WRITE_ERROR = 0x2
	// Position of AXI_READ_ERROR field.
	PXP_STAT_TOG_AXI_READ_ERROR_Pos = 0x2
	// Bit mask of AXI_READ_ERROR field.
	PXP_STAT_TOG_AXI_READ_ERROR_Msk = 0x4
	// Bit AXI_READ_ERROR.
	PXP_STAT_TOG_AXI_READ_ERROR = 0x4
	// Position of NEXT_IRQ field.
	PXP_STAT_TOG_NEXT_IRQ_Pos = 0x3
	// Bit mask of NEXT_IRQ field.
	PXP_STAT_TOG_NEXT_IRQ_Msk = 0x8
	// Bit NEXT_IRQ.
	PXP_STAT_TOG_NEXT_IRQ = 0x8
	// Position of AXI_ERROR_ID field.
	PXP_STAT_TOG_AXI_ERROR_ID_Pos = 0x4
	// Bit mask of AXI_ERROR_ID field.
	PXP_STAT_TOG_AXI_ERROR_ID_Msk = 0xf0
	// Position of LUT_DMA_LOAD_DONE_IRQ field.
	PXP_STAT_TOG_LUT_DMA_LOAD_DONE_IRQ_Pos = 0x8
	// Bit mask of LUT_DMA_LOAD_DONE_IRQ field.
	PXP_STAT_TOG_LUT_DMA_LOAD_DONE_IRQ_Msk = 0x100
	// Bit LUT_DMA_LOAD_DONE_IRQ.
	PXP_STAT_TOG_LUT_DMA_LOAD_DONE_IRQ = 0x100
	// Position of RSVD2 field.
	PXP_STAT_TOG_RSVD2_Pos = 0x9
	// Bit mask of RSVD2 field.
	PXP_STAT_TOG_RSVD2_Msk = 0xfe00
	// Position of BLOCKY field.
	PXP_STAT_TOG_BLOCKY_Pos = 0x10
	// Bit mask of BLOCKY field.
	PXP_STAT_TOG_BLOCKY_Msk = 0xff0000
	// Position of BLOCKX field.
	PXP_STAT_TOG_BLOCKX_Pos = 0x18
	// Bit mask of BLOCKX field.
	PXP_STAT_TOG_BLOCKX_Msk = 0xff000000

	// OUT_CTRL: Output Buffer Control Register
	// Position of FORMAT field.
	PXP_OUT_CTRL_FORMAT_Pos = 0x0
	// Bit mask of FORMAT field.
	PXP_OUT_CTRL_FORMAT_Msk = 0x1f
	// 32-bit pixels
	PXP_OUT_CTRL_FORMAT_ARGB8888 = 0x0
	// 32-bit pixels (unpacked 24-bit pixel in 32 bit DWORD.)
	PXP_OUT_CTRL_FORMAT_RGB888 = 0x4
	// 24-bit pixels (packed 24-bit format)
	PXP_OUT_CTRL_FORMAT_RGB888P = 0x5
	// 16-bit pixels
	PXP_OUT_CTRL_FORMAT_ARGB1555 = 0x8
	// 16-bit pixels
	PXP_OUT_CTRL_FORMAT_ARGB4444 = 0x9
	// 16-bit pixels
	PXP_OUT_CTRL_FORMAT_RGB555 = 0xc
	// 16-bit pixels
	PXP_OUT_CTRL_FORMAT_RGB444 = 0xd
	// 16-bit pixels
	PXP_OUT_CTRL_FORMAT_RGB565 = 0xe
	// 32-bit pixels (1-plane XYUV unpacked)
	PXP_OUT_CTRL_FORMAT_YUV1P444 = 0x10
	// 16-bit pixels (1-plane U0,Y0,V0,Y1 interleaved bytes)
	PXP_OUT_CTRL_FORMAT_UYVY1P422 = 0x12
	// 16-bit pixels (1-plane V0,Y0,U0,Y1 interleaved bytes)
	PXP_OUT_CTRL_FORMAT_VYUY1P422 = 0x13
	// 8-bit monochrome pixels (1-plane Y luma output)
	PXP_OUT_CTRL_FORMAT_Y8 = 0x14
	// 4-bit monochrome pixels (1-plane Y luma, 4 bit truncation)
	PXP_OUT_CTRL_FORMAT_Y4 = 0x15
	// 16-bit pixels (2-plane UV interleaved bytes)
	PXP_OUT_CTRL_FORMAT_YUV2P422 = 0x18
	// 16-bit pixels (2-plane UV)
	PXP_OUT_CTRL_FORMAT_YUV2P420 = 0x19
	// 16-bit pixels (2-plane VU interleaved bytes)
	PXP_OUT_CTRL_FORMAT_YVU2P422 = 0x1a
	// 16-bit pixels (2-plane VU)
	PXP_OUT_CTRL_FORMAT_YVU2P420 = 0x1b
	// Position of RSVD0 field.
	PXP_OUT_CTRL_RSVD0_Pos = 0x5
	// Bit mask of RSVD0 field.
	PXP_OUT_CTRL_RSVD0_Msk = 0xe0
	// Position of INTERLACED_OUTPUT field.
	PXP_OUT_CTRL_INTERLACED_OUTPUT_Pos = 0x8
	// Bit mask of INTERLACED_OUTPUT field.
	PXP_OUT_CTRL_INTERLACED_OUTPUT_Msk = 0x300
	// All data written in progressive format to the OUTBUF Pointer.
	PXP_OUT_CTRL_INTERLACED_OUTPUT_PROGRESSIVE = 0x0
	// Interlaced output: only data for field 0 is written to the OUTBUF Pointer.
	PXP_OUT_CTRL_INTERLACED_OUTPUT_FIELD0 = 0x1
	// Interlaced output: only data for field 1 is written to the OUTBUF2 Pointer.
	PXP_OUT_CTRL_INTERLACED_OUTPUT_FIELD1 = 0x2
	// Interlaced output: data for field 0 is written to OUTBUF and data for field 1 is written to OUTBUF2.
	PXP_OUT_CTRL_INTERLACED_OUTPUT_INTERLACED = 0x3
	// Position of RSVD1 field.
	PXP_OUT_CTRL_RSVD1_Pos = 0xa
	// Bit mask of RSVD1 field.
	PXP_OUT_CTRL_RSVD1_Msk = 0x7ffc00
	// Position of ALPHA_OUTPUT field.
	PXP_OUT_CTRL_ALPHA_OUTPUT_Pos = 0x17
	// Bit mask of ALPHA_OUTPUT field.
	PXP_OUT_CTRL_ALPHA_OUTPUT_Msk = 0x800000
	// Bit ALPHA_OUTPUT.
	PXP_OUT_CTRL_ALPHA_OUTPUT = 0x800000
	// Position of ALPHA field.
	PXP_OUT_CTRL_ALPHA_Pos = 0x18
	// Bit mask of ALPHA field.
	PXP_OUT_CTRL_ALPHA_Msk = 0xff000000

	// OUT_CTRL_SET: Output Buffer Control Register
	// Position of FORMAT field.
	PXP_OUT_CTRL_SET_FORMAT_Pos = 0x0
	// Bit mask of FORMAT field.
	PXP_OUT_CTRL_SET_FORMAT_Msk = 0x1f
	// 32-bit pixels
	PXP_OUT_CTRL_SET_FORMAT_ARGB8888 = 0x0
	// 32-bit pixels (unpacked 24-bit pixel in 32 bit DWORD.)
	PXP_OUT_CTRL_SET_FORMAT_RGB888 = 0x4
	// 24-bit pixels (packed 24-bit format)
	PXP_OUT_CTRL_SET_FORMAT_RGB888P = 0x5
	// 16-bit pixels
	PXP_OUT_CTRL_SET_FORMAT_ARGB1555 = 0x8
	// 16-bit pixels
	PXP_OUT_CTRL_SET_FORMAT_ARGB4444 = 0x9
	// 16-bit pixels
	PXP_OUT_CTRL_SET_FORMAT_RGB555 = 0xc
	// 16-bit pixels
	PXP_OUT_CTRL_SET_FORMAT_RGB444 = 0xd
	// 16-bit pixels
	PXP_OUT_CTRL_SET_FORMAT_RGB565 = 0xe
	// 32-bit pixels (1-plane XYUV unpacked)
	PXP_OUT_CTRL_SET_FORMAT_YUV1P444 = 0x10
	// 16-bit pixels (1-plane U0,Y0,V0,Y1 interleaved bytes)
	PXP_OUT_CTRL_SET_FORMAT_UYVY1P422 = 0x12
	// 16-bit pixels (1-plane V0,Y0,U0,Y1 interleaved bytes)
	PXP_OUT_CTRL_SET_FORMAT_VYUY1P422 = 0x13
	// 8-bit monochrome pixels (1-plane Y luma output)
	PXP_OUT_CTRL_SET_FORMAT_Y8 = 0x14
	// 4-bit monochrome pixels (1-plane Y luma, 4 bit truncation)
	PXP_OUT_CTRL_SET_FORMAT_Y4 = 0x15
	// 16-bit pixels (2-plane UV interleaved bytes)
	PXP_OUT_CTRL_SET_FORMAT_YUV2P422 = 0x18
	// 16-bit pixels (2-plane UV)
	PXP_OUT_CTRL_SET_FORMAT_YUV2P420 = 0x19
	// 16-bit pixels (2-plane VU interleaved bytes)
	PXP_OUT_CTRL_SET_FORMAT_YVU2P422 = 0x1a
	// 16-bit pixels (2-plane VU)
	PXP_OUT_CTRL_SET_FORMAT_YVU2P420 = 0x1b
	// Position of RSVD0 field.
	PXP_OUT_CTRL_SET_RSVD0_Pos = 0x5
	// Bit mask of RSVD0 field.
	PXP_OUT_CTRL_SET_RSVD0_Msk = 0xe0
	// Position of INTERLACED_OUTPUT field.
	PXP_OUT_CTRL_SET_INTERLACED_OUTPUT_Pos = 0x8
	// Bit mask of INTERLACED_OUTPUT field.
	PXP_OUT_CTRL_SET_INTERLACED_OUTPUT_Msk = 0x300
	// All data written in progressive format to the OUTBUF Pointer.
	PXP_OUT_CTRL_SET_INTERLACED_OUTPUT_PROGRESSIVE = 0x0
	// Interlaced output: only data for field 0 is written to the OUTBUF Pointer.
	PXP_OUT_CTRL_SET_INTERLACED_OUTPUT_FIELD0 = 0x1
	// Interlaced output: only data for field 1 is written to the OUTBUF2 Pointer.
	PXP_OUT_CTRL_SET_INTERLACED_OUTPUT_FIELD1 = 0x2
	// Interlaced output: data for field 0 is written to OUTBUF and data for field 1 is written to OUTBUF2.
	PXP_OUT_CTRL_SET_INTERLACED_OUTPUT_INTERLACED = 0x3
	// Position of RSVD1 field.
	PXP_OUT_CTRL_SET_RSVD1_Pos = 0xa
	// Bit mask of RSVD1 field.
	PXP_OUT_CTRL_SET_RSVD1_Msk = 0x7ffc00
	// Position of ALPHA_OUTPUT field.
	PXP_OUT_CTRL_SET_ALPHA_OUTPUT_Pos = 0x17
	// Bit mask of ALPHA_OUTPUT field.
	PXP_OUT_CTRL_SET_ALPHA_OUTPUT_Msk = 0x800000
	// Bit ALPHA_OUTPUT.
	PXP_OUT_CTRL_SET_ALPHA_OUTPUT = 0x800000
	// Position of ALPHA field.
	PXP_OUT_CTRL_SET_ALPHA_Pos = 0x18
	// Bit mask of ALPHA field.
	PXP_OUT_CTRL_SET_ALPHA_Msk = 0xff000000

	// OUT_CTRL_CLR: Output Buffer Control Register
	// Position of FORMAT field.
	PXP_OUT_CTRL_CLR_FORMAT_Pos = 0x0
	// Bit mask of FORMAT field.
	PXP_OUT_CTRL_CLR_FORMAT_Msk = 0x1f
	// 32-bit pixels
	PXP_OUT_CTRL_CLR_FORMAT_ARGB8888 = 0x0
	// 32-bit pixels (unpacked 24-bit pixel in 32 bit DWORD.)
	PXP_OUT_CTRL_CLR_FORMAT_RGB888 = 0x4
	// 24-bit pixels (packed 24-bit format)
	PXP_OUT_CTRL_CLR_FORMAT_RGB888P = 0x5
	// 16-bit pixels
	PXP_OUT_CTRL_CLR_FORMAT_ARGB1555 = 0x8
	// 16-bit pixels
	PXP_OUT_CTRL_CLR_FORMAT_ARGB4444 = 0x9
	// 16-bit pixels
	PXP_OUT_CTRL_CLR_FORMAT_RGB555 = 0xc
	// 16-bit pixels
	PXP_OUT_CTRL_CLR_FORMAT_RGB444 = 0xd
	// 16-bit pixels
	PXP_OUT_CTRL_CLR_FORMAT_RGB565 = 0xe
	// 32-bit pixels (1-plane XYUV unpacked)
	PXP_OUT_CTRL_CLR_FORMAT_YUV1P444 = 0x10
	// 16-bit pixels (1-plane U0,Y0,V0,Y1 interleaved bytes)
	PXP_OUT_CTRL_CLR_FORMAT_UYVY1P422 = 0x12
	// 16-bit pixels (1-plane V0,Y0,U0,Y1 interleaved bytes)
	PXP_OUT_CTRL_CLR_FORMAT_VYUY1P422 = 0x13
	// 8-bit monochrome pixels (1-plane Y luma output)
	PXP_OUT_CTRL_CLR_FORMAT_Y8 = 0x14
	// 4-bit monochrome pixels (1-plane Y luma, 4 bit truncation)
	PXP_OUT_CTRL_CLR_FORMAT_Y4 = 0x15
	// 16-bit pixels (2-plane UV interleaved bytes)
	PXP_OUT_CTRL_CLR_FORMAT_YUV2P422 = 0x18
	// 16-bit pixels (2-plane UV)
	PXP_OUT_CTRL_CLR_FORMAT_YUV2P420 = 0x19
	// 16-bit pixels (2-plane VU interleaved bytes)
	PXP_OUT_CTRL_CLR_FORMAT_YVU2P422 = 0x1a
	// 16-bit pixels (2-plane VU)
	PXP_OUT_CTRL_CLR_FORMAT_YVU2P420 = 0x1b
	// Position of RSVD0 field.
	PXP_OUT_CTRL_CLR_RSVD0_Pos = 0x5
	// Bit mask of RSVD0 field.
	PXP_OUT_CTRL_CLR_RSVD0_Msk = 0xe0
	// Position of INTERLACED_OUTPUT field.
	PXP_OUT_CTRL_CLR_INTERLACED_OUTPUT_Pos = 0x8
	// Bit mask of INTERLACED_OUTPUT field.
	PXP_OUT_CTRL_CLR_INTERLACED_OUTPUT_Msk = 0x300
	// All data written in progressive format to the OUTBUF Pointer.
	PXP_OUT_CTRL_CLR_INTERLACED_OUTPUT_PROGRESSIVE = 0x0
	// Interlaced output: only data for field 0 is written to the OUTBUF Pointer.
	PXP_OUT_CTRL_CLR_INTERLACED_OUTPUT_FIELD0 = 0x1
	// Interlaced output: only data for field 1 is written to the OUTBUF2 Pointer.
	PXP_OUT_CTRL_CLR_INTERLACED_OUTPUT_FIELD1 = 0x2
	// Interlaced output: data for field 0 is written to OUTBUF and data for field 1 is written to OUTBUF2.
	PXP_OUT_CTRL_CLR_INTERLACED_OUTPUT_INTERLACED = 0x3
	// Position of RSVD1 field.
	PXP_OUT_CTRL_CLR_RSVD1_Pos = 0xa
	// Bit mask of RSVD1 field.
	PXP_OUT_CTRL_CLR_RSVD1_Msk = 0x7ffc00
	// Position of ALPHA_OUTPUT field.
	PXP_OUT_CTRL_CLR_ALPHA_OUTPUT_Pos = 0x17
	// Bit mask of ALPHA_OUTPUT field.
	PXP_OUT_CTRL_CLR_ALPHA_OUTPUT_Msk = 0x800000
	// Bit ALPHA_OUTPUT.
	PXP_OUT_CTRL_CLR_ALPHA_OUTPUT = 0x800000
	// Position of ALPHA field.
	PXP_OUT_CTRL_CLR_ALPHA_Pos = 0x18
	// Bit mask of ALPHA field.
	PXP_OUT_CTRL_CLR_ALPHA_Msk = 0xff000000

	// OUT_CTRL_TOG: Output Buffer Control Register
	// Position of FORMAT field.
	PXP_OUT_CTRL_TOG_FORMAT_Pos = 0x0
	// Bit mask of FORMAT field.
	PXP_OUT_CTRL_TOG_FORMAT_Msk = 0x1f
	// 32-bit pixels
	PXP_OUT_CTRL_TOG_FORMAT_ARGB8888 = 0x0
	// 32-bit pixels (unpacked 24-bit pixel in 32 bit DWORD.)
	PXP_OUT_CTRL_TOG_FORMAT_RGB888 = 0x4
	// 24-bit pixels (packed 24-bit format)
	PXP_OUT_CTRL_TOG_FORMAT_RGB888P = 0x5
	// 16-bit pixels
	PXP_OUT_CTRL_TOG_FORMAT_ARGB1555 = 0x8
	// 16-bit pixels
	PXP_OUT_CTRL_TOG_FORMAT_ARGB4444 = 0x9
	// 16-bit pixels
	PXP_OUT_CTRL_TOG_FORMAT_RGB555 = 0xc
	// 16-bit pixels
	PXP_OUT_CTRL_TOG_FORMAT_RGB444 = 0xd
	// 16-bit pixels
	PXP_OUT_CTRL_TOG_FORMAT_RGB565 = 0xe
	// 32-bit pixels (1-plane XYUV unpacked)
	PXP_OUT_CTRL_TOG_FORMAT_YUV1P444 = 0x10
	// 16-bit pixels (1-plane U0,Y0,V0,Y1 interleaved bytes)
	PXP_OUT_CTRL_TOG_FORMAT_UYVY1P422 = 0x12
	// 16-bit pixels (1-plane V0,Y0,U0,Y1 interleaved bytes)
	PXP_OUT_CTRL_TOG_FORMAT_VYUY1P422 = 0x13
	// 8-bit monochrome pixels (1-plane Y luma output)
	PXP_OUT_CTRL_TOG_FORMAT_Y8 = 0x14
	// 4-bit monochrome pixels (1-plane Y luma, 4 bit truncation)
	PXP_OUT_CTRL_TOG_FORMAT_Y4 = 0x15
	// 16-bit pixels (2-plane UV interleaved bytes)
	PXP_OUT_CTRL_TOG_FORMAT_YUV2P422 = 0x18
	// 16-bit pixels (2-plane UV)
	PXP_OUT_CTRL_TOG_FORMAT_YUV2P420 = 0x19
	// 16-bit pixels (2-plane VU interleaved bytes)
	PXP_OUT_CTRL_TOG_FORMAT_YVU2P422 = 0x1a
	// 16-bit pixels (2-plane VU)
	PXP_OUT_CTRL_TOG_FORMAT_YVU2P420 = 0x1b
	// Position of RSVD0 field.
	PXP_OUT_CTRL_TOG_RSVD0_Pos = 0x5
	// Bit mask of RSVD0 field.
	PXP_OUT_CTRL_TOG_RSVD0_Msk = 0xe0
	// Position of INTERLACED_OUTPUT field.
	PXP_OUT_CTRL_TOG_INTERLACED_OUTPUT_Pos = 0x8
	// Bit mask of INTERLACED_OUTPUT field.
	PXP_OUT_CTRL_TOG_INTERLACED_OUTPUT_Msk = 0x300
	// All data written in progressive format to the OUTBUF Pointer.
	PXP_OUT_CTRL_TOG_INTERLACED_OUTPUT_PROGRESSIVE = 0x0
	// Interlaced output: only data for field 0 is written to the OUTBUF Pointer.
	PXP_OUT_CTRL_TOG_INTERLACED_OUTPUT_FIELD0 = 0x1
	// Interlaced output: only data for field 1 is written to the OUTBUF2 Pointer.
	PXP_OUT_CTRL_TOG_INTERLACED_OUTPUT_FIELD1 = 0x2
	// Interlaced output: data for field 0 is written to OUTBUF and data for field 1 is written to OUTBUF2.
	PXP_OUT_CTRL_TOG_INTERLACED_OUTPUT_INTERLACED = 0x3
	// Position of RSVD1 field.
	PXP_OUT_CTRL_TOG_RSVD1_Pos = 0xa
	// Bit mask of RSVD1 field.
	PXP_OUT_CTRL_TOG_RSVD1_Msk = 0x7ffc00
	// Position of ALPHA_OUTPUT field.
	PXP_OUT_CTRL_TOG_ALPHA_OUTPUT_Pos = 0x17
	// Bit mask of ALPHA_OUTPUT field.
	PXP_OUT_CTRL_TOG_ALPHA_OUTPUT_Msk = 0x800000
	// Bit ALPHA_OUTPUT.
	PXP_OUT_CTRL_TOG_ALPHA_OUTPUT = 0x800000
	// Position of ALPHA field.
	PXP_OUT_CTRL_TOG_ALPHA_Pos = 0x18
	// Bit mask of ALPHA field.
	PXP_OUT_CTRL_TOG_ALPHA_Msk = 0xff000000

	// OUT_BUF: Output Frame Buffer Pointer
	// Position of ADDR field.
	PXP_OUT_BUF_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	PXP_OUT_BUF_ADDR_Msk = 0xffffffff

	// OUT_BUF2: Output Frame Buffer Pointer #2
	// Position of ADDR field.
	PXP_OUT_BUF2_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	PXP_OUT_BUF2_ADDR_Msk = 0xffffffff

	// OUT_PITCH: Output Buffer Pitch
	// Position of PITCH field.
	PXP_OUT_PITCH_PITCH_Pos = 0x0
	// Bit mask of PITCH field.
	PXP_OUT_PITCH_PITCH_Msk = 0xffff
	// Position of RSVD field.
	PXP_OUT_PITCH_RSVD_Pos = 0x10
	// Bit mask of RSVD field.
	PXP_OUT_PITCH_RSVD_Msk = 0xffff0000

	// OUT_LRC: Output Surface Lower Right Coordinate
	// Position of Y field.
	PXP_OUT_LRC_Y_Pos = 0x0
	// Bit mask of Y field.
	PXP_OUT_LRC_Y_Msk = 0x3fff
	// Position of RSVD0 field.
	PXP_OUT_LRC_RSVD0_Pos = 0xe
	// Bit mask of RSVD0 field.
	PXP_OUT_LRC_RSVD0_Msk = 0xc000
	// Position of X field.
	PXP_OUT_LRC_X_Pos = 0x10
	// Bit mask of X field.
	PXP_OUT_LRC_X_Msk = 0x3fff0000
	// Position of RSVD1 field.
	PXP_OUT_LRC_RSVD1_Pos = 0x1e
	// Bit mask of RSVD1 field.
	PXP_OUT_LRC_RSVD1_Msk = 0xc0000000

	// OUT_PS_ULC: Processed Surface Upper Left Coordinate
	// Position of Y field.
	PXP_OUT_PS_ULC_Y_Pos = 0x0
	// Bit mask of Y field.
	PXP_OUT_PS_ULC_Y_Msk = 0x3fff
	// Position of RSVD0 field.
	PXP_OUT_PS_ULC_RSVD0_Pos = 0xe
	// Bit mask of RSVD0 field.
	PXP_OUT_PS_ULC_RSVD0_Msk = 0xc000
	// Position of X field.
	PXP_OUT_PS_ULC_X_Pos = 0x10
	// Bit mask of X field.
	PXP_OUT_PS_ULC_X_Msk = 0x3fff0000
	// Position of RSVD1 field.
	PXP_OUT_PS_ULC_RSVD1_Pos = 0x1e
	// Bit mask of RSVD1 field.
	PXP_OUT_PS_ULC_RSVD1_Msk = 0xc0000000

	// OUT_PS_LRC: Processed Surface Lower Right Coordinate
	// Position of Y field.
	PXP_OUT_PS_LRC_Y_Pos = 0x0
	// Bit mask of Y field.
	PXP_OUT_PS_LRC_Y_Msk = 0x3fff
	// Position of RSVD0 field.
	PXP_OUT_PS_LRC_RSVD0_Pos = 0xe
	// Bit mask of RSVD0 field.
	PXP_OUT_PS_LRC_RSVD0_Msk = 0xc000
	// Position of X field.
	PXP_OUT_PS_LRC_X_Pos = 0x10
	// Bit mask of X field.
	PXP_OUT_PS_LRC_X_Msk = 0x3fff0000
	// Position of RSVD1 field.
	PXP_OUT_PS_LRC_RSVD1_Pos = 0x1e
	// Bit mask of RSVD1 field.
	PXP_OUT_PS_LRC_RSVD1_Msk = 0xc0000000

	// OUT_AS_ULC: Alpha Surface Upper Left Coordinate
	// Position of Y field.
	PXP_OUT_AS_ULC_Y_Pos = 0x0
	// Bit mask of Y field.
	PXP_OUT_AS_ULC_Y_Msk = 0x3fff
	// Position of RSVD0 field.
	PXP_OUT_AS_ULC_RSVD0_Pos = 0xe
	// Bit mask of RSVD0 field.
	PXP_OUT_AS_ULC_RSVD0_Msk = 0xc000
	// Position of X field.
	PXP_OUT_AS_ULC_X_Pos = 0x10
	// Bit mask of X field.
	PXP_OUT_AS_ULC_X_Msk = 0x3fff0000
	// Position of RSVD1 field.
	PXP_OUT_AS_ULC_RSVD1_Pos = 0x1e
	// Bit mask of RSVD1 field.
	PXP_OUT_AS_ULC_RSVD1_Msk = 0xc0000000

	// OUT_AS_LRC: Alpha Surface Lower Right Coordinate
	// Position of Y field.
	PXP_OUT_AS_LRC_Y_Pos = 0x0
	// Bit mask of Y field.
	PXP_OUT_AS_LRC_Y_Msk = 0x3fff
	// Position of RSVD0 field.
	PXP_OUT_AS_LRC_RSVD0_Pos = 0xe
	// Bit mask of RSVD0 field.
	PXP_OUT_AS_LRC_RSVD0_Msk = 0xc000
	// Position of X field.
	PXP_OUT_AS_LRC_X_Pos = 0x10
	// Bit mask of X field.
	PXP_OUT_AS_LRC_X_Msk = 0x3fff0000
	// Position of RSVD1 field.
	PXP_OUT_AS_LRC_RSVD1_Pos = 0x1e
	// Bit mask of RSVD1 field.
	PXP_OUT_AS_LRC_RSVD1_Msk = 0xc0000000

	// PS_CTRL: Processed Surface (PS) Control Register
	// Position of FORMAT field.
	PXP_PS_CTRL_FORMAT_Pos = 0x0
	// Bit mask of FORMAT field.
	PXP_PS_CTRL_FORMAT_Msk = 0x1f
	// 32-bit pixels (unpacked 24-bit format)
	PXP_PS_CTRL_FORMAT_RGB888 = 0x4
	// 16-bit pixels
	PXP_PS_CTRL_FORMAT_RGB555 = 0xc
	// 16-bit pixels
	PXP_PS_CTRL_FORMAT_RGB444 = 0xd
	// 16-bit pixels
	PXP_PS_CTRL_FORMAT_RGB565 = 0xe
	// 32-bit pixels (1-plane XYUV unpacked)
	PXP_PS_CTRL_FORMAT_YUV1P444 = 0x10
	// 16-bit pixels (1-plane U0,Y0,V0,Y1 interleaved bytes)
	PXP_PS_CTRL_FORMAT_UYVY1P422 = 0x12
	// 16-bit pixels (1-plane V0,Y0,U0,Y1 interleaved bytes)
	PXP_PS_CTRL_FORMAT_VYUY1P422 = 0x13
	// 8-bit monochrome pixels (1-plane Y luma output)
	PXP_PS_CTRL_FORMAT_Y8 = 0x14
	// 4-bit monochrome pixels (1-plane Y luma, 4 bit truncation)
	PXP_PS_CTRL_FORMAT_Y4 = 0x15
	// 16-bit pixels (2-plane UV interleaved bytes)
	PXP_PS_CTRL_FORMAT_YUV2P422 = 0x18
	// 16-bit pixels (2-plane UV)
	PXP_PS_CTRL_FORMAT_YUV2P420 = 0x19
	// 16-bit pixels (2-plane VU interleaved bytes)
	PXP_PS_CTRL_FORMAT_YVU2P422 = 0x1a
	// 16-bit pixels (2-plane VU)
	PXP_PS_CTRL_FORMAT_YVU2P420 = 0x1b
	// 16-bit pixels (3-plane format)
	PXP_PS_CTRL_FORMAT_YUV422 = 0x1e
	// 16-bit pixels (3-plane format)
	PXP_PS_CTRL_FORMAT_YUV420 = 0x1f
	// Position of WB_SWAP field.
	PXP_PS_CTRL_WB_SWAP_Pos = 0x5
	// Bit mask of WB_SWAP field.
	PXP_PS_CTRL_WB_SWAP_Msk = 0x20
	// Bit WB_SWAP.
	PXP_PS_CTRL_WB_SWAP = 0x20
	// Position of RSVD0 field.
	PXP_PS_CTRL_RSVD0_Pos = 0x6
	// Bit mask of RSVD0 field.
	PXP_PS_CTRL_RSVD0_Msk = 0xc0
	// Position of DECY field.
	PXP_PS_CTRL_DECY_Pos = 0x8
	// Bit mask of DECY field.
	PXP_PS_CTRL_DECY_Msk = 0x300
	// Disable pre-decimation filter.
	PXP_PS_CTRL_DECY_DISABLE = 0x0
	// Decimate PS by 2.
	PXP_PS_CTRL_DECY_DECY2 = 0x1
	// Decimate PS by 4.
	PXP_PS_CTRL_DECY_DECY4 = 0x2
	// Decimate PS by 8.
	PXP_PS_CTRL_DECY_DECY8 = 0x3
	// Position of DECX field.
	PXP_PS_CTRL_DECX_Pos = 0xa
	// Bit mask of DECX field.
	PXP_PS_CTRL_DECX_Msk = 0xc00
	// Disable pre-decimation filter.
	PXP_PS_CTRL_DECX_DISABLE = 0x0
	// Decimate PS by 2.
	PXP_PS_CTRL_DECX_DECX2 = 0x1
	// Decimate PS by 4.
	PXP_PS_CTRL_DECX_DECX4 = 0x2
	// Decimate PS by 8.
	PXP_PS_CTRL_DECX_DECX8 = 0x3
	// Position of RSVD1 field.
	PXP_PS_CTRL_RSVD1_Pos = 0xc
	// Bit mask of RSVD1 field.
	PXP_PS_CTRL_RSVD1_Msk = 0xfffff000

	// PS_CTRL_SET: Processed Surface (PS) Control Register
	// Position of FORMAT field.
	PXP_PS_CTRL_SET_FORMAT_Pos = 0x0
	// Bit mask of FORMAT field.
	PXP_PS_CTRL_SET_FORMAT_Msk = 0x1f
	// 32-bit pixels (unpacked 24-bit format)
	PXP_PS_CTRL_SET_FORMAT_RGB888 = 0x4
	// 16-bit pixels
	PXP_PS_CTRL_SET_FORMAT_RGB555 = 0xc
	// 16-bit pixels
	PXP_PS_CTRL_SET_FORMAT_RGB444 = 0xd
	// 16-bit pixels
	PXP_PS_CTRL_SET_FORMAT_RGB565 = 0xe
	// 32-bit pixels (1-plane XYUV unpacked)
	PXP_PS_CTRL_SET_FORMAT_YUV1P444 = 0x10
	// 16-bit pixels (1-plane U0,Y0,V0,Y1 interleaved bytes)
	PXP_PS_CTRL_SET_FORMAT_UYVY1P422 = 0x12
	// 16-bit pixels (1-plane V0,Y0,U0,Y1 interleaved bytes)
	PXP_PS_CTRL_SET_FORMAT_VYUY1P422 = 0x13
	// 8-bit monochrome pixels (1-plane Y luma output)
	PXP_PS_CTRL_SET_FORMAT_Y8 = 0x14
	// 4-bit monochrome pixels (1-plane Y luma, 4 bit truncation)
	PXP_PS_CTRL_SET_FORMAT_Y4 = 0x15
	// 16-bit pixels (2-plane UV interleaved bytes)
	PXP_PS_CTRL_SET_FORMAT_YUV2P422 = 0x18
	// 16-bit pixels (2-plane UV)
	PXP_PS_CTRL_SET_FORMAT_YUV2P420 = 0x19
	// 16-bit pixels (2-plane VU interleaved bytes)
	PXP_PS_CTRL_SET_FORMAT_YVU2P422 = 0x1a
	// 16-bit pixels (2-plane VU)
	PXP_PS_CTRL_SET_FORMAT_YVU2P420 = 0x1b
	// 16-bit pixels (3-plane format)
	PXP_PS_CTRL_SET_FORMAT_YUV422 = 0x1e
	// 16-bit pixels (3-plane format)
	PXP_PS_CTRL_SET_FORMAT_YUV420 = 0x1f
	// Position of WB_SWAP field.
	PXP_PS_CTRL_SET_WB_SWAP_Pos = 0x5
	// Bit mask of WB_SWAP field.
	PXP_PS_CTRL_SET_WB_SWAP_Msk = 0x20
	// Bit WB_SWAP.
	PXP_PS_CTRL_SET_WB_SWAP = 0x20
	// Position of RSVD0 field.
	PXP_PS_CTRL_SET_RSVD0_Pos = 0x6
	// Bit mask of RSVD0 field.
	PXP_PS_CTRL_SET_RSVD0_Msk = 0xc0
	// Position of DECY field.
	PXP_PS_CTRL_SET_DECY_Pos = 0x8
	// Bit mask of DECY field.
	PXP_PS_CTRL_SET_DECY_Msk = 0x300
	// Disable pre-decimation filter.
	PXP_PS_CTRL_SET_DECY_DISABLE = 0x0
	// Decimate PS by 2.
	PXP_PS_CTRL_SET_DECY_DECY2 = 0x1
	// Decimate PS by 4.
	PXP_PS_CTRL_SET_DECY_DECY4 = 0x2
	// Decimate PS by 8.
	PXP_PS_CTRL_SET_DECY_DECY8 = 0x3
	// Position of DECX field.
	PXP_PS_CTRL_SET_DECX_Pos = 0xa
	// Bit mask of DECX field.
	PXP_PS_CTRL_SET_DECX_Msk = 0xc00
	// Disable pre-decimation filter.
	PXP_PS_CTRL_SET_DECX_DISABLE = 0x0
	// Decimate PS by 2.
	PXP_PS_CTRL_SET_DECX_DECX2 = 0x1
	// Decimate PS by 4.
	PXP_PS_CTRL_SET_DECX_DECX4 = 0x2
	// Decimate PS by 8.
	PXP_PS_CTRL_SET_DECX_DECX8 = 0x3
	// Position of RSVD1 field.
	PXP_PS_CTRL_SET_RSVD1_Pos = 0xc
	// Bit mask of RSVD1 field.
	PXP_PS_CTRL_SET_RSVD1_Msk = 0xfffff000

	// PS_CTRL_CLR: Processed Surface (PS) Control Register
	// Position of FORMAT field.
	PXP_PS_CTRL_CLR_FORMAT_Pos = 0x0
	// Bit mask of FORMAT field.
	PXP_PS_CTRL_CLR_FORMAT_Msk = 0x1f
	// 32-bit pixels (unpacked 24-bit format)
	PXP_PS_CTRL_CLR_FORMAT_RGB888 = 0x4
	// 16-bit pixels
	PXP_PS_CTRL_CLR_FORMAT_RGB555 = 0xc
	// 16-bit pixels
	PXP_PS_CTRL_CLR_FORMAT_RGB444 = 0xd
	// 16-bit pixels
	PXP_PS_CTRL_CLR_FORMAT_RGB565 = 0xe
	// 32-bit pixels (1-plane XYUV unpacked)
	PXP_PS_CTRL_CLR_FORMAT_YUV1P444 = 0x10
	// 16-bit pixels (1-plane U0,Y0,V0,Y1 interleaved bytes)
	PXP_PS_CTRL_CLR_FORMAT_UYVY1P422 = 0x12
	// 16-bit pixels (1-plane V0,Y0,U0,Y1 interleaved bytes)
	PXP_PS_CTRL_CLR_FORMAT_VYUY1P422 = 0x13
	// 8-bit monochrome pixels (1-plane Y luma output)
	PXP_PS_CTRL_CLR_FORMAT_Y8 = 0x14
	// 4-bit monochrome pixels (1-plane Y luma, 4 bit truncation)
	PXP_PS_CTRL_CLR_FORMAT_Y4 = 0x15
	// 16-bit pixels (2-plane UV interleaved bytes)
	PXP_PS_CTRL_CLR_FORMAT_YUV2P422 = 0x18
	// 16-bit pixels (2-plane UV)
	PXP_PS_CTRL_CLR_FORMAT_YUV2P420 = 0x19
	// 16-bit pixels (2-plane VU interleaved bytes)
	PXP_PS_CTRL_CLR_FORMAT_YVU2P422 = 0x1a
	// 16-bit pixels (2-plane VU)
	PXP_PS_CTRL_CLR_FORMAT_YVU2P420 = 0x1b
	// 16-bit pixels (3-plane format)
	PXP_PS_CTRL_CLR_FORMAT_YUV422 = 0x1e
	// 16-bit pixels (3-plane format)
	PXP_PS_CTRL_CLR_FORMAT_YUV420 = 0x1f
	// Position of WB_SWAP field.
	PXP_PS_CTRL_CLR_WB_SWAP_Pos = 0x5
	// Bit mask of WB_SWAP field.
	PXP_PS_CTRL_CLR_WB_SWAP_Msk = 0x20
	// Bit WB_SWAP.
	PXP_PS_CTRL_CLR_WB_SWAP = 0x20
	// Position of RSVD0 field.
	PXP_PS_CTRL_CLR_RSVD0_Pos = 0x6
	// Bit mask of RSVD0 field.
	PXP_PS_CTRL_CLR_RSVD0_Msk = 0xc0
	// Position of DECY field.
	PXP_PS_CTRL_CLR_DECY_Pos = 0x8
	// Bit mask of DECY field.
	PXP_PS_CTRL_CLR_DECY_Msk = 0x300
	// Disable pre-decimation filter.
	PXP_PS_CTRL_CLR_DECY_DISABLE = 0x0
	// Decimate PS by 2.
	PXP_PS_CTRL_CLR_DECY_DECY2 = 0x1
	// Decimate PS by 4.
	PXP_PS_CTRL_CLR_DECY_DECY4 = 0x2
	// Decimate PS by 8.
	PXP_PS_CTRL_CLR_DECY_DECY8 = 0x3
	// Position of DECX field.
	PXP_PS_CTRL_CLR_DECX_Pos = 0xa
	// Bit mask of DECX field.
	PXP_PS_CTRL_CLR_DECX_Msk = 0xc00
	// Disable pre-decimation filter.
	PXP_PS_CTRL_CLR_DECX_DISABLE = 0x0
	// Decimate PS by 2.
	PXP_PS_CTRL_CLR_DECX_DECX2 = 0x1
	// Decimate PS by 4.
	PXP_PS_CTRL_CLR_DECX_DECX4 = 0x2
	// Decimate PS by 8.
	PXP_PS_CTRL_CLR_DECX_DECX8 = 0x3
	// Position of RSVD1 field.
	PXP_PS_CTRL_CLR_RSVD1_Pos = 0xc
	// Bit mask of RSVD1 field.
	PXP_PS_CTRL_CLR_RSVD1_Msk = 0xfffff000

	// PS_CTRL_TOG: Processed Surface (PS) Control Register
	// Position of FORMAT field.
	PXP_PS_CTRL_TOG_FORMAT_Pos = 0x0
	// Bit mask of FORMAT field.
	PXP_PS_CTRL_TOG_FORMAT_Msk = 0x1f
	// 32-bit pixels (unpacked 24-bit format)
	PXP_PS_CTRL_TOG_FORMAT_RGB888 = 0x4
	// 16-bit pixels
	PXP_PS_CTRL_TOG_FORMAT_RGB555 = 0xc
	// 16-bit pixels
	PXP_PS_CTRL_TOG_FORMAT_RGB444 = 0xd
	// 16-bit pixels
	PXP_PS_CTRL_TOG_FORMAT_RGB565 = 0xe
	// 32-bit pixels (1-plane XYUV unpacked)
	PXP_PS_CTRL_TOG_FORMAT_YUV1P444 = 0x10
	// 16-bit pixels (1-plane U0,Y0,V0,Y1 interleaved bytes)
	PXP_PS_CTRL_TOG_FORMAT_UYVY1P422 = 0x12
	// 16-bit pixels (1-plane V0,Y0,U0,Y1 interleaved bytes)
	PXP_PS_CTRL_TOG_FORMAT_VYUY1P422 = 0x13
	// 8-bit monochrome pixels (1-plane Y luma output)
	PXP_PS_CTRL_TOG_FORMAT_Y8 = 0x14
	// 4-bit monochrome pixels (1-plane Y luma, 4 bit truncation)
	PXP_PS_CTRL_TOG_FORMAT_Y4 = 0x15
	// 16-bit pixels (2-plane UV interleaved bytes)
	PXP_PS_CTRL_TOG_FORMAT_YUV2P422 = 0x18
	// 16-bit pixels (2-plane UV)
	PXP_PS_CTRL_TOG_FORMAT_YUV2P420 = 0x19
	// 16-bit pixels (2-plane VU interleaved bytes)
	PXP_PS_CTRL_TOG_FORMAT_YVU2P422 = 0x1a
	// 16-bit pixels (2-plane VU)
	PXP_PS_CTRL_TOG_FORMAT_YVU2P420 = 0x1b
	// 16-bit pixels (3-plane format)
	PXP_PS_CTRL_TOG_FORMAT_YUV422 = 0x1e
	// 16-bit pixels (3-plane format)
	PXP_PS_CTRL_TOG_FORMAT_YUV420 = 0x1f
	// Position of WB_SWAP field.
	PXP_PS_CTRL_TOG_WB_SWAP_Pos = 0x5
	// Bit mask of WB_SWAP field.
	PXP_PS_CTRL_TOG_WB_SWAP_Msk = 0x20
	// Bit WB_SWAP.
	PXP_PS_CTRL_TOG_WB_SWAP = 0x20
	// Position of RSVD0 field.
	PXP_PS_CTRL_TOG_RSVD0_Pos = 0x6
	// Bit mask of RSVD0 field.
	PXP_PS_CTRL_TOG_RSVD0_Msk = 0xc0
	// Position of DECY field.
	PXP_PS_CTRL_TOG_DECY_Pos = 0x8
	// Bit mask of DECY field.
	PXP_PS_CTRL_TOG_DECY_Msk = 0x300
	// Disable pre-decimation filter.
	PXP_PS_CTRL_TOG_DECY_DISABLE = 0x0
	// Decimate PS by 2.
	PXP_PS_CTRL_TOG_DECY_DECY2 = 0x1
	// Decimate PS by 4.
	PXP_PS_CTRL_TOG_DECY_DECY4 = 0x2
	// Decimate PS by 8.
	PXP_PS_CTRL_TOG_DECY_DECY8 = 0x3
	// Position of DECX field.
	PXP_PS_CTRL_TOG_DECX_Pos = 0xa
	// Bit mask of DECX field.
	PXP_PS_CTRL_TOG_DECX_Msk = 0xc00
	// Disable pre-decimation filter.
	PXP_PS_CTRL_TOG_DECX_DISABLE = 0x0
	// Decimate PS by 2.
	PXP_PS_CTRL_TOG_DECX_DECX2 = 0x1
	// Decimate PS by 4.
	PXP_PS_CTRL_TOG_DECX_DECX4 = 0x2
	// Decimate PS by 8.
	PXP_PS_CTRL_TOG_DECX_DECX8 = 0x3
	// Position of RSVD1 field.
	PXP_PS_CTRL_TOG_RSVD1_Pos = 0xc
	// Bit mask of RSVD1 field.
	PXP_PS_CTRL_TOG_RSVD1_Msk = 0xfffff000

	// PS_BUF: PS Input Buffer Address
	// Position of ADDR field.
	PXP_PS_BUF_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	PXP_PS_BUF_ADDR_Msk = 0xffffffff

	// PS_UBUF: PS U/Cb or 2 Plane UV Input Buffer Address
	// Position of ADDR field.
	PXP_PS_UBUF_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	PXP_PS_UBUF_ADDR_Msk = 0xffffffff

	// PS_VBUF: PS V/Cr Input Buffer Address
	// Position of ADDR field.
	PXP_PS_VBUF_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	PXP_PS_VBUF_ADDR_Msk = 0xffffffff

	// PS_PITCH: Processed Surface Pitch
	// Position of PITCH field.
	PXP_PS_PITCH_PITCH_Pos = 0x0
	// Bit mask of PITCH field.
	PXP_PS_PITCH_PITCH_Msk = 0xffff
	// Position of RSVD field.
	PXP_PS_PITCH_RSVD_Pos = 0x10
	// Bit mask of RSVD field.
	PXP_PS_PITCH_RSVD_Msk = 0xffff0000

	// PS_BACKGROUND: PS Background Color
	// Position of COLOR field.
	PXP_PS_BACKGROUND_COLOR_Pos = 0x0
	// Bit mask of COLOR field.
	PXP_PS_BACKGROUND_COLOR_Msk = 0xffffff
	// Position of RSVD field.
	PXP_PS_BACKGROUND_RSVD_Pos = 0x18
	// Bit mask of RSVD field.
	PXP_PS_BACKGROUND_RSVD_Msk = 0xff000000

	// PS_SCALE: PS Scale Factor Register
	// Position of XSCALE field.
	PXP_PS_SCALE_XSCALE_Pos = 0x0
	// Bit mask of XSCALE field.
	PXP_PS_SCALE_XSCALE_Msk = 0x7fff
	// Position of RSVD1 field.
	PXP_PS_SCALE_RSVD1_Pos = 0xf
	// Bit mask of RSVD1 field.
	PXP_PS_SCALE_RSVD1_Msk = 0x8000
	// Bit RSVD1.
	PXP_PS_SCALE_RSVD1 = 0x8000
	// Position of YSCALE field.
	PXP_PS_SCALE_YSCALE_Pos = 0x10
	// Bit mask of YSCALE field.
	PXP_PS_SCALE_YSCALE_Msk = 0x7fff0000
	// Position of RSVD2 field.
	PXP_PS_SCALE_RSVD2_Pos = 0x1f
	// Bit mask of RSVD2 field.
	PXP_PS_SCALE_RSVD2_Msk = 0x80000000
	// Bit RSVD2.
	PXP_PS_SCALE_RSVD2 = 0x80000000

	// PS_OFFSET: PS Scale Offset Register
	// Position of XOFFSET field.
	PXP_PS_OFFSET_XOFFSET_Pos = 0x0
	// Bit mask of XOFFSET field.
	PXP_PS_OFFSET_XOFFSET_Msk = 0xfff
	// Position of RSVD1 field.
	PXP_PS_OFFSET_RSVD1_Pos = 0xc
	// Bit mask of RSVD1 field.
	PXP_PS_OFFSET_RSVD1_Msk = 0xf000
	// Position of YOFFSET field.
	PXP_PS_OFFSET_YOFFSET_Pos = 0x10
	// Bit mask of YOFFSET field.
	PXP_PS_OFFSET_YOFFSET_Msk = 0xfff0000
	// Position of RSVD2 field.
	PXP_PS_OFFSET_RSVD2_Pos = 0x1c
	// Bit mask of RSVD2 field.
	PXP_PS_OFFSET_RSVD2_Msk = 0xf0000000

	// PS_CLRKEYLOW: PS Color Key Low
	// Position of PIXEL field.
	PXP_PS_CLRKEYLOW_PIXEL_Pos = 0x0
	// Bit mask of PIXEL field.
	PXP_PS_CLRKEYLOW_PIXEL_Msk = 0xffffff
	// Position of RSVD1 field.
	PXP_PS_CLRKEYLOW_RSVD1_Pos = 0x18
	// Bit mask of RSVD1 field.
	PXP_PS_CLRKEYLOW_RSVD1_Msk = 0xff000000

	// PS_CLRKEYHIGH: PS Color Key High
	// Position of PIXEL field.
	PXP_PS_CLRKEYHIGH_PIXEL_Pos = 0x0
	// Bit mask of PIXEL field.
	PXP_PS_CLRKEYHIGH_PIXEL_Msk = 0xffffff
	// Position of RSVD1 field.
	PXP_PS_CLRKEYHIGH_RSVD1_Pos = 0x18
	// Bit mask of RSVD1 field.
	PXP_PS_CLRKEYHIGH_RSVD1_Msk = 0xff000000

	// AS_CTRL: Alpha Surface Control
	// Position of RSVD0 field.
	PXP_AS_CTRL_RSVD0_Pos = 0x0
	// Bit mask of RSVD0 field.
	PXP_AS_CTRL_RSVD0_Msk = 0x1
	// Bit RSVD0.
	PXP_AS_CTRL_RSVD0 = 0x1
	// Position of ALPHA_CTRL field.
	PXP_AS_CTRL_ALPHA_CTRL_Pos = 0x1
	// Bit mask of ALPHA_CTRL field.
	PXP_AS_CTRL_ALPHA_CTRL_Msk = 0x6
	// Indicates that the AS pixel alpha value will be used to blend the AS with PS. The ALPHA field is ignored.
	PXP_AS_CTRL_ALPHA_CTRL_Embedded = 0x0
	// Indicates that the value in the ALPHA field should be used instead of the alpha values present in the input pixels.
	PXP_AS_CTRL_ALPHA_CTRL_Override = 0x1
	// Indicates that the value in the ALPHA field should be used to scale all pixel alpha values. Each pixel alpha is multiplied by the value in the ALPHA field.
	PXP_AS_CTRL_ALPHA_CTRL_Multiply = 0x2
	// Enable ROPs. The ROP field indicates an operation to be performed on the alpha surface and PS pixels.
	PXP_AS_CTRL_ALPHA_CTRL_ROPs = 0x3
	// Position of ENABLE_COLORKEY field.
	PXP_AS_CTRL_ENABLE_COLORKEY_Pos = 0x3
	// Bit mask of ENABLE_COLORKEY field.
	PXP_AS_CTRL_ENABLE_COLORKEY_Msk = 0x8
	// Bit ENABLE_COLORKEY.
	PXP_AS_CTRL_ENABLE_COLORKEY = 0x8
	// Position of FORMAT field.
	PXP_AS_CTRL_FORMAT_Pos = 0x4
	// Bit mask of FORMAT field.
	PXP_AS_CTRL_FORMAT_Msk = 0xf0
	// 32-bit pixels with alpha
	PXP_AS_CTRL_FORMAT_ARGB8888 = 0x0
	// 32-bit pixels without alpha (unpacked 24-bit format)
	PXP_AS_CTRL_FORMAT_RGB888 = 0x4
	// 16-bit pixels with alpha
	PXP_AS_CTRL_FORMAT_ARGB1555 = 0x8
	// 16-bit pixels with alpha
	PXP_AS_CTRL_FORMAT_ARGB4444 = 0x9
	// 16-bit pixels without alpha
	PXP_AS_CTRL_FORMAT_RGB555 = 0xc
	// 16-bit pixels without alpha
	PXP_AS_CTRL_FORMAT_RGB444 = 0xd
	// 16-bit pixels without alpha
	PXP_AS_CTRL_FORMAT_RGB565 = 0xe
	// Position of ALPHA field.
	PXP_AS_CTRL_ALPHA_Pos = 0x8
	// Bit mask of ALPHA field.
	PXP_AS_CTRL_ALPHA_Msk = 0xff00
	// Position of ROP field.
	PXP_AS_CTRL_ROP_Pos = 0x10
	// Bit mask of ROP field.
	PXP_AS_CTRL_ROP_Msk = 0xf0000
	// AS AND PS
	PXP_AS_CTRL_ROP_MASKAS = 0x0
	// nAS AND PS
	PXP_AS_CTRL_ROP_MASKNOTAS = 0x1
	// AS AND nPS
	PXP_AS_CTRL_ROP_MASKASNOT = 0x2
	// AS OR PS
	PXP_AS_CTRL_ROP_MERGEAS = 0x3
	// nAS OR PS
	PXP_AS_CTRL_ROP_MERGENOTAS = 0x4
	// AS OR nPS
	PXP_AS_CTRL_ROP_MERGEASNOT = 0x5
	// nAS
	PXP_AS_CTRL_ROP_NOTCOPYAS = 0x6
	// nPS
	PXP_AS_CTRL_ROP_NOT = 0x7
	// AS NAND PS
	PXP_AS_CTRL_ROP_NOTMASKAS = 0x8
	// AS NOR PS
	PXP_AS_CTRL_ROP_NOTMERGEAS = 0x9
	// AS XOR PS
	PXP_AS_CTRL_ROP_XORAS = 0xa
	// AS XNOR PS
	PXP_AS_CTRL_ROP_NOTXORAS = 0xb
	// Position of ALPHA_INVERT field.
	PXP_AS_CTRL_ALPHA_INVERT_Pos = 0x14
	// Bit mask of ALPHA_INVERT field.
	PXP_AS_CTRL_ALPHA_INVERT_Msk = 0x100000
	// Bit ALPHA_INVERT.
	PXP_AS_CTRL_ALPHA_INVERT = 0x100000
	// Position of RSVD1 field.
	PXP_AS_CTRL_RSVD1_Pos = 0x15
	// Bit mask of RSVD1 field.
	PXP_AS_CTRL_RSVD1_Msk = 0xffe00000

	// AS_BUF: Alpha Surface Buffer Pointer
	// Position of ADDR field.
	PXP_AS_BUF_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	PXP_AS_BUF_ADDR_Msk = 0xffffffff

	// AS_PITCH: Alpha Surface Pitch
	// Position of PITCH field.
	PXP_AS_PITCH_PITCH_Pos = 0x0
	// Bit mask of PITCH field.
	PXP_AS_PITCH_PITCH_Msk = 0xffff
	// Position of RSVD field.
	PXP_AS_PITCH_RSVD_Pos = 0x10
	// Bit mask of RSVD field.
	PXP_AS_PITCH_RSVD_Msk = 0xffff0000

	// AS_CLRKEYLOW: Overlay Color Key Low
	// Position of PIXEL field.
	PXP_AS_CLRKEYLOW_PIXEL_Pos = 0x0
	// Bit mask of PIXEL field.
	PXP_AS_CLRKEYLOW_PIXEL_Msk = 0xffffff
	// Position of RSVD1 field.
	PXP_AS_CLRKEYLOW_RSVD1_Pos = 0x18
	// Bit mask of RSVD1 field.
	PXP_AS_CLRKEYLOW_RSVD1_Msk = 0xff000000

	// AS_CLRKEYHIGH: Overlay Color Key High
	// Position of PIXEL field.
	PXP_AS_CLRKEYHIGH_PIXEL_Pos = 0x0
	// Bit mask of PIXEL field.
	PXP_AS_CLRKEYHIGH_PIXEL_Msk = 0xffffff
	// Position of RSVD1 field.
	PXP_AS_CLRKEYHIGH_RSVD1_Pos = 0x18
	// Bit mask of RSVD1 field.
	PXP_AS_CLRKEYHIGH_RSVD1_Msk = 0xff000000

	// CSC1_COEF0: Color Space Conversion Coefficient Register 0
	// Position of Y_OFFSET field.
	PXP_CSC1_COEF0_Y_OFFSET_Pos = 0x0
	// Bit mask of Y_OFFSET field.
	PXP_CSC1_COEF0_Y_OFFSET_Msk = 0x1ff
	// Position of UV_OFFSET field.
	PXP_CSC1_COEF0_UV_OFFSET_Pos = 0x9
	// Bit mask of UV_OFFSET field.
	PXP_CSC1_COEF0_UV_OFFSET_Msk = 0x3fe00
	// Position of C0 field.
	PXP_CSC1_COEF0_C0_Pos = 0x12
	// Bit mask of C0 field.
	PXP_CSC1_COEF0_C0_Msk = 0x1ffc0000
	// Position of RSVD1 field.
	PXP_CSC1_COEF0_RSVD1_Pos = 0x1d
	// Bit mask of RSVD1 field.
	PXP_CSC1_COEF0_RSVD1_Msk = 0x20000000
	// Bit RSVD1.
	PXP_CSC1_COEF0_RSVD1 = 0x20000000
	// Position of BYPASS field.
	PXP_CSC1_COEF0_BYPASS_Pos = 0x1e
	// Bit mask of BYPASS field.
	PXP_CSC1_COEF0_BYPASS_Msk = 0x40000000
	// Bit BYPASS.
	PXP_CSC1_COEF0_BYPASS = 0x40000000
	// Position of YCBCR_MODE field.
	PXP_CSC1_COEF0_YCBCR_MODE_Pos = 0x1f
	// Bit mask of YCBCR_MODE field.
	PXP_CSC1_COEF0_YCBCR_MODE_Msk = 0x80000000
	// Bit YCBCR_MODE.
	PXP_CSC1_COEF0_YCBCR_MODE = 0x80000000

	// CSC1_COEF1: Color Space Conversion Coefficient Register 1
	// Position of C4 field.
	PXP_CSC1_COEF1_C4_Pos = 0x0
	// Bit mask of C4 field.
	PXP_CSC1_COEF1_C4_Msk = 0x7ff
	// Position of RSVD0 field.
	PXP_CSC1_COEF1_RSVD0_Pos = 0xb
	// Bit mask of RSVD0 field.
	PXP_CSC1_COEF1_RSVD0_Msk = 0xf800
	// Position of C1 field.
	PXP_CSC1_COEF1_C1_Pos = 0x10
	// Bit mask of C1 field.
	PXP_CSC1_COEF1_C1_Msk = 0x7ff0000
	// Position of RSVD1 field.
	PXP_CSC1_COEF1_RSVD1_Pos = 0x1b
	// Bit mask of RSVD1 field.
	PXP_CSC1_COEF1_RSVD1_Msk = 0xf8000000

	// CSC1_COEF2: Color Space Conversion Coefficient Register 2
	// Position of C3 field.
	PXP_CSC1_COEF2_C3_Pos = 0x0
	// Bit mask of C3 field.
	PXP_CSC1_COEF2_C3_Msk = 0x7ff
	// Position of RSVD0 field.
	PXP_CSC1_COEF2_RSVD0_Pos = 0xb
	// Bit mask of RSVD0 field.
	PXP_CSC1_COEF2_RSVD0_Msk = 0xf800
	// Position of C2 field.
	PXP_CSC1_COEF2_C2_Pos = 0x10
	// Bit mask of C2 field.
	PXP_CSC1_COEF2_C2_Msk = 0x7ff0000
	// Position of RSVD1 field.
	PXP_CSC1_COEF2_RSVD1_Pos = 0x1b
	// Bit mask of RSVD1 field.
	PXP_CSC1_COEF2_RSVD1_Msk = 0xf8000000

	// POWER: PXP Power Control Register
	// Position of ROT_MEM_LP_STATE field.
	PXP_POWER_ROT_MEM_LP_STATE_Pos = 0x9
	// Bit mask of ROT_MEM_LP_STATE field.
	PXP_POWER_ROT_MEM_LP_STATE_Msk = 0xe00
	// Memory is not in low power state.
	PXP_POWER_ROT_MEM_LP_STATE_NONE = 0x0
	// Light Sleep Mode. Low leakage mode, maintain memory contents.
	PXP_POWER_ROT_MEM_LP_STATE_LS = 0x1
	// Deep Sleep Mode. Low leakage mode, maintain memory contents.
	PXP_POWER_ROT_MEM_LP_STATE_DS = 0x2
	// Shut Down Mode. Shut Down periphery and core, no memory retention.
	PXP_POWER_ROT_MEM_LP_STATE_SD = 0x4
	// Position of CTRL field.
	PXP_POWER_CTRL_Pos = 0xc
	// Bit mask of CTRL field.
	PXP_POWER_CTRL_Msk = 0xfffff000

	// NEXT: Next Frame Pointer
	// Position of ENABLED field.
	PXP_NEXT_ENABLED_Pos = 0x0
	// Bit mask of ENABLED field.
	PXP_NEXT_ENABLED_Msk = 0x1
	// Bit ENABLED.
	PXP_NEXT_ENABLED = 0x1
	// Position of RSVD field.
	PXP_NEXT_RSVD_Pos = 0x1
	// Bit mask of RSVD field.
	PXP_NEXT_RSVD_Msk = 0x2
	// Bit RSVD.
	PXP_NEXT_RSVD = 0x2
	// Position of POINTER field.
	PXP_NEXT_POINTER_Pos = 0x2
	// Bit mask of POINTER field.
	PXP_NEXT_POINTER_Msk = 0xfffffffc

	// PORTER_DUFF_CTRL: PXP Alpha Engine A Control Register.
	// Position of POTER_DUFF_ENABLE field.
	PXP_PORTER_DUFF_CTRL_POTER_DUFF_ENABLE_Pos = 0x0
	// Bit mask of POTER_DUFF_ENABLE field.
	PXP_PORTER_DUFF_CTRL_POTER_DUFF_ENABLE_Msk = 0x1
	// Bit POTER_DUFF_ENABLE.
	PXP_PORTER_DUFF_CTRL_POTER_DUFF_ENABLE = 0x1
	// Position of S0_S1_FACTOR_MODE field.
	PXP_PORTER_DUFF_CTRL_S0_S1_FACTOR_MODE_Pos = 0x1
	// Bit mask of S0_S1_FACTOR_MODE field.
	PXP_PORTER_DUFF_CTRL_S0_S1_FACTOR_MODE_Msk = 0x6
	// Position of S0_GLOBAL_ALPHA_MODE field.
	PXP_PORTER_DUFF_CTRL_S0_GLOBAL_ALPHA_MODE_Pos = 0x3
	// Bit mask of S0_GLOBAL_ALPHA_MODE field.
	PXP_PORTER_DUFF_CTRL_S0_GLOBAL_ALPHA_MODE_Msk = 0x18
	// Position of S0_ALPHA_MODE field.
	PXP_PORTER_DUFF_CTRL_S0_ALPHA_MODE_Pos = 0x5
	// Bit mask of S0_ALPHA_MODE field.
	PXP_PORTER_DUFF_CTRL_S0_ALPHA_MODE_Msk = 0x20
	// Bit S0_ALPHA_MODE.
	PXP_PORTER_DUFF_CTRL_S0_ALPHA_MODE = 0x20
	// Position of S0_COLOR_MODE field.
	PXP_PORTER_DUFF_CTRL_S0_COLOR_MODE_Pos = 0x6
	// Bit mask of S0_COLOR_MODE field.
	PXP_PORTER_DUFF_CTRL_S0_COLOR_MODE_Msk = 0x40
	// Bit S0_COLOR_MODE.
	PXP_PORTER_DUFF_CTRL_S0_COLOR_MODE = 0x40
	// Position of S1_S0_FACTOR_MODE field.
	PXP_PORTER_DUFF_CTRL_S1_S0_FACTOR_MODE_Pos = 0x8
	// Bit mask of S1_S0_FACTOR_MODE field.
	PXP_PORTER_DUFF_CTRL_S1_S0_FACTOR_MODE_Msk = 0x300
	// Position of S1_GLOBAL_ALPHA_MODE field.
	PXP_PORTER_DUFF_CTRL_S1_GLOBAL_ALPHA_MODE_Pos = 0xa
	// Bit mask of S1_GLOBAL_ALPHA_MODE field.
	PXP_PORTER_DUFF_CTRL_S1_GLOBAL_ALPHA_MODE_Msk = 0xc00
	// Position of S1_ALPHA_MODE field.
	PXP_PORTER_DUFF_CTRL_S1_ALPHA_MODE_Pos = 0xc
	// Bit mask of S1_ALPHA_MODE field.
	PXP_PORTER_DUFF_CTRL_S1_ALPHA_MODE_Msk = 0x1000
	// Bit S1_ALPHA_MODE.
	PXP_PORTER_DUFF_CTRL_S1_ALPHA_MODE = 0x1000
	// Position of S1_COLOR_MODE field.
	PXP_PORTER_DUFF_CTRL_S1_COLOR_MODE_Pos = 0xd
	// Bit mask of S1_COLOR_MODE field.
	PXP_PORTER_DUFF_CTRL_S1_COLOR_MODE_Msk = 0x2000
	// Bit S1_COLOR_MODE.
	PXP_PORTER_DUFF_CTRL_S1_COLOR_MODE = 0x2000
	// Position of S0_GLOBAL_ALPHA field.
	PXP_PORTER_DUFF_CTRL_S0_GLOBAL_ALPHA_Pos = 0x10
	// Bit mask of S0_GLOBAL_ALPHA field.
	PXP_PORTER_DUFF_CTRL_S0_GLOBAL_ALPHA_Msk = 0xff0000
	// Position of S1_GLOBAL_ALPHA field.
	PXP_PORTER_DUFF_CTRL_S1_GLOBAL_ALPHA_Pos = 0x18
	// Bit mask of S1_GLOBAL_ALPHA field.
	PXP_PORTER_DUFF_CTRL_S1_GLOBAL_ALPHA_Msk = 0xff000000
)

// Bitfields for LCDIF: LCDIF Register Reference Index
const (
	// CTRL: LCDIF General Control Register
	// Position of RUN field.
	LCDIF_CTRL_RUN_Pos = 0x0
	// Bit mask of RUN field.
	LCDIF_CTRL_RUN_Msk = 0x1
	// Bit RUN.
	LCDIF_CTRL_RUN = 0x1
	// Position of DATA_FORMAT_24_BIT field.
	LCDIF_CTRL_DATA_FORMAT_24_BIT_Pos = 0x1
	// Bit mask of DATA_FORMAT_24_BIT field.
	LCDIF_CTRL_DATA_FORMAT_24_BIT_Msk = 0x2
	// Bit DATA_FORMAT_24_BIT.
	LCDIF_CTRL_DATA_FORMAT_24_BIT = 0x2
	// Data input to the block is in 24 bpp format, such that all RGB 888 data is contained in 24 bits.
	LCDIF_CTRL_DATA_FORMAT_24_BIT_ALL_24_BITS_VALID = 0x0
	// Data input to the block is actually RGB 18 bpp, but there is 1 color per byte, hence the upper 2 bits in each byte do not contain any useful data, and should be dropped.
	LCDIF_CTRL_DATA_FORMAT_24_BIT_DROP_UPPER_2_BITS_PER_BYTE = 0x1
	// Position of DATA_FORMAT_18_BIT field.
	LCDIF_CTRL_DATA_FORMAT_18_BIT_Pos = 0x2
	// Bit mask of DATA_FORMAT_18_BIT field.
	LCDIF_CTRL_DATA_FORMAT_18_BIT_Msk = 0x4
	// Bit DATA_FORMAT_18_BIT.
	LCDIF_CTRL_DATA_FORMAT_18_BIT = 0x4
	// Data input to the block is in 18 bpp format, such that lower 18 bits contain RGB 666 and upper 14 bits do not contain any useful data.
	LCDIF_CTRL_DATA_FORMAT_18_BIT_LOWER_18_BITS_VALID = 0x0
	// Data input to the block is in 18 bpp format, such that upper 18 bits contain RGB 666 and lower 14 bits do not contain any useful data.
	LCDIF_CTRL_DATA_FORMAT_18_BIT_UPPER_18_BITS_VALID = 0x1
	// Position of DATA_FORMAT_16_BIT field.
	LCDIF_CTRL_DATA_FORMAT_16_BIT_Pos = 0x3
	// Bit mask of DATA_FORMAT_16_BIT field.
	LCDIF_CTRL_DATA_FORMAT_16_BIT_Msk = 0x8
	// Bit DATA_FORMAT_16_BIT.
	LCDIF_CTRL_DATA_FORMAT_16_BIT = 0x8
	// Position of MASTER field.
	LCDIF_CTRL_MASTER_Pos = 0x5
	// Bit mask of MASTER field.
	LCDIF_CTRL_MASTER_Msk = 0x20
	// Bit MASTER.
	LCDIF_CTRL_MASTER = 0x20
	// Position of ENABLE_PXP_HANDSHAKE field.
	LCDIF_CTRL_ENABLE_PXP_HANDSHAKE_Pos = 0x6
	// Bit mask of ENABLE_PXP_HANDSHAKE field.
	LCDIF_CTRL_ENABLE_PXP_HANDSHAKE_Msk = 0x40
	// Bit ENABLE_PXP_HANDSHAKE.
	LCDIF_CTRL_ENABLE_PXP_HANDSHAKE = 0x40
	// Position of WORD_LENGTH field.
	LCDIF_CTRL_WORD_LENGTH_Pos = 0x8
	// Bit mask of WORD_LENGTH field.
	LCDIF_CTRL_WORD_LENGTH_Msk = 0x300
	// Input data is 16 bits per pixel.
	LCDIF_CTRL_WORD_LENGTH_16_BIT = 0x0
	// Input data is 8 bits wide.
	LCDIF_CTRL_WORD_LENGTH_8_BIT = 0x1
	// Input data is 18 bits per pixel.
	LCDIF_CTRL_WORD_LENGTH_18_BIT = 0x2
	// Input data is 24 bits per pixel.
	LCDIF_CTRL_WORD_LENGTH_24_BIT = 0x3
	// Position of LCD_DATABUS_WIDTH field.
	LCDIF_CTRL_LCD_DATABUS_WIDTH_Pos = 0xa
	// Bit mask of LCD_DATABUS_WIDTH field.
	LCDIF_CTRL_LCD_DATABUS_WIDTH_Msk = 0xc00
	// 16-bit data bus mode.
	LCDIF_CTRL_LCD_DATABUS_WIDTH_16_BIT = 0x0
	// 8-bit data bus mode.
	LCDIF_CTRL_LCD_DATABUS_WIDTH_8_BIT = 0x1
	// 18-bit data bus mode.
	LCDIF_CTRL_LCD_DATABUS_WIDTH_18_BIT = 0x2
	// 24-bit data bus mode.
	LCDIF_CTRL_LCD_DATABUS_WIDTH_24_BIT = 0x3
	// Position of CSC_DATA_SWIZZLE field.
	LCDIF_CTRL_CSC_DATA_SWIZZLE_Pos = 0xc
	// Bit mask of CSC_DATA_SWIZZLE field.
	LCDIF_CTRL_CSC_DATA_SWIZZLE_Msk = 0x3000
	// No byte swapping.(Little endian)
	LCDIF_CTRL_CSC_DATA_SWIZZLE_NO_SWAP = 0x0
	// Big Endian swap (swap bytes 0,3 and 1,2).
	LCDIF_CTRL_CSC_DATA_SWIZZLE_BIG_ENDIAN_SWAP = 0x1
	// Swap half-words.
	LCDIF_CTRL_CSC_DATA_SWIZZLE_HWD_SWAP = 0x2
	// Swap bytes within each half-word.
	LCDIF_CTRL_CSC_DATA_SWIZZLE_HWD_BYTE_SWAP = 0x3
	// Position of INPUT_DATA_SWIZZLE field.
	LCDIF_CTRL_INPUT_DATA_SWIZZLE_Pos = 0xe
	// Bit mask of INPUT_DATA_SWIZZLE field.
	LCDIF_CTRL_INPUT_DATA_SWIZZLE_Msk = 0xc000
	// No byte swapping.(Little endian)
	LCDIF_CTRL_INPUT_DATA_SWIZZLE_NO_SWAP = 0x0
	// Big Endian swap (swap bytes 0,3 and 1,2).
	LCDIF_CTRL_INPUT_DATA_SWIZZLE_BIG_ENDIAN_SWAP = 0x1
	// Swap half-words.
	LCDIF_CTRL_INPUT_DATA_SWIZZLE_HWD_SWAP = 0x2
	// Swap bytes within each half-word.
	LCDIF_CTRL_INPUT_DATA_SWIZZLE_HWD_BYTE_SWAP = 0x3
	// Position of DOTCLK_MODE field.
	LCDIF_CTRL_DOTCLK_MODE_Pos = 0x11
	// Bit mask of DOTCLK_MODE field.
	LCDIF_CTRL_DOTCLK_MODE_Msk = 0x20000
	// Bit DOTCLK_MODE.
	LCDIF_CTRL_DOTCLK_MODE = 0x20000
	// Position of BYPASS_COUNT field.
	LCDIF_CTRL_BYPASS_COUNT_Pos = 0x13
	// Bit mask of BYPASS_COUNT field.
	LCDIF_CTRL_BYPASS_COUNT_Msk = 0x80000
	// Bit BYPASS_COUNT.
	LCDIF_CTRL_BYPASS_COUNT = 0x80000
	// Position of SHIFT_NUM_BITS field.
	LCDIF_CTRL_SHIFT_NUM_BITS_Pos = 0x15
	// Bit mask of SHIFT_NUM_BITS field.
	LCDIF_CTRL_SHIFT_NUM_BITS_Msk = 0x3e00000
	// Position of DATA_SHIFT_DIR field.
	LCDIF_CTRL_DATA_SHIFT_DIR_Pos = 0x1a
	// Bit mask of DATA_SHIFT_DIR field.
	LCDIF_CTRL_DATA_SHIFT_DIR_Msk = 0x4000000
	// Bit DATA_SHIFT_DIR.
	LCDIF_CTRL_DATA_SHIFT_DIR = 0x4000000
	// Data to be transmitted is shifted LEFT by SHIFT_NUM_BITS bits.
	LCDIF_CTRL_DATA_SHIFT_DIR_TXDATA_SHIFT_LEFT = 0x0
	// Data to be transmitted is shifted RIGHT by SHIFT_NUM_BITS bits.
	LCDIF_CTRL_DATA_SHIFT_DIR_TXDATA_SHIFT_RIGHT = 0x1
	// Position of CLKGATE field.
	LCDIF_CTRL_CLKGATE_Pos = 0x1e
	// Bit mask of CLKGATE field.
	LCDIF_CTRL_CLKGATE_Msk = 0x40000000
	// Bit CLKGATE.
	LCDIF_CTRL_CLKGATE = 0x40000000
	// Position of SFTRST field.
	LCDIF_CTRL_SFTRST_Pos = 0x1f
	// Bit mask of SFTRST field.
	LCDIF_CTRL_SFTRST_Msk = 0x80000000
	// Bit SFTRST.
	LCDIF_CTRL_SFTRST = 0x80000000

	// CTRL_SET: LCDIF General Control Register
	// Position of RUN field.
	LCDIF_CTRL_SET_RUN_Pos = 0x0
	// Bit mask of RUN field.
	LCDIF_CTRL_SET_RUN_Msk = 0x1
	// Bit RUN.
	LCDIF_CTRL_SET_RUN = 0x1
	// Position of DATA_FORMAT_24_BIT field.
	LCDIF_CTRL_SET_DATA_FORMAT_24_BIT_Pos = 0x1
	// Bit mask of DATA_FORMAT_24_BIT field.
	LCDIF_CTRL_SET_DATA_FORMAT_24_BIT_Msk = 0x2
	// Bit DATA_FORMAT_24_BIT.
	LCDIF_CTRL_SET_DATA_FORMAT_24_BIT = 0x2
	// Data input to the block is in 24 bpp format, such that all RGB 888 data is contained in 24 bits.
	LCDIF_CTRL_SET_DATA_FORMAT_24_BIT_ALL_24_BITS_VALID = 0x0
	// Data input to the block is actually RGB 18 bpp, but there is 1 color per byte, hence the upper 2 bits in each byte do not contain any useful data, and should be dropped.
	LCDIF_CTRL_SET_DATA_FORMAT_24_BIT_DROP_UPPER_2_BITS_PER_BYTE = 0x1
	// Position of DATA_FORMAT_18_BIT field.
	LCDIF_CTRL_SET_DATA_FORMAT_18_BIT_Pos = 0x2
	// Bit mask of DATA_FORMAT_18_BIT field.
	LCDIF_CTRL_SET_DATA_FORMAT_18_BIT_Msk = 0x4
	// Bit DATA_FORMAT_18_BIT.
	LCDIF_CTRL_SET_DATA_FORMAT_18_BIT = 0x4
	// Data input to the block is in 18 bpp format, such that lower 18 bits contain RGB 666 and upper 14 bits do not contain any useful data.
	LCDIF_CTRL_SET_DATA_FORMAT_18_BIT_LOWER_18_BITS_VALID = 0x0
	// Data input to the block is in 18 bpp format, such that upper 18 bits contain RGB 666 and lower 14 bits do not contain any useful data.
	LCDIF_CTRL_SET_DATA_FORMAT_18_BIT_UPPER_18_BITS_VALID = 0x1
	// Position of DATA_FORMAT_16_BIT field.
	LCDIF_CTRL_SET_DATA_FORMAT_16_BIT_Pos = 0x3
	// Bit mask of DATA_FORMAT_16_BIT field.
	LCDIF_CTRL_SET_DATA_FORMAT_16_BIT_Msk = 0x8
	// Bit DATA_FORMAT_16_BIT.
	LCDIF_CTRL_SET_DATA_FORMAT_16_BIT = 0x8
	// Position of MASTER field.
	LCDIF_CTRL_SET_MASTER_Pos = 0x5
	// Bit mask of MASTER field.
	LCDIF_CTRL_SET_MASTER_Msk = 0x20
	// Bit MASTER.
	LCDIF_CTRL_SET_MASTER = 0x20
	// Position of ENABLE_PXP_HANDSHAKE field.
	LCDIF_CTRL_SET_ENABLE_PXP_HANDSHAKE_Pos = 0x6
	// Bit mask of ENABLE_PXP_HANDSHAKE field.
	LCDIF_CTRL_SET_ENABLE_PXP_HANDSHAKE_Msk = 0x40
	// Bit ENABLE_PXP_HANDSHAKE.
	LCDIF_CTRL_SET_ENABLE_PXP_HANDSHAKE = 0x40
	// Position of WORD_LENGTH field.
	LCDIF_CTRL_SET_WORD_LENGTH_Pos = 0x8
	// Bit mask of WORD_LENGTH field.
	LCDIF_CTRL_SET_WORD_LENGTH_Msk = 0x300
	// Input data is 16 bits per pixel.
	LCDIF_CTRL_SET_WORD_LENGTH_16_BIT = 0x0
	// Input data is 8 bits wide.
	LCDIF_CTRL_SET_WORD_LENGTH_8_BIT = 0x1
	// Input data is 18 bits per pixel.
	LCDIF_CTRL_SET_WORD_LENGTH_18_BIT = 0x2
	// Input data is 24 bits per pixel.
	LCDIF_CTRL_SET_WORD_LENGTH_24_BIT = 0x3
	// Position of LCD_DATABUS_WIDTH field.
	LCDIF_CTRL_SET_LCD_DATABUS_WIDTH_Pos = 0xa
	// Bit mask of LCD_DATABUS_WIDTH field.
	LCDIF_CTRL_SET_LCD_DATABUS_WIDTH_Msk = 0xc00
	// 16-bit data bus mode.
	LCDIF_CTRL_SET_LCD_DATABUS_WIDTH_16_BIT = 0x0
	// 8-bit data bus mode.
	LCDIF_CTRL_SET_LCD_DATABUS_WIDTH_8_BIT = 0x1
	// 18-bit data bus mode.
	LCDIF_CTRL_SET_LCD_DATABUS_WIDTH_18_BIT = 0x2
	// 24-bit data bus mode.
	LCDIF_CTRL_SET_LCD_DATABUS_WIDTH_24_BIT = 0x3
	// Position of CSC_DATA_SWIZZLE field.
	LCDIF_CTRL_SET_CSC_DATA_SWIZZLE_Pos = 0xc
	// Bit mask of CSC_DATA_SWIZZLE field.
	LCDIF_CTRL_SET_CSC_DATA_SWIZZLE_Msk = 0x3000
	// No byte swapping.(Little endian)
	LCDIF_CTRL_SET_CSC_DATA_SWIZZLE_NO_SWAP = 0x0
	// Big Endian swap (swap bytes 0,3 and 1,2).
	LCDIF_CTRL_SET_CSC_DATA_SWIZZLE_BIG_ENDIAN_SWAP = 0x1
	// Swap half-words.
	LCDIF_CTRL_SET_CSC_DATA_SWIZZLE_HWD_SWAP = 0x2
	// Swap bytes within each half-word.
	LCDIF_CTRL_SET_CSC_DATA_SWIZZLE_HWD_BYTE_SWAP = 0x3
	// Position of INPUT_DATA_SWIZZLE field.
	LCDIF_CTRL_SET_INPUT_DATA_SWIZZLE_Pos = 0xe
	// Bit mask of INPUT_DATA_SWIZZLE field.
	LCDIF_CTRL_SET_INPUT_DATA_SWIZZLE_Msk = 0xc000
	// No byte swapping.(Little endian)
	LCDIF_CTRL_SET_INPUT_DATA_SWIZZLE_NO_SWAP = 0x0
	// Big Endian swap (swap bytes 0,3 and 1,2).
	LCDIF_CTRL_SET_INPUT_DATA_SWIZZLE_BIG_ENDIAN_SWAP = 0x1
	// Swap half-words.
	LCDIF_CTRL_SET_INPUT_DATA_SWIZZLE_HWD_SWAP = 0x2
	// Swap bytes within each half-word.
	LCDIF_CTRL_SET_INPUT_DATA_SWIZZLE_HWD_BYTE_SWAP = 0x3
	// Position of DOTCLK_MODE field.
	LCDIF_CTRL_SET_DOTCLK_MODE_Pos = 0x11
	// Bit mask of DOTCLK_MODE field.
	LCDIF_CTRL_SET_DOTCLK_MODE_Msk = 0x20000
	// Bit DOTCLK_MODE.
	LCDIF_CTRL_SET_DOTCLK_MODE = 0x20000
	// Position of BYPASS_COUNT field.
	LCDIF_CTRL_SET_BYPASS_COUNT_Pos = 0x13
	// Bit mask of BYPASS_COUNT field.
	LCDIF_CTRL_SET_BYPASS_COUNT_Msk = 0x80000
	// Bit BYPASS_COUNT.
	LCDIF_CTRL_SET_BYPASS_COUNT = 0x80000
	// Position of SHIFT_NUM_BITS field.
	LCDIF_CTRL_SET_SHIFT_NUM_BITS_Pos = 0x15
	// Bit mask of SHIFT_NUM_BITS field.
	LCDIF_CTRL_SET_SHIFT_NUM_BITS_Msk = 0x3e00000
	// Position of DATA_SHIFT_DIR field.
	LCDIF_CTRL_SET_DATA_SHIFT_DIR_Pos = 0x1a
	// Bit mask of DATA_SHIFT_DIR field.
	LCDIF_CTRL_SET_DATA_SHIFT_DIR_Msk = 0x4000000
	// Bit DATA_SHIFT_DIR.
	LCDIF_CTRL_SET_DATA_SHIFT_DIR = 0x4000000
	// Data to be transmitted is shifted LEFT by SHIFT_NUM_BITS bits.
	LCDIF_CTRL_SET_DATA_SHIFT_DIR_TXDATA_SHIFT_LEFT = 0x0
	// Data to be transmitted is shifted RIGHT by SHIFT_NUM_BITS bits.
	LCDIF_CTRL_SET_DATA_SHIFT_DIR_TXDATA_SHIFT_RIGHT = 0x1
	// Position of CLKGATE field.
	LCDIF_CTRL_SET_CLKGATE_Pos = 0x1e
	// Bit mask of CLKGATE field.
	LCDIF_CTRL_SET_CLKGATE_Msk = 0x40000000
	// Bit CLKGATE.
	LCDIF_CTRL_SET_CLKGATE = 0x40000000
	// Position of SFTRST field.
	LCDIF_CTRL_SET_SFTRST_Pos = 0x1f
	// Bit mask of SFTRST field.
	LCDIF_CTRL_SET_SFTRST_Msk = 0x80000000
	// Bit SFTRST.
	LCDIF_CTRL_SET_SFTRST = 0x80000000

	// CTRL_CLR: LCDIF General Control Register
	// Position of RUN field.
	LCDIF_CTRL_CLR_RUN_Pos = 0x0
	// Bit mask of RUN field.
	LCDIF_CTRL_CLR_RUN_Msk = 0x1
	// Bit RUN.
	LCDIF_CTRL_CLR_RUN = 0x1
	// Position of DATA_FORMAT_24_BIT field.
	LCDIF_CTRL_CLR_DATA_FORMAT_24_BIT_Pos = 0x1
	// Bit mask of DATA_FORMAT_24_BIT field.
	LCDIF_CTRL_CLR_DATA_FORMAT_24_BIT_Msk = 0x2
	// Bit DATA_FORMAT_24_BIT.
	LCDIF_CTRL_CLR_DATA_FORMAT_24_BIT = 0x2
	// Data input to the block is in 24 bpp format, such that all RGB 888 data is contained in 24 bits.
	LCDIF_CTRL_CLR_DATA_FORMAT_24_BIT_ALL_24_BITS_VALID = 0x0
	// Data input to the block is actually RGB 18 bpp, but there is 1 color per byte, hence the upper 2 bits in each byte do not contain any useful data, and should be dropped.
	LCDIF_CTRL_CLR_DATA_FORMAT_24_BIT_DROP_UPPER_2_BITS_PER_BYTE = 0x1
	// Position of DATA_FORMAT_18_BIT field.
	LCDIF_CTRL_CLR_DATA_FORMAT_18_BIT_Pos = 0x2
	// Bit mask of DATA_FORMAT_18_BIT field.
	LCDIF_CTRL_CLR_DATA_FORMAT_18_BIT_Msk = 0x4
	// Bit DATA_FORMAT_18_BIT.
	LCDIF_CTRL_CLR_DATA_FORMAT_18_BIT = 0x4
	// Data input to the block is in 18 bpp format, such that lower 18 bits contain RGB 666 and upper 14 bits do not contain any useful data.
	LCDIF_CTRL_CLR_DATA_FORMAT_18_BIT_LOWER_18_BITS_VALID = 0x0
	// Data input to the block is in 18 bpp format, such that upper 18 bits contain RGB 666 and lower 14 bits do not contain any useful data.
	LCDIF_CTRL_CLR_DATA_FORMAT_18_BIT_UPPER_18_BITS_VALID = 0x1
	// Position of DATA_FORMAT_16_BIT field.
	LCDIF_CTRL_CLR_DATA_FORMAT_16_BIT_Pos = 0x3
	// Bit mask of DATA_FORMAT_16_BIT field.
	LCDIF_CTRL_CLR_DATA_FORMAT_16_BIT_Msk = 0x8
	// Bit DATA_FORMAT_16_BIT.
	LCDIF_CTRL_CLR_DATA_FORMAT_16_BIT = 0x8
	// Position of MASTER field.
	LCDIF_CTRL_CLR_MASTER_Pos = 0x5
	// Bit mask of MASTER field.
	LCDIF_CTRL_CLR_MASTER_Msk = 0x20
	// Bit MASTER.
	LCDIF_CTRL_CLR_MASTER = 0x20
	// Position of ENABLE_PXP_HANDSHAKE field.
	LCDIF_CTRL_CLR_ENABLE_PXP_HANDSHAKE_Pos = 0x6
	// Bit mask of ENABLE_PXP_HANDSHAKE field.
	LCDIF_CTRL_CLR_ENABLE_PXP_HANDSHAKE_Msk = 0x40
	// Bit ENABLE_PXP_HANDSHAKE.
	LCDIF_CTRL_CLR_ENABLE_PXP_HANDSHAKE = 0x40
	// Position of WORD_LENGTH field.
	LCDIF_CTRL_CLR_WORD_LENGTH_Pos = 0x8
	// Bit mask of WORD_LENGTH field.
	LCDIF_CTRL_CLR_WORD_LENGTH_Msk = 0x300
	// Input data is 16 bits per pixel.
	LCDIF_CTRL_CLR_WORD_LENGTH_16_BIT = 0x0
	// Input data is 8 bits wide.
	LCDIF_CTRL_CLR_WORD_LENGTH_8_BIT = 0x1
	// Input data is 18 bits per pixel.
	LCDIF_CTRL_CLR_WORD_LENGTH_18_BIT = 0x2
	// Input data is 24 bits per pixel.
	LCDIF_CTRL_CLR_WORD_LENGTH_24_BIT = 0x3
	// Position of LCD_DATABUS_WIDTH field.
	LCDIF_CTRL_CLR_LCD_DATABUS_WIDTH_Pos = 0xa
	// Bit mask of LCD_DATABUS_WIDTH field.
	LCDIF_CTRL_CLR_LCD_DATABUS_WIDTH_Msk = 0xc00
	// 16-bit data bus mode.
	LCDIF_CTRL_CLR_LCD_DATABUS_WIDTH_16_BIT = 0x0
	// 8-bit data bus mode.
	LCDIF_CTRL_CLR_LCD_DATABUS_WIDTH_8_BIT = 0x1
	// 18-bit data bus mode.
	LCDIF_CTRL_CLR_LCD_DATABUS_WIDTH_18_BIT = 0x2
	// 24-bit data bus mode.
	LCDIF_CTRL_CLR_LCD_DATABUS_WIDTH_24_BIT = 0x3
	// Position of CSC_DATA_SWIZZLE field.
	LCDIF_CTRL_CLR_CSC_DATA_SWIZZLE_Pos = 0xc
	// Bit mask of CSC_DATA_SWIZZLE field.
	LCDIF_CTRL_CLR_CSC_DATA_SWIZZLE_Msk = 0x3000
	// No byte swapping.(Little endian)
	LCDIF_CTRL_CLR_CSC_DATA_SWIZZLE_NO_SWAP = 0x0
	// Big Endian swap (swap bytes 0,3 and 1,2).
	LCDIF_CTRL_CLR_CSC_DATA_SWIZZLE_BIG_ENDIAN_SWAP = 0x1
	// Swap half-words.
	LCDIF_CTRL_CLR_CSC_DATA_SWIZZLE_HWD_SWAP = 0x2
	// Swap bytes within each half-word.
	LCDIF_CTRL_CLR_CSC_DATA_SWIZZLE_HWD_BYTE_SWAP = 0x3
	// Position of INPUT_DATA_SWIZZLE field.
	LCDIF_CTRL_CLR_INPUT_DATA_SWIZZLE_Pos = 0xe
	// Bit mask of INPUT_DATA_SWIZZLE field.
	LCDIF_CTRL_CLR_INPUT_DATA_SWIZZLE_Msk = 0xc000
	// No byte swapping.(Little endian)
	LCDIF_CTRL_CLR_INPUT_DATA_SWIZZLE_NO_SWAP = 0x0
	// Big Endian swap (swap bytes 0,3 and 1,2).
	LCDIF_CTRL_CLR_INPUT_DATA_SWIZZLE_BIG_ENDIAN_SWAP = 0x1
	// Swap half-words.
	LCDIF_CTRL_CLR_INPUT_DATA_SWIZZLE_HWD_SWAP = 0x2
	// Swap bytes within each half-word.
	LCDIF_CTRL_CLR_INPUT_DATA_SWIZZLE_HWD_BYTE_SWAP = 0x3
	// Position of DOTCLK_MODE field.
	LCDIF_CTRL_CLR_DOTCLK_MODE_Pos = 0x11
	// Bit mask of DOTCLK_MODE field.
	LCDIF_CTRL_CLR_DOTCLK_MODE_Msk = 0x20000
	// Bit DOTCLK_MODE.
	LCDIF_CTRL_CLR_DOTCLK_MODE = 0x20000
	// Position of BYPASS_COUNT field.
	LCDIF_CTRL_CLR_BYPASS_COUNT_Pos = 0x13
	// Bit mask of BYPASS_COUNT field.
	LCDIF_CTRL_CLR_BYPASS_COUNT_Msk = 0x80000
	// Bit BYPASS_COUNT.
	LCDIF_CTRL_CLR_BYPASS_COUNT = 0x80000
	// Position of SHIFT_NUM_BITS field.
	LCDIF_CTRL_CLR_SHIFT_NUM_BITS_Pos = 0x15
	// Bit mask of SHIFT_NUM_BITS field.
	LCDIF_CTRL_CLR_SHIFT_NUM_BITS_Msk = 0x3e00000
	// Position of DATA_SHIFT_DIR field.
	LCDIF_CTRL_CLR_DATA_SHIFT_DIR_Pos = 0x1a
	// Bit mask of DATA_SHIFT_DIR field.
	LCDIF_CTRL_CLR_DATA_SHIFT_DIR_Msk = 0x4000000
	// Bit DATA_SHIFT_DIR.
	LCDIF_CTRL_CLR_DATA_SHIFT_DIR = 0x4000000
	// Data to be transmitted is shifted LEFT by SHIFT_NUM_BITS bits.
	LCDIF_CTRL_CLR_DATA_SHIFT_DIR_TXDATA_SHIFT_LEFT = 0x0
	// Data to be transmitted is shifted RIGHT by SHIFT_NUM_BITS bits.
	LCDIF_CTRL_CLR_DATA_SHIFT_DIR_TXDATA_SHIFT_RIGHT = 0x1
	// Position of CLKGATE field.
	LCDIF_CTRL_CLR_CLKGATE_Pos = 0x1e
	// Bit mask of CLKGATE field.
	LCDIF_CTRL_CLR_CLKGATE_Msk = 0x40000000
	// Bit CLKGATE.
	LCDIF_CTRL_CLR_CLKGATE = 0x40000000
	// Position of SFTRST field.
	LCDIF_CTRL_CLR_SFTRST_Pos = 0x1f
	// Bit mask of SFTRST field.
	LCDIF_CTRL_CLR_SFTRST_Msk = 0x80000000
	// Bit SFTRST.
	LCDIF_CTRL_CLR_SFTRST = 0x80000000

	// CTRL_TOG: LCDIF General Control Register
	// Position of RUN field.
	LCDIF_CTRL_TOG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	LCDIF_CTRL_TOG_RUN_Msk = 0x1
	// Bit RUN.
	LCDIF_CTRL_TOG_RUN = 0x1
	// Position of DATA_FORMAT_24_BIT field.
	LCDIF_CTRL_TOG_DATA_FORMAT_24_BIT_Pos = 0x1
	// Bit mask of DATA_FORMAT_24_BIT field.
	LCDIF_CTRL_TOG_DATA_FORMAT_24_BIT_Msk = 0x2
	// Bit DATA_FORMAT_24_BIT.
	LCDIF_CTRL_TOG_DATA_FORMAT_24_BIT = 0x2
	// Data input to the block is in 24 bpp format, such that all RGB 888 data is contained in 24 bits.
	LCDIF_CTRL_TOG_DATA_FORMAT_24_BIT_ALL_24_BITS_VALID = 0x0
	// Data input to the block is actually RGB 18 bpp, but there is 1 color per byte, hence the upper 2 bits in each byte do not contain any useful data, and should be dropped.
	LCDIF_CTRL_TOG_DATA_FORMAT_24_BIT_DROP_UPPER_2_BITS_PER_BYTE = 0x1
	// Position of DATA_FORMAT_18_BIT field.
	LCDIF_CTRL_TOG_DATA_FORMAT_18_BIT_Pos = 0x2
	// Bit mask of DATA_FORMAT_18_BIT field.
	LCDIF_CTRL_TOG_DATA_FORMAT_18_BIT_Msk = 0x4
	// Bit DATA_FORMAT_18_BIT.
	LCDIF_CTRL_TOG_DATA_FORMAT_18_BIT = 0x4
	// Data input to the block is in 18 bpp format, such that lower 18 bits contain RGB 666 and upper 14 bits do not contain any useful data.
	LCDIF_CTRL_TOG_DATA_FORMAT_18_BIT_LOWER_18_BITS_VALID = 0x0
	// Data input to the block is in 18 bpp format, such that upper 18 bits contain RGB 666 and lower 14 bits do not contain any useful data.
	LCDIF_CTRL_TOG_DATA_FORMAT_18_BIT_UPPER_18_BITS_VALID = 0x1
	// Position of DATA_FORMAT_16_BIT field.
	LCDIF_CTRL_TOG_DATA_FORMAT_16_BIT_Pos = 0x3
	// Bit mask of DATA_FORMAT_16_BIT field.
	LCDIF_CTRL_TOG_DATA_FORMAT_16_BIT_Msk = 0x8
	// Bit DATA_FORMAT_16_BIT.
	LCDIF_CTRL_TOG_DATA_FORMAT_16_BIT = 0x8
	// Position of MASTER field.
	LCDIF_CTRL_TOG_MASTER_Pos = 0x5
	// Bit mask of MASTER field.
	LCDIF_CTRL_TOG_MASTER_Msk = 0x20
	// Bit MASTER.
	LCDIF_CTRL_TOG_MASTER = 0x20
	// Position of ENABLE_PXP_HANDSHAKE field.
	LCDIF_CTRL_TOG_ENABLE_PXP_HANDSHAKE_Pos = 0x6
	// Bit mask of ENABLE_PXP_HANDSHAKE field.
	LCDIF_CTRL_TOG_ENABLE_PXP_HANDSHAKE_Msk = 0x40
	// Bit ENABLE_PXP_HANDSHAKE.
	LCDIF_CTRL_TOG_ENABLE_PXP_HANDSHAKE = 0x40
	// Position of WORD_LENGTH field.
	LCDIF_CTRL_TOG_WORD_LENGTH_Pos = 0x8
	// Bit mask of WORD_LENGTH field.
	LCDIF_CTRL_TOG_WORD_LENGTH_Msk = 0x300
	// Input data is 16 bits per pixel.
	LCDIF_CTRL_TOG_WORD_LENGTH_16_BIT = 0x0
	// Input data is 8 bits wide.
	LCDIF_CTRL_TOG_WORD_LENGTH_8_BIT = 0x1
	// Input data is 18 bits per pixel.
	LCDIF_CTRL_TOG_WORD_LENGTH_18_BIT = 0x2
	// Input data is 24 bits per pixel.
	LCDIF_CTRL_TOG_WORD_LENGTH_24_BIT = 0x3
	// Position of LCD_DATABUS_WIDTH field.
	LCDIF_CTRL_TOG_LCD_DATABUS_WIDTH_Pos = 0xa
	// Bit mask of LCD_DATABUS_WIDTH field.
	LCDIF_CTRL_TOG_LCD_DATABUS_WIDTH_Msk = 0xc00
	// 16-bit data bus mode.
	LCDIF_CTRL_TOG_LCD_DATABUS_WIDTH_16_BIT = 0x0
	// 8-bit data bus mode.
	LCDIF_CTRL_TOG_LCD_DATABUS_WIDTH_8_BIT = 0x1
	// 18-bit data bus mode.
	LCDIF_CTRL_TOG_LCD_DATABUS_WIDTH_18_BIT = 0x2
	// 24-bit data bus mode.
	LCDIF_CTRL_TOG_LCD_DATABUS_WIDTH_24_BIT = 0x3
	// Position of CSC_DATA_SWIZZLE field.
	LCDIF_CTRL_TOG_CSC_DATA_SWIZZLE_Pos = 0xc
	// Bit mask of CSC_DATA_SWIZZLE field.
	LCDIF_CTRL_TOG_CSC_DATA_SWIZZLE_Msk = 0x3000
	// No byte swapping.(Little endian)
	LCDIF_CTRL_TOG_CSC_DATA_SWIZZLE_NO_SWAP = 0x0
	// Big Endian swap (swap bytes 0,3 and 1,2).
	LCDIF_CTRL_TOG_CSC_DATA_SWIZZLE_BIG_ENDIAN_SWAP = 0x1
	// Swap half-words.
	LCDIF_CTRL_TOG_CSC_DATA_SWIZZLE_HWD_SWAP = 0x2
	// Swap bytes within each half-word.
	LCDIF_CTRL_TOG_CSC_DATA_SWIZZLE_HWD_BYTE_SWAP = 0x3
	// Position of INPUT_DATA_SWIZZLE field.
	LCDIF_CTRL_TOG_INPUT_DATA_SWIZZLE_Pos = 0xe
	// Bit mask of INPUT_DATA_SWIZZLE field.
	LCDIF_CTRL_TOG_INPUT_DATA_SWIZZLE_Msk = 0xc000
	// No byte swapping.(Little endian)
	LCDIF_CTRL_TOG_INPUT_DATA_SWIZZLE_NO_SWAP = 0x0
	// Big Endian swap (swap bytes 0,3 and 1,2).
	LCDIF_CTRL_TOG_INPUT_DATA_SWIZZLE_BIG_ENDIAN_SWAP = 0x1
	// Swap half-words.
	LCDIF_CTRL_TOG_INPUT_DATA_SWIZZLE_HWD_SWAP = 0x2
	// Swap bytes within each half-word.
	LCDIF_CTRL_TOG_INPUT_DATA_SWIZZLE_HWD_BYTE_SWAP = 0x3
	// Position of DOTCLK_MODE field.
	LCDIF_CTRL_TOG_DOTCLK_MODE_Pos = 0x11
	// Bit mask of DOTCLK_MODE field.
	LCDIF_CTRL_TOG_DOTCLK_MODE_Msk = 0x20000
	// Bit DOTCLK_MODE.
	LCDIF_CTRL_TOG_DOTCLK_MODE = 0x20000
	// Position of BYPASS_COUNT field.
	LCDIF_CTRL_TOG_BYPASS_COUNT_Pos = 0x13
	// Bit mask of BYPASS_COUNT field.
	LCDIF_CTRL_TOG_BYPASS_COUNT_Msk = 0x80000
	// Bit BYPASS_COUNT.
	LCDIF_CTRL_TOG_BYPASS_COUNT = 0x80000
	// Position of SHIFT_NUM_BITS field.
	LCDIF_CTRL_TOG_SHIFT_NUM_BITS_Pos = 0x15
	// Bit mask of SHIFT_NUM_BITS field.
	LCDIF_CTRL_TOG_SHIFT_NUM_BITS_Msk = 0x3e00000
	// Position of DATA_SHIFT_DIR field.
	LCDIF_CTRL_TOG_DATA_SHIFT_DIR_Pos = 0x1a
	// Bit mask of DATA_SHIFT_DIR field.
	LCDIF_CTRL_TOG_DATA_SHIFT_DIR_Msk = 0x4000000
	// Bit DATA_SHIFT_DIR.
	LCDIF_CTRL_TOG_DATA_SHIFT_DIR = 0x4000000
	// Data to be transmitted is shifted LEFT by SHIFT_NUM_BITS bits.
	LCDIF_CTRL_TOG_DATA_SHIFT_DIR_TXDATA_SHIFT_LEFT = 0x0
	// Data to be transmitted is shifted RIGHT by SHIFT_NUM_BITS bits.
	LCDIF_CTRL_TOG_DATA_SHIFT_DIR_TXDATA_SHIFT_RIGHT = 0x1
	// Position of CLKGATE field.
	LCDIF_CTRL_TOG_CLKGATE_Pos = 0x1e
	// Bit mask of CLKGATE field.
	LCDIF_CTRL_TOG_CLKGATE_Msk = 0x40000000
	// Bit CLKGATE.
	LCDIF_CTRL_TOG_CLKGATE = 0x40000000
	// Position of SFTRST field.
	LCDIF_CTRL_TOG_SFTRST_Pos = 0x1f
	// Bit mask of SFTRST field.
	LCDIF_CTRL_TOG_SFTRST_Msk = 0x80000000
	// Bit SFTRST.
	LCDIF_CTRL_TOG_SFTRST = 0x80000000

	// CTRL1: LCDIF General Control1 Register
	// Position of VSYNC_EDGE_IRQ field.
	LCDIF_CTRL1_VSYNC_EDGE_IRQ_Pos = 0x8
	// Bit mask of VSYNC_EDGE_IRQ field.
	LCDIF_CTRL1_VSYNC_EDGE_IRQ_Msk = 0x100
	// Bit VSYNC_EDGE_IRQ.
	LCDIF_CTRL1_VSYNC_EDGE_IRQ = 0x100
	// No Interrupt Request Pending.
	LCDIF_CTRL1_VSYNC_EDGE_IRQ_NO_REQUEST = 0x0
	// Interrupt Request Pending.
	LCDIF_CTRL1_VSYNC_EDGE_IRQ_REQUEST = 0x1
	// Position of CUR_FRAME_DONE_IRQ field.
	LCDIF_CTRL1_CUR_FRAME_DONE_IRQ_Pos = 0x9
	// Bit mask of CUR_FRAME_DONE_IRQ field.
	LCDIF_CTRL1_CUR_FRAME_DONE_IRQ_Msk = 0x200
	// Bit CUR_FRAME_DONE_IRQ.
	LCDIF_CTRL1_CUR_FRAME_DONE_IRQ = 0x200
	// No Interrupt Request Pending.
	LCDIF_CTRL1_CUR_FRAME_DONE_IRQ_NO_REQUEST = 0x0
	// Interrupt Request Pending.
	LCDIF_CTRL1_CUR_FRAME_DONE_IRQ_REQUEST = 0x1
	// Position of UNDERFLOW_IRQ field.
	LCDIF_CTRL1_UNDERFLOW_IRQ_Pos = 0xa
	// Bit mask of UNDERFLOW_IRQ field.
	LCDIF_CTRL1_UNDERFLOW_IRQ_Msk = 0x400
	// Bit UNDERFLOW_IRQ.
	LCDIF_CTRL1_UNDERFLOW_IRQ = 0x400
	// No Interrupt Request Pending.
	LCDIF_CTRL1_UNDERFLOW_IRQ_NO_REQUEST = 0x0
	// Interrupt Request Pending.
	LCDIF_CTRL1_UNDERFLOW_IRQ_REQUEST = 0x1
	// Position of OVERFLOW_IRQ field.
	LCDIF_CTRL1_OVERFLOW_IRQ_Pos = 0xb
	// Bit mask of OVERFLOW_IRQ field.
	LCDIF_CTRL1_OVERFLOW_IRQ_Msk = 0x800
	// Bit OVERFLOW_IRQ.
	LCDIF_CTRL1_OVERFLOW_IRQ = 0x800
	// No Interrupt Request Pending.
	LCDIF_CTRL1_OVERFLOW_IRQ_NO_REQUEST = 0x0
	// Interrupt Request Pending.
	LCDIF_CTRL1_OVERFLOW_IRQ_REQUEST = 0x1
	// Position of VSYNC_EDGE_IRQ_EN field.
	LCDIF_CTRL1_VSYNC_EDGE_IRQ_EN_Pos = 0xc
	// Bit mask of VSYNC_EDGE_IRQ_EN field.
	LCDIF_CTRL1_VSYNC_EDGE_IRQ_EN_Msk = 0x1000
	// Bit VSYNC_EDGE_IRQ_EN.
	LCDIF_CTRL1_VSYNC_EDGE_IRQ_EN = 0x1000
	// Position of CUR_FRAME_DONE_IRQ_EN field.
	LCDIF_CTRL1_CUR_FRAME_DONE_IRQ_EN_Pos = 0xd
	// Bit mask of CUR_FRAME_DONE_IRQ_EN field.
	LCDIF_CTRL1_CUR_FRAME_DONE_IRQ_EN_Msk = 0x2000
	// Bit CUR_FRAME_DONE_IRQ_EN.
	LCDIF_CTRL1_CUR_FRAME_DONE_IRQ_EN = 0x2000
	// Position of UNDERFLOW_IRQ_EN field.
	LCDIF_CTRL1_UNDERFLOW_IRQ_EN_Pos = 0xe
	// Bit mask of UNDERFLOW_IRQ_EN field.
	LCDIF_CTRL1_UNDERFLOW_IRQ_EN_Msk = 0x4000
	// Bit UNDERFLOW_IRQ_EN.
	LCDIF_CTRL1_UNDERFLOW_IRQ_EN = 0x4000
	// Position of OVERFLOW_IRQ_EN field.
	LCDIF_CTRL1_OVERFLOW_IRQ_EN_Pos = 0xf
	// Bit mask of OVERFLOW_IRQ_EN field.
	LCDIF_CTRL1_OVERFLOW_IRQ_EN_Msk = 0x8000
	// Bit OVERFLOW_IRQ_EN.
	LCDIF_CTRL1_OVERFLOW_IRQ_EN = 0x8000
	// Position of BYTE_PACKING_FORMAT field.
	LCDIF_CTRL1_BYTE_PACKING_FORMAT_Pos = 0x10
	// Bit mask of BYTE_PACKING_FORMAT field.
	LCDIF_CTRL1_BYTE_PACKING_FORMAT_Msk = 0xf0000
	// Position of IRQ_ON_ALTERNATE_FIELDS field.
	LCDIF_CTRL1_IRQ_ON_ALTERNATE_FIELDS_Pos = 0x14
	// Bit mask of IRQ_ON_ALTERNATE_FIELDS field.
	LCDIF_CTRL1_IRQ_ON_ALTERNATE_FIELDS_Msk = 0x100000
	// Bit IRQ_ON_ALTERNATE_FIELDS.
	LCDIF_CTRL1_IRQ_ON_ALTERNATE_FIELDS = 0x100000
	// Position of FIFO_CLEAR field.
	LCDIF_CTRL1_FIFO_CLEAR_Pos = 0x15
	// Bit mask of FIFO_CLEAR field.
	LCDIF_CTRL1_FIFO_CLEAR_Msk = 0x200000
	// Bit FIFO_CLEAR.
	LCDIF_CTRL1_FIFO_CLEAR = 0x200000
	// Position of START_INTERLACE_FROM_SECOND_FIELD field.
	LCDIF_CTRL1_START_INTERLACE_FROM_SECOND_FIELD_Pos = 0x16
	// Bit mask of START_INTERLACE_FROM_SECOND_FIELD field.
	LCDIF_CTRL1_START_INTERLACE_FROM_SECOND_FIELD_Msk = 0x400000
	// Bit START_INTERLACE_FROM_SECOND_FIELD.
	LCDIF_CTRL1_START_INTERLACE_FROM_SECOND_FIELD = 0x400000
	// Position of INTERLACE_FIELDS field.
	LCDIF_CTRL1_INTERLACE_FIELDS_Pos = 0x17
	// Bit mask of INTERLACE_FIELDS field.
	LCDIF_CTRL1_INTERLACE_FIELDS_Msk = 0x800000
	// Bit INTERLACE_FIELDS.
	LCDIF_CTRL1_INTERLACE_FIELDS = 0x800000
	// Position of RECOVER_ON_UNDERFLOW field.
	LCDIF_CTRL1_RECOVER_ON_UNDERFLOW_Pos = 0x18
	// Bit mask of RECOVER_ON_UNDERFLOW field.
	LCDIF_CTRL1_RECOVER_ON_UNDERFLOW_Msk = 0x1000000
	// Bit RECOVER_ON_UNDERFLOW.
	LCDIF_CTRL1_RECOVER_ON_UNDERFLOW = 0x1000000
	// Position of BM_ERROR_IRQ field.
	LCDIF_CTRL1_BM_ERROR_IRQ_Pos = 0x19
	// Bit mask of BM_ERROR_IRQ field.
	LCDIF_CTRL1_BM_ERROR_IRQ_Msk = 0x2000000
	// Bit BM_ERROR_IRQ.
	LCDIF_CTRL1_BM_ERROR_IRQ = 0x2000000
	// No Interrupt Request Pending.
	LCDIF_CTRL1_BM_ERROR_IRQ_NO_REQUEST = 0x0
	// Interrupt Request Pending.
	LCDIF_CTRL1_BM_ERROR_IRQ_REQUEST = 0x1
	// Position of BM_ERROR_IRQ_EN field.
	LCDIF_CTRL1_BM_ERROR_IRQ_EN_Pos = 0x1a
	// Bit mask of BM_ERROR_IRQ_EN field.
	LCDIF_CTRL1_BM_ERROR_IRQ_EN_Msk = 0x4000000
	// Bit BM_ERROR_IRQ_EN.
	LCDIF_CTRL1_BM_ERROR_IRQ_EN = 0x4000000
	// Position of CS_OUT_SELECT field.
	LCDIF_CTRL1_CS_OUT_SELECT_Pos = 0x1e
	// Bit mask of CS_OUT_SELECT field.
	LCDIF_CTRL1_CS_OUT_SELECT_Msk = 0x40000000
	// Bit CS_OUT_SELECT.
	LCDIF_CTRL1_CS_OUT_SELECT = 0x40000000
	// Position of IMAGE_DATA_SELECT field.
	LCDIF_CTRL1_IMAGE_DATA_SELECT_Pos = 0x1f
	// Bit mask of IMAGE_DATA_SELECT field.
	LCDIF_CTRL1_IMAGE_DATA_SELECT_Msk = 0x80000000
	// Bit IMAGE_DATA_SELECT.
	LCDIF_CTRL1_IMAGE_DATA_SELECT = 0x80000000

	// CTRL1_SET: LCDIF General Control1 Register
	// Position of VSYNC_EDGE_IRQ field.
	LCDIF_CTRL1_SET_VSYNC_EDGE_IRQ_Pos = 0x8
	// Bit mask of VSYNC_EDGE_IRQ field.
	LCDIF_CTRL1_SET_VSYNC_EDGE_IRQ_Msk = 0x100
	// Bit VSYNC_EDGE_IRQ.
	LCDIF_CTRL1_SET_VSYNC_EDGE_IRQ = 0x100
	// No Interrupt Request Pending.
	LCDIF_CTRL1_SET_VSYNC_EDGE_IRQ_NO_REQUEST = 0x0
	// Interrupt Request Pending.
	LCDIF_CTRL1_SET_VSYNC_EDGE_IRQ_REQUEST = 0x1
	// Position of CUR_FRAME_DONE_IRQ field.
	LCDIF_CTRL1_SET_CUR_FRAME_DONE_IRQ_Pos = 0x9
	// Bit mask of CUR_FRAME_DONE_IRQ field.
	LCDIF_CTRL1_SET_CUR_FRAME_DONE_IRQ_Msk = 0x200
	// Bit CUR_FRAME_DONE_IRQ.
	LCDIF_CTRL1_SET_CUR_FRAME_DONE_IRQ = 0x200
	// No Interrupt Request Pending.
	LCDIF_CTRL1_SET_CUR_FRAME_DONE_IRQ_NO_REQUEST = 0x0
	// Interrupt Request Pending.
	LCDIF_CTRL1_SET_CUR_FRAME_DONE_IRQ_REQUEST = 0x1
	// Position of UNDERFLOW_IRQ field.
	LCDIF_CTRL1_SET_UNDERFLOW_IRQ_Pos = 0xa
	// Bit mask of UNDERFLOW_IRQ field.
	LCDIF_CTRL1_SET_UNDERFLOW_IRQ_Msk = 0x400
	// Bit UNDERFLOW_IRQ.
	LCDIF_CTRL1_SET_UNDERFLOW_IRQ = 0x400
	// No Interrupt Request Pending.
	LCDIF_CTRL1_SET_UNDERFLOW_IRQ_NO_REQUEST = 0x0
	// Interrupt Request Pending.
	LCDIF_CTRL1_SET_UNDERFLOW_IRQ_REQUEST = 0x1
	// Position of OVERFLOW_IRQ field.
	LCDIF_CTRL1_SET_OVERFLOW_IRQ_Pos = 0xb
	// Bit mask of OVERFLOW_IRQ field.
	LCDIF_CTRL1_SET_OVERFLOW_IRQ_Msk = 0x800
	// Bit OVERFLOW_IRQ.
	LCDIF_CTRL1_SET_OVERFLOW_IRQ = 0x800
	// No Interrupt Request Pending.
	LCDIF_CTRL1_SET_OVERFLOW_IRQ_NO_REQUEST = 0x0
	// Interrupt Request Pending.
	LCDIF_CTRL1_SET_OVERFLOW_IRQ_REQUEST = 0x1
	// Position of VSYNC_EDGE_IRQ_EN field.
	LCDIF_CTRL1_SET_VSYNC_EDGE_IRQ_EN_Pos = 0xc
	// Bit mask of VSYNC_EDGE_IRQ_EN field.
	LCDIF_CTRL1_SET_VSYNC_EDGE_IRQ_EN_Msk = 0x1000
	// Bit VSYNC_EDGE_IRQ_EN.
	LCDIF_CTRL1_SET_VSYNC_EDGE_IRQ_EN = 0x1000
	// Position of CUR_FRAME_DONE_IRQ_EN field.
	LCDIF_CTRL1_SET_CUR_FRAME_DONE_IRQ_EN_Pos = 0xd
	// Bit mask of CUR_FRAME_DONE_IRQ_EN field.
	LCDIF_CTRL1_SET_CUR_FRAME_DONE_IRQ_EN_Msk = 0x2000
	// Bit CUR_FRAME_DONE_IRQ_EN.
	LCDIF_CTRL1_SET_CUR_FRAME_DONE_IRQ_EN = 0x2000
	// Position of UNDERFLOW_IRQ_EN field.
	LCDIF_CTRL1_SET_UNDERFLOW_IRQ_EN_Pos = 0xe
	// Bit mask of UNDERFLOW_IRQ_EN field.
	LCDIF_CTRL1_SET_UNDERFLOW_IRQ_EN_Msk = 0x4000
	// Bit UNDERFLOW_IRQ_EN.
	LCDIF_CTRL1_SET_UNDERFLOW_IRQ_EN = 0x4000
	// Position of OVERFLOW_IRQ_EN field.
	LCDIF_CTRL1_SET_OVERFLOW_IRQ_EN_Pos = 0xf
	// Bit mask of OVERFLOW_IRQ_EN field.
	LCDIF_CTRL1_SET_OVERFLOW_IRQ_EN_Msk = 0x8000
	// Bit OVERFLOW_IRQ_EN.
	LCDIF_CTRL1_SET_OVERFLOW_IRQ_EN = 0x8000
	// Position of BYTE_PACKING_FORMAT field.
	LCDIF_CTRL1_SET_BYTE_PACKING_FORMAT_Pos = 0x10
	// Bit mask of BYTE_PACKING_FORMAT field.
	LCDIF_CTRL1_SET_BYTE_PACKING_FORMAT_Msk = 0xf0000
	// Position of IRQ_ON_ALTERNATE_FIELDS field.
	LCDIF_CTRL1_SET_IRQ_ON_ALTERNATE_FIELDS_Pos = 0x14
	// Bit mask of IRQ_ON_ALTERNATE_FIELDS field.
	LCDIF_CTRL1_SET_IRQ_ON_ALTERNATE_FIELDS_Msk = 0x100000
	// Bit IRQ_ON_ALTERNATE_FIELDS.
	LCDIF_CTRL1_SET_IRQ_ON_ALTERNATE_FIELDS = 0x100000
	// Position of FIFO_CLEAR field.
	LCDIF_CTRL1_SET_FIFO_CLEAR_Pos = 0x15
	// Bit mask of FIFO_CLEAR field.
	LCDIF_CTRL1_SET_FIFO_CLEAR_Msk = 0x200000
	// Bit FIFO_CLEAR.
	LCDIF_CTRL1_SET_FIFO_CLEAR = 0x200000
	// Position of START_INTERLACE_FROM_SECOND_FIELD field.
	LCDIF_CTRL1_SET_START_INTERLACE_FROM_SECOND_FIELD_Pos = 0x16
	// Bit mask of START_INTERLACE_FROM_SECOND_FIELD field.
	LCDIF_CTRL1_SET_START_INTERLACE_FROM_SECOND_FIELD_Msk = 0x400000
	// Bit START_INTERLACE_FROM_SECOND_FIELD.
	LCDIF_CTRL1_SET_START_INTERLACE_FROM_SECOND_FIELD = 0x400000
	// Position of INTERLACE_FIELDS field.
	LCDIF_CTRL1_SET_INTERLACE_FIELDS_Pos = 0x17
	// Bit mask of INTERLACE_FIELDS field.
	LCDIF_CTRL1_SET_INTERLACE_FIELDS_Msk = 0x800000
	// Bit INTERLACE_FIELDS.
	LCDIF_CTRL1_SET_INTERLACE_FIELDS = 0x800000
	// Position of RECOVER_ON_UNDERFLOW field.
	LCDIF_CTRL1_SET_RECOVER_ON_UNDERFLOW_Pos = 0x18
	// Bit mask of RECOVER_ON_UNDERFLOW field.
	LCDIF_CTRL1_SET_RECOVER_ON_UNDERFLOW_Msk = 0x1000000
	// Bit RECOVER_ON_UNDERFLOW.
	LCDIF_CTRL1_SET_RECOVER_ON_UNDERFLOW = 0x1000000
	// Position of BM_ERROR_IRQ field.
	LCDIF_CTRL1_SET_BM_ERROR_IRQ_Pos = 0x19
	// Bit mask of BM_ERROR_IRQ field.
	LCDIF_CTRL1_SET_BM_ERROR_IRQ_Msk = 0x2000000
	// Bit BM_ERROR_IRQ.
	LCDIF_CTRL1_SET_BM_ERROR_IRQ = 0x2000000
	// No Interrupt Request Pending.
	LCDIF_CTRL1_SET_BM_ERROR_IRQ_NO_REQUEST = 0x0
	// Interrupt Request Pending.
	LCDIF_CTRL1_SET_BM_ERROR_IRQ_REQUEST = 0x1
	// Position of BM_ERROR_IRQ_EN field.
	LCDIF_CTRL1_SET_BM_ERROR_IRQ_EN_Pos = 0x1a
	// Bit mask of BM_ERROR_IRQ_EN field.
	LCDIF_CTRL1_SET_BM_ERROR_IRQ_EN_Msk = 0x4000000
	// Bit BM_ERROR_IRQ_EN.
	LCDIF_CTRL1_SET_BM_ERROR_IRQ_EN = 0x4000000
	// Position of CS_OUT_SELECT field.
	LCDIF_CTRL1_SET_CS_OUT_SELECT_Pos = 0x1e
	// Bit mask of CS_OUT_SELECT field.
	LCDIF_CTRL1_SET_CS_OUT_SELECT_Msk = 0x40000000
	// Bit CS_OUT_SELECT.
	LCDIF_CTRL1_SET_CS_OUT_SELECT = 0x40000000
	// Position of IMAGE_DATA_SELECT field.
	LCDIF_CTRL1_SET_IMAGE_DATA_SELECT_Pos = 0x1f
	// Bit mask of IMAGE_DATA_SELECT field.
	LCDIF_CTRL1_SET_IMAGE_DATA_SELECT_Msk = 0x80000000
	// Bit IMAGE_DATA_SELECT.
	LCDIF_CTRL1_SET_IMAGE_DATA_SELECT = 0x80000000

	// CTRL1_CLR: LCDIF General Control1 Register
	// Position of VSYNC_EDGE_IRQ field.
	LCDIF_CTRL1_CLR_VSYNC_EDGE_IRQ_Pos = 0x8
	// Bit mask of VSYNC_EDGE_IRQ field.
	LCDIF_CTRL1_CLR_VSYNC_EDGE_IRQ_Msk = 0x100
	// Bit VSYNC_EDGE_IRQ.
	LCDIF_CTRL1_CLR_VSYNC_EDGE_IRQ = 0x100
	// No Interrupt Request Pending.
	LCDIF_CTRL1_CLR_VSYNC_EDGE_IRQ_NO_REQUEST = 0x0
	// Interrupt Request Pending.
	LCDIF_CTRL1_CLR_VSYNC_EDGE_IRQ_REQUEST = 0x1
	// Position of CUR_FRAME_DONE_IRQ field.
	LCDIF_CTRL1_CLR_CUR_FRAME_DONE_IRQ_Pos = 0x9
	// Bit mask of CUR_FRAME_DONE_IRQ field.
	LCDIF_CTRL1_CLR_CUR_FRAME_DONE_IRQ_Msk = 0x200
	// Bit CUR_FRAME_DONE_IRQ.
	LCDIF_CTRL1_CLR_CUR_FRAME_DONE_IRQ = 0x200
	// No Interrupt Request Pending.
	LCDIF_CTRL1_CLR_CUR_FRAME_DONE_IRQ_NO_REQUEST = 0x0
	// Interrupt Request Pending.
	LCDIF_CTRL1_CLR_CUR_FRAME_DONE_IRQ_REQUEST = 0x1
	// Position of UNDERFLOW_IRQ field.
	LCDIF_CTRL1_CLR_UNDERFLOW_IRQ_Pos = 0xa
	// Bit mask of UNDERFLOW_IRQ field.
	LCDIF_CTRL1_CLR_UNDERFLOW_IRQ_Msk = 0x400
	// Bit UNDERFLOW_IRQ.
	LCDIF_CTRL1_CLR_UNDERFLOW_IRQ = 0x400
	// No Interrupt Request Pending.
	LCDIF_CTRL1_CLR_UNDERFLOW_IRQ_NO_REQUEST = 0x0
	// Interrupt Request Pending.
	LCDIF_CTRL1_CLR_UNDERFLOW_IRQ_REQUEST = 0x1
	// Position of OVERFLOW_IRQ field.
	LCDIF_CTRL1_CLR_OVERFLOW_IRQ_Pos = 0xb
	// Bit mask of OVERFLOW_IRQ field.
	LCDIF_CTRL1_CLR_OVERFLOW_IRQ_Msk = 0x800
	// Bit OVERFLOW_IRQ.
	LCDIF_CTRL1_CLR_OVERFLOW_IRQ = 0x800
	// No Interrupt Request Pending.
	LCDIF_CTRL1_CLR_OVERFLOW_IRQ_NO_REQUEST = 0x0
	// Interrupt Request Pending.
	LCDIF_CTRL1_CLR_OVERFLOW_IRQ_REQUEST = 0x1
	// Position of VSYNC_EDGE_IRQ_EN field.
	LCDIF_CTRL1_CLR_VSYNC_EDGE_IRQ_EN_Pos = 0xc
	// Bit mask of VSYNC_EDGE_IRQ_EN field.
	LCDIF_CTRL1_CLR_VSYNC_EDGE_IRQ_EN_Msk = 0x1000
	// Bit VSYNC_EDGE_IRQ_EN.
	LCDIF_CTRL1_CLR_VSYNC_EDGE_IRQ_EN = 0x1000
	// Position of CUR_FRAME_DONE_IRQ_EN field.
	LCDIF_CTRL1_CLR_CUR_FRAME_DONE_IRQ_EN_Pos = 0xd
	// Bit mask of CUR_FRAME_DONE_IRQ_EN field.
	LCDIF_CTRL1_CLR_CUR_FRAME_DONE_IRQ_EN_Msk = 0x2000
	// Bit CUR_FRAME_DONE_IRQ_EN.
	LCDIF_CTRL1_CLR_CUR_FRAME_DONE_IRQ_EN = 0x2000
	// Position of UNDERFLOW_IRQ_EN field.
	LCDIF_CTRL1_CLR_UNDERFLOW_IRQ_EN_Pos = 0xe
	// Bit mask of UNDERFLOW_IRQ_EN field.
	LCDIF_CTRL1_CLR_UNDERFLOW_IRQ_EN_Msk = 0x4000
	// Bit UNDERFLOW_IRQ_EN.
	LCDIF_CTRL1_CLR_UNDERFLOW_IRQ_EN = 0x4000
	// Position of OVERFLOW_IRQ_EN field.
	LCDIF_CTRL1_CLR_OVERFLOW_IRQ_EN_Pos = 0xf
	// Bit mask of OVERFLOW_IRQ_EN field.
	LCDIF_CTRL1_CLR_OVERFLOW_IRQ_EN_Msk = 0x8000
	// Bit OVERFLOW_IRQ_EN.
	LCDIF_CTRL1_CLR_OVERFLOW_IRQ_EN = 0x8000
	// Position of BYTE_PACKING_FORMAT field.
	LCDIF_CTRL1_CLR_BYTE_PACKING_FORMAT_Pos = 0x10
	// Bit mask of BYTE_PACKING_FORMAT field.
	LCDIF_CTRL1_CLR_BYTE_PACKING_FORMAT_Msk = 0xf0000
	// Position of IRQ_ON_ALTERNATE_FIELDS field.
	LCDIF_CTRL1_CLR_IRQ_ON_ALTERNATE_FIELDS_Pos = 0x14
	// Bit mask of IRQ_ON_ALTERNATE_FIELDS field.
	LCDIF_CTRL1_CLR_IRQ_ON_ALTERNATE_FIELDS_Msk = 0x100000
	// Bit IRQ_ON_ALTERNATE_FIELDS.
	LCDIF_CTRL1_CLR_IRQ_ON_ALTERNATE_FIELDS = 0x100000
	// Position of FIFO_CLEAR field.
	LCDIF_CTRL1_CLR_FIFO_CLEAR_Pos = 0x15
	// Bit mask of FIFO_CLEAR field.
	LCDIF_CTRL1_CLR_FIFO_CLEAR_Msk = 0x200000
	// Bit FIFO_CLEAR.
	LCDIF_CTRL1_CLR_FIFO_CLEAR = 0x200000
	// Position of START_INTERLACE_FROM_SECOND_FIELD field.
	LCDIF_CTRL1_CLR_START_INTERLACE_FROM_SECOND_FIELD_Pos = 0x16
	// Bit mask of START_INTERLACE_FROM_SECOND_FIELD field.
	LCDIF_CTRL1_CLR_START_INTERLACE_FROM_SECOND_FIELD_Msk = 0x400000
	// Bit START_INTERLACE_FROM_SECOND_FIELD.
	LCDIF_CTRL1_CLR_START_INTERLACE_FROM_SECOND_FIELD = 0x400000
	// Position of INTERLACE_FIELDS field.
	LCDIF_CTRL1_CLR_INTERLACE_FIELDS_Pos = 0x17
	// Bit mask of INTERLACE_FIELDS field.
	LCDIF_CTRL1_CLR_INTERLACE_FIELDS_Msk = 0x800000
	// Bit INTERLACE_FIELDS.
	LCDIF_CTRL1_CLR_INTERLACE_FIELDS = 0x800000
	// Position of RECOVER_ON_UNDERFLOW field.
	LCDIF_CTRL1_CLR_RECOVER_ON_UNDERFLOW_Pos = 0x18
	// Bit mask of RECOVER_ON_UNDERFLOW field.
	LCDIF_CTRL1_CLR_RECOVER_ON_UNDERFLOW_Msk = 0x1000000
	// Bit RECOVER_ON_UNDERFLOW.
	LCDIF_CTRL1_CLR_RECOVER_ON_UNDERFLOW = 0x1000000
	// Position of BM_ERROR_IRQ field.
	LCDIF_CTRL1_CLR_BM_ERROR_IRQ_Pos = 0x19
	// Bit mask of BM_ERROR_IRQ field.
	LCDIF_CTRL1_CLR_BM_ERROR_IRQ_Msk = 0x2000000
	// Bit BM_ERROR_IRQ.
	LCDIF_CTRL1_CLR_BM_ERROR_IRQ = 0x2000000
	// No Interrupt Request Pending.
	LCDIF_CTRL1_CLR_BM_ERROR_IRQ_NO_REQUEST = 0x0
	// Interrupt Request Pending.
	LCDIF_CTRL1_CLR_BM_ERROR_IRQ_REQUEST = 0x1
	// Position of BM_ERROR_IRQ_EN field.
	LCDIF_CTRL1_CLR_BM_ERROR_IRQ_EN_Pos = 0x1a
	// Bit mask of BM_ERROR_IRQ_EN field.
	LCDIF_CTRL1_CLR_BM_ERROR_IRQ_EN_Msk = 0x4000000
	// Bit BM_ERROR_IRQ_EN.
	LCDIF_CTRL1_CLR_BM_ERROR_IRQ_EN = 0x4000000
	// Position of CS_OUT_SELECT field.
	LCDIF_CTRL1_CLR_CS_OUT_SELECT_Pos = 0x1e
	// Bit mask of CS_OUT_SELECT field.
	LCDIF_CTRL1_CLR_CS_OUT_SELECT_Msk = 0x40000000
	// Bit CS_OUT_SELECT.
	LCDIF_CTRL1_CLR_CS_OUT_SELECT = 0x40000000
	// Position of IMAGE_DATA_SELECT field.
	LCDIF_CTRL1_CLR_IMAGE_DATA_SELECT_Pos = 0x1f
	// Bit mask of IMAGE_DATA_SELECT field.
	LCDIF_CTRL1_CLR_IMAGE_DATA_SELECT_Msk = 0x80000000
	// Bit IMAGE_DATA_SELECT.
	LCDIF_CTRL1_CLR_IMAGE_DATA_SELECT = 0x80000000

	// CTRL1_TOG: LCDIF General Control1 Register
	// Position of VSYNC_EDGE_IRQ field.
	LCDIF_CTRL1_TOG_VSYNC_EDGE_IRQ_Pos = 0x8
	// Bit mask of VSYNC_EDGE_IRQ field.
	LCDIF_CTRL1_TOG_VSYNC_EDGE_IRQ_Msk = 0x100
	// Bit VSYNC_EDGE_IRQ.
	LCDIF_CTRL1_TOG_VSYNC_EDGE_IRQ = 0x100
	// No Interrupt Request Pending.
	LCDIF_CTRL1_TOG_VSYNC_EDGE_IRQ_NO_REQUEST = 0x0
	// Interrupt Request Pending.
	LCDIF_CTRL1_TOG_VSYNC_EDGE_IRQ_REQUEST = 0x1
	// Position of CUR_FRAME_DONE_IRQ field.
	LCDIF_CTRL1_TOG_CUR_FRAME_DONE_IRQ_Pos = 0x9
	// Bit mask of CUR_FRAME_DONE_IRQ field.
	LCDIF_CTRL1_TOG_CUR_FRAME_DONE_IRQ_Msk = 0x200
	// Bit CUR_FRAME_DONE_IRQ.
	LCDIF_CTRL1_TOG_CUR_FRAME_DONE_IRQ = 0x200
	// No Interrupt Request Pending.
	LCDIF_CTRL1_TOG_CUR_FRAME_DONE_IRQ_NO_REQUEST = 0x0
	// Interrupt Request Pending.
	LCDIF_CTRL1_TOG_CUR_FRAME_DONE_IRQ_REQUEST = 0x1
	// Position of UNDERFLOW_IRQ field.
	LCDIF_CTRL1_TOG_UNDERFLOW_IRQ_Pos = 0xa
	// Bit mask of UNDERFLOW_IRQ field.
	LCDIF_CTRL1_TOG_UNDERFLOW_IRQ_Msk = 0x400
	// Bit UNDERFLOW_IRQ.
	LCDIF_CTRL1_TOG_UNDERFLOW_IRQ = 0x400
	// No Interrupt Request Pending.
	LCDIF_CTRL1_TOG_UNDERFLOW_IRQ_NO_REQUEST = 0x0
	// Interrupt Request Pending.
	LCDIF_CTRL1_TOG_UNDERFLOW_IRQ_REQUEST = 0x1
	// Position of OVERFLOW_IRQ field.
	LCDIF_CTRL1_TOG_OVERFLOW_IRQ_Pos = 0xb
	// Bit mask of OVERFLOW_IRQ field.
	LCDIF_CTRL1_TOG_OVERFLOW_IRQ_Msk = 0x800
	// Bit OVERFLOW_IRQ.
	LCDIF_CTRL1_TOG_OVERFLOW_IRQ = 0x800
	// No Interrupt Request Pending.
	LCDIF_CTRL1_TOG_OVERFLOW_IRQ_NO_REQUEST = 0x0
	// Interrupt Request Pending.
	LCDIF_CTRL1_TOG_OVERFLOW_IRQ_REQUEST = 0x1
	// Position of VSYNC_EDGE_IRQ_EN field.
	LCDIF_CTRL1_TOG_VSYNC_EDGE_IRQ_EN_Pos = 0xc
	// Bit mask of VSYNC_EDGE_IRQ_EN field.
	LCDIF_CTRL1_TOG_VSYNC_EDGE_IRQ_EN_Msk = 0x1000
	// Bit VSYNC_EDGE_IRQ_EN.
	LCDIF_CTRL1_TOG_VSYNC_EDGE_IRQ_EN = 0x1000
	// Position of CUR_FRAME_DONE_IRQ_EN field.
	LCDIF_CTRL1_TOG_CUR_FRAME_DONE_IRQ_EN_Pos = 0xd
	// Bit mask of CUR_FRAME_DONE_IRQ_EN field.
	LCDIF_CTRL1_TOG_CUR_FRAME_DONE_IRQ_EN_Msk = 0x2000
	// Bit CUR_FRAME_DONE_IRQ_EN.
	LCDIF_CTRL1_TOG_CUR_FRAME_DONE_IRQ_EN = 0x2000
	// Position of UNDERFLOW_IRQ_EN field.
	LCDIF_CTRL1_TOG_UNDERFLOW_IRQ_EN_Pos = 0xe
	// Bit mask of UNDERFLOW_IRQ_EN field.
	LCDIF_CTRL1_TOG_UNDERFLOW_IRQ_EN_Msk = 0x4000
	// Bit UNDERFLOW_IRQ_EN.
	LCDIF_CTRL1_TOG_UNDERFLOW_IRQ_EN = 0x4000
	// Position of OVERFLOW_IRQ_EN field.
	LCDIF_CTRL1_TOG_OVERFLOW_IRQ_EN_Pos = 0xf
	// Bit mask of OVERFLOW_IRQ_EN field.
	LCDIF_CTRL1_TOG_OVERFLOW_IRQ_EN_Msk = 0x8000
	// Bit OVERFLOW_IRQ_EN.
	LCDIF_CTRL1_TOG_OVERFLOW_IRQ_EN = 0x8000
	// Position of BYTE_PACKING_FORMAT field.
	LCDIF_CTRL1_TOG_BYTE_PACKING_FORMAT_Pos = 0x10
	// Bit mask of BYTE_PACKING_FORMAT field.
	LCDIF_CTRL1_TOG_BYTE_PACKING_FORMAT_Msk = 0xf0000
	// Position of IRQ_ON_ALTERNATE_FIELDS field.
	LCDIF_CTRL1_TOG_IRQ_ON_ALTERNATE_FIELDS_Pos = 0x14
	// Bit mask of IRQ_ON_ALTERNATE_FIELDS field.
	LCDIF_CTRL1_TOG_IRQ_ON_ALTERNATE_FIELDS_Msk = 0x100000
	// Bit IRQ_ON_ALTERNATE_FIELDS.
	LCDIF_CTRL1_TOG_IRQ_ON_ALTERNATE_FIELDS = 0x100000
	// Position of FIFO_CLEAR field.
	LCDIF_CTRL1_TOG_FIFO_CLEAR_Pos = 0x15
	// Bit mask of FIFO_CLEAR field.
	LCDIF_CTRL1_TOG_FIFO_CLEAR_Msk = 0x200000
	// Bit FIFO_CLEAR.
	LCDIF_CTRL1_TOG_FIFO_CLEAR = 0x200000
	// Position of START_INTERLACE_FROM_SECOND_FIELD field.
	LCDIF_CTRL1_TOG_START_INTERLACE_FROM_SECOND_FIELD_Pos = 0x16
	// Bit mask of START_INTERLACE_FROM_SECOND_FIELD field.
	LCDIF_CTRL1_TOG_START_INTERLACE_FROM_SECOND_FIELD_Msk = 0x400000
	// Bit START_INTERLACE_FROM_SECOND_FIELD.
	LCDIF_CTRL1_TOG_START_INTERLACE_FROM_SECOND_FIELD = 0x400000
	// Position of INTERLACE_FIELDS field.
	LCDIF_CTRL1_TOG_INTERLACE_FIELDS_Pos = 0x17
	// Bit mask of INTERLACE_FIELDS field.
	LCDIF_CTRL1_TOG_INTERLACE_FIELDS_Msk = 0x800000
	// Bit INTERLACE_FIELDS.
	LCDIF_CTRL1_TOG_INTERLACE_FIELDS = 0x800000
	// Position of RECOVER_ON_UNDERFLOW field.
	LCDIF_CTRL1_TOG_RECOVER_ON_UNDERFLOW_Pos = 0x18
	// Bit mask of RECOVER_ON_UNDERFLOW field.
	LCDIF_CTRL1_TOG_RECOVER_ON_UNDERFLOW_Msk = 0x1000000
	// Bit RECOVER_ON_UNDERFLOW.
	LCDIF_CTRL1_TOG_RECOVER_ON_UNDERFLOW = 0x1000000
	// Position of BM_ERROR_IRQ field.
	LCDIF_CTRL1_TOG_BM_ERROR_IRQ_Pos = 0x19
	// Bit mask of BM_ERROR_IRQ field.
	LCDIF_CTRL1_TOG_BM_ERROR_IRQ_Msk = 0x2000000
	// Bit BM_ERROR_IRQ.
	LCDIF_CTRL1_TOG_BM_ERROR_IRQ = 0x2000000
	// No Interrupt Request Pending.
	LCDIF_CTRL1_TOG_BM_ERROR_IRQ_NO_REQUEST = 0x0
	// Interrupt Request Pending.
	LCDIF_CTRL1_TOG_BM_ERROR_IRQ_REQUEST = 0x1
	// Position of BM_ERROR_IRQ_EN field.
	LCDIF_CTRL1_TOG_BM_ERROR_IRQ_EN_Pos = 0x1a
	// Bit mask of BM_ERROR_IRQ_EN field.
	LCDIF_CTRL1_TOG_BM_ERROR_IRQ_EN_Msk = 0x4000000
	// Bit BM_ERROR_IRQ_EN.
	LCDIF_CTRL1_TOG_BM_ERROR_IRQ_EN = 0x4000000
	// Position of CS_OUT_SELECT field.
	LCDIF_CTRL1_TOG_CS_OUT_SELECT_Pos = 0x1e
	// Bit mask of CS_OUT_SELECT field.
	LCDIF_CTRL1_TOG_CS_OUT_SELECT_Msk = 0x40000000
	// Bit CS_OUT_SELECT.
	LCDIF_CTRL1_TOG_CS_OUT_SELECT = 0x40000000
	// Position of IMAGE_DATA_SELECT field.
	LCDIF_CTRL1_TOG_IMAGE_DATA_SELECT_Pos = 0x1f
	// Bit mask of IMAGE_DATA_SELECT field.
	LCDIF_CTRL1_TOG_IMAGE_DATA_SELECT_Msk = 0x80000000
	// Bit IMAGE_DATA_SELECT.
	LCDIF_CTRL1_TOG_IMAGE_DATA_SELECT = 0x80000000

	// CTRL2: LCDIF General Control2 Register
	// Position of EVEN_LINE_PATTERN field.
	LCDIF_CTRL2_EVEN_LINE_PATTERN_Pos = 0xc
	// Bit mask of EVEN_LINE_PATTERN field.
	LCDIF_CTRL2_EVEN_LINE_PATTERN_Msk = 0x7000
	// RGB
	LCDIF_CTRL2_EVEN_LINE_PATTERN_RGB = 0x0
	// RBG
	LCDIF_CTRL2_EVEN_LINE_PATTERN_RBG = 0x1
	// GBR
	LCDIF_CTRL2_EVEN_LINE_PATTERN_GBR = 0x2
	// GRB
	LCDIF_CTRL2_EVEN_LINE_PATTERN_GRB = 0x3
	// BRG
	LCDIF_CTRL2_EVEN_LINE_PATTERN_BRG = 0x4
	// BGR
	LCDIF_CTRL2_EVEN_LINE_PATTERN_BGR = 0x5
	// Position of ODD_LINE_PATTERN field.
	LCDIF_CTRL2_ODD_LINE_PATTERN_Pos = 0x10
	// Bit mask of ODD_LINE_PATTERN field.
	LCDIF_CTRL2_ODD_LINE_PATTERN_Msk = 0x70000
	// RGB
	LCDIF_CTRL2_ODD_LINE_PATTERN_RGB = 0x0
	// RBG
	LCDIF_CTRL2_ODD_LINE_PATTERN_RBG = 0x1
	// GBR
	LCDIF_CTRL2_ODD_LINE_PATTERN_GBR = 0x2
	// GRB
	LCDIF_CTRL2_ODD_LINE_PATTERN_GRB = 0x3
	// BRG
	LCDIF_CTRL2_ODD_LINE_PATTERN_BRG = 0x4
	// BGR
	LCDIF_CTRL2_ODD_LINE_PATTERN_BGR = 0x5
	// Position of BURST_LEN_8 field.
	LCDIF_CTRL2_BURST_LEN_8_Pos = 0x14
	// Bit mask of BURST_LEN_8 field.
	LCDIF_CTRL2_BURST_LEN_8_Msk = 0x100000
	// Bit BURST_LEN_8.
	LCDIF_CTRL2_BURST_LEN_8 = 0x100000
	// Position of OUTSTANDING_REQS field.
	LCDIF_CTRL2_OUTSTANDING_REQS_Pos = 0x15
	// Bit mask of OUTSTANDING_REQS field.
	LCDIF_CTRL2_OUTSTANDING_REQS_Msk = 0xe00000
	// REQ_1
	LCDIF_CTRL2_OUTSTANDING_REQS_REQ_1 = 0x0
	// REQ_2
	LCDIF_CTRL2_OUTSTANDING_REQS_REQ_2 = 0x1
	// REQ_4
	LCDIF_CTRL2_OUTSTANDING_REQS_REQ_4 = 0x2
	// REQ_8
	LCDIF_CTRL2_OUTSTANDING_REQS_REQ_8 = 0x3
	// REQ_16
	LCDIF_CTRL2_OUTSTANDING_REQS_REQ_16 = 0x4

	// CTRL2_SET: LCDIF General Control2 Register
	// Position of EVEN_LINE_PATTERN field.
	LCDIF_CTRL2_SET_EVEN_LINE_PATTERN_Pos = 0xc
	// Bit mask of EVEN_LINE_PATTERN field.
	LCDIF_CTRL2_SET_EVEN_LINE_PATTERN_Msk = 0x7000
	// RGB
	LCDIF_CTRL2_SET_EVEN_LINE_PATTERN_RGB = 0x0
	// RBG
	LCDIF_CTRL2_SET_EVEN_LINE_PATTERN_RBG = 0x1
	// GBR
	LCDIF_CTRL2_SET_EVEN_LINE_PATTERN_GBR = 0x2
	// GRB
	LCDIF_CTRL2_SET_EVEN_LINE_PATTERN_GRB = 0x3
	// BRG
	LCDIF_CTRL2_SET_EVEN_LINE_PATTERN_BRG = 0x4
	// BGR
	LCDIF_CTRL2_SET_EVEN_LINE_PATTERN_BGR = 0x5
	// Position of ODD_LINE_PATTERN field.
	LCDIF_CTRL2_SET_ODD_LINE_PATTERN_Pos = 0x10
	// Bit mask of ODD_LINE_PATTERN field.
	LCDIF_CTRL2_SET_ODD_LINE_PATTERN_Msk = 0x70000
	// RGB
	LCDIF_CTRL2_SET_ODD_LINE_PATTERN_RGB = 0x0
	// RBG
	LCDIF_CTRL2_SET_ODD_LINE_PATTERN_RBG = 0x1
	// GBR
	LCDIF_CTRL2_SET_ODD_LINE_PATTERN_GBR = 0x2
	// GRB
	LCDIF_CTRL2_SET_ODD_LINE_PATTERN_GRB = 0x3
	// BRG
	LCDIF_CTRL2_SET_ODD_LINE_PATTERN_BRG = 0x4
	// BGR
	LCDIF_CTRL2_SET_ODD_LINE_PATTERN_BGR = 0x5
	// Position of BURST_LEN_8 field.
	LCDIF_CTRL2_SET_BURST_LEN_8_Pos = 0x14
	// Bit mask of BURST_LEN_8 field.
	LCDIF_CTRL2_SET_BURST_LEN_8_Msk = 0x100000
	// Bit BURST_LEN_8.
	LCDIF_CTRL2_SET_BURST_LEN_8 = 0x100000
	// Position of OUTSTANDING_REQS field.
	LCDIF_CTRL2_SET_OUTSTANDING_REQS_Pos = 0x15
	// Bit mask of OUTSTANDING_REQS field.
	LCDIF_CTRL2_SET_OUTSTANDING_REQS_Msk = 0xe00000
	// REQ_1
	LCDIF_CTRL2_SET_OUTSTANDING_REQS_REQ_1 = 0x0
	// REQ_2
	LCDIF_CTRL2_SET_OUTSTANDING_REQS_REQ_2 = 0x1
	// REQ_4
	LCDIF_CTRL2_SET_OUTSTANDING_REQS_REQ_4 = 0x2
	// REQ_8
	LCDIF_CTRL2_SET_OUTSTANDING_REQS_REQ_8 = 0x3
	// REQ_16
	LCDIF_CTRL2_SET_OUTSTANDING_REQS_REQ_16 = 0x4

	// CTRL2_CLR: LCDIF General Control2 Register
	// Position of EVEN_LINE_PATTERN field.
	LCDIF_CTRL2_CLR_EVEN_LINE_PATTERN_Pos = 0xc
	// Bit mask of EVEN_LINE_PATTERN field.
	LCDIF_CTRL2_CLR_EVEN_LINE_PATTERN_Msk = 0x7000
	// RGB
	LCDIF_CTRL2_CLR_EVEN_LINE_PATTERN_RGB = 0x0
	// RBG
	LCDIF_CTRL2_CLR_EVEN_LINE_PATTERN_RBG = 0x1
	// GBR
	LCDIF_CTRL2_CLR_EVEN_LINE_PATTERN_GBR = 0x2
	// GRB
	LCDIF_CTRL2_CLR_EVEN_LINE_PATTERN_GRB = 0x3
	// BRG
	LCDIF_CTRL2_CLR_EVEN_LINE_PATTERN_BRG = 0x4
	// BGR
	LCDIF_CTRL2_CLR_EVEN_LINE_PATTERN_BGR = 0x5
	// Position of ODD_LINE_PATTERN field.
	LCDIF_CTRL2_CLR_ODD_LINE_PATTERN_Pos = 0x10
	// Bit mask of ODD_LINE_PATTERN field.
	LCDIF_CTRL2_CLR_ODD_LINE_PATTERN_Msk = 0x70000
	// RGB
	LCDIF_CTRL2_CLR_ODD_LINE_PATTERN_RGB = 0x0
	// RBG
	LCDIF_CTRL2_CLR_ODD_LINE_PATTERN_RBG = 0x1
	// GBR
	LCDIF_CTRL2_CLR_ODD_LINE_PATTERN_GBR = 0x2
	// GRB
	LCDIF_CTRL2_CLR_ODD_LINE_PATTERN_GRB = 0x3
	// BRG
	LCDIF_CTRL2_CLR_ODD_LINE_PATTERN_BRG = 0x4
	// BGR
	LCDIF_CTRL2_CLR_ODD_LINE_PATTERN_BGR = 0x5
	// Position of BURST_LEN_8 field.
	LCDIF_CTRL2_CLR_BURST_LEN_8_Pos = 0x14
	// Bit mask of BURST_LEN_8 field.
	LCDIF_CTRL2_CLR_BURST_LEN_8_Msk = 0x100000
	// Bit BURST_LEN_8.
	LCDIF_CTRL2_CLR_BURST_LEN_8 = 0x100000
	// Position of OUTSTANDING_REQS field.
	LCDIF_CTRL2_CLR_OUTSTANDING_REQS_Pos = 0x15
	// Bit mask of OUTSTANDING_REQS field.
	LCDIF_CTRL2_CLR_OUTSTANDING_REQS_Msk = 0xe00000
	// REQ_1
	LCDIF_CTRL2_CLR_OUTSTANDING_REQS_REQ_1 = 0x0
	// REQ_2
	LCDIF_CTRL2_CLR_OUTSTANDING_REQS_REQ_2 = 0x1
	// REQ_4
	LCDIF_CTRL2_CLR_OUTSTANDING_REQS_REQ_4 = 0x2
	// REQ_8
	LCDIF_CTRL2_CLR_OUTSTANDING_REQS_REQ_8 = 0x3
	// REQ_16
	LCDIF_CTRL2_CLR_OUTSTANDING_REQS_REQ_16 = 0x4

	// CTRL2_TOG: LCDIF General Control2 Register
	// Position of EVEN_LINE_PATTERN field.
	LCDIF_CTRL2_TOG_EVEN_LINE_PATTERN_Pos = 0xc
	// Bit mask of EVEN_LINE_PATTERN field.
	LCDIF_CTRL2_TOG_EVEN_LINE_PATTERN_Msk = 0x7000
	// RGB
	LCDIF_CTRL2_TOG_EVEN_LINE_PATTERN_RGB = 0x0
	// RBG
	LCDIF_CTRL2_TOG_EVEN_LINE_PATTERN_RBG = 0x1
	// GBR
	LCDIF_CTRL2_TOG_EVEN_LINE_PATTERN_GBR = 0x2
	// GRB
	LCDIF_CTRL2_TOG_EVEN_LINE_PATTERN_GRB = 0x3
	// BRG
	LCDIF_CTRL2_TOG_EVEN_LINE_PATTERN_BRG = 0x4
	// BGR
	LCDIF_CTRL2_TOG_EVEN_LINE_PATTERN_BGR = 0x5
	// Position of ODD_LINE_PATTERN field.
	LCDIF_CTRL2_TOG_ODD_LINE_PATTERN_Pos = 0x10
	// Bit mask of ODD_LINE_PATTERN field.
	LCDIF_CTRL2_TOG_ODD_LINE_PATTERN_Msk = 0x70000
	// RGB
	LCDIF_CTRL2_TOG_ODD_LINE_PATTERN_RGB = 0x0
	// RBG
	LCDIF_CTRL2_TOG_ODD_LINE_PATTERN_RBG = 0x1
	// GBR
	LCDIF_CTRL2_TOG_ODD_LINE_PATTERN_GBR = 0x2
	// GRB
	LCDIF_CTRL2_TOG_ODD_LINE_PATTERN_GRB = 0x3
	// BRG
	LCDIF_CTRL2_TOG_ODD_LINE_PATTERN_BRG = 0x4
	// BGR
	LCDIF_CTRL2_TOG_ODD_LINE_PATTERN_BGR = 0x5
	// Position of BURST_LEN_8 field.
	LCDIF_CTRL2_TOG_BURST_LEN_8_Pos = 0x14
	// Bit mask of BURST_LEN_8 field.
	LCDIF_CTRL2_TOG_BURST_LEN_8_Msk = 0x100000
	// Bit BURST_LEN_8.
	LCDIF_CTRL2_TOG_BURST_LEN_8 = 0x100000
	// Position of OUTSTANDING_REQS field.
	LCDIF_CTRL2_TOG_OUTSTANDING_REQS_Pos = 0x15
	// Bit mask of OUTSTANDING_REQS field.
	LCDIF_CTRL2_TOG_OUTSTANDING_REQS_Msk = 0xe00000
	// REQ_1
	LCDIF_CTRL2_TOG_OUTSTANDING_REQS_REQ_1 = 0x0
	// REQ_2
	LCDIF_CTRL2_TOG_OUTSTANDING_REQS_REQ_2 = 0x1
	// REQ_4
	LCDIF_CTRL2_TOG_OUTSTANDING_REQS_REQ_4 = 0x2
	// REQ_8
	LCDIF_CTRL2_TOG_OUTSTANDING_REQS_REQ_8 = 0x3
	// REQ_16
	LCDIF_CTRL2_TOG_OUTSTANDING_REQS_REQ_16 = 0x4

	// TRANSFER_COUNT: LCDIF Horizontal and Vertical Valid Data Count Register
	// Position of H_COUNT field.
	LCDIF_TRANSFER_COUNT_H_COUNT_Pos = 0x0
	// Bit mask of H_COUNT field.
	LCDIF_TRANSFER_COUNT_H_COUNT_Msk = 0xffff
	// Position of V_COUNT field.
	LCDIF_TRANSFER_COUNT_V_COUNT_Pos = 0x10
	// Bit mask of V_COUNT field.
	LCDIF_TRANSFER_COUNT_V_COUNT_Msk = 0xffff0000

	// CUR_BUF: LCD Interface Current Buffer Address Register
	// Position of ADDR field.
	LCDIF_CUR_BUF_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	LCDIF_CUR_BUF_ADDR_Msk = 0xffffffff

	// NEXT_BUF: LCD Interface Next Buffer Address Register
	// Position of ADDR field.
	LCDIF_NEXT_BUF_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	LCDIF_NEXT_BUF_ADDR_Msk = 0xffffffff

	// VDCTRL0: LCDIF VSYNC Mode and Dotclk Mode Control Register0
	// Position of VSYNC_PULSE_WIDTH field.
	LCDIF_VDCTRL0_VSYNC_PULSE_WIDTH_Pos = 0x0
	// Bit mask of VSYNC_PULSE_WIDTH field.
	LCDIF_VDCTRL0_VSYNC_PULSE_WIDTH_Msk = 0x3ffff
	// Position of HALF_LINE_MODE field.
	LCDIF_VDCTRL0_HALF_LINE_MODE_Pos = 0x12
	// Bit mask of HALF_LINE_MODE field.
	LCDIF_VDCTRL0_HALF_LINE_MODE_Msk = 0x40000
	// Bit HALF_LINE_MODE.
	LCDIF_VDCTRL0_HALF_LINE_MODE = 0x40000
	// Position of HALF_LINE field.
	LCDIF_VDCTRL0_HALF_LINE_Pos = 0x13
	// Bit mask of HALF_LINE field.
	LCDIF_VDCTRL0_HALF_LINE_Msk = 0x80000
	// Bit HALF_LINE.
	LCDIF_VDCTRL0_HALF_LINE = 0x80000
	// Position of VSYNC_PULSE_WIDTH_UNIT field.
	LCDIF_VDCTRL0_VSYNC_PULSE_WIDTH_UNIT_Pos = 0x14
	// Bit mask of VSYNC_PULSE_WIDTH_UNIT field.
	LCDIF_VDCTRL0_VSYNC_PULSE_WIDTH_UNIT_Msk = 0x100000
	// Bit VSYNC_PULSE_WIDTH_UNIT.
	LCDIF_VDCTRL0_VSYNC_PULSE_WIDTH_UNIT = 0x100000
	// Position of VSYNC_PERIOD_UNIT field.
	LCDIF_VDCTRL0_VSYNC_PERIOD_UNIT_Pos = 0x15
	// Bit mask of VSYNC_PERIOD_UNIT field.
	LCDIF_VDCTRL0_VSYNC_PERIOD_UNIT_Msk = 0x200000
	// Bit VSYNC_PERIOD_UNIT.
	LCDIF_VDCTRL0_VSYNC_PERIOD_UNIT = 0x200000
	// Position of ENABLE_POL field.
	LCDIF_VDCTRL0_ENABLE_POL_Pos = 0x18
	// Bit mask of ENABLE_POL field.
	LCDIF_VDCTRL0_ENABLE_POL_Msk = 0x1000000
	// Bit ENABLE_POL.
	LCDIF_VDCTRL0_ENABLE_POL = 0x1000000
	// Position of DOTCLK_POL field.
	LCDIF_VDCTRL0_DOTCLK_POL_Pos = 0x19
	// Bit mask of DOTCLK_POL field.
	LCDIF_VDCTRL0_DOTCLK_POL_Msk = 0x2000000
	// Bit DOTCLK_POL.
	LCDIF_VDCTRL0_DOTCLK_POL = 0x2000000
	// Position of HSYNC_POL field.
	LCDIF_VDCTRL0_HSYNC_POL_Pos = 0x1a
	// Bit mask of HSYNC_POL field.
	LCDIF_VDCTRL0_HSYNC_POL_Msk = 0x4000000
	// Bit HSYNC_POL.
	LCDIF_VDCTRL0_HSYNC_POL = 0x4000000
	// Position of VSYNC_POL field.
	LCDIF_VDCTRL0_VSYNC_POL_Pos = 0x1b
	// Bit mask of VSYNC_POL field.
	LCDIF_VDCTRL0_VSYNC_POL_Msk = 0x8000000
	// Bit VSYNC_POL.
	LCDIF_VDCTRL0_VSYNC_POL = 0x8000000
	// Position of ENABLE_PRESENT field.
	LCDIF_VDCTRL0_ENABLE_PRESENT_Pos = 0x1c
	// Bit mask of ENABLE_PRESENT field.
	LCDIF_VDCTRL0_ENABLE_PRESENT_Msk = 0x10000000
	// Bit ENABLE_PRESENT.
	LCDIF_VDCTRL0_ENABLE_PRESENT = 0x10000000

	// VDCTRL0_SET: LCDIF VSYNC Mode and Dotclk Mode Control Register0
	// Position of VSYNC_PULSE_WIDTH field.
	LCDIF_VDCTRL0_SET_VSYNC_PULSE_WIDTH_Pos = 0x0
	// Bit mask of VSYNC_PULSE_WIDTH field.
	LCDIF_VDCTRL0_SET_VSYNC_PULSE_WIDTH_Msk = 0x3ffff
	// Position of HALF_LINE_MODE field.
	LCDIF_VDCTRL0_SET_HALF_LINE_MODE_Pos = 0x12
	// Bit mask of HALF_LINE_MODE field.
	LCDIF_VDCTRL0_SET_HALF_LINE_MODE_Msk = 0x40000
	// Bit HALF_LINE_MODE.
	LCDIF_VDCTRL0_SET_HALF_LINE_MODE = 0x40000
	// Position of HALF_LINE field.
	LCDIF_VDCTRL0_SET_HALF_LINE_Pos = 0x13
	// Bit mask of HALF_LINE field.
	LCDIF_VDCTRL0_SET_HALF_LINE_Msk = 0x80000
	// Bit HALF_LINE.
	LCDIF_VDCTRL0_SET_HALF_LINE = 0x80000
	// Position of VSYNC_PULSE_WIDTH_UNIT field.
	LCDIF_VDCTRL0_SET_VSYNC_PULSE_WIDTH_UNIT_Pos = 0x14
	// Bit mask of VSYNC_PULSE_WIDTH_UNIT field.
	LCDIF_VDCTRL0_SET_VSYNC_PULSE_WIDTH_UNIT_Msk = 0x100000
	// Bit VSYNC_PULSE_WIDTH_UNIT.
	LCDIF_VDCTRL0_SET_VSYNC_PULSE_WIDTH_UNIT = 0x100000
	// Position of VSYNC_PERIOD_UNIT field.
	LCDIF_VDCTRL0_SET_VSYNC_PERIOD_UNIT_Pos = 0x15
	// Bit mask of VSYNC_PERIOD_UNIT field.
	LCDIF_VDCTRL0_SET_VSYNC_PERIOD_UNIT_Msk = 0x200000
	// Bit VSYNC_PERIOD_UNIT.
	LCDIF_VDCTRL0_SET_VSYNC_PERIOD_UNIT = 0x200000
	// Position of ENABLE_POL field.
	LCDIF_VDCTRL0_SET_ENABLE_POL_Pos = 0x18
	// Bit mask of ENABLE_POL field.
	LCDIF_VDCTRL0_SET_ENABLE_POL_Msk = 0x1000000
	// Bit ENABLE_POL.
	LCDIF_VDCTRL0_SET_ENABLE_POL = 0x1000000
	// Position of DOTCLK_POL field.
	LCDIF_VDCTRL0_SET_DOTCLK_POL_Pos = 0x19
	// Bit mask of DOTCLK_POL field.
	LCDIF_VDCTRL0_SET_DOTCLK_POL_Msk = 0x2000000
	// Bit DOTCLK_POL.
	LCDIF_VDCTRL0_SET_DOTCLK_POL = 0x2000000
	// Position of HSYNC_POL field.
	LCDIF_VDCTRL0_SET_HSYNC_POL_Pos = 0x1a
	// Bit mask of HSYNC_POL field.
	LCDIF_VDCTRL0_SET_HSYNC_POL_Msk = 0x4000000
	// Bit HSYNC_POL.
	LCDIF_VDCTRL0_SET_HSYNC_POL = 0x4000000
	// Position of VSYNC_POL field.
	LCDIF_VDCTRL0_SET_VSYNC_POL_Pos = 0x1b
	// Bit mask of VSYNC_POL field.
	LCDIF_VDCTRL0_SET_VSYNC_POL_Msk = 0x8000000
	// Bit VSYNC_POL.
	LCDIF_VDCTRL0_SET_VSYNC_POL = 0x8000000
	// Position of ENABLE_PRESENT field.
	LCDIF_VDCTRL0_SET_ENABLE_PRESENT_Pos = 0x1c
	// Bit mask of ENABLE_PRESENT field.
	LCDIF_VDCTRL0_SET_ENABLE_PRESENT_Msk = 0x10000000
	// Bit ENABLE_PRESENT.
	LCDIF_VDCTRL0_SET_ENABLE_PRESENT = 0x10000000

	// VDCTRL0_CLR: LCDIF VSYNC Mode and Dotclk Mode Control Register0
	// Position of VSYNC_PULSE_WIDTH field.
	LCDIF_VDCTRL0_CLR_VSYNC_PULSE_WIDTH_Pos = 0x0
	// Bit mask of VSYNC_PULSE_WIDTH field.
	LCDIF_VDCTRL0_CLR_VSYNC_PULSE_WIDTH_Msk = 0x3ffff
	// Position of HALF_LINE_MODE field.
	LCDIF_VDCTRL0_CLR_HALF_LINE_MODE_Pos = 0x12
	// Bit mask of HALF_LINE_MODE field.
	LCDIF_VDCTRL0_CLR_HALF_LINE_MODE_Msk = 0x40000
	// Bit HALF_LINE_MODE.
	LCDIF_VDCTRL0_CLR_HALF_LINE_MODE = 0x40000
	// Position of HALF_LINE field.
	LCDIF_VDCTRL0_CLR_HALF_LINE_Pos = 0x13
	// Bit mask of HALF_LINE field.
	LCDIF_VDCTRL0_CLR_HALF_LINE_Msk = 0x80000
	// Bit HALF_LINE.
	LCDIF_VDCTRL0_CLR_HALF_LINE = 0x80000
	// Position of VSYNC_PULSE_WIDTH_UNIT field.
	LCDIF_VDCTRL0_CLR_VSYNC_PULSE_WIDTH_UNIT_Pos = 0x14
	// Bit mask of VSYNC_PULSE_WIDTH_UNIT field.
	LCDIF_VDCTRL0_CLR_VSYNC_PULSE_WIDTH_UNIT_Msk = 0x100000
	// Bit VSYNC_PULSE_WIDTH_UNIT.
	LCDIF_VDCTRL0_CLR_VSYNC_PULSE_WIDTH_UNIT = 0x100000
	// Position of VSYNC_PERIOD_UNIT field.
	LCDIF_VDCTRL0_CLR_VSYNC_PERIOD_UNIT_Pos = 0x15
	// Bit mask of VSYNC_PERIOD_UNIT field.
	LCDIF_VDCTRL0_CLR_VSYNC_PERIOD_UNIT_Msk = 0x200000
	// Bit VSYNC_PERIOD_UNIT.
	LCDIF_VDCTRL0_CLR_VSYNC_PERIOD_UNIT = 0x200000
	// Position of ENABLE_POL field.
	LCDIF_VDCTRL0_CLR_ENABLE_POL_Pos = 0x18
	// Bit mask of ENABLE_POL field.
	LCDIF_VDCTRL0_CLR_ENABLE_POL_Msk = 0x1000000
	// Bit ENABLE_POL.
	LCDIF_VDCTRL0_CLR_ENABLE_POL = 0x1000000
	// Position of DOTCLK_POL field.
	LCDIF_VDCTRL0_CLR_DOTCLK_POL_Pos = 0x19
	// Bit mask of DOTCLK_POL field.
	LCDIF_VDCTRL0_CLR_DOTCLK_POL_Msk = 0x2000000
	// Bit DOTCLK_POL.
	LCDIF_VDCTRL0_CLR_DOTCLK_POL = 0x2000000
	// Position of HSYNC_POL field.
	LCDIF_VDCTRL0_CLR_HSYNC_POL_Pos = 0x1a
	// Bit mask of HSYNC_POL field.
	LCDIF_VDCTRL0_CLR_HSYNC_POL_Msk = 0x4000000
	// Bit HSYNC_POL.
	LCDIF_VDCTRL0_CLR_HSYNC_POL = 0x4000000
	// Position of VSYNC_POL field.
	LCDIF_VDCTRL0_CLR_VSYNC_POL_Pos = 0x1b
	// Bit mask of VSYNC_POL field.
	LCDIF_VDCTRL0_CLR_VSYNC_POL_Msk = 0x8000000
	// Bit VSYNC_POL.
	LCDIF_VDCTRL0_CLR_VSYNC_POL = 0x8000000
	// Position of ENABLE_PRESENT field.
	LCDIF_VDCTRL0_CLR_ENABLE_PRESENT_Pos = 0x1c
	// Bit mask of ENABLE_PRESENT field.
	LCDIF_VDCTRL0_CLR_ENABLE_PRESENT_Msk = 0x10000000
	// Bit ENABLE_PRESENT.
	LCDIF_VDCTRL0_CLR_ENABLE_PRESENT = 0x10000000

	// VDCTRL0_TOG: LCDIF VSYNC Mode and Dotclk Mode Control Register0
	// Position of VSYNC_PULSE_WIDTH field.
	LCDIF_VDCTRL0_TOG_VSYNC_PULSE_WIDTH_Pos = 0x0
	// Bit mask of VSYNC_PULSE_WIDTH field.
	LCDIF_VDCTRL0_TOG_VSYNC_PULSE_WIDTH_Msk = 0x3ffff
	// Position of HALF_LINE_MODE field.
	LCDIF_VDCTRL0_TOG_HALF_LINE_MODE_Pos = 0x12
	// Bit mask of HALF_LINE_MODE field.
	LCDIF_VDCTRL0_TOG_HALF_LINE_MODE_Msk = 0x40000
	// Bit HALF_LINE_MODE.
	LCDIF_VDCTRL0_TOG_HALF_LINE_MODE = 0x40000
	// Position of HALF_LINE field.
	LCDIF_VDCTRL0_TOG_HALF_LINE_Pos = 0x13
	// Bit mask of HALF_LINE field.
	LCDIF_VDCTRL0_TOG_HALF_LINE_Msk = 0x80000
	// Bit HALF_LINE.
	LCDIF_VDCTRL0_TOG_HALF_LINE = 0x80000
	// Position of VSYNC_PULSE_WIDTH_UNIT field.
	LCDIF_VDCTRL0_TOG_VSYNC_PULSE_WIDTH_UNIT_Pos = 0x14
	// Bit mask of VSYNC_PULSE_WIDTH_UNIT field.
	LCDIF_VDCTRL0_TOG_VSYNC_PULSE_WIDTH_UNIT_Msk = 0x100000
	// Bit VSYNC_PULSE_WIDTH_UNIT.
	LCDIF_VDCTRL0_TOG_VSYNC_PULSE_WIDTH_UNIT = 0x100000
	// Position of VSYNC_PERIOD_UNIT field.
	LCDIF_VDCTRL0_TOG_VSYNC_PERIOD_UNIT_Pos = 0x15
	// Bit mask of VSYNC_PERIOD_UNIT field.
	LCDIF_VDCTRL0_TOG_VSYNC_PERIOD_UNIT_Msk = 0x200000
	// Bit VSYNC_PERIOD_UNIT.
	LCDIF_VDCTRL0_TOG_VSYNC_PERIOD_UNIT = 0x200000
	// Position of ENABLE_POL field.
	LCDIF_VDCTRL0_TOG_ENABLE_POL_Pos = 0x18
	// Bit mask of ENABLE_POL field.
	LCDIF_VDCTRL0_TOG_ENABLE_POL_Msk = 0x1000000
	// Bit ENABLE_POL.
	LCDIF_VDCTRL0_TOG_ENABLE_POL = 0x1000000
	// Position of DOTCLK_POL field.
	LCDIF_VDCTRL0_TOG_DOTCLK_POL_Pos = 0x19
	// Bit mask of DOTCLK_POL field.
	LCDIF_VDCTRL0_TOG_DOTCLK_POL_Msk = 0x2000000
	// Bit DOTCLK_POL.
	LCDIF_VDCTRL0_TOG_DOTCLK_POL = 0x2000000
	// Position of HSYNC_POL field.
	LCDIF_VDCTRL0_TOG_HSYNC_POL_Pos = 0x1a
	// Bit mask of HSYNC_POL field.
	LCDIF_VDCTRL0_TOG_HSYNC_POL_Msk = 0x4000000
	// Bit HSYNC_POL.
	LCDIF_VDCTRL0_TOG_HSYNC_POL = 0x4000000
	// Position of VSYNC_POL field.
	LCDIF_VDCTRL0_TOG_VSYNC_POL_Pos = 0x1b
	// Bit mask of VSYNC_POL field.
	LCDIF_VDCTRL0_TOG_VSYNC_POL_Msk = 0x8000000
	// Bit VSYNC_POL.
	LCDIF_VDCTRL0_TOG_VSYNC_POL = 0x8000000
	// Position of ENABLE_PRESENT field.
	LCDIF_VDCTRL0_TOG_ENABLE_PRESENT_Pos = 0x1c
	// Bit mask of ENABLE_PRESENT field.
	LCDIF_VDCTRL0_TOG_ENABLE_PRESENT_Msk = 0x10000000
	// Bit ENABLE_PRESENT.
	LCDIF_VDCTRL0_TOG_ENABLE_PRESENT = 0x10000000

	// VDCTRL1: LCDIF VSYNC Mode and Dotclk Mode Control Register1
	// Position of VSYNC_PERIOD field.
	LCDIF_VDCTRL1_VSYNC_PERIOD_Pos = 0x0
	// Bit mask of VSYNC_PERIOD field.
	LCDIF_VDCTRL1_VSYNC_PERIOD_Msk = 0xffffffff

	// VDCTRL2: LCDIF VSYNC Mode and Dotclk Mode Control Register2
	// Position of HSYNC_PERIOD field.
	LCDIF_VDCTRL2_HSYNC_PERIOD_Pos = 0x0
	// Bit mask of HSYNC_PERIOD field.
	LCDIF_VDCTRL2_HSYNC_PERIOD_Msk = 0x3ffff
	// Position of HSYNC_PULSE_WIDTH field.
	LCDIF_VDCTRL2_HSYNC_PULSE_WIDTH_Pos = 0x12
	// Bit mask of HSYNC_PULSE_WIDTH field.
	LCDIF_VDCTRL2_HSYNC_PULSE_WIDTH_Msk = 0xfffc0000

	// VDCTRL3: LCDIF VSYNC Mode and Dotclk Mode Control Register3
	// Position of VERTICAL_WAIT_CNT field.
	LCDIF_VDCTRL3_VERTICAL_WAIT_CNT_Pos = 0x0
	// Bit mask of VERTICAL_WAIT_CNT field.
	LCDIF_VDCTRL3_VERTICAL_WAIT_CNT_Msk = 0xffff
	// Position of HORIZONTAL_WAIT_CNT field.
	LCDIF_VDCTRL3_HORIZONTAL_WAIT_CNT_Pos = 0x10
	// Bit mask of HORIZONTAL_WAIT_CNT field.
	LCDIF_VDCTRL3_HORIZONTAL_WAIT_CNT_Msk = 0xfff0000
	// Position of VSYNC_ONLY field.
	LCDIF_VDCTRL3_VSYNC_ONLY_Pos = 0x1c
	// Bit mask of VSYNC_ONLY field.
	LCDIF_VDCTRL3_VSYNC_ONLY_Msk = 0x10000000
	// Bit VSYNC_ONLY.
	LCDIF_VDCTRL3_VSYNC_ONLY = 0x10000000
	// Position of MUX_SYNC_SIGNALS field.
	LCDIF_VDCTRL3_MUX_SYNC_SIGNALS_Pos = 0x1d
	// Bit mask of MUX_SYNC_SIGNALS field.
	LCDIF_VDCTRL3_MUX_SYNC_SIGNALS_Msk = 0x20000000
	// Bit MUX_SYNC_SIGNALS.
	LCDIF_VDCTRL3_MUX_SYNC_SIGNALS = 0x20000000

	// VDCTRL4: LCDIF VSYNC Mode and Dotclk Mode Control Register4
	// Position of DOTCLK_H_VALID_DATA_CNT field.
	LCDIF_VDCTRL4_DOTCLK_H_VALID_DATA_CNT_Pos = 0x0
	// Bit mask of DOTCLK_H_VALID_DATA_CNT field.
	LCDIF_VDCTRL4_DOTCLK_H_VALID_DATA_CNT_Msk = 0x3ffff
	// Position of SYNC_SIGNALS_ON field.
	LCDIF_VDCTRL4_SYNC_SIGNALS_ON_Pos = 0x12
	// Bit mask of SYNC_SIGNALS_ON field.
	LCDIF_VDCTRL4_SYNC_SIGNALS_ON_Msk = 0x40000
	// Bit SYNC_SIGNALS_ON.
	LCDIF_VDCTRL4_SYNC_SIGNALS_ON = 0x40000
	// Position of DOTCLK_DLY_SEL field.
	LCDIF_VDCTRL4_DOTCLK_DLY_SEL_Pos = 0x1d
	// Bit mask of DOTCLK_DLY_SEL field.
	LCDIF_VDCTRL4_DOTCLK_DLY_SEL_Msk = 0xe0000000

	// BM_ERROR_STAT: Bus Master Error Status Register
	// Position of ADDR field.
	LCDIF_BM_ERROR_STAT_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	LCDIF_BM_ERROR_STAT_ADDR_Msk = 0xffffffff

	// CRC_STAT: CRC Status Register
	// Position of CRC_VALUE field.
	LCDIF_CRC_STAT_CRC_VALUE_Pos = 0x0
	// Bit mask of CRC_VALUE field.
	LCDIF_CRC_STAT_CRC_VALUE_Msk = 0xffffffff

	// STAT: LCD Interface Status Register
	// Position of LFIFO_COUNT field.
	LCDIF_STAT_LFIFO_COUNT_Pos = 0x0
	// Bit mask of LFIFO_COUNT field.
	LCDIF_STAT_LFIFO_COUNT_Msk = 0x1ff
	// Position of TXFIFO_EMPTY field.
	LCDIF_STAT_TXFIFO_EMPTY_Pos = 0x1a
	// Bit mask of TXFIFO_EMPTY field.
	LCDIF_STAT_TXFIFO_EMPTY_Msk = 0x4000000
	// Bit TXFIFO_EMPTY.
	LCDIF_STAT_TXFIFO_EMPTY = 0x4000000
	// Position of TXFIFO_FULL field.
	LCDIF_STAT_TXFIFO_FULL_Pos = 0x1b
	// Bit mask of TXFIFO_FULL field.
	LCDIF_STAT_TXFIFO_FULL_Msk = 0x8000000
	// Bit TXFIFO_FULL.
	LCDIF_STAT_TXFIFO_FULL = 0x8000000
	// Position of LFIFO_EMPTY field.
	LCDIF_STAT_LFIFO_EMPTY_Pos = 0x1c
	// Bit mask of LFIFO_EMPTY field.
	LCDIF_STAT_LFIFO_EMPTY_Msk = 0x10000000
	// Bit LFIFO_EMPTY.
	LCDIF_STAT_LFIFO_EMPTY = 0x10000000
	// Position of LFIFO_FULL field.
	LCDIF_STAT_LFIFO_FULL_Pos = 0x1d
	// Bit mask of LFIFO_FULL field.
	LCDIF_STAT_LFIFO_FULL_Msk = 0x20000000
	// Bit LFIFO_FULL.
	LCDIF_STAT_LFIFO_FULL = 0x20000000
	// Position of DMA_REQ field.
	LCDIF_STAT_DMA_REQ_Pos = 0x1e
	// Bit mask of DMA_REQ field.
	LCDIF_STAT_DMA_REQ_Msk = 0x40000000
	// Bit DMA_REQ.
	LCDIF_STAT_DMA_REQ = 0x40000000
	// Position of PRESENT field.
	LCDIF_STAT_PRESENT_Pos = 0x1f
	// Bit mask of PRESENT field.
	LCDIF_STAT_PRESENT_Msk = 0x80000000
	// Bit PRESENT.
	LCDIF_STAT_PRESENT = 0x80000000

	// PIGEONCTRL0: LCDIF Pigeon Mode Control0 Register
	// Position of FD_PERIOD field.
	LCDIF_PIGEONCTRL0_FD_PERIOD_Pos = 0x0
	// Bit mask of FD_PERIOD field.
	LCDIF_PIGEONCTRL0_FD_PERIOD_Msk = 0xfff
	// Position of LD_PERIOD field.
	LCDIF_PIGEONCTRL0_LD_PERIOD_Pos = 0x10
	// Bit mask of LD_PERIOD field.
	LCDIF_PIGEONCTRL0_LD_PERIOD_Msk = 0xfff0000

	// PIGEONCTRL0_SET: LCDIF Pigeon Mode Control0 Register
	// Position of FD_PERIOD field.
	LCDIF_PIGEONCTRL0_SET_FD_PERIOD_Pos = 0x0
	// Bit mask of FD_PERIOD field.
	LCDIF_PIGEONCTRL0_SET_FD_PERIOD_Msk = 0xfff
	// Position of LD_PERIOD field.
	LCDIF_PIGEONCTRL0_SET_LD_PERIOD_Pos = 0x10
	// Bit mask of LD_PERIOD field.
	LCDIF_PIGEONCTRL0_SET_LD_PERIOD_Msk = 0xfff0000

	// PIGEONCTRL0_CLR: LCDIF Pigeon Mode Control0 Register
	// Position of FD_PERIOD field.
	LCDIF_PIGEONCTRL0_CLR_FD_PERIOD_Pos = 0x0
	// Bit mask of FD_PERIOD field.
	LCDIF_PIGEONCTRL0_CLR_FD_PERIOD_Msk = 0xfff
	// Position of LD_PERIOD field.
	LCDIF_PIGEONCTRL0_CLR_LD_PERIOD_Pos = 0x10
	// Bit mask of LD_PERIOD field.
	LCDIF_PIGEONCTRL0_CLR_LD_PERIOD_Msk = 0xfff0000

	// PIGEONCTRL0_TOG: LCDIF Pigeon Mode Control0 Register
	// Position of FD_PERIOD field.
	LCDIF_PIGEONCTRL0_TOG_FD_PERIOD_Pos = 0x0
	// Bit mask of FD_PERIOD field.
	LCDIF_PIGEONCTRL0_TOG_FD_PERIOD_Msk = 0xfff
	// Position of LD_PERIOD field.
	LCDIF_PIGEONCTRL0_TOG_LD_PERIOD_Pos = 0x10
	// Bit mask of LD_PERIOD field.
	LCDIF_PIGEONCTRL0_TOG_LD_PERIOD_Msk = 0xfff0000

	// PIGEONCTRL1: LCDIF Pigeon Mode Control1 Register
	// Position of FRAME_CNT_PERIOD field.
	LCDIF_PIGEONCTRL1_FRAME_CNT_PERIOD_Pos = 0x0
	// Bit mask of FRAME_CNT_PERIOD field.
	LCDIF_PIGEONCTRL1_FRAME_CNT_PERIOD_Msk = 0xfff
	// Position of FRAME_CNT_CYCLES field.
	LCDIF_PIGEONCTRL1_FRAME_CNT_CYCLES_Pos = 0x10
	// Bit mask of FRAME_CNT_CYCLES field.
	LCDIF_PIGEONCTRL1_FRAME_CNT_CYCLES_Msk = 0xfff0000

	// PIGEONCTRL1_SET: LCDIF Pigeon Mode Control1 Register
	// Position of FRAME_CNT_PERIOD field.
	LCDIF_PIGEONCTRL1_SET_FRAME_CNT_PERIOD_Pos = 0x0
	// Bit mask of FRAME_CNT_PERIOD field.
	LCDIF_PIGEONCTRL1_SET_FRAME_CNT_PERIOD_Msk = 0xfff
	// Position of FRAME_CNT_CYCLES field.
	LCDIF_PIGEONCTRL1_SET_FRAME_CNT_CYCLES_Pos = 0x10
	// Bit mask of FRAME_CNT_CYCLES field.
	LCDIF_PIGEONCTRL1_SET_FRAME_CNT_CYCLES_Msk = 0xfff0000

	// PIGEONCTRL1_CLR: LCDIF Pigeon Mode Control1 Register
	// Position of FRAME_CNT_PERIOD field.
	LCDIF_PIGEONCTRL1_CLR_FRAME_CNT_PERIOD_Pos = 0x0
	// Bit mask of FRAME_CNT_PERIOD field.
	LCDIF_PIGEONCTRL1_CLR_FRAME_CNT_PERIOD_Msk = 0xfff
	// Position of FRAME_CNT_CYCLES field.
	LCDIF_PIGEONCTRL1_CLR_FRAME_CNT_CYCLES_Pos = 0x10
	// Bit mask of FRAME_CNT_CYCLES field.
	LCDIF_PIGEONCTRL1_CLR_FRAME_CNT_CYCLES_Msk = 0xfff0000

	// PIGEONCTRL1_TOG: LCDIF Pigeon Mode Control1 Register
	// Position of FRAME_CNT_PERIOD field.
	LCDIF_PIGEONCTRL1_TOG_FRAME_CNT_PERIOD_Pos = 0x0
	// Bit mask of FRAME_CNT_PERIOD field.
	LCDIF_PIGEONCTRL1_TOG_FRAME_CNT_PERIOD_Msk = 0xfff
	// Position of FRAME_CNT_CYCLES field.
	LCDIF_PIGEONCTRL1_TOG_FRAME_CNT_CYCLES_Pos = 0x10
	// Bit mask of FRAME_CNT_CYCLES field.
	LCDIF_PIGEONCTRL1_TOG_FRAME_CNT_CYCLES_Msk = 0xfff0000

	// PIGEONCTRL2: LCDIF Pigeon Mode Control2 Register
	// Position of PIGEON_DATA_EN field.
	LCDIF_PIGEONCTRL2_PIGEON_DATA_EN_Pos = 0x0
	// Bit mask of PIGEON_DATA_EN field.
	LCDIF_PIGEONCTRL2_PIGEON_DATA_EN_Msk = 0x1
	// Bit PIGEON_DATA_EN.
	LCDIF_PIGEONCTRL2_PIGEON_DATA_EN = 0x1
	// Position of PIGEON_CLK_GATE field.
	LCDIF_PIGEONCTRL2_PIGEON_CLK_GATE_Pos = 0x1
	// Bit mask of PIGEON_CLK_GATE field.
	LCDIF_PIGEONCTRL2_PIGEON_CLK_GATE_Msk = 0x2
	// Bit PIGEON_CLK_GATE.
	LCDIF_PIGEONCTRL2_PIGEON_CLK_GATE = 0x2

	// PIGEONCTRL2_SET: LCDIF Pigeon Mode Control2 Register
	// Position of PIGEON_DATA_EN field.
	LCDIF_PIGEONCTRL2_SET_PIGEON_DATA_EN_Pos = 0x0
	// Bit mask of PIGEON_DATA_EN field.
	LCDIF_PIGEONCTRL2_SET_PIGEON_DATA_EN_Msk = 0x1
	// Bit PIGEON_DATA_EN.
	LCDIF_PIGEONCTRL2_SET_PIGEON_DATA_EN = 0x1
	// Position of PIGEON_CLK_GATE field.
	LCDIF_PIGEONCTRL2_SET_PIGEON_CLK_GATE_Pos = 0x1
	// Bit mask of PIGEON_CLK_GATE field.
	LCDIF_PIGEONCTRL2_SET_PIGEON_CLK_GATE_Msk = 0x2
	// Bit PIGEON_CLK_GATE.
	LCDIF_PIGEONCTRL2_SET_PIGEON_CLK_GATE = 0x2

	// PIGEONCTRL2_CLR: LCDIF Pigeon Mode Control2 Register
	// Position of PIGEON_DATA_EN field.
	LCDIF_PIGEONCTRL2_CLR_PIGEON_DATA_EN_Pos = 0x0
	// Bit mask of PIGEON_DATA_EN field.
	LCDIF_PIGEONCTRL2_CLR_PIGEON_DATA_EN_Msk = 0x1
	// Bit PIGEON_DATA_EN.
	LCDIF_PIGEONCTRL2_CLR_PIGEON_DATA_EN = 0x1
	// Position of PIGEON_CLK_GATE field.
	LCDIF_PIGEONCTRL2_CLR_PIGEON_CLK_GATE_Pos = 0x1
	// Bit mask of PIGEON_CLK_GATE field.
	LCDIF_PIGEONCTRL2_CLR_PIGEON_CLK_GATE_Msk = 0x2
	// Bit PIGEON_CLK_GATE.
	LCDIF_PIGEONCTRL2_CLR_PIGEON_CLK_GATE = 0x2

	// PIGEONCTRL2_TOG: LCDIF Pigeon Mode Control2 Register
	// Position of PIGEON_DATA_EN field.
	LCDIF_PIGEONCTRL2_TOG_PIGEON_DATA_EN_Pos = 0x0
	// Bit mask of PIGEON_DATA_EN field.
	LCDIF_PIGEONCTRL2_TOG_PIGEON_DATA_EN_Msk = 0x1
	// Bit PIGEON_DATA_EN.
	LCDIF_PIGEONCTRL2_TOG_PIGEON_DATA_EN = 0x1
	// Position of PIGEON_CLK_GATE field.
	LCDIF_PIGEONCTRL2_TOG_PIGEON_CLK_GATE_Pos = 0x1
	// Bit mask of PIGEON_CLK_GATE field.
	LCDIF_PIGEONCTRL2_TOG_PIGEON_CLK_GATE_Msk = 0x2
	// Bit PIGEON_CLK_GATE.
	LCDIF_PIGEONCTRL2_TOG_PIGEON_CLK_GATE = 0x2

	// PIGEON_0_0: Panel Interface Signal Generator Register
	// Position of EN field.
	LCDIF_PIGEON_0_0_EN_Pos = 0x0
	// Bit mask of EN field.
	LCDIF_PIGEON_0_0_EN_Msk = 0x1
	// Bit EN.
	LCDIF_PIGEON_0_0_EN = 0x1
	// Position of POL field.
	LCDIF_PIGEON_0_0_POL_Pos = 0x1
	// Bit mask of POL field.
	LCDIF_PIGEON_0_0_POL_Msk = 0x2
	// Bit POL.
	LCDIF_PIGEON_0_0_POL = 0x2
	// Normal Signal (Active high)
	LCDIF_PIGEON_0_0_POL_ACTIVE_HIGH = 0x0
	// Inverted signal (Active low)
	LCDIF_PIGEON_0_0_POL_ACTIVE_LOW = 0x1
	// Position of INC_SEL field.
	LCDIF_PIGEON_0_0_INC_SEL_Pos = 0x2
	// Bit mask of INC_SEL field.
	LCDIF_PIGEON_0_0_INC_SEL_Msk = 0xc
	// pclk
	LCDIF_PIGEON_0_0_INC_SEL_PCLK = 0x0
	// Line start pulse
	LCDIF_PIGEON_0_0_INC_SEL_LINE = 0x1
	// Frame start pulse
	LCDIF_PIGEON_0_0_INC_SEL_FRAME = 0x2
	// Use another signal as tick event
	LCDIF_PIGEON_0_0_INC_SEL_SIG_ANOTHER = 0x3
	// Position of OFFSET field.
	LCDIF_PIGEON_0_0_OFFSET_Pos = 0x4
	// Bit mask of OFFSET field.
	LCDIF_PIGEON_0_0_OFFSET_Msk = 0xf0
	// Position of MASK_CNT_SEL field.
	LCDIF_PIGEON_0_0_MASK_CNT_SEL_Pos = 0x8
	// Bit mask of MASK_CNT_SEL field.
	LCDIF_PIGEON_0_0_MASK_CNT_SEL_Msk = 0xf00
	// pclk counter within one hscan state
	LCDIF_PIGEON_0_0_MASK_CNT_SEL_HSTATE_CNT = 0x0
	// pclk cycle within one hscan state
	LCDIF_PIGEON_0_0_MASK_CNT_SEL_HSTATE_CYCLE = 0x1
	// line counter within one vscan state
	LCDIF_PIGEON_0_0_MASK_CNT_SEL_VSTATE_CNT = 0x2
	// line cycle within one vscan state
	LCDIF_PIGEON_0_0_MASK_CNT_SEL_VSTATE_CYCLE = 0x3
	// frame counter
	LCDIF_PIGEON_0_0_MASK_CNT_SEL_FRAME_CNT = 0x4
	// frame cycle
	LCDIF_PIGEON_0_0_MASK_CNT_SEL_FRAME_CYCLE = 0x5
	// horizontal counter (pclk counter within one line )
	LCDIF_PIGEON_0_0_MASK_CNT_SEL_HCNT = 0x6
	// vertical counter (line counter within one frame)
	LCDIF_PIGEON_0_0_MASK_CNT_SEL_VCNT = 0x7
	// Position of MASK_CNT field.
	LCDIF_PIGEON_0_0_MASK_CNT_Pos = 0xc
	// Bit mask of MASK_CNT field.
	LCDIF_PIGEON_0_0_MASK_CNT_Msk = 0xfff000
	// Position of STATE_MASK field.
	LCDIF_PIGEON_0_0_STATE_MASK_Pos = 0x18
	// Bit mask of STATE_MASK field.
	LCDIF_PIGEON_0_0_STATE_MASK_Msk = 0xff000000
	// FRAME SYNC
	LCDIF_PIGEON_0_0_STATE_MASK_FS = 0x1
	// FRAME BEGIN
	LCDIF_PIGEON_0_0_STATE_MASK_FB = 0x2
	// FRAME DATA
	LCDIF_PIGEON_0_0_STATE_MASK_FD = 0x4
	// FRAME END
	LCDIF_PIGEON_0_0_STATE_MASK_FE = 0x8
	// LINE SYNC
	LCDIF_PIGEON_0_0_STATE_MASK_LS = 0x10
	// LINE BEGIN
	LCDIF_PIGEON_0_0_STATE_MASK_LB = 0x20
	// LINE DATA
	LCDIF_PIGEON_0_0_STATE_MASK_LD = 0x40
	// LINE END
	LCDIF_PIGEON_0_0_STATE_MASK_LE = 0x80

	// PIGEON_0_1: Panel Interface Signal Generator Register
	// Position of SET_CNT field.
	LCDIF_PIGEON_0_1_SET_CNT_Pos = 0x0
	// Bit mask of SET_CNT field.
	LCDIF_PIGEON_0_1_SET_CNT_Msk = 0xffff
	// Start as active
	LCDIF_PIGEON_0_1_SET_CNT_START_ACTIVE = 0x0
	// Position of CLR_CNT field.
	LCDIF_PIGEON_0_1_CLR_CNT_Pos = 0x10
	// Bit mask of CLR_CNT field.
	LCDIF_PIGEON_0_1_CLR_CNT_Msk = 0xffff0000
	// Keep active until mask off
	LCDIF_PIGEON_0_1_CLR_CNT_CLEAR_USING_MASK = 0x0

	// PIGEON_0_2: Panel Interface Signal Generator Register
	// Position of SIG_LOGIC field.
	LCDIF_PIGEON_0_2_SIG_LOGIC_Pos = 0x0
	// Bit mask of SIG_LOGIC field.
	LCDIF_PIGEON_0_2_SIG_LOGIC_Msk = 0xf
	// No logic operation
	LCDIF_PIGEON_0_2_SIG_LOGIC_DIS = 0x0
	// sigout = sig_another AND this_sig
	LCDIF_PIGEON_0_2_SIG_LOGIC_AND = 0x1
	// sigout = sig_another OR this_sig
	LCDIF_PIGEON_0_2_SIG_LOGIC_OR = 0x2
	// mask = sig_another AND other_masks
	LCDIF_PIGEON_0_2_SIG_LOGIC_MASK = 0x3
	// Position of SIG_ANOTHER field.
	LCDIF_PIGEON_0_2_SIG_ANOTHER_Pos = 0x4
	// Bit mask of SIG_ANOTHER field.
	LCDIF_PIGEON_0_2_SIG_ANOTHER_Msk = 0x1f0
	// Keep active until mask off
	LCDIF_PIGEON_0_2_SIG_ANOTHER_CLEAR_USING_MASK = 0x0

	// PIGEON_1_0: Panel Interface Signal Generator Register
	// Position of EN field.
	LCDIF_PIGEON_1_0_EN_Pos = 0x0
	// Bit mask of EN field.
	LCDIF_PIGEON_1_0_EN_Msk = 0x1
	// Bit EN.
	LCDIF_PIGEON_1_0_EN = 0x1
	// Position of POL field.
	LCDIF_PIGEON_1_0_POL_Pos = 0x1
	// Bit mask of POL field.
	LCDIF_PIGEON_1_0_POL_Msk = 0x2
	// Bit POL.
	LCDIF_PIGEON_1_0_POL = 0x2
	// Normal Signal (Active high)
	LCDIF_PIGEON_1_0_POL_ACTIVE_HIGH = 0x0
	// Inverted signal (Active low)
	LCDIF_PIGEON_1_0_POL_ACTIVE_LOW = 0x1
	// Position of INC_SEL field.
	LCDIF_PIGEON_1_0_INC_SEL_Pos = 0x2
	// Bit mask of INC_SEL field.
	LCDIF_PIGEON_1_0_INC_SEL_Msk = 0xc
	// pclk
	LCDIF_PIGEON_1_0_INC_SEL_PCLK = 0x0
	// Line start pulse
	LCDIF_PIGEON_1_0_INC_SEL_LINE = 0x1
	// Frame start pulse
	LCDIF_PIGEON_1_0_INC_SEL_FRAME = 0x2
	// Use another signal as tick event
	LCDIF_PIGEON_1_0_INC_SEL_SIG_ANOTHER = 0x3
	// Position of OFFSET field.
	LCDIF_PIGEON_1_0_OFFSET_Pos = 0x4
	// Bit mask of OFFSET field.
	LCDIF_PIGEON_1_0_OFFSET_Msk = 0xf0
	// Position of MASK_CNT_SEL field.
	LCDIF_PIGEON_1_0_MASK_CNT_SEL_Pos = 0x8
	// Bit mask of MASK_CNT_SEL field.
	LCDIF_PIGEON_1_0_MASK_CNT_SEL_Msk = 0xf00
	// pclk counter within one hscan state
	LCDIF_PIGEON_1_0_MASK_CNT_SEL_HSTATE_CNT = 0x0
	// pclk cycle within one hscan state
	LCDIF_PIGEON_1_0_MASK_CNT_SEL_HSTATE_CYCLE = 0x1
	// line counter within one vscan state
	LCDIF_PIGEON_1_0_MASK_CNT_SEL_VSTATE_CNT = 0x2
	// line cycle within one vscan state
	LCDIF_PIGEON_1_0_MASK_CNT_SEL_VSTATE_CYCLE = 0x3
	// frame counter
	LCDIF_PIGEON_1_0_MASK_CNT_SEL_FRAME_CNT = 0x4
	// frame cycle
	LCDIF_PIGEON_1_0_MASK_CNT_SEL_FRAME_CYCLE = 0x5
	// horizontal counter (pclk counter within one line )
	LCDIF_PIGEON_1_0_MASK_CNT_SEL_HCNT = 0x6
	// vertical counter (line counter within one frame)
	LCDIF_PIGEON_1_0_MASK_CNT_SEL_VCNT = 0x7
	// Position of MASK_CNT field.
	LCDIF_PIGEON_1_0_MASK_CNT_Pos = 0xc
	// Bit mask of MASK_CNT field.
	LCDIF_PIGEON_1_0_MASK_CNT_Msk = 0xfff000
	// Position of STATE_MASK field.
	LCDIF_PIGEON_1_0_STATE_MASK_Pos = 0x18
	// Bit mask of STATE_MASK field.
	LCDIF_PIGEON_1_0_STATE_MASK_Msk = 0xff000000
	// FRAME SYNC
	LCDIF_PIGEON_1_0_STATE_MASK_FS = 0x1
	// FRAME BEGIN
	LCDIF_PIGEON_1_0_STATE_MASK_FB = 0x2
	// FRAME DATA
	LCDIF_PIGEON_1_0_STATE_MASK_FD = 0x4
	// FRAME END
	LCDIF_PIGEON_1_0_STATE_MASK_FE = 0x8
	// LINE SYNC
	LCDIF_PIGEON_1_0_STATE_MASK_LS = 0x10
	// LINE BEGIN
	LCDIF_PIGEON_1_0_STATE_MASK_LB = 0x20
	// LINE DATA
	LCDIF_PIGEON_1_0_STATE_MASK_LD = 0x40
	// LINE END
	LCDIF_PIGEON_1_0_STATE_MASK_LE = 0x80

	// PIGEON_1_1: Panel Interface Signal Generator Register
	// Position of SET_CNT field.
	LCDIF_PIGEON_1_1_SET_CNT_Pos = 0x0
	// Bit mask of SET_CNT field.
	LCDIF_PIGEON_1_1_SET_CNT_Msk = 0xffff
	// Start as active
	LCDIF_PIGEON_1_1_SET_CNT_START_ACTIVE = 0x0
	// Position of CLR_CNT field.
	LCDIF_PIGEON_1_1_CLR_CNT_Pos = 0x10
	// Bit mask of CLR_CNT field.
	LCDIF_PIGEON_1_1_CLR_CNT_Msk = 0xffff0000
	// Keep active until mask off
	LCDIF_PIGEON_1_1_CLR_CNT_CLEAR_USING_MASK = 0x0

	// PIGEON_1_2: Panel Interface Signal Generator Register
	// Position of SIG_LOGIC field.
	LCDIF_PIGEON_1_2_SIG_LOGIC_Pos = 0x0
	// Bit mask of SIG_LOGIC field.
	LCDIF_PIGEON_1_2_SIG_LOGIC_Msk = 0xf
	// No logic operation
	LCDIF_PIGEON_1_2_SIG_LOGIC_DIS = 0x0
	// sigout = sig_another AND this_sig
	LCDIF_PIGEON_1_2_SIG_LOGIC_AND = 0x1
	// sigout = sig_another OR this_sig
	LCDIF_PIGEON_1_2_SIG_LOGIC_OR = 0x2
	// mask = sig_another AND other_masks
	LCDIF_PIGEON_1_2_SIG_LOGIC_MASK = 0x3
	// Position of SIG_ANOTHER field.
	LCDIF_PIGEON_1_2_SIG_ANOTHER_Pos = 0x4
	// Bit mask of SIG_ANOTHER field.
	LCDIF_PIGEON_1_2_SIG_ANOTHER_Msk = 0x1f0
	// Keep active until mask off
	LCDIF_PIGEON_1_2_SIG_ANOTHER_CLEAR_USING_MASK = 0x0

	// PIGEON_2_0: Panel Interface Signal Generator Register
	// Position of EN field.
	LCDIF_PIGEON_2_0_EN_Pos = 0x0
	// Bit mask of EN field.
	LCDIF_PIGEON_2_0_EN_Msk = 0x1
	// Bit EN.
	LCDIF_PIGEON_2_0_EN = 0x1
	// Position of POL field.
	LCDIF_PIGEON_2_0_POL_Pos = 0x1
	// Bit mask of POL field.
	LCDIF_PIGEON_2_0_POL_Msk = 0x2
	// Bit POL.
	LCDIF_PIGEON_2_0_POL = 0x2
	// Normal Signal (Active high)
	LCDIF_PIGEON_2_0_POL_ACTIVE_HIGH = 0x0
	// Inverted signal (Active low)
	LCDIF_PIGEON_2_0_POL_ACTIVE_LOW = 0x1
	// Position of INC_SEL field.
	LCDIF_PIGEON_2_0_INC_SEL_Pos = 0x2
	// Bit mask of INC_SEL field.
	LCDIF_PIGEON_2_0_INC_SEL_Msk = 0xc
	// pclk
	LCDIF_PIGEON_2_0_INC_SEL_PCLK = 0x0
	// Line start pulse
	LCDIF_PIGEON_2_0_INC_SEL_LINE = 0x1
	// Frame start pulse
	LCDIF_PIGEON_2_0_INC_SEL_FRAME = 0x2
	// Use another signal as tick event
	LCDIF_PIGEON_2_0_INC_SEL_SIG_ANOTHER = 0x3
	// Position of OFFSET field.
	LCDIF_PIGEON_2_0_OFFSET_Pos = 0x4
	// Bit mask of OFFSET field.
	LCDIF_PIGEON_2_0_OFFSET_Msk = 0xf0
	// Position of MASK_CNT_SEL field.
	LCDIF_PIGEON_2_0_MASK_CNT_SEL_Pos = 0x8
	// Bit mask of MASK_CNT_SEL field.
	LCDIF_PIGEON_2_0_MASK_CNT_SEL_Msk = 0xf00
	// pclk counter within one hscan state
	LCDIF_PIGEON_2_0_MASK_CNT_SEL_HSTATE_CNT = 0x0
	// pclk cycle within one hscan state
	LCDIF_PIGEON_2_0_MASK_CNT_SEL_HSTATE_CYCLE = 0x1
	// line counter within one vscan state
	LCDIF_PIGEON_2_0_MASK_CNT_SEL_VSTATE_CNT = 0x2
	// line cycle within one vscan state
	LCDIF_PIGEON_2_0_MASK_CNT_SEL_VSTATE_CYCLE = 0x3
	// frame counter
	LCDIF_PIGEON_2_0_MASK_CNT_SEL_FRAME_CNT = 0x4
	// frame cycle
	LCDIF_PIGEON_2_0_MASK_CNT_SEL_FRAME_CYCLE = 0x5
	// horizontal counter (pclk counter within one line )
	LCDIF_PIGEON_2_0_MASK_CNT_SEL_HCNT = 0x6
	// vertical counter (line counter within one frame)
	LCDIF_PIGEON_2_0_MASK_CNT_SEL_VCNT = 0x7
	// Position of MASK_CNT field.
	LCDIF_PIGEON_2_0_MASK_CNT_Pos = 0xc
	// Bit mask of MASK_CNT field.
	LCDIF_PIGEON_2_0_MASK_CNT_Msk = 0xfff000
	// Position of STATE_MASK field.
	LCDIF_PIGEON_2_0_STATE_MASK_Pos = 0x18
	// Bit mask of STATE_MASK field.
	LCDIF_PIGEON_2_0_STATE_MASK_Msk = 0xff000000
	// FRAME SYNC
	LCDIF_PIGEON_2_0_STATE_MASK_FS = 0x1
	// FRAME BEGIN
	LCDIF_PIGEON_2_0_STATE_MASK_FB = 0x2
	// FRAME DATA
	LCDIF_PIGEON_2_0_STATE_MASK_FD = 0x4
	// FRAME END
	LCDIF_PIGEON_2_0_STATE_MASK_FE = 0x8
	// LINE SYNC
	LCDIF_PIGEON_2_0_STATE_MASK_LS = 0x10
	// LINE BEGIN
	LCDIF_PIGEON_2_0_STATE_MASK_LB = 0x20
	// LINE DATA
	LCDIF_PIGEON_2_0_STATE_MASK_LD = 0x40
	// LINE END
	LCDIF_PIGEON_2_0_STATE_MASK_LE = 0x80

	// PIGEON_2_1: Panel Interface Signal Generator Register
	// Position of SET_CNT field.
	LCDIF_PIGEON_2_1_SET_CNT_Pos = 0x0
	// Bit mask of SET_CNT field.
	LCDIF_PIGEON_2_1_SET_CNT_Msk = 0xffff
	// Start as active
	LCDIF_PIGEON_2_1_SET_CNT_START_ACTIVE = 0x0
	// Position of CLR_CNT field.
	LCDIF_PIGEON_2_1_CLR_CNT_Pos = 0x10
	// Bit mask of CLR_CNT field.
	LCDIF_PIGEON_2_1_CLR_CNT_Msk = 0xffff0000
	// Keep active until mask off
	LCDIF_PIGEON_2_1_CLR_CNT_CLEAR_USING_MASK = 0x0

	// PIGEON_2_2: Panel Interface Signal Generator Register
	// Position of SIG_LOGIC field.
	LCDIF_PIGEON_2_2_SIG_LOGIC_Pos = 0x0
	// Bit mask of SIG_LOGIC field.
	LCDIF_PIGEON_2_2_SIG_LOGIC_Msk = 0xf
	// No logic operation
	LCDIF_PIGEON_2_2_SIG_LOGIC_DIS = 0x0
	// sigout = sig_another AND this_sig
	LCDIF_PIGEON_2_2_SIG_LOGIC_AND = 0x1
	// sigout = sig_another OR this_sig
	LCDIF_PIGEON_2_2_SIG_LOGIC_OR = 0x2
	// mask = sig_another AND other_masks
	LCDIF_PIGEON_2_2_SIG_LOGIC_MASK = 0x3
	// Position of SIG_ANOTHER field.
	LCDIF_PIGEON_2_2_SIG_ANOTHER_Pos = 0x4
	// Bit mask of SIG_ANOTHER field.
	LCDIF_PIGEON_2_2_SIG_ANOTHER_Msk = 0x1f0
	// Keep active until mask off
	LCDIF_PIGEON_2_2_SIG_ANOTHER_CLEAR_USING_MASK = 0x0

	// PIGEON_3_0: Panel Interface Signal Generator Register
	// Position of EN field.
	LCDIF_PIGEON_3_0_EN_Pos = 0x0
	// Bit mask of EN field.
	LCDIF_PIGEON_3_0_EN_Msk = 0x1
	// Bit EN.
	LCDIF_PIGEON_3_0_EN = 0x1
	// Position of POL field.
	LCDIF_PIGEON_3_0_POL_Pos = 0x1
	// Bit mask of POL field.
	LCDIF_PIGEON_3_0_POL_Msk = 0x2
	// Bit POL.
	LCDIF_PIGEON_3_0_POL = 0x2
	// Normal Signal (Active high)
	LCDIF_PIGEON_3_0_POL_ACTIVE_HIGH = 0x0
	// Inverted signal (Active low)
	LCDIF_PIGEON_3_0_POL_ACTIVE_LOW = 0x1
	// Position of INC_SEL field.
	LCDIF_PIGEON_3_0_INC_SEL_Pos = 0x2
	// Bit mask of INC_SEL field.
	LCDIF_PIGEON_3_0_INC_SEL_Msk = 0xc
	// pclk
	LCDIF_PIGEON_3_0_INC_SEL_PCLK = 0x0
	// Line start pulse
	LCDIF_PIGEON_3_0_INC_SEL_LINE = 0x1
	// Frame start pulse
	LCDIF_PIGEON_3_0_INC_SEL_FRAME = 0x2
	// Use another signal as tick event
	LCDIF_PIGEON_3_0_INC_SEL_SIG_ANOTHER = 0x3
	// Position of OFFSET field.
	LCDIF_PIGEON_3_0_OFFSET_Pos = 0x4
	// Bit mask of OFFSET field.
	LCDIF_PIGEON_3_0_OFFSET_Msk = 0xf0
	// Position of MASK_CNT_SEL field.
	LCDIF_PIGEON_3_0_MASK_CNT_SEL_Pos = 0x8
	// Bit mask of MASK_CNT_SEL field.
	LCDIF_PIGEON_3_0_MASK_CNT_SEL_Msk = 0xf00
	// pclk counter within one hscan state
	LCDIF_PIGEON_3_0_MASK_CNT_SEL_HSTATE_CNT = 0x0
	// pclk cycle within one hscan state
	LCDIF_PIGEON_3_0_MASK_CNT_SEL_HSTATE_CYCLE = 0x1
	// line counter within one vscan state
	LCDIF_PIGEON_3_0_MASK_CNT_SEL_VSTATE_CNT = 0x2
	// line cycle within one vscan state
	LCDIF_PIGEON_3_0_MASK_CNT_SEL_VSTATE_CYCLE = 0x3
	// frame counter
	LCDIF_PIGEON_3_0_MASK_CNT_SEL_FRAME_CNT = 0x4
	// frame cycle
	LCDIF_PIGEON_3_0_MASK_CNT_SEL_FRAME_CYCLE = 0x5
	// horizontal counter (pclk counter within one line )
	LCDIF_PIGEON_3_0_MASK_CNT_SEL_HCNT = 0x6
	// vertical counter (line counter within one frame)
	LCDIF_PIGEON_3_0_MASK_CNT_SEL_VCNT = 0x7
	// Position of MASK_CNT field.
	LCDIF_PIGEON_3_0_MASK_CNT_Pos = 0xc
	// Bit mask of MASK_CNT field.
	LCDIF_PIGEON_3_0_MASK_CNT_Msk = 0xfff000
	// Position of STATE_MASK field.
	LCDIF_PIGEON_3_0_STATE_MASK_Pos = 0x18
	// Bit mask of STATE_MASK field.
	LCDIF_PIGEON_3_0_STATE_MASK_Msk = 0xff000000
	// FRAME SYNC
	LCDIF_PIGEON_3_0_STATE_MASK_FS = 0x1
	// FRAME BEGIN
	LCDIF_PIGEON_3_0_STATE_MASK_FB = 0x2
	// FRAME DATA
	LCDIF_PIGEON_3_0_STATE_MASK_FD = 0x4
	// FRAME END
	LCDIF_PIGEON_3_0_STATE_MASK_FE = 0x8
	// LINE SYNC
	LCDIF_PIGEON_3_0_STATE_MASK_LS = 0x10
	// LINE BEGIN
	LCDIF_PIGEON_3_0_STATE_MASK_LB = 0x20
	// LINE DATA
	LCDIF_PIGEON_3_0_STATE_MASK_LD = 0x40
	// LINE END
	LCDIF_PIGEON_3_0_STATE_MASK_LE = 0x80

	// PIGEON_3_1: Panel Interface Signal Generator Register
	// Position of SET_CNT field.
	LCDIF_PIGEON_3_1_SET_CNT_Pos = 0x0
	// Bit mask of SET_CNT field.
	LCDIF_PIGEON_3_1_SET_CNT_Msk = 0xffff
	// Start as active
	LCDIF_PIGEON_3_1_SET_CNT_START_ACTIVE = 0x0
	// Position of CLR_CNT field.
	LCDIF_PIGEON_3_1_CLR_CNT_Pos = 0x10
	// Bit mask of CLR_CNT field.
	LCDIF_PIGEON_3_1_CLR_CNT_Msk = 0xffff0000
	// Keep active until mask off
	LCDIF_PIGEON_3_1_CLR_CNT_CLEAR_USING_MASK = 0x0

	// PIGEON_3_2: Panel Interface Signal Generator Register
	// Position of SIG_LOGIC field.
	LCDIF_PIGEON_3_2_SIG_LOGIC_Pos = 0x0
	// Bit mask of SIG_LOGIC field.
	LCDIF_PIGEON_3_2_SIG_LOGIC_Msk = 0xf
	// No logic operation
	LCDIF_PIGEON_3_2_SIG_LOGIC_DIS = 0x0
	// sigout = sig_another AND this_sig
	LCDIF_PIGEON_3_2_SIG_LOGIC_AND = 0x1
	// sigout = sig_another OR this_sig
	LCDIF_PIGEON_3_2_SIG_LOGIC_OR = 0x2
	// mask = sig_another AND other_masks
	LCDIF_PIGEON_3_2_SIG_LOGIC_MASK = 0x3
	// Position of SIG_ANOTHER field.
	LCDIF_PIGEON_3_2_SIG_ANOTHER_Pos = 0x4
	// Bit mask of SIG_ANOTHER field.
	LCDIF_PIGEON_3_2_SIG_ANOTHER_Msk = 0x1f0
	// Keep active until mask off
	LCDIF_PIGEON_3_2_SIG_ANOTHER_CLEAR_USING_MASK = 0x0

	// PIGEON_4_0: Panel Interface Signal Generator Register
	// Position of EN field.
	LCDIF_PIGEON_4_0_EN_Pos = 0x0
	// Bit mask of EN field.
	LCDIF_PIGEON_4_0_EN_Msk = 0x1
	// Bit EN.
	LCDIF_PIGEON_4_0_EN = 0x1
	// Position of POL field.
	LCDIF_PIGEON_4_0_POL_Pos = 0x1
	// Bit mask of POL field.
	LCDIF_PIGEON_4_0_POL_Msk = 0x2
	// Bit POL.
	LCDIF_PIGEON_4_0_POL = 0x2
	// Normal Signal (Active high)
	LCDIF_PIGEON_4_0_POL_ACTIVE_HIGH = 0x0
	// Inverted signal (Active low)
	LCDIF_PIGEON_4_0_POL_ACTIVE_LOW = 0x1
	// Position of INC_SEL field.
	LCDIF_PIGEON_4_0_INC_SEL_Pos = 0x2
	// Bit mask of INC_SEL field.
	LCDIF_PIGEON_4_0_INC_SEL_Msk = 0xc
	// pclk
	LCDIF_PIGEON_4_0_INC_SEL_PCLK = 0x0
	// Line start pulse
	LCDIF_PIGEON_4_0_INC_SEL_LINE = 0x1
	// Frame start pulse
	LCDIF_PIGEON_4_0_INC_SEL_FRAME = 0x2
	// Use another signal as tick event
	LCDIF_PIGEON_4_0_INC_SEL_SIG_ANOTHER = 0x3
	// Position of OFFSET field.
	LCDIF_PIGEON_4_0_OFFSET_Pos = 0x4
	// Bit mask of OFFSET field.
	LCDIF_PIGEON_4_0_OFFSET_Msk = 0xf0
	// Position of MASK_CNT_SEL field.
	LCDIF_PIGEON_4_0_MASK_CNT_SEL_Pos = 0x8
	// Bit mask of MASK_CNT_SEL field.
	LCDIF_PIGEON_4_0_MASK_CNT_SEL_Msk = 0xf00
	// pclk counter within one hscan state
	LCDIF_PIGEON_4_0_MASK_CNT_SEL_HSTATE_CNT = 0x0
	// pclk cycle within one hscan state
	LCDIF_PIGEON_4_0_MASK_CNT_SEL_HSTATE_CYCLE = 0x1
	// line counter within one vscan state
	LCDIF_PIGEON_4_0_MASK_CNT_SEL_VSTATE_CNT = 0x2
	// line cycle within one vscan state
	LCDIF_PIGEON_4_0_MASK_CNT_SEL_VSTATE_CYCLE = 0x3
	// frame counter
	LCDIF_PIGEON_4_0_MASK_CNT_SEL_FRAME_CNT = 0x4
	// frame cycle
	LCDIF_PIGEON_4_0_MASK_CNT_SEL_FRAME_CYCLE = 0x5
	// horizontal counter (pclk counter within one line )
	LCDIF_PIGEON_4_0_MASK_CNT_SEL_HCNT = 0x6
	// vertical counter (line counter within one frame)
	LCDIF_PIGEON_4_0_MASK_CNT_SEL_VCNT = 0x7
	// Position of MASK_CNT field.
	LCDIF_PIGEON_4_0_MASK_CNT_Pos = 0xc
	// Bit mask of MASK_CNT field.
	LCDIF_PIGEON_4_0_MASK_CNT_Msk = 0xfff000
	// Position of STATE_MASK field.
	LCDIF_PIGEON_4_0_STATE_MASK_Pos = 0x18
	// Bit mask of STATE_MASK field.
	LCDIF_PIGEON_4_0_STATE_MASK_Msk = 0xff000000
	// FRAME SYNC
	LCDIF_PIGEON_4_0_STATE_MASK_FS = 0x1
	// FRAME BEGIN
	LCDIF_PIGEON_4_0_STATE_MASK_FB = 0x2
	// FRAME DATA
	LCDIF_PIGEON_4_0_STATE_MASK_FD = 0x4
	// FRAME END
	LCDIF_PIGEON_4_0_STATE_MASK_FE = 0x8
	// LINE SYNC
	LCDIF_PIGEON_4_0_STATE_MASK_LS = 0x10
	// LINE BEGIN
	LCDIF_PIGEON_4_0_STATE_MASK_LB = 0x20
	// LINE DATA
	LCDIF_PIGEON_4_0_STATE_MASK_LD = 0x40
	// LINE END
	LCDIF_PIGEON_4_0_STATE_MASK_LE = 0x80

	// PIGEON_4_1: Panel Interface Signal Generator Register
	// Position of SET_CNT field.
	LCDIF_PIGEON_4_1_SET_CNT_Pos = 0x0
	// Bit mask of SET_CNT field.
	LCDIF_PIGEON_4_1_SET_CNT_Msk = 0xffff
	// Start as active
	LCDIF_PIGEON_4_1_SET_CNT_START_ACTIVE = 0x0
	// Position of CLR_CNT field.
	LCDIF_PIGEON_4_1_CLR_CNT_Pos = 0x10
	// Bit mask of CLR_CNT field.
	LCDIF_PIGEON_4_1_CLR_CNT_Msk = 0xffff0000
	// Keep active until mask off
	LCDIF_PIGEON_4_1_CLR_CNT_CLEAR_USING_MASK = 0x0

	// PIGEON_4_2: Panel Interface Signal Generator Register
	// Position of SIG_LOGIC field.
	LCDIF_PIGEON_4_2_SIG_LOGIC_Pos = 0x0
	// Bit mask of SIG_LOGIC field.
	LCDIF_PIGEON_4_2_SIG_LOGIC_Msk = 0xf
	// No logic operation
	LCDIF_PIGEON_4_2_SIG_LOGIC_DIS = 0x0
	// sigout = sig_another AND this_sig
	LCDIF_PIGEON_4_2_SIG_LOGIC_AND = 0x1
	// sigout = sig_another OR this_sig
	LCDIF_PIGEON_4_2_SIG_LOGIC_OR = 0x2
	// mask = sig_another AND other_masks
	LCDIF_PIGEON_4_2_SIG_LOGIC_MASK = 0x3
	// Position of SIG_ANOTHER field.
	LCDIF_PIGEON_4_2_SIG_ANOTHER_Pos = 0x4
	// Bit mask of SIG_ANOTHER field.
	LCDIF_PIGEON_4_2_SIG_ANOTHER_Msk = 0x1f0
	// Keep active until mask off
	LCDIF_PIGEON_4_2_SIG_ANOTHER_CLEAR_USING_MASK = 0x0

	// PIGEON_5_0: Panel Interface Signal Generator Register
	// Position of EN field.
	LCDIF_PIGEON_5_0_EN_Pos = 0x0
	// Bit mask of EN field.
	LCDIF_PIGEON_5_0_EN_Msk = 0x1
	// Bit EN.
	LCDIF_PIGEON_5_0_EN = 0x1
	// Position of POL field.
	LCDIF_PIGEON_5_0_POL_Pos = 0x1
	// Bit mask of POL field.
	LCDIF_PIGEON_5_0_POL_Msk = 0x2
	// Bit POL.
	LCDIF_PIGEON_5_0_POL = 0x2
	// Normal Signal (Active high)
	LCDIF_PIGEON_5_0_POL_ACTIVE_HIGH = 0x0
	// Inverted signal (Active low)
	LCDIF_PIGEON_5_0_POL_ACTIVE_LOW = 0x1
	// Position of INC_SEL field.
	LCDIF_PIGEON_5_0_INC_SEL_Pos = 0x2
	// Bit mask of INC_SEL field.
	LCDIF_PIGEON_5_0_INC_SEL_Msk = 0xc
	// pclk
	LCDIF_PIGEON_5_0_INC_SEL_PCLK = 0x0
	// Line start pulse
	LCDIF_PIGEON_5_0_INC_SEL_LINE = 0x1
	// Frame start pulse
	LCDIF_PIGEON_5_0_INC_SEL_FRAME = 0x2
	// Use another signal as tick event
	LCDIF_PIGEON_5_0_INC_SEL_SIG_ANOTHER = 0x3
	// Position of OFFSET field.
	LCDIF_PIGEON_5_0_OFFSET_Pos = 0x4
	// Bit mask of OFFSET field.
	LCDIF_PIGEON_5_0_OFFSET_Msk = 0xf0
	// Position of MASK_CNT_SEL field.
	LCDIF_PIGEON_5_0_MASK_CNT_SEL_Pos = 0x8
	// Bit mask of MASK_CNT_SEL field.
	LCDIF_PIGEON_5_0_MASK_CNT_SEL_Msk = 0xf00
	// pclk counter within one hscan state
	LCDIF_PIGEON_5_0_MASK_CNT_SEL_HSTATE_CNT = 0x0
	// pclk cycle within one hscan state
	LCDIF_PIGEON_5_0_MASK_CNT_SEL_HSTATE_CYCLE = 0x1
	// line counter within one vscan state
	LCDIF_PIGEON_5_0_MASK_CNT_SEL_VSTATE_CNT = 0x2
	// line cycle within one vscan state
	LCDIF_PIGEON_5_0_MASK_CNT_SEL_VSTATE_CYCLE = 0x3
	// frame counter
	LCDIF_PIGEON_5_0_MASK_CNT_SEL_FRAME_CNT = 0x4
	// frame cycle
	LCDIF_PIGEON_5_0_MASK_CNT_SEL_FRAME_CYCLE = 0x5
	// horizontal counter (pclk counter within one line )
	LCDIF_PIGEON_5_0_MASK_CNT_SEL_HCNT = 0x6
	// vertical counter (line counter within one frame)
	LCDIF_PIGEON_5_0_MASK_CNT_SEL_VCNT = 0x7
	// Position of MASK_CNT field.
	LCDIF_PIGEON_5_0_MASK_CNT_Pos = 0xc
	// Bit mask of MASK_CNT field.
	LCDIF_PIGEON_5_0_MASK_CNT_Msk = 0xfff000
	// Position of STATE_MASK field.
	LCDIF_PIGEON_5_0_STATE_MASK_Pos = 0x18
	// Bit mask of STATE_MASK field.
	LCDIF_PIGEON_5_0_STATE_MASK_Msk = 0xff000000
	// FRAME SYNC
	LCDIF_PIGEON_5_0_STATE_MASK_FS = 0x1
	// FRAME BEGIN
	LCDIF_PIGEON_5_0_STATE_MASK_FB = 0x2
	// FRAME DATA
	LCDIF_PIGEON_5_0_STATE_MASK_FD = 0x4
	// FRAME END
	LCDIF_PIGEON_5_0_STATE_MASK_FE = 0x8
	// LINE SYNC
	LCDIF_PIGEON_5_0_STATE_MASK_LS = 0x10
	// LINE BEGIN
	LCDIF_PIGEON_5_0_STATE_MASK_LB = 0x20
	// LINE DATA
	LCDIF_PIGEON_5_0_STATE_MASK_LD = 0x40
	// LINE END
	LCDIF_PIGEON_5_0_STATE_MASK_LE = 0x80

	// PIGEON_5_1: Panel Interface Signal Generator Register
	// Position of SET_CNT field.
	LCDIF_PIGEON_5_1_SET_CNT_Pos = 0x0
	// Bit mask of SET_CNT field.
	LCDIF_PIGEON_5_1_SET_CNT_Msk = 0xffff
	// Start as active
	LCDIF_PIGEON_5_1_SET_CNT_START_ACTIVE = 0x0
	// Position of CLR_CNT field.
	LCDIF_PIGEON_5_1_CLR_CNT_Pos = 0x10
	// Bit mask of CLR_CNT field.
	LCDIF_PIGEON_5_1_CLR_CNT_Msk = 0xffff0000
	// Keep active until mask off
	LCDIF_PIGEON_5_1_CLR_CNT_CLEAR_USING_MASK = 0x0

	// PIGEON_5_2: Panel Interface Signal Generator Register
	// Position of SIG_LOGIC field.
	LCDIF_PIGEON_5_2_SIG_LOGIC_Pos = 0x0
	// Bit mask of SIG_LOGIC field.
	LCDIF_PIGEON_5_2_SIG_LOGIC_Msk = 0xf
	// No logic operation
	LCDIF_PIGEON_5_2_SIG_LOGIC_DIS = 0x0
	// sigout = sig_another AND this_sig
	LCDIF_PIGEON_5_2_SIG_LOGIC_AND = 0x1
	// sigout = sig_another OR this_sig
	LCDIF_PIGEON_5_2_SIG_LOGIC_OR = 0x2
	// mask = sig_another AND other_masks
	LCDIF_PIGEON_5_2_SIG_LOGIC_MASK = 0x3
	// Position of SIG_ANOTHER field.
	LCDIF_PIGEON_5_2_SIG_ANOTHER_Pos = 0x4
	// Bit mask of SIG_ANOTHER field.
	LCDIF_PIGEON_5_2_SIG_ANOTHER_Msk = 0x1f0
	// Keep active until mask off
	LCDIF_PIGEON_5_2_SIG_ANOTHER_CLEAR_USING_MASK = 0x0

	// PIGEON_6_0: Panel Interface Signal Generator Register
	// Position of EN field.
	LCDIF_PIGEON_6_0_EN_Pos = 0x0
	// Bit mask of EN field.
	LCDIF_PIGEON_6_0_EN_Msk = 0x1
	// Bit EN.
	LCDIF_PIGEON_6_0_EN = 0x1
	// Position of POL field.
	LCDIF_PIGEON_6_0_POL_Pos = 0x1
	// Bit mask of POL field.
	LCDIF_PIGEON_6_0_POL_Msk = 0x2
	// Bit POL.
	LCDIF_PIGEON_6_0_POL = 0x2
	// Normal Signal (Active high)
	LCDIF_PIGEON_6_0_POL_ACTIVE_HIGH = 0x0
	// Inverted signal (Active low)
	LCDIF_PIGEON_6_0_POL_ACTIVE_LOW = 0x1
	// Position of INC_SEL field.
	LCDIF_PIGEON_6_0_INC_SEL_Pos = 0x2
	// Bit mask of INC_SEL field.
	LCDIF_PIGEON_6_0_INC_SEL_Msk = 0xc
	// pclk
	LCDIF_PIGEON_6_0_INC_SEL_PCLK = 0x0
	// Line start pulse
	LCDIF_PIGEON_6_0_INC_SEL_LINE = 0x1
	// Frame start pulse
	LCDIF_PIGEON_6_0_INC_SEL_FRAME = 0x2
	// Use another signal as tick event
	LCDIF_PIGEON_6_0_INC_SEL_SIG_ANOTHER = 0x3
	// Position of OFFSET field.
	LCDIF_PIGEON_6_0_OFFSET_Pos = 0x4
	// Bit mask of OFFSET field.
	LCDIF_PIGEON_6_0_OFFSET_Msk = 0xf0
	// Position of MASK_CNT_SEL field.
	LCDIF_PIGEON_6_0_MASK_CNT_SEL_Pos = 0x8
	// Bit mask of MASK_CNT_SEL field.
	LCDIF_PIGEON_6_0_MASK_CNT_SEL_Msk = 0xf00
	// pclk counter within one hscan state
	LCDIF_PIGEON_6_0_MASK_CNT_SEL_HSTATE_CNT = 0x0
	// pclk cycle within one hscan state
	LCDIF_PIGEON_6_0_MASK_CNT_SEL_HSTATE_CYCLE = 0x1
	// line counter within one vscan state
	LCDIF_PIGEON_6_0_MASK_CNT_SEL_VSTATE_CNT = 0x2
	// line cycle within one vscan state
	LCDIF_PIGEON_6_0_MASK_CNT_SEL_VSTATE_CYCLE = 0x3
	// frame counter
	LCDIF_PIGEON_6_0_MASK_CNT_SEL_FRAME_CNT = 0x4
	// frame cycle
	LCDIF_PIGEON_6_0_MASK_CNT_SEL_FRAME_CYCLE = 0x5
	// horizontal counter (pclk counter within one line )
	LCDIF_PIGEON_6_0_MASK_CNT_SEL_HCNT = 0x6
	// vertical counter (line counter within one frame)
	LCDIF_PIGEON_6_0_MASK_CNT_SEL_VCNT = 0x7
	// Position of MASK_CNT field.
	LCDIF_PIGEON_6_0_MASK_CNT_Pos = 0xc
	// Bit mask of MASK_CNT field.
	LCDIF_PIGEON_6_0_MASK_CNT_Msk = 0xfff000
	// Position of STATE_MASK field.
	LCDIF_PIGEON_6_0_STATE_MASK_Pos = 0x18
	// Bit mask of STATE_MASK field.
	LCDIF_PIGEON_6_0_STATE_MASK_Msk = 0xff000000
	// FRAME SYNC
	LCDIF_PIGEON_6_0_STATE_MASK_FS = 0x1
	// FRAME BEGIN
	LCDIF_PIGEON_6_0_STATE_MASK_FB = 0x2
	// FRAME DATA
	LCDIF_PIGEON_6_0_STATE_MASK_FD = 0x4
	// FRAME END
	LCDIF_PIGEON_6_0_STATE_MASK_FE = 0x8
	// LINE SYNC
	LCDIF_PIGEON_6_0_STATE_MASK_LS = 0x10
	// LINE BEGIN
	LCDIF_PIGEON_6_0_STATE_MASK_LB = 0x20
	// LINE DATA
	LCDIF_PIGEON_6_0_STATE_MASK_LD = 0x40
	// LINE END
	LCDIF_PIGEON_6_0_STATE_MASK_LE = 0x80

	// PIGEON_6_1: Panel Interface Signal Generator Register
	// Position of SET_CNT field.
	LCDIF_PIGEON_6_1_SET_CNT_Pos = 0x0
	// Bit mask of SET_CNT field.
	LCDIF_PIGEON_6_1_SET_CNT_Msk = 0xffff
	// Start as active
	LCDIF_PIGEON_6_1_SET_CNT_START_ACTIVE = 0x0
	// Position of CLR_CNT field.
	LCDIF_PIGEON_6_1_CLR_CNT_Pos = 0x10
	// Bit mask of CLR_CNT field.
	LCDIF_PIGEON_6_1_CLR_CNT_Msk = 0xffff0000
	// Keep active until mask off
	LCDIF_PIGEON_6_1_CLR_CNT_CLEAR_USING_MASK = 0x0

	// PIGEON_6_2: Panel Interface Signal Generator Register
	// Position of SIG_LOGIC field.
	LCDIF_PIGEON_6_2_SIG_LOGIC_Pos = 0x0
	// Bit mask of SIG_LOGIC field.
	LCDIF_PIGEON_6_2_SIG_LOGIC_Msk = 0xf
	// No logic operation
	LCDIF_PIGEON_6_2_SIG_LOGIC_DIS = 0x0
	// sigout = sig_another AND this_sig
	LCDIF_PIGEON_6_2_SIG_LOGIC_AND = 0x1
	// sigout = sig_another OR this_sig
	LCDIF_PIGEON_6_2_SIG_LOGIC_OR = 0x2
	// mask = sig_another AND other_masks
	LCDIF_PIGEON_6_2_SIG_LOGIC_MASK = 0x3
	// Position of SIG_ANOTHER field.
	LCDIF_PIGEON_6_2_SIG_ANOTHER_Pos = 0x4
	// Bit mask of SIG_ANOTHER field.
	LCDIF_PIGEON_6_2_SIG_ANOTHER_Msk = 0x1f0
	// Keep active until mask off
	LCDIF_PIGEON_6_2_SIG_ANOTHER_CLEAR_USING_MASK = 0x0

	// PIGEON_7_0: Panel Interface Signal Generator Register
	// Position of EN field.
	LCDIF_PIGEON_7_0_EN_Pos = 0x0
	// Bit mask of EN field.
	LCDIF_PIGEON_7_0_EN_Msk = 0x1
	// Bit EN.
	LCDIF_PIGEON_7_0_EN = 0x1
	// Position of POL field.
	LCDIF_PIGEON_7_0_POL_Pos = 0x1
	// Bit mask of POL field.
	LCDIF_PIGEON_7_0_POL_Msk = 0x2
	// Bit POL.
	LCDIF_PIGEON_7_0_POL = 0x2
	// Normal Signal (Active high)
	LCDIF_PIGEON_7_0_POL_ACTIVE_HIGH = 0x0
	// Inverted signal (Active low)
	LCDIF_PIGEON_7_0_POL_ACTIVE_LOW = 0x1
	// Position of INC_SEL field.
	LCDIF_PIGEON_7_0_INC_SEL_Pos = 0x2
	// Bit mask of INC_SEL field.
	LCDIF_PIGEON_7_0_INC_SEL_Msk = 0xc
	// pclk
	LCDIF_PIGEON_7_0_INC_SEL_PCLK = 0x0
	// Line start pulse
	LCDIF_PIGEON_7_0_INC_SEL_LINE = 0x1
	// Frame start pulse
	LCDIF_PIGEON_7_0_INC_SEL_FRAME = 0x2
	// Use another signal as tick event
	LCDIF_PIGEON_7_0_INC_SEL_SIG_ANOTHER = 0x3
	// Position of OFFSET field.
	LCDIF_PIGEON_7_0_OFFSET_Pos = 0x4
	// Bit mask of OFFSET field.
	LCDIF_PIGEON_7_0_OFFSET_Msk = 0xf0
	// Position of MASK_CNT_SEL field.
	LCDIF_PIGEON_7_0_MASK_CNT_SEL_Pos = 0x8
	// Bit mask of MASK_CNT_SEL field.
	LCDIF_PIGEON_7_0_MASK_CNT_SEL_Msk = 0xf00
	// pclk counter within one hscan state
	LCDIF_PIGEON_7_0_MASK_CNT_SEL_HSTATE_CNT = 0x0
	// pclk cycle within one hscan state
	LCDIF_PIGEON_7_0_MASK_CNT_SEL_HSTATE_CYCLE = 0x1
	// line counter within one vscan state
	LCDIF_PIGEON_7_0_MASK_CNT_SEL_VSTATE_CNT = 0x2
	// line cycle within one vscan state
	LCDIF_PIGEON_7_0_MASK_CNT_SEL_VSTATE_CYCLE = 0x3
	// frame counter
	LCDIF_PIGEON_7_0_MASK_CNT_SEL_FRAME_CNT = 0x4
	// frame cycle
	LCDIF_PIGEON_7_0_MASK_CNT_SEL_FRAME_CYCLE = 0x5
	// horizontal counter (pclk counter within one line )
	LCDIF_PIGEON_7_0_MASK_CNT_SEL_HCNT = 0x6
	// vertical counter (line counter within one frame)
	LCDIF_PIGEON_7_0_MASK_CNT_SEL_VCNT = 0x7
	// Position of MASK_CNT field.
	LCDIF_PIGEON_7_0_MASK_CNT_Pos = 0xc
	// Bit mask of MASK_CNT field.
	LCDIF_PIGEON_7_0_MASK_CNT_Msk = 0xfff000
	// Position of STATE_MASK field.
	LCDIF_PIGEON_7_0_STATE_MASK_Pos = 0x18
	// Bit mask of STATE_MASK field.
	LCDIF_PIGEON_7_0_STATE_MASK_Msk = 0xff000000
	// FRAME SYNC
	LCDIF_PIGEON_7_0_STATE_MASK_FS = 0x1
	// FRAME BEGIN
	LCDIF_PIGEON_7_0_STATE_MASK_FB = 0x2
	// FRAME DATA
	LCDIF_PIGEON_7_0_STATE_MASK_FD = 0x4
	// FRAME END
	LCDIF_PIGEON_7_0_STATE_MASK_FE = 0x8
	// LINE SYNC
	LCDIF_PIGEON_7_0_STATE_MASK_LS = 0x10
	// LINE BEGIN
	LCDIF_PIGEON_7_0_STATE_MASK_LB = 0x20
	// LINE DATA
	LCDIF_PIGEON_7_0_STATE_MASK_LD = 0x40
	// LINE END
	LCDIF_PIGEON_7_0_STATE_MASK_LE = 0x80

	// PIGEON_7_1: Panel Interface Signal Generator Register
	// Position of SET_CNT field.
	LCDIF_PIGEON_7_1_SET_CNT_Pos = 0x0
	// Bit mask of SET_CNT field.
	LCDIF_PIGEON_7_1_SET_CNT_Msk = 0xffff
	// Start as active
	LCDIF_PIGEON_7_1_SET_CNT_START_ACTIVE = 0x0
	// Position of CLR_CNT field.
	LCDIF_PIGEON_7_1_CLR_CNT_Pos = 0x10
	// Bit mask of CLR_CNT field.
	LCDIF_PIGEON_7_1_CLR_CNT_Msk = 0xffff0000
	// Keep active until mask off
	LCDIF_PIGEON_7_1_CLR_CNT_CLEAR_USING_MASK = 0x0

	// PIGEON_7_2: Panel Interface Signal Generator Register
	// Position of SIG_LOGIC field.
	LCDIF_PIGEON_7_2_SIG_LOGIC_Pos = 0x0
	// Bit mask of SIG_LOGIC field.
	LCDIF_PIGEON_7_2_SIG_LOGIC_Msk = 0xf
	// No logic operation
	LCDIF_PIGEON_7_2_SIG_LOGIC_DIS = 0x0
	// sigout = sig_another AND this_sig
	LCDIF_PIGEON_7_2_SIG_LOGIC_AND = 0x1
	// sigout = sig_another OR this_sig
	LCDIF_PIGEON_7_2_SIG_LOGIC_OR = 0x2
	// mask = sig_another AND other_masks
	LCDIF_PIGEON_7_2_SIG_LOGIC_MASK = 0x3
	// Position of SIG_ANOTHER field.
	LCDIF_PIGEON_7_2_SIG_ANOTHER_Pos = 0x4
	// Bit mask of SIG_ANOTHER field.
	LCDIF_PIGEON_7_2_SIG_ANOTHER_Msk = 0x1f0
	// Keep active until mask off
	LCDIF_PIGEON_7_2_SIG_ANOTHER_CLEAR_USING_MASK = 0x0

	// PIGEON_8_0: Panel Interface Signal Generator Register
	// Position of EN field.
	LCDIF_PIGEON_8_0_EN_Pos = 0x0
	// Bit mask of EN field.
	LCDIF_PIGEON_8_0_EN_Msk = 0x1
	// Bit EN.
	LCDIF_PIGEON_8_0_EN = 0x1
	// Position of POL field.
	LCDIF_PIGEON_8_0_POL_Pos = 0x1
	// Bit mask of POL field.
	LCDIF_PIGEON_8_0_POL_Msk = 0x2
	// Bit POL.
	LCDIF_PIGEON_8_0_POL = 0x2
	// Normal Signal (Active high)
	LCDIF_PIGEON_8_0_POL_ACTIVE_HIGH = 0x0
	// Inverted signal (Active low)
	LCDIF_PIGEON_8_0_POL_ACTIVE_LOW = 0x1
	// Position of INC_SEL field.
	LCDIF_PIGEON_8_0_INC_SEL_Pos = 0x2
	// Bit mask of INC_SEL field.
	LCDIF_PIGEON_8_0_INC_SEL_Msk = 0xc
	// pclk
	LCDIF_PIGEON_8_0_INC_SEL_PCLK = 0x0
	// Line start pulse
	LCDIF_PIGEON_8_0_INC_SEL_LINE = 0x1
	// Frame start pulse
	LCDIF_PIGEON_8_0_INC_SEL_FRAME = 0x2
	// Use another signal as tick event
	LCDIF_PIGEON_8_0_INC_SEL_SIG_ANOTHER = 0x3
	// Position of OFFSET field.
	LCDIF_PIGEON_8_0_OFFSET_Pos = 0x4
	// Bit mask of OFFSET field.
	LCDIF_PIGEON_8_0_OFFSET_Msk = 0xf0
	// Position of MASK_CNT_SEL field.
	LCDIF_PIGEON_8_0_MASK_CNT_SEL_Pos = 0x8
	// Bit mask of MASK_CNT_SEL field.
	LCDIF_PIGEON_8_0_MASK_CNT_SEL_Msk = 0xf00
	// pclk counter within one hscan state
	LCDIF_PIGEON_8_0_MASK_CNT_SEL_HSTATE_CNT = 0x0
	// pclk cycle within one hscan state
	LCDIF_PIGEON_8_0_MASK_CNT_SEL_HSTATE_CYCLE = 0x1
	// line counter within one vscan state
	LCDIF_PIGEON_8_0_MASK_CNT_SEL_VSTATE_CNT = 0x2
	// line cycle within one vscan state
	LCDIF_PIGEON_8_0_MASK_CNT_SEL_VSTATE_CYCLE = 0x3
	// frame counter
	LCDIF_PIGEON_8_0_MASK_CNT_SEL_FRAME_CNT = 0x4
	// frame cycle
	LCDIF_PIGEON_8_0_MASK_CNT_SEL_FRAME_CYCLE = 0x5
	// horizontal counter (pclk counter within one line )
	LCDIF_PIGEON_8_0_MASK_CNT_SEL_HCNT = 0x6
	// vertical counter (line counter within one frame)
	LCDIF_PIGEON_8_0_MASK_CNT_SEL_VCNT = 0x7
	// Position of MASK_CNT field.
	LCDIF_PIGEON_8_0_MASK_CNT_Pos = 0xc
	// Bit mask of MASK_CNT field.
	LCDIF_PIGEON_8_0_MASK_CNT_Msk = 0xfff000
	// Position of STATE_MASK field.
	LCDIF_PIGEON_8_0_STATE_MASK_Pos = 0x18
	// Bit mask of STATE_MASK field.
	LCDIF_PIGEON_8_0_STATE_MASK_Msk = 0xff000000
	// FRAME SYNC
	LCDIF_PIGEON_8_0_STATE_MASK_FS = 0x1
	// FRAME BEGIN
	LCDIF_PIGEON_8_0_STATE_MASK_FB = 0x2
	// FRAME DATA
	LCDIF_PIGEON_8_0_STATE_MASK_FD = 0x4
	// FRAME END
	LCDIF_PIGEON_8_0_STATE_MASK_FE = 0x8
	// LINE SYNC
	LCDIF_PIGEON_8_0_STATE_MASK_LS = 0x10
	// LINE BEGIN
	LCDIF_PIGEON_8_0_STATE_MASK_LB = 0x20
	// LINE DATA
	LCDIF_PIGEON_8_0_STATE_MASK_LD = 0x40
	// LINE END
	LCDIF_PIGEON_8_0_STATE_MASK_LE = 0x80

	// PIGEON_8_1: Panel Interface Signal Generator Register
	// Position of SET_CNT field.
	LCDIF_PIGEON_8_1_SET_CNT_Pos = 0x0
	// Bit mask of SET_CNT field.
	LCDIF_PIGEON_8_1_SET_CNT_Msk = 0xffff
	// Start as active
	LCDIF_PIGEON_8_1_SET_CNT_START_ACTIVE = 0x0
	// Position of CLR_CNT field.
	LCDIF_PIGEON_8_1_CLR_CNT_Pos = 0x10
	// Bit mask of CLR_CNT field.
	LCDIF_PIGEON_8_1_CLR_CNT_Msk = 0xffff0000
	// Keep active until mask off
	LCDIF_PIGEON_8_1_CLR_CNT_CLEAR_USING_MASK = 0x0

	// PIGEON_8_2: Panel Interface Signal Generator Register
	// Position of SIG_LOGIC field.
	LCDIF_PIGEON_8_2_SIG_LOGIC_Pos = 0x0
	// Bit mask of SIG_LOGIC field.
	LCDIF_PIGEON_8_2_SIG_LOGIC_Msk = 0xf
	// No logic operation
	LCDIF_PIGEON_8_2_SIG_LOGIC_DIS = 0x0
	// sigout = sig_another AND this_sig
	LCDIF_PIGEON_8_2_SIG_LOGIC_AND = 0x1
	// sigout = sig_another OR this_sig
	LCDIF_PIGEON_8_2_SIG_LOGIC_OR = 0x2
	// mask = sig_another AND other_masks
	LCDIF_PIGEON_8_2_SIG_LOGIC_MASK = 0x3
	// Position of SIG_ANOTHER field.
	LCDIF_PIGEON_8_2_SIG_ANOTHER_Pos = 0x4
	// Bit mask of SIG_ANOTHER field.
	LCDIF_PIGEON_8_2_SIG_ANOTHER_Msk = 0x1f0
	// Keep active until mask off
	LCDIF_PIGEON_8_2_SIG_ANOTHER_CLEAR_USING_MASK = 0x0

	// PIGEON_9_0: Panel Interface Signal Generator Register
	// Position of EN field.
	LCDIF_PIGEON_9_0_EN_Pos = 0x0
	// Bit mask of EN field.
	LCDIF_PIGEON_9_0_EN_Msk = 0x1
	// Bit EN.
	LCDIF_PIGEON_9_0_EN = 0x1
	// Position of POL field.
	LCDIF_PIGEON_9_0_POL_Pos = 0x1
	// Bit mask of POL field.
	LCDIF_PIGEON_9_0_POL_Msk = 0x2
	// Bit POL.
	LCDIF_PIGEON_9_0_POL = 0x2
	// Normal Signal (Active high)
	LCDIF_PIGEON_9_0_POL_ACTIVE_HIGH = 0x0
	// Inverted signal (Active low)
	LCDIF_PIGEON_9_0_POL_ACTIVE_LOW = 0x1
	// Position of INC_SEL field.
	LCDIF_PIGEON_9_0_INC_SEL_Pos = 0x2
	// Bit mask of INC_SEL field.
	LCDIF_PIGEON_9_0_INC_SEL_Msk = 0xc
	// pclk
	LCDIF_PIGEON_9_0_INC_SEL_PCLK = 0x0
	// Line start pulse
	LCDIF_PIGEON_9_0_INC_SEL_LINE = 0x1
	// Frame start pulse
	LCDIF_PIGEON_9_0_INC_SEL_FRAME = 0x2
	// Use another signal as tick event
	LCDIF_PIGEON_9_0_INC_SEL_SIG_ANOTHER = 0x3
	// Position of OFFSET field.
	LCDIF_PIGEON_9_0_OFFSET_Pos = 0x4
	// Bit mask of OFFSET field.
	LCDIF_PIGEON_9_0_OFFSET_Msk = 0xf0
	// Position of MASK_CNT_SEL field.
	LCDIF_PIGEON_9_0_MASK_CNT_SEL_Pos = 0x8
	// Bit mask of MASK_CNT_SEL field.
	LCDIF_PIGEON_9_0_MASK_CNT_SEL_Msk = 0xf00
	// pclk counter within one hscan state
	LCDIF_PIGEON_9_0_MASK_CNT_SEL_HSTATE_CNT = 0x0
	// pclk cycle within one hscan state
	LCDIF_PIGEON_9_0_MASK_CNT_SEL_HSTATE_CYCLE = 0x1
	// line counter within one vscan state
	LCDIF_PIGEON_9_0_MASK_CNT_SEL_VSTATE_CNT = 0x2
	// line cycle within one vscan state
	LCDIF_PIGEON_9_0_MASK_CNT_SEL_VSTATE_CYCLE = 0x3
	// frame counter
	LCDIF_PIGEON_9_0_MASK_CNT_SEL_FRAME_CNT = 0x4
	// frame cycle
	LCDIF_PIGEON_9_0_MASK_CNT_SEL_FRAME_CYCLE = 0x5
	// horizontal counter (pclk counter within one line )
	LCDIF_PIGEON_9_0_MASK_CNT_SEL_HCNT = 0x6
	// vertical counter (line counter within one frame)
	LCDIF_PIGEON_9_0_MASK_CNT_SEL_VCNT = 0x7
	// Position of MASK_CNT field.
	LCDIF_PIGEON_9_0_MASK_CNT_Pos = 0xc
	// Bit mask of MASK_CNT field.
	LCDIF_PIGEON_9_0_MASK_CNT_Msk = 0xfff000
	// Position of STATE_MASK field.
	LCDIF_PIGEON_9_0_STATE_MASK_Pos = 0x18
	// Bit mask of STATE_MASK field.
	LCDIF_PIGEON_9_0_STATE_MASK_Msk = 0xff000000
	// FRAME SYNC
	LCDIF_PIGEON_9_0_STATE_MASK_FS = 0x1
	// FRAME BEGIN
	LCDIF_PIGEON_9_0_STATE_MASK_FB = 0x2
	// FRAME DATA
	LCDIF_PIGEON_9_0_STATE_MASK_FD = 0x4
	// FRAME END
	LCDIF_PIGEON_9_0_STATE_MASK_FE = 0x8
	// LINE SYNC
	LCDIF_PIGEON_9_0_STATE_MASK_LS = 0x10
	// LINE BEGIN
	LCDIF_PIGEON_9_0_STATE_MASK_LB = 0x20
	// LINE DATA
	LCDIF_PIGEON_9_0_STATE_MASK_LD = 0x40
	// LINE END
	LCDIF_PIGEON_9_0_STATE_MASK_LE = 0x80

	// PIGEON_9_1: Panel Interface Signal Generator Register
	// Position of SET_CNT field.
	LCDIF_PIGEON_9_1_SET_CNT_Pos = 0x0
	// Bit mask of SET_CNT field.
	LCDIF_PIGEON_9_1_SET_CNT_Msk = 0xffff
	// Start as active
	LCDIF_PIGEON_9_1_SET_CNT_START_ACTIVE = 0x0
	// Position of CLR_CNT field.
	LCDIF_PIGEON_9_1_CLR_CNT_Pos = 0x10
	// Bit mask of CLR_CNT field.
	LCDIF_PIGEON_9_1_CLR_CNT_Msk = 0xffff0000
	// Keep active until mask off
	LCDIF_PIGEON_9_1_CLR_CNT_CLEAR_USING_MASK = 0x0

	// PIGEON_9_2: Panel Interface Signal Generator Register
	// Position of SIG_LOGIC field.
	LCDIF_PIGEON_9_2_SIG_LOGIC_Pos = 0x0
	// Bit mask of SIG_LOGIC field.
	LCDIF_PIGEON_9_2_SIG_LOGIC_Msk = 0xf
	// No logic operation
	LCDIF_PIGEON_9_2_SIG_LOGIC_DIS = 0x0
	// sigout = sig_another AND this_sig
	LCDIF_PIGEON_9_2_SIG_LOGIC_AND = 0x1
	// sigout = sig_another OR this_sig
	LCDIF_PIGEON_9_2_SIG_LOGIC_OR = 0x2
	// mask = sig_another AND other_masks
	LCDIF_PIGEON_9_2_SIG_LOGIC_MASK = 0x3
	// Position of SIG_ANOTHER field.
	LCDIF_PIGEON_9_2_SIG_ANOTHER_Pos = 0x4
	// Bit mask of SIG_ANOTHER field.
	LCDIF_PIGEON_9_2_SIG_ANOTHER_Msk = 0x1f0
	// Keep active until mask off
	LCDIF_PIGEON_9_2_SIG_ANOTHER_CLEAR_USING_MASK = 0x0

	// PIGEON_10_0: Panel Interface Signal Generator Register
	// Position of EN field.
	LCDIF_PIGEON_10_0_EN_Pos = 0x0
	// Bit mask of EN field.
	LCDIF_PIGEON_10_0_EN_Msk = 0x1
	// Bit EN.
	LCDIF_PIGEON_10_0_EN = 0x1
	// Position of POL field.
	LCDIF_PIGEON_10_0_POL_Pos = 0x1
	// Bit mask of POL field.
	LCDIF_PIGEON_10_0_POL_Msk = 0x2
	// Bit POL.
	LCDIF_PIGEON_10_0_POL = 0x2
	// Normal Signal (Active high)
	LCDIF_PIGEON_10_0_POL_ACTIVE_HIGH = 0x0
	// Inverted signal (Active low)
	LCDIF_PIGEON_10_0_POL_ACTIVE_LOW = 0x1
	// Position of INC_SEL field.
	LCDIF_PIGEON_10_0_INC_SEL_Pos = 0x2
	// Bit mask of INC_SEL field.
	LCDIF_PIGEON_10_0_INC_SEL_Msk = 0xc
	// pclk
	LCDIF_PIGEON_10_0_INC_SEL_PCLK = 0x0
	// Line start pulse
	LCDIF_PIGEON_10_0_INC_SEL_LINE = 0x1
	// Frame start pulse
	LCDIF_PIGEON_10_0_INC_SEL_FRAME = 0x2
	// Use another signal as tick event
	LCDIF_PIGEON_10_0_INC_SEL_SIG_ANOTHER = 0x3
	// Position of OFFSET field.
	LCDIF_PIGEON_10_0_OFFSET_Pos = 0x4
	// Bit mask of OFFSET field.
	LCDIF_PIGEON_10_0_OFFSET_Msk = 0xf0
	// Position of MASK_CNT_SEL field.
	LCDIF_PIGEON_10_0_MASK_CNT_SEL_Pos = 0x8
	// Bit mask of MASK_CNT_SEL field.
	LCDIF_PIGEON_10_0_MASK_CNT_SEL_Msk = 0xf00
	// pclk counter within one hscan state
	LCDIF_PIGEON_10_0_MASK_CNT_SEL_HSTATE_CNT = 0x0
	// pclk cycle within one hscan state
	LCDIF_PIGEON_10_0_MASK_CNT_SEL_HSTATE_CYCLE = 0x1
	// line counter within one vscan state
	LCDIF_PIGEON_10_0_MASK_CNT_SEL_VSTATE_CNT = 0x2
	// line cycle within one vscan state
	LCDIF_PIGEON_10_0_MASK_CNT_SEL_VSTATE_CYCLE = 0x3
	// frame counter
	LCDIF_PIGEON_10_0_MASK_CNT_SEL_FRAME_CNT = 0x4
	// frame cycle
	LCDIF_PIGEON_10_0_MASK_CNT_SEL_FRAME_CYCLE = 0x5
	// horizontal counter (pclk counter within one line )
	LCDIF_PIGEON_10_0_MASK_CNT_SEL_HCNT = 0x6
	// vertical counter (line counter within one frame)
	LCDIF_PIGEON_10_0_MASK_CNT_SEL_VCNT = 0x7
	// Position of MASK_CNT field.
	LCDIF_PIGEON_10_0_MASK_CNT_Pos = 0xc
	// Bit mask of MASK_CNT field.
	LCDIF_PIGEON_10_0_MASK_CNT_Msk = 0xfff000
	// Position of STATE_MASK field.
	LCDIF_PIGEON_10_0_STATE_MASK_Pos = 0x18
	// Bit mask of STATE_MASK field.
	LCDIF_PIGEON_10_0_STATE_MASK_Msk = 0xff000000
	// FRAME SYNC
	LCDIF_PIGEON_10_0_STATE_MASK_FS = 0x1
	// FRAME BEGIN
	LCDIF_PIGEON_10_0_STATE_MASK_FB = 0x2
	// FRAME DATA
	LCDIF_PIGEON_10_0_STATE_MASK_FD = 0x4
	// FRAME END
	LCDIF_PIGEON_10_0_STATE_MASK_FE = 0x8
	// LINE SYNC
	LCDIF_PIGEON_10_0_STATE_MASK_LS = 0x10
	// LINE BEGIN
	LCDIF_PIGEON_10_0_STATE_MASK_LB = 0x20
	// LINE DATA
	LCDIF_PIGEON_10_0_STATE_MASK_LD = 0x40
	// LINE END
	LCDIF_PIGEON_10_0_STATE_MASK_LE = 0x80

	// PIGEON_10_1: Panel Interface Signal Generator Register
	// Position of SET_CNT field.
	LCDIF_PIGEON_10_1_SET_CNT_Pos = 0x0
	// Bit mask of SET_CNT field.
	LCDIF_PIGEON_10_1_SET_CNT_Msk = 0xffff
	// Start as active
	LCDIF_PIGEON_10_1_SET_CNT_START_ACTIVE = 0x0
	// Position of CLR_CNT field.
	LCDIF_PIGEON_10_1_CLR_CNT_Pos = 0x10
	// Bit mask of CLR_CNT field.
	LCDIF_PIGEON_10_1_CLR_CNT_Msk = 0xffff0000
	// Keep active until mask off
	LCDIF_PIGEON_10_1_CLR_CNT_CLEAR_USING_MASK = 0x0

	// PIGEON_10_2: Panel Interface Signal Generator Register
	// Position of SIG_LOGIC field.
	LCDIF_PIGEON_10_2_SIG_LOGIC_Pos = 0x0
	// Bit mask of SIG_LOGIC field.
	LCDIF_PIGEON_10_2_SIG_LOGIC_Msk = 0xf
	// No logic operation
	LCDIF_PIGEON_10_2_SIG_LOGIC_DIS = 0x0
	// sigout = sig_another AND this_sig
	LCDIF_PIGEON_10_2_SIG_LOGIC_AND = 0x1
	// sigout = sig_another OR this_sig
	LCDIF_PIGEON_10_2_SIG_LOGIC_OR = 0x2
	// mask = sig_another AND other_masks
	LCDIF_PIGEON_10_2_SIG_LOGIC_MASK = 0x3
	// Position of SIG_ANOTHER field.
	LCDIF_PIGEON_10_2_SIG_ANOTHER_Pos = 0x4
	// Bit mask of SIG_ANOTHER field.
	LCDIF_PIGEON_10_2_SIG_ANOTHER_Msk = 0x1f0
	// Keep active until mask off
	LCDIF_PIGEON_10_2_SIG_ANOTHER_CLEAR_USING_MASK = 0x0

	// PIGEON_11_0: Panel Interface Signal Generator Register
	// Position of EN field.
	LCDIF_PIGEON_11_0_EN_Pos = 0x0
	// Bit mask of EN field.
	LCDIF_PIGEON_11_0_EN_Msk = 0x1
	// Bit EN.
	LCDIF_PIGEON_11_0_EN = 0x1
	// Position of POL field.
	LCDIF_PIGEON_11_0_POL_Pos = 0x1
	// Bit mask of POL field.
	LCDIF_PIGEON_11_0_POL_Msk = 0x2
	// Bit POL.
	LCDIF_PIGEON_11_0_POL = 0x2
	// Normal Signal (Active high)
	LCDIF_PIGEON_11_0_POL_ACTIVE_HIGH = 0x0
	// Inverted signal (Active low)
	LCDIF_PIGEON_11_0_POL_ACTIVE_LOW = 0x1
	// Position of INC_SEL field.
	LCDIF_PIGEON_11_0_INC_SEL_Pos = 0x2
	// Bit mask of INC_SEL field.
	LCDIF_PIGEON_11_0_INC_SEL_Msk = 0xc
	// pclk
	LCDIF_PIGEON_11_0_INC_SEL_PCLK = 0x0
	// Line start pulse
	LCDIF_PIGEON_11_0_INC_SEL_LINE = 0x1
	// Frame start pulse
	LCDIF_PIGEON_11_0_INC_SEL_FRAME = 0x2
	// Use another signal as tick event
	LCDIF_PIGEON_11_0_INC_SEL_SIG_ANOTHER = 0x3
	// Position of OFFSET field.
	LCDIF_PIGEON_11_0_OFFSET_Pos = 0x4
	// Bit mask of OFFSET field.
	LCDIF_PIGEON_11_0_OFFSET_Msk = 0xf0
	// Position of MASK_CNT_SEL field.
	LCDIF_PIGEON_11_0_MASK_CNT_SEL_Pos = 0x8
	// Bit mask of MASK_CNT_SEL field.
	LCDIF_PIGEON_11_0_MASK_CNT_SEL_Msk = 0xf00
	// pclk counter within one hscan state
	LCDIF_PIGEON_11_0_MASK_CNT_SEL_HSTATE_CNT = 0x0
	// pclk cycle within one hscan state
	LCDIF_PIGEON_11_0_MASK_CNT_SEL_HSTATE_CYCLE = 0x1
	// line counter within one vscan state
	LCDIF_PIGEON_11_0_MASK_CNT_SEL_VSTATE_CNT = 0x2
	// line cycle within one vscan state
	LCDIF_PIGEON_11_0_MASK_CNT_SEL_VSTATE_CYCLE = 0x3
	// frame counter
	LCDIF_PIGEON_11_0_MASK_CNT_SEL_FRAME_CNT = 0x4
	// frame cycle
	LCDIF_PIGEON_11_0_MASK_CNT_SEL_FRAME_CYCLE = 0x5
	// horizontal counter (pclk counter within one line )
	LCDIF_PIGEON_11_0_MASK_CNT_SEL_HCNT = 0x6
	// vertical counter (line counter within one frame)
	LCDIF_PIGEON_11_0_MASK_CNT_SEL_VCNT = 0x7
	// Position of MASK_CNT field.
	LCDIF_PIGEON_11_0_MASK_CNT_Pos = 0xc
	// Bit mask of MASK_CNT field.
	LCDIF_PIGEON_11_0_MASK_CNT_Msk = 0xfff000
	// Position of STATE_MASK field.
	LCDIF_PIGEON_11_0_STATE_MASK_Pos = 0x18
	// Bit mask of STATE_MASK field.
	LCDIF_PIGEON_11_0_STATE_MASK_Msk = 0xff000000
	// FRAME SYNC
	LCDIF_PIGEON_11_0_STATE_MASK_FS = 0x1
	// FRAME BEGIN
	LCDIF_PIGEON_11_0_STATE_MASK_FB = 0x2
	// FRAME DATA
	LCDIF_PIGEON_11_0_STATE_MASK_FD = 0x4
	// FRAME END
	LCDIF_PIGEON_11_0_STATE_MASK_FE = 0x8
	// LINE SYNC
	LCDIF_PIGEON_11_0_STATE_MASK_LS = 0x10
	// LINE BEGIN
	LCDIF_PIGEON_11_0_STATE_MASK_LB = 0x20
	// LINE DATA
	LCDIF_PIGEON_11_0_STATE_MASK_LD = 0x40
	// LINE END
	LCDIF_PIGEON_11_0_STATE_MASK_LE = 0x80

	// PIGEON_11_1: Panel Interface Signal Generator Register
	// Position of SET_CNT field.
	LCDIF_PIGEON_11_1_SET_CNT_Pos = 0x0
	// Bit mask of SET_CNT field.
	LCDIF_PIGEON_11_1_SET_CNT_Msk = 0xffff
	// Start as active
	LCDIF_PIGEON_11_1_SET_CNT_START_ACTIVE = 0x0
	// Position of CLR_CNT field.
	LCDIF_PIGEON_11_1_CLR_CNT_Pos = 0x10
	// Bit mask of CLR_CNT field.
	LCDIF_PIGEON_11_1_CLR_CNT_Msk = 0xffff0000
	// Keep active until mask off
	LCDIF_PIGEON_11_1_CLR_CNT_CLEAR_USING_MASK = 0x0

	// PIGEON_11_2: Panel Interface Signal Generator Register
	// Position of SIG_LOGIC field.
	LCDIF_PIGEON_11_2_SIG_LOGIC_Pos = 0x0
	// Bit mask of SIG_LOGIC field.
	LCDIF_PIGEON_11_2_SIG_LOGIC_Msk = 0xf
	// No logic operation
	LCDIF_PIGEON_11_2_SIG_LOGIC_DIS = 0x0
	// sigout = sig_another AND this_sig
	LCDIF_PIGEON_11_2_SIG_LOGIC_AND = 0x1
	// sigout = sig_another OR this_sig
	LCDIF_PIGEON_11_2_SIG_LOGIC_OR = 0x2
	// mask = sig_another AND other_masks
	LCDIF_PIGEON_11_2_SIG_LOGIC_MASK = 0x3
	// Position of SIG_ANOTHER field.
	LCDIF_PIGEON_11_2_SIG_ANOTHER_Pos = 0x4
	// Bit mask of SIG_ANOTHER field.
	LCDIF_PIGEON_11_2_SIG_ANOTHER_Msk = 0x1f0
	// Keep active until mask off
	LCDIF_PIGEON_11_2_SIG_ANOTHER_CLEAR_USING_MASK = 0x0

	// LUT_CTRL: Lookup Table Data Register.
	// Position of LUT_BYPASS field.
	LCDIF_LUT_CTRL_LUT_BYPASS_Pos = 0x0
	// Bit mask of LUT_BYPASS field.
	LCDIF_LUT_CTRL_LUT_BYPASS_Msk = 0x1
	// Bit LUT_BYPASS.
	LCDIF_LUT_CTRL_LUT_BYPASS = 0x1

	// LUT0_ADDR: Lookup Table Control Register.
	// Position of ADDR field.
	LCDIF_LUT0_ADDR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	LCDIF_LUT0_ADDR_ADDR_Msk = 0xff

	// LUT0_DATA: Lookup Table Data Register.
	// Position of DATA field.
	LCDIF_LUT0_DATA_DATA_Pos = 0x0
	// Bit mask of DATA field.
	LCDIF_LUT0_DATA_DATA_Msk = 0xffffffff

	// LUT1_ADDR: Lookup Table Control Register.
	// Position of ADDR field.
	LCDIF_LUT1_ADDR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	LCDIF_LUT1_ADDR_ADDR_Msk = 0xff

	// LUT1_DATA: Lookup Table Data Register.
	// Position of DATA field.
	LCDIF_LUT1_DATA_DATA_Pos = 0x0
	// Bit mask of DATA field.
	LCDIF_LUT1_DATA_DATA_Msk = 0xffffffff
)

// Bitfields for CSI: CSI
const (
	// CSICR1: CSI Control Register 1
	// Position of PIXEL_BIT field.
	CSI_CSICR1_PIXEL_BIT_Pos = 0x0
	// Bit mask of PIXEL_BIT field.
	CSI_CSICR1_PIXEL_BIT_Msk = 0x1
	// Bit PIXEL_BIT.
	CSI_CSICR1_PIXEL_BIT = 0x1
	// 8-bit data for each pixel
	CSI_CSICR1_PIXEL_BIT_PIXEL_BIT_0 = 0x0
	// 10-bit data for each pixel
	CSI_CSICR1_PIXEL_BIT_PIXEL_BIT_1 = 0x1
	// Position of REDGE field.
	CSI_CSICR1_REDGE_Pos = 0x1
	// Bit mask of REDGE field.
	CSI_CSICR1_REDGE_Msk = 0x2
	// Bit REDGE.
	CSI_CSICR1_REDGE = 0x2
	// Pixel data is latched at the falling edge of CSI_PIXCLK
	CSI_CSICR1_REDGE_REDGE_0 = 0x0
	// Pixel data is latched at the rising edge of CSI_PIXCLK
	CSI_CSICR1_REDGE_REDGE_1 = 0x1
	// Position of INV_PCLK field.
	CSI_CSICR1_INV_PCLK_Pos = 0x2
	// Bit mask of INV_PCLK field.
	CSI_CSICR1_INV_PCLK_Msk = 0x4
	// Bit INV_PCLK.
	CSI_CSICR1_INV_PCLK = 0x4
	// CSI_PIXCLK is directly applied to internal circuitry
	CSI_CSICR1_INV_PCLK_INV_PCLK_0 = 0x0
	// CSI_PIXCLK is inverted before applied to internal circuitry
	CSI_CSICR1_INV_PCLK_INV_PCLK_1 = 0x1
	// Position of INV_DATA field.
	CSI_CSICR1_INV_DATA_Pos = 0x3
	// Bit mask of INV_DATA field.
	CSI_CSICR1_INV_DATA_Msk = 0x8
	// Bit INV_DATA.
	CSI_CSICR1_INV_DATA = 0x8
	// CSI_D[7:0] data lines are directly applied to internal circuitry
	CSI_CSICR1_INV_DATA_INV_DATA_0 = 0x0
	// CSI_D[7:0] data lines are inverted before applied to internal circuitry
	CSI_CSICR1_INV_DATA_INV_DATA_1 = 0x1
	// Position of GCLK_MODE field.
	CSI_CSICR1_GCLK_MODE_Pos = 0x4
	// Bit mask of GCLK_MODE field.
	CSI_CSICR1_GCLK_MODE_Msk = 0x10
	// Bit GCLK_MODE.
	CSI_CSICR1_GCLK_MODE = 0x10
	// Non-gated clock mode. All incoming pixel clocks are valid. HSYNC is ignored.
	CSI_CSICR1_GCLK_MODE_GCLK_MODE_0 = 0x0
	// Gated clock mode. Pixel clock signal is valid only when HSYNC is active.
	CSI_CSICR1_GCLK_MODE_GCLK_MODE_1 = 0x1
	// Position of CLR_RXFIFO field.
	CSI_CSICR1_CLR_RXFIFO_Pos = 0x5
	// Bit mask of CLR_RXFIFO field.
	CSI_CSICR1_CLR_RXFIFO_Msk = 0x20
	// Bit CLR_RXFIFO.
	CSI_CSICR1_CLR_RXFIFO = 0x20
	// Position of CLR_STATFIFO field.
	CSI_CSICR1_CLR_STATFIFO_Pos = 0x6
	// Bit mask of CLR_STATFIFO field.
	CSI_CSICR1_CLR_STATFIFO_Msk = 0x40
	// Bit CLR_STATFIFO.
	CSI_CSICR1_CLR_STATFIFO = 0x40
	// Position of PACK_DIR field.
	CSI_CSICR1_PACK_DIR_Pos = 0x7
	// Bit mask of PACK_DIR field.
	CSI_CSICR1_PACK_DIR_Msk = 0x80
	// Bit PACK_DIR.
	CSI_CSICR1_PACK_DIR = 0x80
	// Pack from LSB first. For image data, 0x11, 0x22, 0x33, 0x44, it will appear as 0x44332211 in RX FIFO. For stat data, 0xAAAA, 0xBBBB, it will appear as 0xBBBBAAAA in STAT FIFO.
	CSI_CSICR1_PACK_DIR_PACK_DIR_0 = 0x0
	// Pack from MSB first. For image data, 0x11, 0x22, 0x33, 0x44, it will appear as 0x11223344 in RX FIFO. For stat data, 0xAAAA, 0xBBBB, it will appear as 0xAAAABBBB in STAT FIFO.
	CSI_CSICR1_PACK_DIR_PACK_DIR_1 = 0x1
	// Position of FCC field.
	CSI_CSICR1_FCC_Pos = 0x8
	// Bit mask of FCC field.
	CSI_CSICR1_FCC_Msk = 0x100
	// Bit FCC.
	CSI_CSICR1_FCC = 0x100
	// Asynchronous FIFO clear is selected.
	CSI_CSICR1_FCC_FCC_0 = 0x0
	// Synchronous FIFO clear is selected.
	CSI_CSICR1_FCC_FCC_1 = 0x1
	// Position of CCIR_EN field.
	CSI_CSICR1_CCIR_EN_Pos = 0xa
	// Bit mask of CCIR_EN field.
	CSI_CSICR1_CCIR_EN_Msk = 0x400
	// Bit CCIR_EN.
	CSI_CSICR1_CCIR_EN = 0x400
	// Traditional interface is selected. Timing interface logic is used to latch data.
	CSI_CSICR1_CCIR_EN_CCIR_EN_0 = 0x0
	// CCIR656 interface is selected.
	CSI_CSICR1_CCIR_EN_CCIR_EN_1 = 0x1
	// Position of HSYNC_POL field.
	CSI_CSICR1_HSYNC_POL_Pos = 0xb
	// Bit mask of HSYNC_POL field.
	CSI_CSICR1_HSYNC_POL_Msk = 0x800
	// Bit HSYNC_POL.
	CSI_CSICR1_HSYNC_POL = 0x800
	// HSYNC is active low
	CSI_CSICR1_HSYNC_POL_HSYNC_POL_0 = 0x0
	// HSYNC is active high
	CSI_CSICR1_HSYNC_POL_HSYNC_POL_1 = 0x1
	// Position of SOF_INTEN field.
	CSI_CSICR1_SOF_INTEN_Pos = 0x10
	// Bit mask of SOF_INTEN field.
	CSI_CSICR1_SOF_INTEN_Msk = 0x10000
	// Bit SOF_INTEN.
	CSI_CSICR1_SOF_INTEN = 0x10000
	// SOF interrupt disable
	CSI_CSICR1_SOF_INTEN_SOF_INTEN_0 = 0x0
	// SOF interrupt enable
	CSI_CSICR1_SOF_INTEN_SOF_INTEN_1 = 0x1
	// Position of SOF_POL field.
	CSI_CSICR1_SOF_POL_Pos = 0x11
	// Bit mask of SOF_POL field.
	CSI_CSICR1_SOF_POL_Msk = 0x20000
	// Bit SOF_POL.
	CSI_CSICR1_SOF_POL = 0x20000
	// SOF interrupt is generated on SOF falling edge
	CSI_CSICR1_SOF_POL_SOF_POL_0 = 0x0
	// SOF interrupt is generated on SOF rising edge
	CSI_CSICR1_SOF_POL_SOF_POL_1 = 0x1
	// Position of RXFF_INTEN field.
	CSI_CSICR1_RXFF_INTEN_Pos = 0x12
	// Bit mask of RXFF_INTEN field.
	CSI_CSICR1_RXFF_INTEN_Msk = 0x40000
	// Bit RXFF_INTEN.
	CSI_CSICR1_RXFF_INTEN = 0x40000
	// RxFIFO full interrupt disable
	CSI_CSICR1_RXFF_INTEN_RXFF_INTEN_0 = 0x0
	// RxFIFO full interrupt enable
	CSI_CSICR1_RXFF_INTEN_RXFF_INTEN_1 = 0x1
	// Position of FB1_DMA_DONE_INTEN field.
	CSI_CSICR1_FB1_DMA_DONE_INTEN_Pos = 0x13
	// Bit mask of FB1_DMA_DONE_INTEN field.
	CSI_CSICR1_FB1_DMA_DONE_INTEN_Msk = 0x80000
	// Bit FB1_DMA_DONE_INTEN.
	CSI_CSICR1_FB1_DMA_DONE_INTEN = 0x80000
	// Frame Buffer1 DMA Transfer Done interrupt disable
	CSI_CSICR1_FB1_DMA_DONE_INTEN_FB1_DMA_DONE_INTEN_0 = 0x0
	// Frame Buffer1 DMA Transfer Done interrupt enable
	CSI_CSICR1_FB1_DMA_DONE_INTEN_FB1_DMA_DONE_INTEN_1 = 0x1
	// Position of FB2_DMA_DONE_INTEN field.
	CSI_CSICR1_FB2_DMA_DONE_INTEN_Pos = 0x14
	// Bit mask of FB2_DMA_DONE_INTEN field.
	CSI_CSICR1_FB2_DMA_DONE_INTEN_Msk = 0x100000
	// Bit FB2_DMA_DONE_INTEN.
	CSI_CSICR1_FB2_DMA_DONE_INTEN = 0x100000
	// Frame Buffer2 DMA Transfer Done interrupt disable
	CSI_CSICR1_FB2_DMA_DONE_INTEN_FB2_DMA_DONE_INTEN_0 = 0x0
	// Frame Buffer2 DMA Transfer Done interrupt enable
	CSI_CSICR1_FB2_DMA_DONE_INTEN_FB2_DMA_DONE_INTEN_1 = 0x1
	// Position of STATFF_INTEN field.
	CSI_CSICR1_STATFF_INTEN_Pos = 0x15
	// Bit mask of STATFF_INTEN field.
	CSI_CSICR1_STATFF_INTEN_Msk = 0x200000
	// Bit STATFF_INTEN.
	CSI_CSICR1_STATFF_INTEN = 0x200000
	// STATFIFO full interrupt disable
	CSI_CSICR1_STATFF_INTEN_STATFF_INTEN_0 = 0x0
	// STATFIFO full interrupt enable
	CSI_CSICR1_STATFF_INTEN_STATFF_INTEN_1 = 0x1
	// Position of SFF_DMA_DONE_INTEN field.
	CSI_CSICR1_SFF_DMA_DONE_INTEN_Pos = 0x16
	// Bit mask of SFF_DMA_DONE_INTEN field.
	CSI_CSICR1_SFF_DMA_DONE_INTEN_Msk = 0x400000
	// Bit SFF_DMA_DONE_INTEN.
	CSI_CSICR1_SFF_DMA_DONE_INTEN = 0x400000
	// STATFIFO DMA Transfer Done interrupt disable
	CSI_CSICR1_SFF_DMA_DONE_INTEN_SFF_DMA_DONE_INTEN_0 = 0x0
	// STATFIFO DMA Transfer Done interrupt enable
	CSI_CSICR1_SFF_DMA_DONE_INTEN_SFF_DMA_DONE_INTEN_1 = 0x1
	// Position of RF_OR_INTEN field.
	CSI_CSICR1_RF_OR_INTEN_Pos = 0x18
	// Bit mask of RF_OR_INTEN field.
	CSI_CSICR1_RF_OR_INTEN_Msk = 0x1000000
	// Bit RF_OR_INTEN.
	CSI_CSICR1_RF_OR_INTEN = 0x1000000
	// RxFIFO overrun interrupt is disabled
	CSI_CSICR1_RF_OR_INTEN_RF_OR_INTEN_0 = 0x0
	// RxFIFO overrun interrupt is enabled
	CSI_CSICR1_RF_OR_INTEN_RF_OR_INTEN_1 = 0x1
	// Position of SF_OR_INTEN field.
	CSI_CSICR1_SF_OR_INTEN_Pos = 0x19
	// Bit mask of SF_OR_INTEN field.
	CSI_CSICR1_SF_OR_INTEN_Msk = 0x2000000
	// Bit SF_OR_INTEN.
	CSI_CSICR1_SF_OR_INTEN = 0x2000000
	// STATFIFO overrun interrupt is disabled
	CSI_CSICR1_SF_OR_INTEN_SF_OR_INTEN_0 = 0x0
	// STATFIFO overrun interrupt is enabled
	CSI_CSICR1_SF_OR_INTEN_SF_OR_INTEN_1 = 0x1
	// Position of COF_INT_EN field.
	CSI_CSICR1_COF_INT_EN_Pos = 0x1a
	// Bit mask of COF_INT_EN field.
	CSI_CSICR1_COF_INT_EN_Msk = 0x4000000
	// Bit COF_INT_EN.
	CSI_CSICR1_COF_INT_EN = 0x4000000
	// COF interrupt is disabled
	CSI_CSICR1_COF_INT_EN_COF_INT_EN_0 = 0x0
	// COF interrupt is enabled
	CSI_CSICR1_COF_INT_EN_COF_INT_EN_1 = 0x1
	// Position of CCIR_MODE field.
	CSI_CSICR1_CCIR_MODE_Pos = 0x1b
	// Bit mask of CCIR_MODE field.
	CSI_CSICR1_CCIR_MODE_Msk = 0x8000000
	// Bit CCIR_MODE.
	CSI_CSICR1_CCIR_MODE = 0x8000000
	// Progressive mode is selected
	CSI_CSICR1_CCIR_MODE_CCIR_MODE_0 = 0x0
	// Interlace mode is selected
	CSI_CSICR1_CCIR_MODE_CCIR_MODE_1 = 0x1
	// Position of PrP_IF_EN field.
	CSI_CSICR1_PrP_IF_EN_Pos = 0x1c
	// Bit mask of PrP_IF_EN field.
	CSI_CSICR1_PrP_IF_EN_Msk = 0x10000000
	// Bit PrP_IF_EN.
	CSI_CSICR1_PrP_IF_EN = 0x10000000
	// CSI to PrP bus is disabled
	CSI_CSICR1_PrP_IF_EN_PrP_IF_EN_0 = 0x0
	// CSI to PrP bus is enabled
	CSI_CSICR1_PrP_IF_EN_PrP_IF_EN_1 = 0x1
	// Position of EOF_INT_EN field.
	CSI_CSICR1_EOF_INT_EN_Pos = 0x1d
	// Bit mask of EOF_INT_EN field.
	CSI_CSICR1_EOF_INT_EN_Msk = 0x20000000
	// Bit EOF_INT_EN.
	CSI_CSICR1_EOF_INT_EN = 0x20000000
	// EOF interrupt is disabled.
	CSI_CSICR1_EOF_INT_EN_EOF_INT_EN_0 = 0x0
	// EOF interrupt is generated when RX count value is reached.
	CSI_CSICR1_EOF_INT_EN_EOF_INT_EN_1 = 0x1
	// Position of EXT_VSYNC field.
	CSI_CSICR1_EXT_VSYNC_Pos = 0x1e
	// Bit mask of EXT_VSYNC field.
	CSI_CSICR1_EXT_VSYNC_Msk = 0x40000000
	// Bit EXT_VSYNC.
	CSI_CSICR1_EXT_VSYNC = 0x40000000
	// Internal VSYNC mode
	CSI_CSICR1_EXT_VSYNC_EXT_VSYNC_0 = 0x0
	// External VSYNC mode
	CSI_CSICR1_EXT_VSYNC_EXT_VSYNC_1 = 0x1
	// Position of SWAP16_EN field.
	CSI_CSICR1_SWAP16_EN_Pos = 0x1f
	// Bit mask of SWAP16_EN field.
	CSI_CSICR1_SWAP16_EN_Msk = 0x80000000
	// Bit SWAP16_EN.
	CSI_CSICR1_SWAP16_EN = 0x80000000
	// Disable swapping
	CSI_CSICR1_SWAP16_EN_SWAP16_EN_0 = 0x0
	// Enable swapping
	CSI_CSICR1_SWAP16_EN_SWAP16_EN_1 = 0x1

	// CSICR2: CSI Control Register 2
	// Position of HSC field.
	CSI_CSICR2_HSC_Pos = 0x0
	// Bit mask of HSC field.
	CSI_CSICR2_HSC_Msk = 0xff
	// Position of VSC field.
	CSI_CSICR2_VSC_Pos = 0x8
	// Bit mask of VSC field.
	CSI_CSICR2_VSC_Msk = 0xff00
	// Position of LVRM field.
	CSI_CSICR2_LVRM_Pos = 0x10
	// Bit mask of LVRM field.
	CSI_CSICR2_LVRM_Msk = 0x70000
	// 512 x 384
	CSI_CSICR2_LVRM_LVRM_0 = 0x0
	// 448 x 336
	CSI_CSICR2_LVRM_LVRM_1 = 0x1
	// 384 x 288
	CSI_CSICR2_LVRM_LVRM_2 = 0x2
	// 384 x 256
	CSI_CSICR2_LVRM_LVRM_3 = 0x3
	// 320 x 240
	CSI_CSICR2_LVRM_LVRM_4 = 0x4
	// 288 x 216
	CSI_CSICR2_LVRM_LVRM_5 = 0x5
	// 400 x 300
	CSI_CSICR2_LVRM_LVRM_6 = 0x6
	// Position of BTS field.
	CSI_CSICR2_BTS_Pos = 0x13
	// Bit mask of BTS field.
	CSI_CSICR2_BTS_Msk = 0x180000
	// GR
	CSI_CSICR2_BTS_BTS_0 = 0x0
	// RG
	CSI_CSICR2_BTS_BTS_1 = 0x1
	// BG
	CSI_CSICR2_BTS_BTS_2 = 0x2
	// GB
	CSI_CSICR2_BTS_BTS_3 = 0x3
	// Position of SCE field.
	CSI_CSICR2_SCE_Pos = 0x17
	// Bit mask of SCE field.
	CSI_CSICR2_SCE_Msk = 0x800000
	// Bit SCE.
	CSI_CSICR2_SCE = 0x800000
	// Skip count disable
	CSI_CSICR2_SCE_SCE_0 = 0x0
	// Skip count enable
	CSI_CSICR2_SCE_SCE_1 = 0x1
	// Position of AFS field.
	CSI_CSICR2_AFS_Pos = 0x18
	// Bit mask of AFS field.
	CSI_CSICR2_AFS_Msk = 0x3000000
	// Abs Diff on consecutive green pixels
	CSI_CSICR2_AFS_AFS_0 = 0x0
	// Abs Diff on every third green pixels
	CSI_CSICR2_AFS_AFS_1 = 0x1
	// Abs Diff on every four green pixels
	CSI_CSICR2_AFS_AFS_2 = 0x2
	// Position of DRM field.
	CSI_CSICR2_DRM_Pos = 0x1a
	// Bit mask of DRM field.
	CSI_CSICR2_DRM_Msk = 0x4000000
	// Bit DRM.
	CSI_CSICR2_DRM = 0x4000000
	// Stats grid of 8 x 6
	CSI_CSICR2_DRM_DRM_0 = 0x0
	// Stats grid of 8 x 12
	CSI_CSICR2_DRM_DRM_1 = 0x1
	// Position of DMA_BURST_TYPE_SFF field.
	CSI_CSICR2_DMA_BURST_TYPE_SFF_Pos = 0x1c
	// Bit mask of DMA_BURST_TYPE_SFF field.
	CSI_CSICR2_DMA_BURST_TYPE_SFF_Msk = 0x30000000
	// INCR8
	CSI_CSICR2_DMA_BURST_TYPE_SFF_DMA_BURST_TYPE_SFF_0 = 0x0
	// INCR4
	CSI_CSICR2_DMA_BURST_TYPE_SFF_DMA_BURST_TYPE_SFF_1 = 0x1
	// INCR16
	CSI_CSICR2_DMA_BURST_TYPE_SFF_DMA_BURST_TYPE_SFF_3 = 0x3
	// Position of DMA_BURST_TYPE_RFF field.
	CSI_CSICR2_DMA_BURST_TYPE_RFF_Pos = 0x1e
	// Bit mask of DMA_BURST_TYPE_RFF field.
	CSI_CSICR2_DMA_BURST_TYPE_RFF_Msk = 0xc0000000
	// INCR8
	CSI_CSICR2_DMA_BURST_TYPE_RFF_DMA_BURST_TYPE_RFF_0 = 0x0
	// INCR4
	CSI_CSICR2_DMA_BURST_TYPE_RFF_DMA_BURST_TYPE_RFF_1 = 0x1
	// INCR16
	CSI_CSICR2_DMA_BURST_TYPE_RFF_DMA_BURST_TYPE_RFF_3 = 0x3

	// CSICR3: CSI Control Register 3
	// Position of ECC_AUTO_EN field.
	CSI_CSICR3_ECC_AUTO_EN_Pos = 0x0
	// Bit mask of ECC_AUTO_EN field.
	CSI_CSICR3_ECC_AUTO_EN_Msk = 0x1
	// Bit ECC_AUTO_EN.
	CSI_CSICR3_ECC_AUTO_EN = 0x1
	// Auto Error correction is disabled.
	CSI_CSICR3_ECC_AUTO_EN_ECC_AUTO_EN_0 = 0x0
	// Auto Error correction is enabled.
	CSI_CSICR3_ECC_AUTO_EN_ECC_AUTO_EN_1 = 0x1
	// Position of ECC_INT_EN field.
	CSI_CSICR3_ECC_INT_EN_Pos = 0x1
	// Bit mask of ECC_INT_EN field.
	CSI_CSICR3_ECC_INT_EN_Msk = 0x2
	// Bit ECC_INT_EN.
	CSI_CSICR3_ECC_INT_EN = 0x2
	// No interrupt is generated when error is detected. Only the status bit ECC_INT is set.
	CSI_CSICR3_ECC_INT_EN_ECC_INT_EN_0 = 0x0
	// Interrupt is generated when error is detected.
	CSI_CSICR3_ECC_INT_EN_ECC_INT_EN_1 = 0x1
	// Position of ZERO_PACK_EN field.
	CSI_CSICR3_ZERO_PACK_EN_Pos = 0x2
	// Bit mask of ZERO_PACK_EN field.
	CSI_CSICR3_ZERO_PACK_EN_Msk = 0x4
	// Bit ZERO_PACK_EN.
	CSI_CSICR3_ZERO_PACK_EN = 0x4
	// Zero packing disabled
	CSI_CSICR3_ZERO_PACK_EN_ZERO_PACK_EN_0 = 0x0
	// Zero packing enabled
	CSI_CSICR3_ZERO_PACK_EN_ZERO_PACK_EN_1 = 0x1
	// Position of TWO_8BIT_SENSOR field.
	CSI_CSICR3_TWO_8BIT_SENSOR_Pos = 0x3
	// Bit mask of TWO_8BIT_SENSOR field.
	CSI_CSICR3_TWO_8BIT_SENSOR_Msk = 0x8
	// Bit TWO_8BIT_SENSOR.
	CSI_CSICR3_TWO_8BIT_SENSOR = 0x8
	// Only one sensor is connected.
	CSI_CSICR3_TWO_8BIT_SENSOR_TWO_8BIT_SENSOR_0 = 0x0
	// Two 8-bit sensors are connected or one 16-bit sensor is connected.
	CSI_CSICR3_TWO_8BIT_SENSOR_TWO_8BIT_SENSOR_1 = 0x1
	// Position of RxFF_LEVEL field.
	CSI_CSICR3_RxFF_LEVEL_Pos = 0x4
	// Bit mask of RxFF_LEVEL field.
	CSI_CSICR3_RxFF_LEVEL_Msk = 0x70
	// 4 Double words
	CSI_CSICR3_RxFF_LEVEL_RxFF_LEVEL_0 = 0x0
	// 8 Double words
	CSI_CSICR3_RxFF_LEVEL_RxFF_LEVEL_1 = 0x1
	// 16 Double words
	CSI_CSICR3_RxFF_LEVEL_RxFF_LEVEL_2 = 0x2
	// 24 Double words
	CSI_CSICR3_RxFF_LEVEL_RxFF_LEVEL_3 = 0x3
	// 32 Double words
	CSI_CSICR3_RxFF_LEVEL_RxFF_LEVEL_4 = 0x4
	// 48 Double words
	CSI_CSICR3_RxFF_LEVEL_RxFF_LEVEL_5 = 0x5
	// 64 Double words
	CSI_CSICR3_RxFF_LEVEL_RxFF_LEVEL_6 = 0x6
	// 96 Double words
	CSI_CSICR3_RxFF_LEVEL_RxFF_LEVEL_7 = 0x7
	// Position of HRESP_ERR_EN field.
	CSI_CSICR3_HRESP_ERR_EN_Pos = 0x7
	// Bit mask of HRESP_ERR_EN field.
	CSI_CSICR3_HRESP_ERR_EN_Msk = 0x80
	// Bit HRESP_ERR_EN.
	CSI_CSICR3_HRESP_ERR_EN = 0x80
	// Disable hresponse error interrupt
	CSI_CSICR3_HRESP_ERR_EN_HRESP_ERR_EN_0 = 0x0
	// Enable hresponse error interrupt
	CSI_CSICR3_HRESP_ERR_EN_HRESP_ERR_EN_1 = 0x1
	// Position of STATFF_LEVEL field.
	CSI_CSICR3_STATFF_LEVEL_Pos = 0x8
	// Bit mask of STATFF_LEVEL field.
	CSI_CSICR3_STATFF_LEVEL_Msk = 0x700
	// 4 Double words
	CSI_CSICR3_STATFF_LEVEL_STATFF_LEVEL_0 = 0x0
	// 8 Double words
	CSI_CSICR3_STATFF_LEVEL_STATFF_LEVEL_1 = 0x1
	// 12 Double words
	CSI_CSICR3_STATFF_LEVEL_STATFF_LEVEL_2 = 0x2
	// 16 Double words
	CSI_CSICR3_STATFF_LEVEL_STATFF_LEVEL_3 = 0x3
	// 24 Double words
	CSI_CSICR3_STATFF_LEVEL_STATFF_LEVEL_4 = 0x4
	// 32 Double words
	CSI_CSICR3_STATFF_LEVEL_STATFF_LEVEL_5 = 0x5
	// 48 Double words
	CSI_CSICR3_STATFF_LEVEL_STATFF_LEVEL_6 = 0x6
	// 64 Double words
	CSI_CSICR3_STATFF_LEVEL_STATFF_LEVEL_7 = 0x7
	// Position of DMA_REQ_EN_SFF field.
	CSI_CSICR3_DMA_REQ_EN_SFF_Pos = 0xb
	// Bit mask of DMA_REQ_EN_SFF field.
	CSI_CSICR3_DMA_REQ_EN_SFF_Msk = 0x800
	// Bit DMA_REQ_EN_SFF.
	CSI_CSICR3_DMA_REQ_EN_SFF = 0x800
	// Disable the dma request
	CSI_CSICR3_DMA_REQ_EN_SFF_DMA_REQ_EN_SFF_0 = 0x0
	// Enable the dma request
	CSI_CSICR3_DMA_REQ_EN_SFF_DMA_REQ_EN_SFF_1 = 0x1
	// Position of DMA_REQ_EN_RFF field.
	CSI_CSICR3_DMA_REQ_EN_RFF_Pos = 0xc
	// Bit mask of DMA_REQ_EN_RFF field.
	CSI_CSICR3_DMA_REQ_EN_RFF_Msk = 0x1000
	// Bit DMA_REQ_EN_RFF.
	CSI_CSICR3_DMA_REQ_EN_RFF = 0x1000
	// Disable the dma request
	CSI_CSICR3_DMA_REQ_EN_RFF_DMA_REQ_EN_RFF_0 = 0x0
	// Enable the dma request
	CSI_CSICR3_DMA_REQ_EN_RFF_DMA_REQ_EN_RFF_1 = 0x1
	// Position of DMA_REFLASH_SFF field.
	CSI_CSICR3_DMA_REFLASH_SFF_Pos = 0xd
	// Bit mask of DMA_REFLASH_SFF field.
	CSI_CSICR3_DMA_REFLASH_SFF_Msk = 0x2000
	// Bit DMA_REFLASH_SFF.
	CSI_CSICR3_DMA_REFLASH_SFF = 0x2000
	// No reflashing
	CSI_CSICR3_DMA_REFLASH_SFF_DMA_REFLASH_SFF_0 = 0x0
	// Reflash the embedded DMA controller
	CSI_CSICR3_DMA_REFLASH_SFF_DMA_REFLASH_SFF_1 = 0x1
	// Position of DMA_REFLASH_RFF field.
	CSI_CSICR3_DMA_REFLASH_RFF_Pos = 0xe
	// Bit mask of DMA_REFLASH_RFF field.
	CSI_CSICR3_DMA_REFLASH_RFF_Msk = 0x4000
	// Bit DMA_REFLASH_RFF.
	CSI_CSICR3_DMA_REFLASH_RFF = 0x4000
	// No reflashing
	CSI_CSICR3_DMA_REFLASH_RFF_DMA_REFLASH_RFF_0 = 0x0
	// Reflash the embedded DMA controller
	CSI_CSICR3_DMA_REFLASH_RFF_DMA_REFLASH_RFF_1 = 0x1
	// Position of FRMCNT_RST field.
	CSI_CSICR3_FRMCNT_RST_Pos = 0xf
	// Bit mask of FRMCNT_RST field.
	CSI_CSICR3_FRMCNT_RST_Msk = 0x8000
	// Bit FRMCNT_RST.
	CSI_CSICR3_FRMCNT_RST = 0x8000
	// Do not reset
	CSI_CSICR3_FRMCNT_RST_FRMCNT_RST_0 = 0x0
	// Reset frame counter immediately
	CSI_CSICR3_FRMCNT_RST_FRMCNT_RST_1 = 0x1
	// Position of FRMCNT field.
	CSI_CSICR3_FRMCNT_Pos = 0x10
	// Bit mask of FRMCNT field.
	CSI_CSICR3_FRMCNT_Msk = 0xffff0000

	// CSISTATFIFO: CSI Statistic FIFO Register
	// Position of STAT field.
	CSI_CSISTATFIFO_STAT_Pos = 0x0
	// Bit mask of STAT field.
	CSI_CSISTATFIFO_STAT_Msk = 0xffffffff

	// CSIRFIFO: CSI RX FIFO Register
	// Position of IMAGE field.
	CSI_CSIRFIFO_IMAGE_Pos = 0x0
	// Bit mask of IMAGE field.
	CSI_CSIRFIFO_IMAGE_Msk = 0xffffffff

	// CSIRXCNT: CSI RX Count Register
	// Position of RXCNT field.
	CSI_CSIRXCNT_RXCNT_Pos = 0x0
	// Bit mask of RXCNT field.
	CSI_CSIRXCNT_RXCNT_Msk = 0x3fffff

	// CSISR: CSI Status Register
	// Position of DRDY field.
	CSI_CSISR_DRDY_Pos = 0x0
	// Bit mask of DRDY field.
	CSI_CSISR_DRDY_Msk = 0x1
	// Bit DRDY.
	CSI_CSISR_DRDY = 0x1
	// No data (word) is ready
	CSI_CSISR_DRDY_DRDY_0 = 0x0
	// At least 1 datum (word) is ready in RXFIFO.
	CSI_CSISR_DRDY_DRDY_1 = 0x1
	// Position of ECC_INT field.
	CSI_CSISR_ECC_INT_Pos = 0x1
	// Bit mask of ECC_INT field.
	CSI_CSISR_ECC_INT_Msk = 0x2
	// Bit ECC_INT.
	CSI_CSISR_ECC_INT = 0x2
	// No error detected
	CSI_CSISR_ECC_INT_ECC_INT_0 = 0x0
	// Error is detected in CCIR coding
	CSI_CSISR_ECC_INT_ECC_INT_1 = 0x1
	// Position of HRESP_ERR_INT field.
	CSI_CSISR_HRESP_ERR_INT_Pos = 0x7
	// Bit mask of HRESP_ERR_INT field.
	CSI_CSISR_HRESP_ERR_INT_Msk = 0x80
	// Bit HRESP_ERR_INT.
	CSI_CSISR_HRESP_ERR_INT = 0x80
	// No hresponse error.
	CSI_CSISR_HRESP_ERR_INT_HRESP_ERR_INT_0 = 0x0
	// Hresponse error is detected.
	CSI_CSISR_HRESP_ERR_INT_HRESP_ERR_INT_1 = 0x1
	// Position of COF_INT field.
	CSI_CSISR_COF_INT_Pos = 0xd
	// Bit mask of COF_INT field.
	CSI_CSISR_COF_INT_Msk = 0x2000
	// Bit COF_INT.
	CSI_CSISR_COF_INT = 0x2000
	// Video field has no change.
	CSI_CSISR_COF_INT_COF_INT_0 = 0x0
	// Change of video field is detected.
	CSI_CSISR_COF_INT_COF_INT_1 = 0x1
	// Position of F1_INT field.
	CSI_CSISR_F1_INT_Pos = 0xe
	// Bit mask of F1_INT field.
	CSI_CSISR_F1_INT_Msk = 0x4000
	// Bit F1_INT.
	CSI_CSISR_F1_INT = 0x4000
	// Field 1 of video is not detected.
	CSI_CSISR_F1_INT_F1_INT_0 = 0x0
	// Field 1 of video is about to start.
	CSI_CSISR_F1_INT_F1_INT_1 = 0x1
	// Position of F2_INT field.
	CSI_CSISR_F2_INT_Pos = 0xf
	// Bit mask of F2_INT field.
	CSI_CSISR_F2_INT_Msk = 0x8000
	// Bit F2_INT.
	CSI_CSISR_F2_INT = 0x8000
	// Field 2 of video is not detected
	CSI_CSISR_F2_INT_F2_INT_0 = 0x0
	// Field 2 of video is about to start
	CSI_CSISR_F2_INT_F2_INT_1 = 0x1
	// Position of SOF_INT field.
	CSI_CSISR_SOF_INT_Pos = 0x10
	// Bit mask of SOF_INT field.
	CSI_CSISR_SOF_INT_Msk = 0x10000
	// Bit SOF_INT.
	CSI_CSISR_SOF_INT = 0x10000
	// SOF is not detected.
	CSI_CSISR_SOF_INT_SOF_INT_0 = 0x0
	// SOF is detected.
	CSI_CSISR_SOF_INT_SOF_INT_1 = 0x1
	// Position of EOF_INT field.
	CSI_CSISR_EOF_INT_Pos = 0x11
	// Bit mask of EOF_INT field.
	CSI_CSISR_EOF_INT_Msk = 0x20000
	// Bit EOF_INT.
	CSI_CSISR_EOF_INT = 0x20000
	// EOF is not detected.
	CSI_CSISR_EOF_INT_EOF_INT_0 = 0x0
	// EOF is detected.
	CSI_CSISR_EOF_INT_EOF_INT_1 = 0x1
	// Position of RxFF_INT field.
	CSI_CSISR_RxFF_INT_Pos = 0x12
	// Bit mask of RxFF_INT field.
	CSI_CSISR_RxFF_INT_Msk = 0x40000
	// Bit RxFF_INT.
	CSI_CSISR_RxFF_INT = 0x40000
	// RxFIFO is not full.
	CSI_CSISR_RxFF_INT_RxFF_INT_0 = 0x0
	// RxFIFO is full.
	CSI_CSISR_RxFF_INT_RxFF_INT_1 = 0x1
	// Position of DMA_TSF_DONE_FB1 field.
	CSI_CSISR_DMA_TSF_DONE_FB1_Pos = 0x13
	// Bit mask of DMA_TSF_DONE_FB1 field.
	CSI_CSISR_DMA_TSF_DONE_FB1_Msk = 0x80000
	// Bit DMA_TSF_DONE_FB1.
	CSI_CSISR_DMA_TSF_DONE_FB1 = 0x80000
	// DMA transfer is not completed.
	CSI_CSISR_DMA_TSF_DONE_FB1_DMA_TSF_DONE_FB1_0 = 0x0
	// DMA transfer is completed.
	CSI_CSISR_DMA_TSF_DONE_FB1_DMA_TSF_DONE_FB1_1 = 0x1
	// Position of DMA_TSF_DONE_FB2 field.
	CSI_CSISR_DMA_TSF_DONE_FB2_Pos = 0x14
	// Bit mask of DMA_TSF_DONE_FB2 field.
	CSI_CSISR_DMA_TSF_DONE_FB2_Msk = 0x100000
	// Bit DMA_TSF_DONE_FB2.
	CSI_CSISR_DMA_TSF_DONE_FB2 = 0x100000
	// DMA transfer is not completed.
	CSI_CSISR_DMA_TSF_DONE_FB2_DMA_TSF_DONE_FB2_0 = 0x0
	// DMA transfer is completed.
	CSI_CSISR_DMA_TSF_DONE_FB2_DMA_TSF_DONE_FB2_1 = 0x1
	// Position of STATFF_INT field.
	CSI_CSISR_STATFF_INT_Pos = 0x15
	// Bit mask of STATFF_INT field.
	CSI_CSISR_STATFF_INT_Msk = 0x200000
	// Bit STATFF_INT.
	CSI_CSISR_STATFF_INT = 0x200000
	// STATFIFO is not full.
	CSI_CSISR_STATFF_INT_STATFF_INT_0 = 0x0
	// STATFIFO is full.
	CSI_CSISR_STATFF_INT_STATFF_INT_1 = 0x1
	// Position of DMA_TSF_DONE_SFF field.
	CSI_CSISR_DMA_TSF_DONE_SFF_Pos = 0x16
	// Bit mask of DMA_TSF_DONE_SFF field.
	CSI_CSISR_DMA_TSF_DONE_SFF_Msk = 0x400000
	// Bit DMA_TSF_DONE_SFF.
	CSI_CSISR_DMA_TSF_DONE_SFF = 0x400000
	// DMA transfer is not completed.
	CSI_CSISR_DMA_TSF_DONE_SFF_DMA_TSF_DONE_SFF_0 = 0x0
	// DMA transfer is completed.
	CSI_CSISR_DMA_TSF_DONE_SFF_DMA_TSF_DONE_SFF_1 = 0x1
	// Position of RF_OR_INT field.
	CSI_CSISR_RF_OR_INT_Pos = 0x18
	// Bit mask of RF_OR_INT field.
	CSI_CSISR_RF_OR_INT_Msk = 0x1000000
	// Bit RF_OR_INT.
	CSI_CSISR_RF_OR_INT = 0x1000000
	// RXFIFO has not overflowed.
	CSI_CSISR_RF_OR_INT_RF_OR_INT_0 = 0x0
	// RXFIFO has overflowed.
	CSI_CSISR_RF_OR_INT_RF_OR_INT_1 = 0x1
	// Position of SF_OR_INT field.
	CSI_CSISR_SF_OR_INT_Pos = 0x19
	// Bit mask of SF_OR_INT field.
	CSI_CSISR_SF_OR_INT_Msk = 0x2000000
	// Bit SF_OR_INT.
	CSI_CSISR_SF_OR_INT = 0x2000000
	// STATFIFO has not overflowed.
	CSI_CSISR_SF_OR_INT_SF_OR_INT_0 = 0x0
	// STATFIFO has overflowed.
	CSI_CSISR_SF_OR_INT_SF_OR_INT_1 = 0x1
	// Position of DMA_FIELD1_DONE field.
	CSI_CSISR_DMA_FIELD1_DONE_Pos = 0x1a
	// Bit mask of DMA_FIELD1_DONE field.
	CSI_CSISR_DMA_FIELD1_DONE_Msk = 0x4000000
	// Bit DMA_FIELD1_DONE.
	CSI_CSISR_DMA_FIELD1_DONE = 0x4000000
	// Position of DMA_FIELD0_DONE field.
	CSI_CSISR_DMA_FIELD0_DONE_Pos = 0x1b
	// Bit mask of DMA_FIELD0_DONE field.
	CSI_CSISR_DMA_FIELD0_DONE_Msk = 0x8000000
	// Bit DMA_FIELD0_DONE.
	CSI_CSISR_DMA_FIELD0_DONE = 0x8000000
	// Position of BASEADDR_CHHANGE_ERROR field.
	CSI_CSISR_BASEADDR_CHHANGE_ERROR_Pos = 0x1c
	// Bit mask of BASEADDR_CHHANGE_ERROR field.
	CSI_CSISR_BASEADDR_CHHANGE_ERROR_Msk = 0x10000000
	// Bit BASEADDR_CHHANGE_ERROR.
	CSI_CSISR_BASEADDR_CHHANGE_ERROR = 0x10000000

	// CSIDMASA_STATFIFO: CSI DMA Start Address Register - for STATFIFO
	// Position of DMA_START_ADDR_SFF field.
	CSI_CSIDMASA_STATFIFO_DMA_START_ADDR_SFF_Pos = 0x2
	// Bit mask of DMA_START_ADDR_SFF field.
	CSI_CSIDMASA_STATFIFO_DMA_START_ADDR_SFF_Msk = 0xfffffffc

	// CSIDMATS_STATFIFO: CSI DMA Transfer Size Register - for STATFIFO
	// Position of DMA_TSF_SIZE_SFF field.
	CSI_CSIDMATS_STATFIFO_DMA_TSF_SIZE_SFF_Pos = 0x0
	// Bit mask of DMA_TSF_SIZE_SFF field.
	CSI_CSIDMATS_STATFIFO_DMA_TSF_SIZE_SFF_Msk = 0xffffffff

	// CSIDMASA_FB1: CSI DMA Start Address Register - for Frame Buffer1
	// Position of DMA_START_ADDR_FB1 field.
	CSI_CSIDMASA_FB1_DMA_START_ADDR_FB1_Pos = 0x2
	// Bit mask of DMA_START_ADDR_FB1 field.
	CSI_CSIDMASA_FB1_DMA_START_ADDR_FB1_Msk = 0xfffffffc

	// CSIDMASA_FB2: CSI DMA Transfer Size Register - for Frame Buffer2
	// Position of DMA_START_ADDR_FB2 field.
	CSI_CSIDMASA_FB2_DMA_START_ADDR_FB2_Pos = 0x2
	// Bit mask of DMA_START_ADDR_FB2 field.
	CSI_CSIDMASA_FB2_DMA_START_ADDR_FB2_Msk = 0xfffffffc

	// CSIFBUF_PARA: CSI Frame Buffer Parameter Register
	// Position of FBUF_STRIDE field.
	CSI_CSIFBUF_PARA_FBUF_STRIDE_Pos = 0x0
	// Bit mask of FBUF_STRIDE field.
	CSI_CSIFBUF_PARA_FBUF_STRIDE_Msk = 0xffff
	// Position of DEINTERLACE_STRIDE field.
	CSI_CSIFBUF_PARA_DEINTERLACE_STRIDE_Pos = 0x10
	// Bit mask of DEINTERLACE_STRIDE field.
	CSI_CSIFBUF_PARA_DEINTERLACE_STRIDE_Msk = 0xffff0000

	// CSIIMAG_PARA: CSI Image Parameter Register
	// Position of IMAGE_HEIGHT field.
	CSI_CSIIMAG_PARA_IMAGE_HEIGHT_Pos = 0x0
	// Bit mask of IMAGE_HEIGHT field.
	CSI_CSIIMAG_PARA_IMAGE_HEIGHT_Msk = 0xffff
	// Position of IMAGE_WIDTH field.
	CSI_CSIIMAG_PARA_IMAGE_WIDTH_Pos = 0x10
	// Bit mask of IMAGE_WIDTH field.
	CSI_CSIIMAG_PARA_IMAGE_WIDTH_Msk = 0xffff0000

	// CSICR18: CSI Control Register 18
	// Position of DEINTERLACE_EN field.
	CSI_CSICR18_DEINTERLACE_EN_Pos = 0x2
	// Bit mask of DEINTERLACE_EN field.
	CSI_CSICR18_DEINTERLACE_EN_Msk = 0x4
	// Bit DEINTERLACE_EN.
	CSI_CSICR18_DEINTERLACE_EN = 0x4
	// Deinterlace disabled
	CSI_CSICR18_DEINTERLACE_EN_DEINTERLACE_EN_0 = 0x0
	// Deinterlace enabled
	CSI_CSICR18_DEINTERLACE_EN_DEINTERLACE_EN_1 = 0x1
	// Position of PARALLEL24_EN field.
	CSI_CSICR18_PARALLEL24_EN_Pos = 0x3
	// Bit mask of PARALLEL24_EN field.
	CSI_CSICR18_PARALLEL24_EN_Msk = 0x8
	// Bit PARALLEL24_EN.
	CSI_CSICR18_PARALLEL24_EN = 0x8
	// Position of BASEADDR_SWITCH_EN field.
	CSI_CSICR18_BASEADDR_SWITCH_EN_Pos = 0x4
	// Bit mask of BASEADDR_SWITCH_EN field.
	CSI_CSICR18_BASEADDR_SWITCH_EN_Msk = 0x10
	// Bit BASEADDR_SWITCH_EN.
	CSI_CSICR18_BASEADDR_SWITCH_EN = 0x10
	// Position of BASEADDR_SWITCH_SEL field.
	CSI_CSICR18_BASEADDR_SWITCH_SEL_Pos = 0x5
	// Bit mask of BASEADDR_SWITCH_SEL field.
	CSI_CSICR18_BASEADDR_SWITCH_SEL_Msk = 0x20
	// Bit BASEADDR_SWITCH_SEL.
	CSI_CSICR18_BASEADDR_SWITCH_SEL = 0x20
	// Switching base address at the edge of the vsync
	CSI_CSICR18_BASEADDR_SWITCH_SEL_BASEADDR_SWITCH_SEL_0 = 0x0
	// Switching base address at the edge of the first data of each frame
	CSI_CSICR18_BASEADDR_SWITCH_SEL_BASEADDR_SWITCH_SEL_1 = 0x1
	// Position of FIELD0_DONE_IE field.
	CSI_CSICR18_FIELD0_DONE_IE_Pos = 0x6
	// Bit mask of FIELD0_DONE_IE field.
	CSI_CSICR18_FIELD0_DONE_IE_Msk = 0x40
	// Bit FIELD0_DONE_IE.
	CSI_CSICR18_FIELD0_DONE_IE = 0x40
	// Interrupt disabled
	CSI_CSICR18_FIELD0_DONE_IE_FIELD0_DONE_IE_0 = 0x0
	// Interrupt enabled
	CSI_CSICR18_FIELD0_DONE_IE_FIELD0_DONE_IE_1 = 0x1
	// Position of DMA_FIELD1_DONE_IE field.
	CSI_CSICR18_DMA_FIELD1_DONE_IE_Pos = 0x7
	// Bit mask of DMA_FIELD1_DONE_IE field.
	CSI_CSICR18_DMA_FIELD1_DONE_IE_Msk = 0x80
	// Bit DMA_FIELD1_DONE_IE.
	CSI_CSICR18_DMA_FIELD1_DONE_IE = 0x80
	// Interrupt disabled
	CSI_CSICR18_DMA_FIELD1_DONE_IE_DMA_FIELD1_DONE_IE_0 = 0x0
	// Interrupt enabled
	CSI_CSICR18_DMA_FIELD1_DONE_IE_DMA_FIELD1_DONE_IE_1 = 0x1
	// Position of LAST_DMA_REQ_SEL field.
	CSI_CSICR18_LAST_DMA_REQ_SEL_Pos = 0x8
	// Bit mask of LAST_DMA_REQ_SEL field.
	CSI_CSICR18_LAST_DMA_REQ_SEL_Msk = 0x100
	// Bit LAST_DMA_REQ_SEL.
	CSI_CSICR18_LAST_DMA_REQ_SEL = 0x100
	// fifo_full_level
	CSI_CSICR18_LAST_DMA_REQ_SEL_LAST_DMA_REQ_SEL_0 = 0x0
	// hburst_length
	CSI_CSICR18_LAST_DMA_REQ_SEL_LAST_DMA_REQ_SEL_1 = 0x1
	// Position of BASEADDR_CHANGE_ERROR_IE field.
	CSI_CSICR18_BASEADDR_CHANGE_ERROR_IE_Pos = 0x9
	// Bit mask of BASEADDR_CHANGE_ERROR_IE field.
	CSI_CSICR18_BASEADDR_CHANGE_ERROR_IE_Msk = 0x200
	// Bit BASEADDR_CHANGE_ERROR_IE.
	CSI_CSICR18_BASEADDR_CHANGE_ERROR_IE = 0x200
	// Position of RGB888A_FORMAT_SEL field.
	CSI_CSICR18_RGB888A_FORMAT_SEL_Pos = 0xa
	// Bit mask of RGB888A_FORMAT_SEL field.
	CSI_CSICR18_RGB888A_FORMAT_SEL_Msk = 0x400
	// Bit RGB888A_FORMAT_SEL.
	CSI_CSICR18_RGB888A_FORMAT_SEL = 0x400
	// {8'h0, data[23:0]}
	CSI_CSICR18_RGB888A_FORMAT_SEL_RGB888A_FORMAT_SEL_0 = 0x0
	// {data[23:0], 8'h0}
	CSI_CSICR18_RGB888A_FORMAT_SEL_RGB888A_FORMAT_SEL_1 = 0x1
	// Position of AHB_HPROT field.
	CSI_CSICR18_AHB_HPROT_Pos = 0xc
	// Bit mask of AHB_HPROT field.
	CSI_CSICR18_AHB_HPROT_Msk = 0xf000
	// Position of MASK_OPTION field.
	CSI_CSICR18_MASK_OPTION_Pos = 0x12
	// Bit mask of MASK_OPTION field.
	CSI_CSICR18_MASK_OPTION_Msk = 0xc0000
	// Writing to memory from first completely frame, when using this option, the CSI_ENABLE should be 1.
	CSI_CSICR18_MASK_OPTION_MASK_OPTION_0 = 0x0
	// Writing to memory when CSI_ENABLE is 1.
	CSI_CSICR18_MASK_OPTION_MASK_OPTION_1 = 0x1
	// Writing to memory from second completely frame, when using this option, the CSI_ENABLE should be 1.
	CSI_CSICR18_MASK_OPTION_MASK_OPTION_2 = 0x2
	// Writing to memory when data comes in, not matter the CSI_ENABLE is 1 or 0.
	CSI_CSICR18_MASK_OPTION_MASK_OPTION_3 = 0x3
	// Position of CSI_ENABLE field.
	CSI_CSICR18_CSI_ENABLE_Pos = 0x1f
	// Bit mask of CSI_ENABLE field.
	CSI_CSICR18_CSI_ENABLE_Msk = 0x80000000
	// Bit CSI_ENABLE.
	CSI_CSICR18_CSI_ENABLE = 0x80000000

	// CSICR19: CSI Control Register 19
	// Position of DMA_RFIFO_HIGHEST_FIFO_LEVEL field.
	CSI_CSICR19_DMA_RFIFO_HIGHEST_FIFO_LEVEL_Pos = 0x0
	// Bit mask of DMA_RFIFO_HIGHEST_FIFO_LEVEL field.
	CSI_CSICR19_DMA_RFIFO_HIGHEST_FIFO_LEVEL_Msk = 0xff
)

// Bitfields for USDHC1: uSDHC
const (
	// DS_ADDR: DMA System Address
	// Position of DS_ADDR field.
	USDHC_DS_ADDR_DS_ADDR_Pos = 0x0
	// Bit mask of DS_ADDR field.
	USDHC_DS_ADDR_DS_ADDR_Msk = 0xffffffff

	// BLK_ATT: Block Attributes
	// Position of BLKSIZE field.
	USDHC_BLK_ATT_BLKSIZE_Pos = 0x0
	// Bit mask of BLKSIZE field.
	USDHC_BLK_ATT_BLKSIZE_Msk = 0x1fff
	// No data transfer
	USDHC_BLK_ATT_BLKSIZE_BLKSIZE_0 = 0x0
	// 1 Byte
	USDHC_BLK_ATT_BLKSIZE_BLKSIZE_1 = 0x1
	// 2 Bytes
	USDHC_BLK_ATT_BLKSIZE_BLKSIZE_2 = 0x2
	// 3 Bytes
	USDHC_BLK_ATT_BLKSIZE_BLKSIZE_3 = 0x3
	// 4 Bytes
	USDHC_BLK_ATT_BLKSIZE_BLKSIZE_4 = 0x4
	// 511 Bytes
	USDHC_BLK_ATT_BLKSIZE_BLKSIZE_511 = 0x1ff
	// 512 Bytes
	USDHC_BLK_ATT_BLKSIZE_BLKSIZE_512 = 0x200
	// 2048 Bytes
	USDHC_BLK_ATT_BLKSIZE_BLKSIZE_2048 = 0x800
	// 4096 Bytes
	USDHC_BLK_ATT_BLKSIZE_BLKSIZE_4096 = 0x1000
	// Position of BLKCNT field.
	USDHC_BLK_ATT_BLKCNT_Pos = 0x10
	// Bit mask of BLKCNT field.
	USDHC_BLK_ATT_BLKCNT_Msk = 0xffff0000
	// Stop Count
	USDHC_BLK_ATT_BLKCNT_BLKCNT_0 = 0x0
	// 1 block
	USDHC_BLK_ATT_BLKCNT_BLKCNT_1 = 0x1
	// 2 blocks
	USDHC_BLK_ATT_BLKCNT_BLKCNT_2 = 0x2
	// 65535 blocks
	USDHC_BLK_ATT_BLKCNT_BLKCNT_65535 = 0xffff

	// CMD_ARG: Command Argument
	// Position of CMDARG field.
	USDHC_CMD_ARG_CMDARG_Pos = 0x0
	// Bit mask of CMDARG field.
	USDHC_CMD_ARG_CMDARG_Msk = 0xffffffff

	// CMD_XFR_TYP: Command Transfer Type
	// Position of RSPTYP field.
	USDHC_CMD_XFR_TYP_RSPTYP_Pos = 0x10
	// Bit mask of RSPTYP field.
	USDHC_CMD_XFR_TYP_RSPTYP_Msk = 0x30000
	// No Response
	USDHC_CMD_XFR_TYP_RSPTYP_RSPTYP_0 = 0x0
	// Response Length 136
	USDHC_CMD_XFR_TYP_RSPTYP_RSPTYP_1 = 0x1
	// Response Length 48
	USDHC_CMD_XFR_TYP_RSPTYP_RSPTYP_2 = 0x2
	// Response Length 48, check Busy after response
	USDHC_CMD_XFR_TYP_RSPTYP_RSPTYP_3 = 0x3
	// Position of CCCEN field.
	USDHC_CMD_XFR_TYP_CCCEN_Pos = 0x13
	// Bit mask of CCCEN field.
	USDHC_CMD_XFR_TYP_CCCEN_Msk = 0x80000
	// Bit CCCEN.
	USDHC_CMD_XFR_TYP_CCCEN = 0x80000
	// Disable
	USDHC_CMD_XFR_TYP_CCCEN_CCCEN_0 = 0x0
	// Enable
	USDHC_CMD_XFR_TYP_CCCEN_CCCEN_1 = 0x1
	// Position of CICEN field.
	USDHC_CMD_XFR_TYP_CICEN_Pos = 0x14
	// Bit mask of CICEN field.
	USDHC_CMD_XFR_TYP_CICEN_Msk = 0x100000
	// Bit CICEN.
	USDHC_CMD_XFR_TYP_CICEN = 0x100000
	// Disable
	USDHC_CMD_XFR_TYP_CICEN_CICEN_0 = 0x0
	// Enable
	USDHC_CMD_XFR_TYP_CICEN_CICEN_1 = 0x1
	// Position of DPSEL field.
	USDHC_CMD_XFR_TYP_DPSEL_Pos = 0x15
	// Bit mask of DPSEL field.
	USDHC_CMD_XFR_TYP_DPSEL_Msk = 0x200000
	// Bit DPSEL.
	USDHC_CMD_XFR_TYP_DPSEL = 0x200000
	// No Data Present
	USDHC_CMD_XFR_TYP_DPSEL_DPSEL_0 = 0x0
	// Data Present
	USDHC_CMD_XFR_TYP_DPSEL_DPSEL_1 = 0x1
	// Position of CMDTYP field.
	USDHC_CMD_XFR_TYP_CMDTYP_Pos = 0x16
	// Bit mask of CMDTYP field.
	USDHC_CMD_XFR_TYP_CMDTYP_Msk = 0xc00000
	// Normal Other commands
	USDHC_CMD_XFR_TYP_CMDTYP_CMDTYP_0 = 0x0
	// Suspend CMD52 for writing Bus Suspend in CCCR
	USDHC_CMD_XFR_TYP_CMDTYP_CMDTYP_1 = 0x1
	// Resume CMD52 for writing Function Select in CCCR
	USDHC_CMD_XFR_TYP_CMDTYP_CMDTYP_2 = 0x2
	// Abort CMD12, CMD52 for writing I/O Abort in CCCR
	USDHC_CMD_XFR_TYP_CMDTYP_CMDTYP_3 = 0x3
	// Position of CMDINX field.
	USDHC_CMD_XFR_TYP_CMDINX_Pos = 0x18
	// Bit mask of CMDINX field.
	USDHC_CMD_XFR_TYP_CMDINX_Msk = 0x3f000000

	// CMD_RSP0: Command Response0
	// Position of CMDRSP0 field.
	USDHC_CMD_RSP0_CMDRSP0_Pos = 0x0
	// Bit mask of CMDRSP0 field.
	USDHC_CMD_RSP0_CMDRSP0_Msk = 0xffffffff

	// CMD_RSP1: Command Response1
	// Position of CMDRSP1 field.
	USDHC_CMD_RSP1_CMDRSP1_Pos = 0x0
	// Bit mask of CMDRSP1 field.
	USDHC_CMD_RSP1_CMDRSP1_Msk = 0xffffffff

	// CMD_RSP2: Command Response2
	// Position of CMDRSP2 field.
	USDHC_CMD_RSP2_CMDRSP2_Pos = 0x0
	// Bit mask of CMDRSP2 field.
	USDHC_CMD_RSP2_CMDRSP2_Msk = 0xffffffff

	// CMD_RSP3: Command Response3
	// Position of CMDRSP3 field.
	USDHC_CMD_RSP3_CMDRSP3_Pos = 0x0
	// Bit mask of CMDRSP3 field.
	USDHC_CMD_RSP3_CMDRSP3_Msk = 0xffffffff

	// DATA_BUFF_ACC_PORT: Data Buffer Access Port
	// Position of DATCONT field.
	USDHC_DATA_BUFF_ACC_PORT_DATCONT_Pos = 0x0
	// Bit mask of DATCONT field.
	USDHC_DATA_BUFF_ACC_PORT_DATCONT_Msk = 0xffffffff

	// PRES_STATE: Present State
	// Position of CIHB field.
	USDHC_PRES_STATE_CIHB_Pos = 0x0
	// Bit mask of CIHB field.
	USDHC_PRES_STATE_CIHB_Msk = 0x1
	// Bit CIHB.
	USDHC_PRES_STATE_CIHB = 0x1
	// Can issue command using only CMD line
	USDHC_PRES_STATE_CIHB_CIHB_0 = 0x0
	// Cannot issue command
	USDHC_PRES_STATE_CIHB_CIHB_1 = 0x1
	// Position of CDIHB field.
	USDHC_PRES_STATE_CDIHB_Pos = 0x1
	// Bit mask of CDIHB field.
	USDHC_PRES_STATE_CDIHB_Msk = 0x2
	// Bit CDIHB.
	USDHC_PRES_STATE_CDIHB = 0x2
	// Can issue command which uses the DATA line
	USDHC_PRES_STATE_CDIHB_CDIHB_0 = 0x0
	// Cannot issue command which uses the DATA line
	USDHC_PRES_STATE_CDIHB_CDIHB_1 = 0x1
	// Position of DLA field.
	USDHC_PRES_STATE_DLA_Pos = 0x2
	// Bit mask of DLA field.
	USDHC_PRES_STATE_DLA_Msk = 0x4
	// Bit DLA.
	USDHC_PRES_STATE_DLA = 0x4
	// DATA Line Inactive
	USDHC_PRES_STATE_DLA_DLA_0 = 0x0
	// DATA Line Active
	USDHC_PRES_STATE_DLA_DLA_1 = 0x1
	// Position of SDSTB field.
	USDHC_PRES_STATE_SDSTB_Pos = 0x3
	// Bit mask of SDSTB field.
	USDHC_PRES_STATE_SDSTB_Msk = 0x8
	// Bit SDSTB.
	USDHC_PRES_STATE_SDSTB = 0x8
	// Clock is changing frequency and not stable.
	USDHC_PRES_STATE_SDSTB_SDSTB_0 = 0x0
	// Clock is stable.
	USDHC_PRES_STATE_SDSTB_SDSTB_1 = 0x1
	// Position of IPGOFF field.
	USDHC_PRES_STATE_IPGOFF_Pos = 0x4
	// Bit mask of IPGOFF field.
	USDHC_PRES_STATE_IPGOFF_Msk = 0x10
	// Bit IPGOFF.
	USDHC_PRES_STATE_IPGOFF = 0x10
	// IPG_CLK is active.
	USDHC_PRES_STATE_IPGOFF_IPGOFF_0 = 0x0
	// IPG_CLK is gated off.
	USDHC_PRES_STATE_IPGOFF_IPGOFF_1 = 0x1
	// Position of HCKOFF field.
	USDHC_PRES_STATE_HCKOFF_Pos = 0x5
	// Bit mask of HCKOFF field.
	USDHC_PRES_STATE_HCKOFF_Msk = 0x20
	// Bit HCKOFF.
	USDHC_PRES_STATE_HCKOFF = 0x20
	// HCLK is active.
	USDHC_PRES_STATE_HCKOFF_HCKOFF_0 = 0x0
	// HCLK is gated off.
	USDHC_PRES_STATE_HCKOFF_HCKOFF_1 = 0x1
	// Position of PEROFF field.
	USDHC_PRES_STATE_PEROFF_Pos = 0x6
	// Bit mask of PEROFF field.
	USDHC_PRES_STATE_PEROFF_Msk = 0x40
	// Bit PEROFF.
	USDHC_PRES_STATE_PEROFF = 0x40
	// IPG_PERCLK is active.
	USDHC_PRES_STATE_PEROFF_PEROFF_0 = 0x0
	// IPG_PERCLK is gated off.
	USDHC_PRES_STATE_PEROFF_PEROFF_1 = 0x1
	// Position of SDOFF field.
	USDHC_PRES_STATE_SDOFF_Pos = 0x7
	// Bit mask of SDOFF field.
	USDHC_PRES_STATE_SDOFF_Msk = 0x80
	// Bit SDOFF.
	USDHC_PRES_STATE_SDOFF = 0x80
	// SD Clock is active.
	USDHC_PRES_STATE_SDOFF_SDOFF_0 = 0x0
	// SD Clock is gated off.
	USDHC_PRES_STATE_SDOFF_SDOFF_1 = 0x1
	// Position of WTA field.
	USDHC_PRES_STATE_WTA_Pos = 0x8
	// Bit mask of WTA field.
	USDHC_PRES_STATE_WTA_Msk = 0x100
	// Bit WTA.
	USDHC_PRES_STATE_WTA = 0x100
	// No valid data
	USDHC_PRES_STATE_WTA_WTA_0 = 0x0
	// Transferring data
	USDHC_PRES_STATE_WTA_WTA_1 = 0x1
	// Position of RTA field.
	USDHC_PRES_STATE_RTA_Pos = 0x9
	// Bit mask of RTA field.
	USDHC_PRES_STATE_RTA_Msk = 0x200
	// Bit RTA.
	USDHC_PRES_STATE_RTA = 0x200
	// No valid data
	USDHC_PRES_STATE_RTA_RTA_0 = 0x0
	// Transferring data
	USDHC_PRES_STATE_RTA_RTA_1 = 0x1
	// Position of BWEN field.
	USDHC_PRES_STATE_BWEN_Pos = 0xa
	// Bit mask of BWEN field.
	USDHC_PRES_STATE_BWEN_Msk = 0x400
	// Bit BWEN.
	USDHC_PRES_STATE_BWEN = 0x400
	// Write disable
	USDHC_PRES_STATE_BWEN_BWEN_0 = 0x0
	// Write enable
	USDHC_PRES_STATE_BWEN_BWEN_1 = 0x1
	// Position of BREN field.
	USDHC_PRES_STATE_BREN_Pos = 0xb
	// Bit mask of BREN field.
	USDHC_PRES_STATE_BREN_Msk = 0x800
	// Bit BREN.
	USDHC_PRES_STATE_BREN = 0x800
	// Read disable
	USDHC_PRES_STATE_BREN_BREN_0 = 0x0
	// Read enable
	USDHC_PRES_STATE_BREN_BREN_1 = 0x1
	// Position of RTR field.
	USDHC_PRES_STATE_RTR_Pos = 0xc
	// Bit mask of RTR field.
	USDHC_PRES_STATE_RTR_Msk = 0x1000
	// Bit RTR.
	USDHC_PRES_STATE_RTR = 0x1000
	// Fixed or well tuned sampling clock
	USDHC_PRES_STATE_RTR_RTR_0 = 0x0
	// Sampling clock needs re-tuning
	USDHC_PRES_STATE_RTR_RTR_1 = 0x1
	// Position of TSCD field.
	USDHC_PRES_STATE_TSCD_Pos = 0xf
	// Bit mask of TSCD field.
	USDHC_PRES_STATE_TSCD_Msk = 0x8000
	// Bit TSCD.
	USDHC_PRES_STATE_TSCD = 0x8000
	// Delay cell select change is not finished.
	USDHC_PRES_STATE_TSCD_TSCD_0 = 0x0
	// Delay cell select change is finished.
	USDHC_PRES_STATE_TSCD_TSCD_1 = 0x1
	// Position of CINST field.
	USDHC_PRES_STATE_CINST_Pos = 0x10
	// Bit mask of CINST field.
	USDHC_PRES_STATE_CINST_Msk = 0x10000
	// Bit CINST.
	USDHC_PRES_STATE_CINST = 0x10000
	// Power on Reset or No Card
	USDHC_PRES_STATE_CINST_CINST_0 = 0x0
	// Card Inserted
	USDHC_PRES_STATE_CINST_CINST_1 = 0x1
	// Position of CDPL field.
	USDHC_PRES_STATE_CDPL_Pos = 0x12
	// Bit mask of CDPL field.
	USDHC_PRES_STATE_CDPL_Msk = 0x40000
	// Bit CDPL.
	USDHC_PRES_STATE_CDPL = 0x40000
	// No card present (CD_B = 1)
	USDHC_PRES_STATE_CDPL_CDPL_0 = 0x0
	// Card present (CD_B = 0)
	USDHC_PRES_STATE_CDPL_CDPL_1 = 0x1
	// Position of WPSPL field.
	USDHC_PRES_STATE_WPSPL_Pos = 0x13
	// Bit mask of WPSPL field.
	USDHC_PRES_STATE_WPSPL_Msk = 0x80000
	// Bit WPSPL.
	USDHC_PRES_STATE_WPSPL = 0x80000
	// Write protected (WP = 1)
	USDHC_PRES_STATE_WPSPL_WPSPL_0 = 0x0
	// Write enabled (WP = 0)
	USDHC_PRES_STATE_WPSPL_WPSPL_1 = 0x1
	// Position of CLSL field.
	USDHC_PRES_STATE_CLSL_Pos = 0x17
	// Bit mask of CLSL field.
	USDHC_PRES_STATE_CLSL_Msk = 0x800000
	// Bit CLSL.
	USDHC_PRES_STATE_CLSL = 0x800000
	// Position of DLSL field.
	USDHC_PRES_STATE_DLSL_Pos = 0x18
	// Bit mask of DLSL field.
	USDHC_PRES_STATE_DLSL_Msk = 0xff000000
	// Data 0 line signal level
	USDHC_PRES_STATE_DLSL_DATA0 = 0x0
	// Data 1 line signal level
	USDHC_PRES_STATE_DLSL_DATA1 = 0x1
	// Data 2 line signal level
	USDHC_PRES_STATE_DLSL_DATA2 = 0x2
	// Data 3 line signal level
	USDHC_PRES_STATE_DLSL_DATA3 = 0x3
	// Data 4 line signal level
	USDHC_PRES_STATE_DLSL_DATA4 = 0x4
	// Data 5 line signal level
	USDHC_PRES_STATE_DLSL_DATA5 = 0x5
	// Data 6 line signal level
	USDHC_PRES_STATE_DLSL_DATA6 = 0x6
	// Data 7 line signal level
	USDHC_PRES_STATE_DLSL_DATA7 = 0x7

	// PROT_CTRL: Protocol Control
	// Position of LCTL field.
	USDHC_PROT_CTRL_LCTL_Pos = 0x0
	// Bit mask of LCTL field.
	USDHC_PROT_CTRL_LCTL_Msk = 0x1
	// Bit LCTL.
	USDHC_PROT_CTRL_LCTL = 0x1
	// LED off
	USDHC_PROT_CTRL_LCTL_LCTL_0 = 0x0
	// LED on
	USDHC_PROT_CTRL_LCTL_LCTL_1 = 0x1
	// Position of DTW field.
	USDHC_PROT_CTRL_DTW_Pos = 0x1
	// Bit mask of DTW field.
	USDHC_PROT_CTRL_DTW_Msk = 0x6
	// 1-bit mode
	USDHC_PROT_CTRL_DTW_DTW_0 = 0x0
	// 4-bit mode
	USDHC_PROT_CTRL_DTW_DTW_1 = 0x1
	// 8-bit mode
	USDHC_PROT_CTRL_DTW_DTW_2 = 0x2
	// Position of D3CD field.
	USDHC_PROT_CTRL_D3CD_Pos = 0x3
	// Bit mask of D3CD field.
	USDHC_PROT_CTRL_D3CD_Msk = 0x8
	// Bit D3CD.
	USDHC_PROT_CTRL_D3CD = 0x8
	// DATA3 does not monitor Card Insertion
	USDHC_PROT_CTRL_D3CD_D3CD_0 = 0x0
	// DATA3 as Card Detection Pin
	USDHC_PROT_CTRL_D3CD_D3CD_1 = 0x1
	// Position of EMODE field.
	USDHC_PROT_CTRL_EMODE_Pos = 0x4
	// Bit mask of EMODE field.
	USDHC_PROT_CTRL_EMODE_Msk = 0x30
	// Big Endian Mode
	USDHC_PROT_CTRL_EMODE_EMODE_0 = 0x0
	// Half Word Big Endian Mode
	USDHC_PROT_CTRL_EMODE_EMODE_1 = 0x1
	// Little Endian Mode
	USDHC_PROT_CTRL_EMODE_EMODE_2 = 0x2
	// Position of CDTL field.
	USDHC_PROT_CTRL_CDTL_Pos = 0x6
	// Bit mask of CDTL field.
	USDHC_PROT_CTRL_CDTL_Msk = 0x40
	// Bit CDTL.
	USDHC_PROT_CTRL_CDTL = 0x40
	// Card Detect Test Level is 0, no card inserted
	USDHC_PROT_CTRL_CDTL_CDTL_0 = 0x0
	// Card Detect Test Level is 1, card inserted
	USDHC_PROT_CTRL_CDTL_CDTL_1 = 0x1
	// Position of CDSS field.
	USDHC_PROT_CTRL_CDSS_Pos = 0x7
	// Bit mask of CDSS field.
	USDHC_PROT_CTRL_CDSS_Msk = 0x80
	// Bit CDSS.
	USDHC_PROT_CTRL_CDSS = 0x80
	// Card Detection Level is selected (for normal purpose).
	USDHC_PROT_CTRL_CDSS_CDSS_0 = 0x0
	// Card Detection Test Level is selected (for test purpose).
	USDHC_PROT_CTRL_CDSS_CDSS_1 = 0x1
	// Position of DMASEL field.
	USDHC_PROT_CTRL_DMASEL_Pos = 0x8
	// Bit mask of DMASEL field.
	USDHC_PROT_CTRL_DMASEL_Msk = 0x300
	// No DMA or Simple DMA is selected
	USDHC_PROT_CTRL_DMASEL_DMASEL_0 = 0x0
	// ADMA1 is selected
	USDHC_PROT_CTRL_DMASEL_DMASEL_1 = 0x1
	// ADMA2 is selected
	USDHC_PROT_CTRL_DMASEL_DMASEL_2 = 0x2
	// Position of SABGREQ field.
	USDHC_PROT_CTRL_SABGREQ_Pos = 0x10
	// Bit mask of SABGREQ field.
	USDHC_PROT_CTRL_SABGREQ_Msk = 0x10000
	// Bit SABGREQ.
	USDHC_PROT_CTRL_SABGREQ = 0x10000
	// Transfer
	USDHC_PROT_CTRL_SABGREQ_SABGREQ_0 = 0x0
	// Stop
	USDHC_PROT_CTRL_SABGREQ_SABGREQ_1 = 0x1
	// Position of CREQ field.
	USDHC_PROT_CTRL_CREQ_Pos = 0x11
	// Bit mask of CREQ field.
	USDHC_PROT_CTRL_CREQ_Msk = 0x20000
	// Bit CREQ.
	USDHC_PROT_CTRL_CREQ = 0x20000
	// No effect
	USDHC_PROT_CTRL_CREQ_CREQ_0 = 0x0
	// Restart
	USDHC_PROT_CTRL_CREQ_CREQ_1 = 0x1
	// Position of RWCTL field.
	USDHC_PROT_CTRL_RWCTL_Pos = 0x12
	// Bit mask of RWCTL field.
	USDHC_PROT_CTRL_RWCTL_Msk = 0x40000
	// Bit RWCTL.
	USDHC_PROT_CTRL_RWCTL = 0x40000
	// Disable Read Wait Control, and stop SD Clock at block gap when SABGREQ bit is set
	USDHC_PROT_CTRL_RWCTL_RWCTL_0 = 0x0
	// Enable Read Wait Control, and assert Read Wait without stopping SD Clock at block gap when SABGREQ bit is set
	USDHC_PROT_CTRL_RWCTL_RWCTL_1 = 0x1
	// Position of IABG field.
	USDHC_PROT_CTRL_IABG_Pos = 0x13
	// Bit mask of IABG field.
	USDHC_PROT_CTRL_IABG_Msk = 0x80000
	// Bit IABG.
	USDHC_PROT_CTRL_IABG = 0x80000
	// Disabled
	USDHC_PROT_CTRL_IABG_IABG_0 = 0x0
	// Enabled
	USDHC_PROT_CTRL_IABG_IABG_1 = 0x1
	// Position of RD_DONE_NO_8CLK field.
	USDHC_PROT_CTRL_RD_DONE_NO_8CLK_Pos = 0x14
	// Bit mask of RD_DONE_NO_8CLK field.
	USDHC_PROT_CTRL_RD_DONE_NO_8CLK_Msk = 0x100000
	// Bit RD_DONE_NO_8CLK.
	USDHC_PROT_CTRL_RD_DONE_NO_8CLK = 0x100000
	// Position of WECINT field.
	USDHC_PROT_CTRL_WECINT_Pos = 0x18
	// Bit mask of WECINT field.
	USDHC_PROT_CTRL_WECINT_Msk = 0x1000000
	// Bit WECINT.
	USDHC_PROT_CTRL_WECINT = 0x1000000
	// Disable
	USDHC_PROT_CTRL_WECINT_WECINT_0 = 0x0
	// Enable
	USDHC_PROT_CTRL_WECINT_WECINT_1 = 0x1
	// Position of WECINS field.
	USDHC_PROT_CTRL_WECINS_Pos = 0x19
	// Bit mask of WECINS field.
	USDHC_PROT_CTRL_WECINS_Msk = 0x2000000
	// Bit WECINS.
	USDHC_PROT_CTRL_WECINS = 0x2000000
	// Disable
	USDHC_PROT_CTRL_WECINS_WECINS_0 = 0x0
	// Enable
	USDHC_PROT_CTRL_WECINS_WECINS_1 = 0x1
	// Position of WECRM field.
	USDHC_PROT_CTRL_WECRM_Pos = 0x1a
	// Bit mask of WECRM field.
	USDHC_PROT_CTRL_WECRM_Msk = 0x4000000
	// Bit WECRM.
	USDHC_PROT_CTRL_WECRM = 0x4000000
	// Disable
	USDHC_PROT_CTRL_WECRM_WECRM_0 = 0x0
	// Enable
	USDHC_PROT_CTRL_WECRM_WECRM_1 = 0x1
	// Position of BURST_LEN_EN field.
	USDHC_PROT_CTRL_BURST_LEN_EN_Pos = 0x1b
	// Bit mask of BURST_LEN_EN field.
	USDHC_PROT_CTRL_BURST_LEN_EN_Msk = 0x38000000
	// Burst length is enabled for INCR
	USDHC_PROT_CTRL_BURST_LEN_EN_BURST_LEN_EN_1 = 0x1
	// Position of NON_EXACT_BLK_RD field.
	USDHC_PROT_CTRL_NON_EXACT_BLK_RD_Pos = 0x1e
	// Bit mask of NON_EXACT_BLK_RD field.
	USDHC_PROT_CTRL_NON_EXACT_BLK_RD_Msk = 0x40000000
	// Bit NON_EXACT_BLK_RD.
	USDHC_PROT_CTRL_NON_EXACT_BLK_RD = 0x40000000
	// The block read is exact block read. Host driver doesn't need to issue abort command to terminate this multi-block read.
	USDHC_PROT_CTRL_NON_EXACT_BLK_RD_NON_EXACT_BLK_RD_0 = 0x0
	// The block read is non-exact block read. Host driver needs to issue abort command to terminate this multi-block read.
	USDHC_PROT_CTRL_NON_EXACT_BLK_RD_NON_EXACT_BLK_RD_1 = 0x1

	// SYS_CTRL: System Control
	// Position of DVS field.
	USDHC_SYS_CTRL_DVS_Pos = 0x4
	// Bit mask of DVS field.
	USDHC_SYS_CTRL_DVS_Msk = 0xf0
	// Divide-by-1
	USDHC_SYS_CTRL_DVS_DVS_0 = 0x0
	// Divide-by-2
	USDHC_SYS_CTRL_DVS_DVS_1 = 0x1
	// Divide-by-15
	USDHC_SYS_CTRL_DVS_DVS_14 = 0xe
	// Divide-by-16
	USDHC_SYS_CTRL_DVS_DVS_15 = 0xf
	// Position of SDCLKFS field.
	USDHC_SYS_CTRL_SDCLKFS_Pos = 0x8
	// Bit mask of SDCLKFS field.
	USDHC_SYS_CTRL_SDCLKFS_Msk = 0xff00
	// Position of DTOCV field.
	USDHC_SYS_CTRL_DTOCV_Pos = 0x10
	// Bit mask of DTOCV field.
	USDHC_SYS_CTRL_DTOCV_Msk = 0xf0000
	// SDCLK x 2 14
	USDHC_SYS_CTRL_DTOCV_DTOCV_0 = 0x0
	// SDCLK x 2 15
	USDHC_SYS_CTRL_DTOCV_DTOCV_1 = 0x1
	// SDCLK x 2 27
	USDHC_SYS_CTRL_DTOCV_DTOCV_13 = 0xd
	// SDCLK x 2 28
	USDHC_SYS_CTRL_DTOCV_DTOCV_14 = 0xe
	// SDCLK x 2 29
	USDHC_SYS_CTRL_DTOCV_DTOCV_15 = 0xf
	// Position of IPP_RST_N field.
	USDHC_SYS_CTRL_IPP_RST_N_Pos = 0x17
	// Bit mask of IPP_RST_N field.
	USDHC_SYS_CTRL_IPP_RST_N_Msk = 0x800000
	// Bit IPP_RST_N.
	USDHC_SYS_CTRL_IPP_RST_N = 0x800000
	// Position of RSTA field.
	USDHC_SYS_CTRL_RSTA_Pos = 0x18
	// Bit mask of RSTA field.
	USDHC_SYS_CTRL_RSTA_Msk = 0x1000000
	// Bit RSTA.
	USDHC_SYS_CTRL_RSTA = 0x1000000
	// No Reset
	USDHC_SYS_CTRL_RSTA_RSTA_0 = 0x0
	// Reset
	USDHC_SYS_CTRL_RSTA_RSTA_1 = 0x1
	// Position of RSTC field.
	USDHC_SYS_CTRL_RSTC_Pos = 0x19
	// Bit mask of RSTC field.
	USDHC_SYS_CTRL_RSTC_Msk = 0x2000000
	// Bit RSTC.
	USDHC_SYS_CTRL_RSTC = 0x2000000
	// No Reset
	USDHC_SYS_CTRL_RSTC_RSTC_0 = 0x0
	// Reset
	USDHC_SYS_CTRL_RSTC_RSTC_1 = 0x1
	// Position of RSTD field.
	USDHC_SYS_CTRL_RSTD_Pos = 0x1a
	// Bit mask of RSTD field.
	USDHC_SYS_CTRL_RSTD_Msk = 0x4000000
	// Bit RSTD.
	USDHC_SYS_CTRL_RSTD = 0x4000000
	// No Reset
	USDHC_SYS_CTRL_RSTD_RSTD_0 = 0x0
	// Reset
	USDHC_SYS_CTRL_RSTD_RSTD_1 = 0x1
	// Position of INITA field.
	USDHC_SYS_CTRL_INITA_Pos = 0x1b
	// Bit mask of INITA field.
	USDHC_SYS_CTRL_INITA_Msk = 0x8000000
	// Bit INITA.
	USDHC_SYS_CTRL_INITA = 0x8000000
	// Position of RSTT field.
	USDHC_SYS_CTRL_RSTT_Pos = 0x1c
	// Bit mask of RSTT field.
	USDHC_SYS_CTRL_RSTT_Msk = 0x10000000
	// Bit RSTT.
	USDHC_SYS_CTRL_RSTT = 0x10000000

	// INT_STATUS: Interrupt Status
	// Position of CC field.
	USDHC_INT_STATUS_CC_Pos = 0x0
	// Bit mask of CC field.
	USDHC_INT_STATUS_CC_Msk = 0x1
	// Bit CC.
	USDHC_INT_STATUS_CC = 0x1
	// Command not complete
	USDHC_INT_STATUS_CC_CC_0 = 0x0
	// Command complete
	USDHC_INT_STATUS_CC_CC_1 = 0x1
	// Position of TC field.
	USDHC_INT_STATUS_TC_Pos = 0x1
	// Bit mask of TC field.
	USDHC_INT_STATUS_TC_Msk = 0x2
	// Bit TC.
	USDHC_INT_STATUS_TC = 0x2
	// Transfer not complete
	USDHC_INT_STATUS_TC_TC_0 = 0x0
	// Transfer complete
	USDHC_INT_STATUS_TC_TC_1 = 0x1
	// Position of BGE field.
	USDHC_INT_STATUS_BGE_Pos = 0x2
	// Bit mask of BGE field.
	USDHC_INT_STATUS_BGE_Msk = 0x4
	// Bit BGE.
	USDHC_INT_STATUS_BGE = 0x4
	// No block gap event
	USDHC_INT_STATUS_BGE_BGE_0 = 0x0
	// Transaction stopped at block gap
	USDHC_INT_STATUS_BGE_BGE_1 = 0x1
	// Position of DINT field.
	USDHC_INT_STATUS_DINT_Pos = 0x3
	// Bit mask of DINT field.
	USDHC_INT_STATUS_DINT_Msk = 0x8
	// Bit DINT.
	USDHC_INT_STATUS_DINT = 0x8
	// No DMA Interrupt
	USDHC_INT_STATUS_DINT_DINT_0 = 0x0
	// DMA Interrupt is generated
	USDHC_INT_STATUS_DINT_DINT_1 = 0x1
	// Position of BWR field.
	USDHC_INT_STATUS_BWR_Pos = 0x4
	// Bit mask of BWR field.
	USDHC_INT_STATUS_BWR_Msk = 0x10
	// Bit BWR.
	USDHC_INT_STATUS_BWR = 0x10
	// Not ready to write buffer
	USDHC_INT_STATUS_BWR_BWR_0 = 0x0
	// Ready to write buffer:
	USDHC_INT_STATUS_BWR_BWR_1 = 0x1
	// Position of BRR field.
	USDHC_INT_STATUS_BRR_Pos = 0x5
	// Bit mask of BRR field.
	USDHC_INT_STATUS_BRR_Msk = 0x20
	// Bit BRR.
	USDHC_INT_STATUS_BRR = 0x20
	// Not ready to read buffer
	USDHC_INT_STATUS_BRR_BRR_0 = 0x0
	// Ready to read buffer
	USDHC_INT_STATUS_BRR_BRR_1 = 0x1
	// Position of CINS field.
	USDHC_INT_STATUS_CINS_Pos = 0x6
	// Bit mask of CINS field.
	USDHC_INT_STATUS_CINS_Msk = 0x40
	// Bit CINS.
	USDHC_INT_STATUS_CINS = 0x40
	// Card state unstable or removed
	USDHC_INT_STATUS_CINS_CINS_0 = 0x0
	// Card inserted
	USDHC_INT_STATUS_CINS_CINS_1 = 0x1
	// Position of CRM field.
	USDHC_INT_STATUS_CRM_Pos = 0x7
	// Bit mask of CRM field.
	USDHC_INT_STATUS_CRM_Msk = 0x80
	// Bit CRM.
	USDHC_INT_STATUS_CRM = 0x80
	// Card state unstable or inserted
	USDHC_INT_STATUS_CRM_CRM_0 = 0x0
	// Card removed
	USDHC_INT_STATUS_CRM_CRM_1 = 0x1
	// Position of CINT field.
	USDHC_INT_STATUS_CINT_Pos = 0x8
	// Bit mask of CINT field.
	USDHC_INT_STATUS_CINT_Msk = 0x100
	// Bit CINT.
	USDHC_INT_STATUS_CINT = 0x100
	// No Card Interrupt
	USDHC_INT_STATUS_CINT_CINT_0 = 0x0
	// Generate Card Interrupt
	USDHC_INT_STATUS_CINT_CINT_1 = 0x1
	// Position of RTE field.
	USDHC_INT_STATUS_RTE_Pos = 0xc
	// Bit mask of RTE field.
	USDHC_INT_STATUS_RTE_Msk = 0x1000
	// Bit RTE.
	USDHC_INT_STATUS_RTE = 0x1000
	// Re-Tuning is not required
	USDHC_INT_STATUS_RTE_RTE_0 = 0x0
	// Re-Tuning should be performed
	USDHC_INT_STATUS_RTE_RTE_1 = 0x1
	// Position of TP field.
	USDHC_INT_STATUS_TP_Pos = 0xe
	// Bit mask of TP field.
	USDHC_INT_STATUS_TP_Msk = 0x4000
	// Bit TP.
	USDHC_INT_STATUS_TP = 0x4000
	// Position of CTOE field.
	USDHC_INT_STATUS_CTOE_Pos = 0x10
	// Bit mask of CTOE field.
	USDHC_INT_STATUS_CTOE_Msk = 0x10000
	// Bit CTOE.
	USDHC_INT_STATUS_CTOE = 0x10000
	// No Error
	USDHC_INT_STATUS_CTOE_CTOE_0 = 0x0
	// Time out
	USDHC_INT_STATUS_CTOE_CTOE_1 = 0x1
	// Position of CCE field.
	USDHC_INT_STATUS_CCE_Pos = 0x11
	// Bit mask of CCE field.
	USDHC_INT_STATUS_CCE_Msk = 0x20000
	// Bit CCE.
	USDHC_INT_STATUS_CCE = 0x20000
	// No Error
	USDHC_INT_STATUS_CCE_CCE_0 = 0x0
	// CRC Error Generated.
	USDHC_INT_STATUS_CCE_CCE_1 = 0x1
	// Position of CEBE field.
	USDHC_INT_STATUS_CEBE_Pos = 0x12
	// Bit mask of CEBE field.
	USDHC_INT_STATUS_CEBE_Msk = 0x40000
	// Bit CEBE.
	USDHC_INT_STATUS_CEBE = 0x40000
	// No Error
	USDHC_INT_STATUS_CEBE_CEBE_0 = 0x0
	// End Bit Error Generated
	USDHC_INT_STATUS_CEBE_CEBE_1 = 0x1
	// Position of CIE field.
	USDHC_INT_STATUS_CIE_Pos = 0x13
	// Bit mask of CIE field.
	USDHC_INT_STATUS_CIE_Msk = 0x80000
	// Bit CIE.
	USDHC_INT_STATUS_CIE = 0x80000
	// No Error
	USDHC_INT_STATUS_CIE_CIE_0 = 0x0
	// Error
	USDHC_INT_STATUS_CIE_CIE_1 = 0x1
	// Position of DTOE field.
	USDHC_INT_STATUS_DTOE_Pos = 0x14
	// Bit mask of DTOE field.
	USDHC_INT_STATUS_DTOE_Msk = 0x100000
	// Bit DTOE.
	USDHC_INT_STATUS_DTOE = 0x100000
	// No Error
	USDHC_INT_STATUS_DTOE_DTOE_0 = 0x0
	// Time out
	USDHC_INT_STATUS_DTOE_DTOE_1 = 0x1
	// Position of DCE field.
	USDHC_INT_STATUS_DCE_Pos = 0x15
	// Bit mask of DCE field.
	USDHC_INT_STATUS_DCE_Msk = 0x200000
	// Bit DCE.
	USDHC_INT_STATUS_DCE = 0x200000
	// No Error
	USDHC_INT_STATUS_DCE_DCE_0 = 0x0
	// Error
	USDHC_INT_STATUS_DCE_DCE_1 = 0x1
	// Position of DEBE field.
	USDHC_INT_STATUS_DEBE_Pos = 0x16
	// Bit mask of DEBE field.
	USDHC_INT_STATUS_DEBE_Msk = 0x400000
	// Bit DEBE.
	USDHC_INT_STATUS_DEBE = 0x400000
	// No Error
	USDHC_INT_STATUS_DEBE_DEBE_0 = 0x0
	// Error
	USDHC_INT_STATUS_DEBE_DEBE_1 = 0x1
	// Position of AC12E field.
	USDHC_INT_STATUS_AC12E_Pos = 0x18
	// Bit mask of AC12E field.
	USDHC_INT_STATUS_AC12E_Msk = 0x1000000
	// Bit AC12E.
	USDHC_INT_STATUS_AC12E = 0x1000000
	// No Error
	USDHC_INT_STATUS_AC12E_AC12E_0 = 0x0
	// Error
	USDHC_INT_STATUS_AC12E_AC12E_1 = 0x1
	// Position of TNE field.
	USDHC_INT_STATUS_TNE_Pos = 0x1a
	// Bit mask of TNE field.
	USDHC_INT_STATUS_TNE_Msk = 0x4000000
	// Bit TNE.
	USDHC_INT_STATUS_TNE = 0x4000000
	// Position of DMAE field.
	USDHC_INT_STATUS_DMAE_Pos = 0x1c
	// Bit mask of DMAE field.
	USDHC_INT_STATUS_DMAE_Msk = 0x10000000
	// Bit DMAE.
	USDHC_INT_STATUS_DMAE = 0x10000000
	// No Error
	USDHC_INT_STATUS_DMAE_DMAE_0 = 0x0
	// Error
	USDHC_INT_STATUS_DMAE_DMAE_1 = 0x1

	// INT_STATUS_EN: Interrupt Status Enable
	// Position of CCSEN field.
	USDHC_INT_STATUS_EN_CCSEN_Pos = 0x0
	// Bit mask of CCSEN field.
	USDHC_INT_STATUS_EN_CCSEN_Msk = 0x1
	// Bit CCSEN.
	USDHC_INT_STATUS_EN_CCSEN = 0x1
	// Masked
	USDHC_INT_STATUS_EN_CCSEN_CCSEN_0 = 0x0
	// Enabled
	USDHC_INT_STATUS_EN_CCSEN_CCSEN_1 = 0x1
	// Position of TCSEN field.
	USDHC_INT_STATUS_EN_TCSEN_Pos = 0x1
	// Bit mask of TCSEN field.
	USDHC_INT_STATUS_EN_TCSEN_Msk = 0x2
	// Bit TCSEN.
	USDHC_INT_STATUS_EN_TCSEN = 0x2
	// Masked
	USDHC_INT_STATUS_EN_TCSEN_TCSEN_0 = 0x0
	// Enabled
	USDHC_INT_STATUS_EN_TCSEN_TCSEN_1 = 0x1
	// Position of BGESEN field.
	USDHC_INT_STATUS_EN_BGESEN_Pos = 0x2
	// Bit mask of BGESEN field.
	USDHC_INT_STATUS_EN_BGESEN_Msk = 0x4
	// Bit BGESEN.
	USDHC_INT_STATUS_EN_BGESEN = 0x4
	// Masked
	USDHC_INT_STATUS_EN_BGESEN_BGESEN_0 = 0x0
	// Enabled
	USDHC_INT_STATUS_EN_BGESEN_BGESEN_1 = 0x1
	// Position of DINTSEN field.
	USDHC_INT_STATUS_EN_DINTSEN_Pos = 0x3
	// Bit mask of DINTSEN field.
	USDHC_INT_STATUS_EN_DINTSEN_Msk = 0x8
	// Bit DINTSEN.
	USDHC_INT_STATUS_EN_DINTSEN = 0x8
	// Masked
	USDHC_INT_STATUS_EN_DINTSEN_DINTSEN_0 = 0x0
	// Enabled
	USDHC_INT_STATUS_EN_DINTSEN_DINTSEN_1 = 0x1
	// Position of BWRSEN field.
	USDHC_INT_STATUS_EN_BWRSEN_Pos = 0x4
	// Bit mask of BWRSEN field.
	USDHC_INT_STATUS_EN_BWRSEN_Msk = 0x10
	// Bit BWRSEN.
	USDHC_INT_STATUS_EN_BWRSEN = 0x10
	// Masked
	USDHC_INT_STATUS_EN_BWRSEN_BWRSEN_0 = 0x0
	// Enabled
	USDHC_INT_STATUS_EN_BWRSEN_BWRSEN_1 = 0x1
	// Position of BRRSEN field.
	USDHC_INT_STATUS_EN_BRRSEN_Pos = 0x5
	// Bit mask of BRRSEN field.
	USDHC_INT_STATUS_EN_BRRSEN_Msk = 0x20
	// Bit BRRSEN.
	USDHC_INT_STATUS_EN_BRRSEN = 0x20
	// Masked
	USDHC_INT_STATUS_EN_BRRSEN_BRRSEN_0 = 0x0
	// Enabled
	USDHC_INT_STATUS_EN_BRRSEN_BRRSEN_1 = 0x1
	// Position of CINSSEN field.
	USDHC_INT_STATUS_EN_CINSSEN_Pos = 0x6
	// Bit mask of CINSSEN field.
	USDHC_INT_STATUS_EN_CINSSEN_Msk = 0x40
	// Bit CINSSEN.
	USDHC_INT_STATUS_EN_CINSSEN = 0x40
	// Masked
	USDHC_INT_STATUS_EN_CINSSEN_CINSSEN_0 = 0x0
	// Enabled
	USDHC_INT_STATUS_EN_CINSSEN_CINSSEN_1 = 0x1
	// Position of CRMSEN field.
	USDHC_INT_STATUS_EN_CRMSEN_Pos = 0x7
	// Bit mask of CRMSEN field.
	USDHC_INT_STATUS_EN_CRMSEN_Msk = 0x80
	// Bit CRMSEN.
	USDHC_INT_STATUS_EN_CRMSEN = 0x80
	// Masked
	USDHC_INT_STATUS_EN_CRMSEN_CRMSEN_0 = 0x0
	// Enabled
	USDHC_INT_STATUS_EN_CRMSEN_CRMSEN_1 = 0x1
	// Position of CINTSEN field.
	USDHC_INT_STATUS_EN_CINTSEN_Pos = 0x8
	// Bit mask of CINTSEN field.
	USDHC_INT_STATUS_EN_CINTSEN_Msk = 0x100
	// Bit CINTSEN.
	USDHC_INT_STATUS_EN_CINTSEN = 0x100
	// Masked
	USDHC_INT_STATUS_EN_CINTSEN_CINTSEN_0 = 0x0
	// Enabled
	USDHC_INT_STATUS_EN_CINTSEN_CINTSEN_1 = 0x1
	// Position of RTESEN field.
	USDHC_INT_STATUS_EN_RTESEN_Pos = 0xc
	// Bit mask of RTESEN field.
	USDHC_INT_STATUS_EN_RTESEN_Msk = 0x1000
	// Bit RTESEN.
	USDHC_INT_STATUS_EN_RTESEN = 0x1000
	// Masked
	USDHC_INT_STATUS_EN_RTESEN_RTESEN_0 = 0x0
	// Enabled
	USDHC_INT_STATUS_EN_RTESEN_RTESEN_1 = 0x1
	// Position of TPSEN field.
	USDHC_INT_STATUS_EN_TPSEN_Pos = 0xe
	// Bit mask of TPSEN field.
	USDHC_INT_STATUS_EN_TPSEN_Msk = 0x4000
	// Bit TPSEN.
	USDHC_INT_STATUS_EN_TPSEN = 0x4000
	// Masked
	USDHC_INT_STATUS_EN_TPSEN_TPSEN_0 = 0x0
	// Enabled
	USDHC_INT_STATUS_EN_TPSEN_TPSEN_1 = 0x1
	// Position of CTOESEN field.
	USDHC_INT_STATUS_EN_CTOESEN_Pos = 0x10
	// Bit mask of CTOESEN field.
	USDHC_INT_STATUS_EN_CTOESEN_Msk = 0x10000
	// Bit CTOESEN.
	USDHC_INT_STATUS_EN_CTOESEN = 0x10000
	// Masked
	USDHC_INT_STATUS_EN_CTOESEN_CTOESEN_0 = 0x0
	// Enabled
	USDHC_INT_STATUS_EN_CTOESEN_CTOESEN_1 = 0x1
	// Position of CCESEN field.
	USDHC_INT_STATUS_EN_CCESEN_Pos = 0x11
	// Bit mask of CCESEN field.
	USDHC_INT_STATUS_EN_CCESEN_Msk = 0x20000
	// Bit CCESEN.
	USDHC_INT_STATUS_EN_CCESEN = 0x20000
	// Masked
	USDHC_INT_STATUS_EN_CCESEN_CCESEN_0 = 0x0
	// Enabled
	USDHC_INT_STATUS_EN_CCESEN_CCESEN_1 = 0x1
	// Position of CEBESEN field.
	USDHC_INT_STATUS_EN_CEBESEN_Pos = 0x12
	// Bit mask of CEBESEN field.
	USDHC_INT_STATUS_EN_CEBESEN_Msk = 0x40000
	// Bit CEBESEN.
	USDHC_INT_STATUS_EN_CEBESEN = 0x40000
	// Masked
	USDHC_INT_STATUS_EN_CEBESEN_CEBESEN_0 = 0x0
	// Enabled
	USDHC_INT_STATUS_EN_CEBESEN_CEBESEN_1 = 0x1
	// Position of CIESEN field.
	USDHC_INT_STATUS_EN_CIESEN_Pos = 0x13
	// Bit mask of CIESEN field.
	USDHC_INT_STATUS_EN_CIESEN_Msk = 0x80000
	// Bit CIESEN.
	USDHC_INT_STATUS_EN_CIESEN = 0x80000
	// Masked
	USDHC_INT_STATUS_EN_CIESEN_CIESEN_0 = 0x0
	// Enabled
	USDHC_INT_STATUS_EN_CIESEN_CIESEN_1 = 0x1
	// Position of DTOESEN field.
	USDHC_INT_STATUS_EN_DTOESEN_Pos = 0x14
	// Bit mask of DTOESEN field.
	USDHC_INT_STATUS_EN_DTOESEN_Msk = 0x100000
	// Bit DTOESEN.
	USDHC_INT_STATUS_EN_DTOESEN = 0x100000
	// Masked
	USDHC_INT_STATUS_EN_DTOESEN_DTOESEN_0 = 0x0
	// Enabled
	USDHC_INT_STATUS_EN_DTOESEN_DTOESEN_1 = 0x1
	// Position of DCESEN field.
	USDHC_INT_STATUS_EN_DCESEN_Pos = 0x15
	// Bit mask of DCESEN field.
	USDHC_INT_STATUS_EN_DCESEN_Msk = 0x200000
	// Bit DCESEN.
	USDHC_INT_STATUS_EN_DCESEN = 0x200000
	// Masked
	USDHC_INT_STATUS_EN_DCESEN_DCESEN_0 = 0x0
	// Enabled
	USDHC_INT_STATUS_EN_DCESEN_DCESEN_1 = 0x1
	// Position of DEBESEN field.
	USDHC_INT_STATUS_EN_DEBESEN_Pos = 0x16
	// Bit mask of DEBESEN field.
	USDHC_INT_STATUS_EN_DEBESEN_Msk = 0x400000
	// Bit DEBESEN.
	USDHC_INT_STATUS_EN_DEBESEN = 0x400000
	// Masked
	USDHC_INT_STATUS_EN_DEBESEN_DEBESEN_0 = 0x0
	// Enabled
	USDHC_INT_STATUS_EN_DEBESEN_DEBESEN_1 = 0x1
	// Position of AC12ESEN field.
	USDHC_INT_STATUS_EN_AC12ESEN_Pos = 0x18
	// Bit mask of AC12ESEN field.
	USDHC_INT_STATUS_EN_AC12ESEN_Msk = 0x1000000
	// Bit AC12ESEN.
	USDHC_INT_STATUS_EN_AC12ESEN = 0x1000000
	// Masked
	USDHC_INT_STATUS_EN_AC12ESEN_AC12ESEN_0 = 0x0
	// Enabled
	USDHC_INT_STATUS_EN_AC12ESEN_AC12ESEN_1 = 0x1
	// Position of TNESEN field.
	USDHC_INT_STATUS_EN_TNESEN_Pos = 0x1a
	// Bit mask of TNESEN field.
	USDHC_INT_STATUS_EN_TNESEN_Msk = 0x4000000
	// Bit TNESEN.
	USDHC_INT_STATUS_EN_TNESEN = 0x4000000
	// Masked
	USDHC_INT_STATUS_EN_TNESEN_TNESEN_0 = 0x0
	// Enabled
	USDHC_INT_STATUS_EN_TNESEN_TNESEN_1 = 0x1
	// Position of DMAESEN field.
	USDHC_INT_STATUS_EN_DMAESEN_Pos = 0x1c
	// Bit mask of DMAESEN field.
	USDHC_INT_STATUS_EN_DMAESEN_Msk = 0x10000000
	// Bit DMAESEN.
	USDHC_INT_STATUS_EN_DMAESEN = 0x10000000
	// Masked
	USDHC_INT_STATUS_EN_DMAESEN_DMAESEN_0 = 0x0
	// Enabled
	USDHC_INT_STATUS_EN_DMAESEN_DMAESEN_1 = 0x1

	// INT_SIGNAL_EN: Interrupt Signal Enable
	// Position of CCIEN field.
	USDHC_INT_SIGNAL_EN_CCIEN_Pos = 0x0
	// Bit mask of CCIEN field.
	USDHC_INT_SIGNAL_EN_CCIEN_Msk = 0x1
	// Bit CCIEN.
	USDHC_INT_SIGNAL_EN_CCIEN = 0x1
	// Masked
	USDHC_INT_SIGNAL_EN_CCIEN_CCIEN_0 = 0x0
	// Enabled
	USDHC_INT_SIGNAL_EN_CCIEN_CCIEN_1 = 0x1
	// Position of TCIEN field.
	USDHC_INT_SIGNAL_EN_TCIEN_Pos = 0x1
	// Bit mask of TCIEN field.
	USDHC_INT_SIGNAL_EN_TCIEN_Msk = 0x2
	// Bit TCIEN.
	USDHC_INT_SIGNAL_EN_TCIEN = 0x2
	// Masked
	USDHC_INT_SIGNAL_EN_TCIEN_TCIEN_0 = 0x0
	// Enabled
	USDHC_INT_SIGNAL_EN_TCIEN_TCIEN_1 = 0x1
	// Position of BGEIEN field.
	USDHC_INT_SIGNAL_EN_BGEIEN_Pos = 0x2
	// Bit mask of BGEIEN field.
	USDHC_INT_SIGNAL_EN_BGEIEN_Msk = 0x4
	// Bit BGEIEN.
	USDHC_INT_SIGNAL_EN_BGEIEN = 0x4
	// Masked
	USDHC_INT_SIGNAL_EN_BGEIEN_BGEIEN_0 = 0x0
	// Enabled
	USDHC_INT_SIGNAL_EN_BGEIEN_BGEIEN_1 = 0x1
	// Position of DINTIEN field.
	USDHC_INT_SIGNAL_EN_DINTIEN_Pos = 0x3
	// Bit mask of DINTIEN field.
	USDHC_INT_SIGNAL_EN_DINTIEN_Msk = 0x8
	// Bit DINTIEN.
	USDHC_INT_SIGNAL_EN_DINTIEN = 0x8
	// Masked
	USDHC_INT_SIGNAL_EN_DINTIEN_DINTIEN_0 = 0x0
	// Enabled
	USDHC_INT_SIGNAL_EN_DINTIEN_DINTIEN_1 = 0x1
	// Position of BWRIEN field.
	USDHC_INT_SIGNAL_EN_BWRIEN_Pos = 0x4
	// Bit mask of BWRIEN field.
	USDHC_INT_SIGNAL_EN_BWRIEN_Msk = 0x10
	// Bit BWRIEN.
	USDHC_INT_SIGNAL_EN_BWRIEN = 0x10
	// Masked
	USDHC_INT_SIGNAL_EN_BWRIEN_BWRIEN_0 = 0x0
	// Enabled
	USDHC_INT_SIGNAL_EN_BWRIEN_BWRIEN_1 = 0x1
	// Position of BRRIEN field.
	USDHC_INT_SIGNAL_EN_BRRIEN_Pos = 0x5
	// Bit mask of BRRIEN field.
	USDHC_INT_SIGNAL_EN_BRRIEN_Msk = 0x20
	// Bit BRRIEN.
	USDHC_INT_SIGNAL_EN_BRRIEN = 0x20
	// Masked
	USDHC_INT_SIGNAL_EN_BRRIEN_BRRIEN_0 = 0x0
	// Enabled
	USDHC_INT_SIGNAL_EN_BRRIEN_BRRIEN_1 = 0x1
	// Position of CINSIEN field.
	USDHC_INT_SIGNAL_EN_CINSIEN_Pos = 0x6
	// Bit mask of CINSIEN field.
	USDHC_INT_SIGNAL_EN_CINSIEN_Msk = 0x40
	// Bit CINSIEN.
	USDHC_INT_SIGNAL_EN_CINSIEN = 0x40
	// Masked
	USDHC_INT_SIGNAL_EN_CINSIEN_CINSIEN_0 = 0x0
	// Enabled
	USDHC_INT_SIGNAL_EN_CINSIEN_CINSIEN_1 = 0x1
	// Position of CRMIEN field.
	USDHC_INT_SIGNAL_EN_CRMIEN_Pos = 0x7
	// Bit mask of CRMIEN field.
	USDHC_INT_SIGNAL_EN_CRMIEN_Msk = 0x80
	// Bit CRMIEN.
	USDHC_INT_SIGNAL_EN_CRMIEN = 0x80
	// Masked
	USDHC_INT_SIGNAL_EN_CRMIEN_CRMIEN_0 = 0x0
	// Enabled
	USDHC_INT_SIGNAL_EN_CRMIEN_CRMIEN_1 = 0x1
	// Position of CINTIEN field.
	USDHC_INT_SIGNAL_EN_CINTIEN_Pos = 0x8
	// Bit mask of CINTIEN field.
	USDHC_INT_SIGNAL_EN_CINTIEN_Msk = 0x100
	// Bit CINTIEN.
	USDHC_INT_SIGNAL_EN_CINTIEN = 0x100
	// Masked
	USDHC_INT_SIGNAL_EN_CINTIEN_CINTIEN_0 = 0x0
	// Enabled
	USDHC_INT_SIGNAL_EN_CINTIEN_CINTIEN_1 = 0x1
	// Position of RTEIEN field.
	USDHC_INT_SIGNAL_EN_RTEIEN_Pos = 0xc
	// Bit mask of RTEIEN field.
	USDHC_INT_SIGNAL_EN_RTEIEN_Msk = 0x1000
	// Bit RTEIEN.
	USDHC_INT_SIGNAL_EN_RTEIEN = 0x1000
	// Masked
	USDHC_INT_SIGNAL_EN_RTEIEN_RTEIEN_0 = 0x0
	// Enabled
	USDHC_INT_SIGNAL_EN_RTEIEN_RTEIEN_1 = 0x1
	// Position of TPIEN field.
	USDHC_INT_SIGNAL_EN_TPIEN_Pos = 0xe
	// Bit mask of TPIEN field.
	USDHC_INT_SIGNAL_EN_TPIEN_Msk = 0x4000
	// Bit TPIEN.
	USDHC_INT_SIGNAL_EN_TPIEN = 0x4000
	// Masked
	USDHC_INT_SIGNAL_EN_TPIEN_TPIEN_0 = 0x0
	// Enabled
	USDHC_INT_SIGNAL_EN_TPIEN_TPIEN_1 = 0x1
	// Position of CTOEIEN field.
	USDHC_INT_SIGNAL_EN_CTOEIEN_Pos = 0x10
	// Bit mask of CTOEIEN field.
	USDHC_INT_SIGNAL_EN_CTOEIEN_Msk = 0x10000
	// Bit CTOEIEN.
	USDHC_INT_SIGNAL_EN_CTOEIEN = 0x10000
	// Masked
	USDHC_INT_SIGNAL_EN_CTOEIEN_CTOEIEN_0 = 0x0
	// Enabled
	USDHC_INT_SIGNAL_EN_CTOEIEN_CTOEIEN_1 = 0x1
	// Position of CCEIEN field.
	USDHC_INT_SIGNAL_EN_CCEIEN_Pos = 0x11
	// Bit mask of CCEIEN field.
	USDHC_INT_SIGNAL_EN_CCEIEN_Msk = 0x20000
	// Bit CCEIEN.
	USDHC_INT_SIGNAL_EN_CCEIEN = 0x20000
	// Masked
	USDHC_INT_SIGNAL_EN_CCEIEN_CCEIEN_0 = 0x0
	// Enabled
	USDHC_INT_SIGNAL_EN_CCEIEN_CCEIEN_1 = 0x1
	// Position of CEBEIEN field.
	USDHC_INT_SIGNAL_EN_CEBEIEN_Pos = 0x12
	// Bit mask of CEBEIEN field.
	USDHC_INT_SIGNAL_EN_CEBEIEN_Msk = 0x40000
	// Bit CEBEIEN.
	USDHC_INT_SIGNAL_EN_CEBEIEN = 0x40000
	// Masked
	USDHC_INT_SIGNAL_EN_CEBEIEN_CEBEIEN_0 = 0x0
	// Enabled
	USDHC_INT_SIGNAL_EN_CEBEIEN_CEBEIEN_1 = 0x1
	// Position of CIEIEN field.
	USDHC_INT_SIGNAL_EN_CIEIEN_Pos = 0x13
	// Bit mask of CIEIEN field.
	USDHC_INT_SIGNAL_EN_CIEIEN_Msk = 0x80000
	// Bit CIEIEN.
	USDHC_INT_SIGNAL_EN_CIEIEN = 0x80000
	// Masked
	USDHC_INT_SIGNAL_EN_CIEIEN_CIEIEN_0 = 0x0
	// Enabled
	USDHC_INT_SIGNAL_EN_CIEIEN_CIEIEN_1 = 0x1
	// Position of DTOEIEN field.
	USDHC_INT_SIGNAL_EN_DTOEIEN_Pos = 0x14
	// Bit mask of DTOEIEN field.
	USDHC_INT_SIGNAL_EN_DTOEIEN_Msk = 0x100000
	// Bit DTOEIEN.
	USDHC_INT_SIGNAL_EN_DTOEIEN = 0x100000
	// Masked
	USDHC_INT_SIGNAL_EN_DTOEIEN_DTOEIEN_0 = 0x0
	// Enabled
	USDHC_INT_SIGNAL_EN_DTOEIEN_DTOEIEN_1 = 0x1
	// Position of DCEIEN field.
	USDHC_INT_SIGNAL_EN_DCEIEN_Pos = 0x15
	// Bit mask of DCEIEN field.
	USDHC_INT_SIGNAL_EN_DCEIEN_Msk = 0x200000
	// Bit DCEIEN.
	USDHC_INT_SIGNAL_EN_DCEIEN = 0x200000
	// Masked
	USDHC_INT_SIGNAL_EN_DCEIEN_DCEIEN_0 = 0x0
	// Enabled
	USDHC_INT_SIGNAL_EN_DCEIEN_DCEIEN_1 = 0x1
	// Position of DEBEIEN field.
	USDHC_INT_SIGNAL_EN_DEBEIEN_Pos = 0x16
	// Bit mask of DEBEIEN field.
	USDHC_INT_SIGNAL_EN_DEBEIEN_Msk = 0x400000
	// Bit DEBEIEN.
	USDHC_INT_SIGNAL_EN_DEBEIEN = 0x400000
	// Masked
	USDHC_INT_SIGNAL_EN_DEBEIEN_DEBEIEN_0 = 0x0
	// Enabled
	USDHC_INT_SIGNAL_EN_DEBEIEN_DEBEIEN_1 = 0x1
	// Position of AC12EIEN field.
	USDHC_INT_SIGNAL_EN_AC12EIEN_Pos = 0x18
	// Bit mask of AC12EIEN field.
	USDHC_INT_SIGNAL_EN_AC12EIEN_Msk = 0x1000000
	// Bit AC12EIEN.
	USDHC_INT_SIGNAL_EN_AC12EIEN = 0x1000000
	// Masked
	USDHC_INT_SIGNAL_EN_AC12EIEN_AC12EIEN_0 = 0x0
	// Enabled
	USDHC_INT_SIGNAL_EN_AC12EIEN_AC12EIEN_1 = 0x1
	// Position of TNEIEN field.
	USDHC_INT_SIGNAL_EN_TNEIEN_Pos = 0x1a
	// Bit mask of TNEIEN field.
	USDHC_INT_SIGNAL_EN_TNEIEN_Msk = 0x4000000
	// Bit TNEIEN.
	USDHC_INT_SIGNAL_EN_TNEIEN = 0x4000000
	// Masked
	USDHC_INT_SIGNAL_EN_TNEIEN_TNEIEN_0 = 0x0
	// Enabled
	USDHC_INT_SIGNAL_EN_TNEIEN_TNEIEN_1 = 0x1
	// Position of DMAEIEN field.
	USDHC_INT_SIGNAL_EN_DMAEIEN_Pos = 0x1c
	// Bit mask of DMAEIEN field.
	USDHC_INT_SIGNAL_EN_DMAEIEN_Msk = 0x10000000
	// Bit DMAEIEN.
	USDHC_INT_SIGNAL_EN_DMAEIEN = 0x10000000
	// Masked
	USDHC_INT_SIGNAL_EN_DMAEIEN_DMAEIEN_0 = 0x0
	// Enable
	USDHC_INT_SIGNAL_EN_DMAEIEN_DMAEIEN_1 = 0x1

	// AUTOCMD12_ERR_STATUS: Auto CMD12 Error Status
	// Position of AC12NE field.
	USDHC_AUTOCMD12_ERR_STATUS_AC12NE_Pos = 0x0
	// Bit mask of AC12NE field.
	USDHC_AUTOCMD12_ERR_STATUS_AC12NE_Msk = 0x1
	// Bit AC12NE.
	USDHC_AUTOCMD12_ERR_STATUS_AC12NE = 0x1
	// Executed
	USDHC_AUTOCMD12_ERR_STATUS_AC12NE_AC12NE_0 = 0x0
	// Not executed
	USDHC_AUTOCMD12_ERR_STATUS_AC12NE_AC12NE_1 = 0x1
	// Position of AC12TOE field.
	USDHC_AUTOCMD12_ERR_STATUS_AC12TOE_Pos = 0x1
	// Bit mask of AC12TOE field.
	USDHC_AUTOCMD12_ERR_STATUS_AC12TOE_Msk = 0x2
	// Bit AC12TOE.
	USDHC_AUTOCMD12_ERR_STATUS_AC12TOE = 0x2
	// No error
	USDHC_AUTOCMD12_ERR_STATUS_AC12TOE_AC12TOE_0 = 0x0
	// Time out
	USDHC_AUTOCMD12_ERR_STATUS_AC12TOE_AC12TOE_1 = 0x1
	// Position of AC12EBE field.
	USDHC_AUTOCMD12_ERR_STATUS_AC12EBE_Pos = 0x2
	// Bit mask of AC12EBE field.
	USDHC_AUTOCMD12_ERR_STATUS_AC12EBE_Msk = 0x4
	// Bit AC12EBE.
	USDHC_AUTOCMD12_ERR_STATUS_AC12EBE = 0x4
	// No error
	USDHC_AUTOCMD12_ERR_STATUS_AC12EBE_AC12EBE_0 = 0x0
	// End Bit Error Generated
	USDHC_AUTOCMD12_ERR_STATUS_AC12EBE_AC12EBE_1 = 0x1
	// Position of AC12CE field.
	USDHC_AUTOCMD12_ERR_STATUS_AC12CE_Pos = 0x3
	// Bit mask of AC12CE field.
	USDHC_AUTOCMD12_ERR_STATUS_AC12CE_Msk = 0x8
	// Bit AC12CE.
	USDHC_AUTOCMD12_ERR_STATUS_AC12CE = 0x8
	// No CRC error
	USDHC_AUTOCMD12_ERR_STATUS_AC12CE_AC12CE_0 = 0x0
	// CRC Error Met in Auto CMD12/23 Response
	USDHC_AUTOCMD12_ERR_STATUS_AC12CE_AC12CE_1 = 0x1
	// Position of AC12IE field.
	USDHC_AUTOCMD12_ERR_STATUS_AC12IE_Pos = 0x4
	// Bit mask of AC12IE field.
	USDHC_AUTOCMD12_ERR_STATUS_AC12IE_Msk = 0x10
	// Bit AC12IE.
	USDHC_AUTOCMD12_ERR_STATUS_AC12IE = 0x10
	// No error
	USDHC_AUTOCMD12_ERR_STATUS_AC12IE_AC12IE_0 = 0x0
	// Error, the CMD index in response is not CMD12/23
	USDHC_AUTOCMD12_ERR_STATUS_AC12IE_AC12IE_1 = 0x1
	// Position of CNIBAC12E field.
	USDHC_AUTOCMD12_ERR_STATUS_CNIBAC12E_Pos = 0x7
	// Bit mask of CNIBAC12E field.
	USDHC_AUTOCMD12_ERR_STATUS_CNIBAC12E_Msk = 0x80
	// Bit CNIBAC12E.
	USDHC_AUTOCMD12_ERR_STATUS_CNIBAC12E = 0x80
	// No error
	USDHC_AUTOCMD12_ERR_STATUS_CNIBAC12E_CNIBAC12E_0 = 0x0
	// Not Issued
	USDHC_AUTOCMD12_ERR_STATUS_CNIBAC12E_CNIBAC12E_1 = 0x1
	// Position of EXECUTE_TUNING field.
	USDHC_AUTOCMD12_ERR_STATUS_EXECUTE_TUNING_Pos = 0x16
	// Bit mask of EXECUTE_TUNING field.
	USDHC_AUTOCMD12_ERR_STATUS_EXECUTE_TUNING_Msk = 0x400000
	// Bit EXECUTE_TUNING.
	USDHC_AUTOCMD12_ERR_STATUS_EXECUTE_TUNING = 0x400000
	// Position of SMP_CLK_SEL field.
	USDHC_AUTOCMD12_ERR_STATUS_SMP_CLK_SEL_Pos = 0x17
	// Bit mask of SMP_CLK_SEL field.
	USDHC_AUTOCMD12_ERR_STATUS_SMP_CLK_SEL_Msk = 0x800000
	// Bit SMP_CLK_SEL.
	USDHC_AUTOCMD12_ERR_STATUS_SMP_CLK_SEL = 0x800000
	// Fixed clock is used to sample data
	USDHC_AUTOCMD12_ERR_STATUS_SMP_CLK_SEL_SMP_CLK_SEL_0 = 0x0
	// Tuned clock is used to sample data
	USDHC_AUTOCMD12_ERR_STATUS_SMP_CLK_SEL_SMP_CLK_SEL_1 = 0x1

	// HOST_CTRL_CAP: Host Controller Capabilities
	// Position of SDR50_SUPPORT field.
	USDHC_HOST_CTRL_CAP_SDR50_SUPPORT_Pos = 0x0
	// Bit mask of SDR50_SUPPORT field.
	USDHC_HOST_CTRL_CAP_SDR50_SUPPORT_Msk = 0x1
	// Bit SDR50_SUPPORT.
	USDHC_HOST_CTRL_CAP_SDR50_SUPPORT = 0x1
	// Position of SDR104_SUPPORT field.
	USDHC_HOST_CTRL_CAP_SDR104_SUPPORT_Pos = 0x1
	// Bit mask of SDR104_SUPPORT field.
	USDHC_HOST_CTRL_CAP_SDR104_SUPPORT_Msk = 0x2
	// Bit SDR104_SUPPORT.
	USDHC_HOST_CTRL_CAP_SDR104_SUPPORT = 0x2
	// Position of DDR50_SUPPORT field.
	USDHC_HOST_CTRL_CAP_DDR50_SUPPORT_Pos = 0x2
	// Bit mask of DDR50_SUPPORT field.
	USDHC_HOST_CTRL_CAP_DDR50_SUPPORT_Msk = 0x4
	// Bit DDR50_SUPPORT.
	USDHC_HOST_CTRL_CAP_DDR50_SUPPORT = 0x4
	// Position of TIME_COUNT_RETUNING field.
	USDHC_HOST_CTRL_CAP_TIME_COUNT_RETUNING_Pos = 0x8
	// Bit mask of TIME_COUNT_RETUNING field.
	USDHC_HOST_CTRL_CAP_TIME_COUNT_RETUNING_Msk = 0xf00
	// Position of USE_TUNING_SDR50 field.
	USDHC_HOST_CTRL_CAP_USE_TUNING_SDR50_Pos = 0xd
	// Bit mask of USE_TUNING_SDR50 field.
	USDHC_HOST_CTRL_CAP_USE_TUNING_SDR50_Msk = 0x2000
	// Bit USE_TUNING_SDR50.
	USDHC_HOST_CTRL_CAP_USE_TUNING_SDR50 = 0x2000
	// SDR does not require tuning
	USDHC_HOST_CTRL_CAP_USE_TUNING_SDR50_USE_TUNING_SDR50_0 = 0x0
	// SDR50 requires tuning
	USDHC_HOST_CTRL_CAP_USE_TUNING_SDR50_USE_TUNING_SDR50_1 = 0x1
	// Position of RETUNING_MODE field.
	USDHC_HOST_CTRL_CAP_RETUNING_MODE_Pos = 0xe
	// Bit mask of RETUNING_MODE field.
	USDHC_HOST_CTRL_CAP_RETUNING_MODE_Msk = 0xc000
	// Mode 1
	USDHC_HOST_CTRL_CAP_RETUNING_MODE_RETUNING_MODE_0 = 0x0
	// Mode 2
	USDHC_HOST_CTRL_CAP_RETUNING_MODE_RETUNING_MODE_1 = 0x1
	// Mode 3
	USDHC_HOST_CTRL_CAP_RETUNING_MODE_RETUNING_MODE_2 = 0x2
	// Position of MBL field.
	USDHC_HOST_CTRL_CAP_MBL_Pos = 0x10
	// Bit mask of MBL field.
	USDHC_HOST_CTRL_CAP_MBL_Msk = 0x70000
	// 512 bytes
	USDHC_HOST_CTRL_CAP_MBL_MBL_0 = 0x0
	// 1024 bytes
	USDHC_HOST_CTRL_CAP_MBL_MBL_1 = 0x1
	// 2048 bytes
	USDHC_HOST_CTRL_CAP_MBL_MBL_2 = 0x2
	// 4096 bytes
	USDHC_HOST_CTRL_CAP_MBL_MBL_3 = 0x3
	// Position of ADMAS field.
	USDHC_HOST_CTRL_CAP_ADMAS_Pos = 0x14
	// Bit mask of ADMAS field.
	USDHC_HOST_CTRL_CAP_ADMAS_Msk = 0x100000
	// Bit ADMAS.
	USDHC_HOST_CTRL_CAP_ADMAS = 0x100000
	// Advanced DMA Not supported
	USDHC_HOST_CTRL_CAP_ADMAS_ADMAS_0 = 0x0
	// Advanced DMA Supported
	USDHC_HOST_CTRL_CAP_ADMAS_ADMAS_1 = 0x1
	// Position of HSS field.
	USDHC_HOST_CTRL_CAP_HSS_Pos = 0x15
	// Bit mask of HSS field.
	USDHC_HOST_CTRL_CAP_HSS_Msk = 0x200000
	// Bit HSS.
	USDHC_HOST_CTRL_CAP_HSS = 0x200000
	// High Speed Not Supported
	USDHC_HOST_CTRL_CAP_HSS_HSS_0 = 0x0
	// High Speed Supported
	USDHC_HOST_CTRL_CAP_HSS_HSS_1 = 0x1
	// Position of DMAS field.
	USDHC_HOST_CTRL_CAP_DMAS_Pos = 0x16
	// Bit mask of DMAS field.
	USDHC_HOST_CTRL_CAP_DMAS_Msk = 0x400000
	// Bit DMAS.
	USDHC_HOST_CTRL_CAP_DMAS = 0x400000
	// DMA not supported
	USDHC_HOST_CTRL_CAP_DMAS_DMAS_0 = 0x0
	// DMA Supported
	USDHC_HOST_CTRL_CAP_DMAS_DMAS_1 = 0x1
	// Position of SRS field.
	USDHC_HOST_CTRL_CAP_SRS_Pos = 0x17
	// Bit mask of SRS field.
	USDHC_HOST_CTRL_CAP_SRS_Msk = 0x800000
	// Bit SRS.
	USDHC_HOST_CTRL_CAP_SRS = 0x800000
	// Not supported
	USDHC_HOST_CTRL_CAP_SRS_SRS_0 = 0x0
	// Supported
	USDHC_HOST_CTRL_CAP_SRS_SRS_1 = 0x1
	// Position of VS33 field.
	USDHC_HOST_CTRL_CAP_VS33_Pos = 0x18
	// Bit mask of VS33 field.
	USDHC_HOST_CTRL_CAP_VS33_Msk = 0x1000000
	// Bit VS33.
	USDHC_HOST_CTRL_CAP_VS33 = 0x1000000
	// 3.3V not supported
	USDHC_HOST_CTRL_CAP_VS33_VS33_0 = 0x0
	// 3.3V supported
	USDHC_HOST_CTRL_CAP_VS33_VS33_1 = 0x1
	// Position of VS30 field.
	USDHC_HOST_CTRL_CAP_VS30_Pos = 0x19
	// Bit mask of VS30 field.
	USDHC_HOST_CTRL_CAP_VS30_Msk = 0x2000000
	// Bit VS30.
	USDHC_HOST_CTRL_CAP_VS30 = 0x2000000
	// 3.0V not supported
	USDHC_HOST_CTRL_CAP_VS30_VS30_0 = 0x0
	// 3.0V supported
	USDHC_HOST_CTRL_CAP_VS30_VS30_1 = 0x1
	// Position of VS18 field.
	USDHC_HOST_CTRL_CAP_VS18_Pos = 0x1a
	// Bit mask of VS18 field.
	USDHC_HOST_CTRL_CAP_VS18_Msk = 0x4000000
	// Bit VS18.
	USDHC_HOST_CTRL_CAP_VS18 = 0x4000000
	// 1.8V not supported
	USDHC_HOST_CTRL_CAP_VS18_VS18_0 = 0x0
	// 1.8V supported
	USDHC_HOST_CTRL_CAP_VS18_VS18_1 = 0x1

	// WTMK_LVL: Watermark Level
	// Position of RD_WML field.
	USDHC_WTMK_LVL_RD_WML_Pos = 0x0
	// Bit mask of RD_WML field.
	USDHC_WTMK_LVL_RD_WML_Msk = 0xff
	// Position of RD_BRST_LEN field.
	USDHC_WTMK_LVL_RD_BRST_LEN_Pos = 0x8
	// Bit mask of RD_BRST_LEN field.
	USDHC_WTMK_LVL_RD_BRST_LEN_Msk = 0x1f00
	// Position of WR_WML field.
	USDHC_WTMK_LVL_WR_WML_Pos = 0x10
	// Bit mask of WR_WML field.
	USDHC_WTMK_LVL_WR_WML_Msk = 0xff0000
	// Position of WR_BRST_LEN field.
	USDHC_WTMK_LVL_WR_BRST_LEN_Pos = 0x18
	// Bit mask of WR_BRST_LEN field.
	USDHC_WTMK_LVL_WR_BRST_LEN_Msk = 0x1f000000

	// MIX_CTRL: Mixer Control
	// Position of DMAEN field.
	USDHC_MIX_CTRL_DMAEN_Pos = 0x0
	// Bit mask of DMAEN field.
	USDHC_MIX_CTRL_DMAEN_Msk = 0x1
	// Bit DMAEN.
	USDHC_MIX_CTRL_DMAEN = 0x1
	// Disable
	USDHC_MIX_CTRL_DMAEN_DMAEN_0 = 0x0
	// Enable
	USDHC_MIX_CTRL_DMAEN_DMAEN_1 = 0x1
	// Position of BCEN field.
	USDHC_MIX_CTRL_BCEN_Pos = 0x1
	// Bit mask of BCEN field.
	USDHC_MIX_CTRL_BCEN_Msk = 0x2
	// Bit BCEN.
	USDHC_MIX_CTRL_BCEN = 0x2
	// Disable
	USDHC_MIX_CTRL_BCEN_BCEN_0 = 0x0
	// Enable
	USDHC_MIX_CTRL_BCEN_BCEN_1 = 0x1
	// Position of AC12EN field.
	USDHC_MIX_CTRL_AC12EN_Pos = 0x2
	// Bit mask of AC12EN field.
	USDHC_MIX_CTRL_AC12EN_Msk = 0x4
	// Bit AC12EN.
	USDHC_MIX_CTRL_AC12EN = 0x4
	// Disable
	USDHC_MIX_CTRL_AC12EN_AC12EN_0 = 0x0
	// Enable
	USDHC_MIX_CTRL_AC12EN_AC12EN_1 = 0x1
	// Position of DDR_EN field.
	USDHC_MIX_CTRL_DDR_EN_Pos = 0x3
	// Bit mask of DDR_EN field.
	USDHC_MIX_CTRL_DDR_EN_Msk = 0x8
	// Bit DDR_EN.
	USDHC_MIX_CTRL_DDR_EN = 0x8
	// Position of DTDSEL field.
	USDHC_MIX_CTRL_DTDSEL_Pos = 0x4
	// Bit mask of DTDSEL field.
	USDHC_MIX_CTRL_DTDSEL_Msk = 0x10
	// Bit DTDSEL.
	USDHC_MIX_CTRL_DTDSEL = 0x10
	// Write (Host to Card)
	USDHC_MIX_CTRL_DTDSEL_DTDSEL_0 = 0x0
	// Read (Card to Host)
	USDHC_MIX_CTRL_DTDSEL_DTDSEL_1 = 0x1
	// Position of MSBSEL field.
	USDHC_MIX_CTRL_MSBSEL_Pos = 0x5
	// Bit mask of MSBSEL field.
	USDHC_MIX_CTRL_MSBSEL_Msk = 0x20
	// Bit MSBSEL.
	USDHC_MIX_CTRL_MSBSEL = 0x20
	// Single Block
	USDHC_MIX_CTRL_MSBSEL_MSBSEL_0 = 0x0
	// Multiple Blocks
	USDHC_MIX_CTRL_MSBSEL_MSBSEL_1 = 0x1
	// Position of NIBBLE_POS field.
	USDHC_MIX_CTRL_NIBBLE_POS_Pos = 0x6
	// Bit mask of NIBBLE_POS field.
	USDHC_MIX_CTRL_NIBBLE_POS_Msk = 0x40
	// Bit NIBBLE_POS.
	USDHC_MIX_CTRL_NIBBLE_POS = 0x40
	// Position of AC23EN field.
	USDHC_MIX_CTRL_AC23EN_Pos = 0x7
	// Bit mask of AC23EN field.
	USDHC_MIX_CTRL_AC23EN_Msk = 0x80
	// Bit AC23EN.
	USDHC_MIX_CTRL_AC23EN = 0x80
	// Position of EXE_TUNE field.
	USDHC_MIX_CTRL_EXE_TUNE_Pos = 0x16
	// Bit mask of EXE_TUNE field.
	USDHC_MIX_CTRL_EXE_TUNE_Msk = 0x400000
	// Bit EXE_TUNE.
	USDHC_MIX_CTRL_EXE_TUNE = 0x400000
	// Not Tuned or Tuning Completed
	USDHC_MIX_CTRL_EXE_TUNE_EXE_TUNE_0 = 0x0
	// Execute Tuning
	USDHC_MIX_CTRL_EXE_TUNE_EXE_TUNE_1 = 0x1
	// Position of SMP_CLK_SEL field.
	USDHC_MIX_CTRL_SMP_CLK_SEL_Pos = 0x17
	// Bit mask of SMP_CLK_SEL field.
	USDHC_MIX_CTRL_SMP_CLK_SEL_Msk = 0x800000
	// Bit SMP_CLK_SEL.
	USDHC_MIX_CTRL_SMP_CLK_SEL = 0x800000
	// Fixed clock is used to sample data / cmd
	USDHC_MIX_CTRL_SMP_CLK_SEL_SMP_CLK_SEL_0 = 0x0
	// Tuned clock is used to sample data / cmd
	USDHC_MIX_CTRL_SMP_CLK_SEL_SMP_CLK_SEL_1 = 0x1
	// Position of AUTO_TUNE_EN field.
	USDHC_MIX_CTRL_AUTO_TUNE_EN_Pos = 0x18
	// Bit mask of AUTO_TUNE_EN field.
	USDHC_MIX_CTRL_AUTO_TUNE_EN_Msk = 0x1000000
	// Bit AUTO_TUNE_EN.
	USDHC_MIX_CTRL_AUTO_TUNE_EN = 0x1000000
	// Disable auto tuning
	USDHC_MIX_CTRL_AUTO_TUNE_EN_AUTO_TUNE_EN_0 = 0x0
	// Enable auto tuning
	USDHC_MIX_CTRL_AUTO_TUNE_EN_AUTO_TUNE_EN_1 = 0x1
	// Position of FBCLK_SEL field.
	USDHC_MIX_CTRL_FBCLK_SEL_Pos = 0x19
	// Bit mask of FBCLK_SEL field.
	USDHC_MIX_CTRL_FBCLK_SEL_Msk = 0x2000000
	// Bit FBCLK_SEL.
	USDHC_MIX_CTRL_FBCLK_SEL = 0x2000000
	// Feedback clock comes from the loopback CLK
	USDHC_MIX_CTRL_FBCLK_SEL_FBCLK_SEL_0 = 0x0
	// Feedback clock comes from the ipp_card_clk_out
	USDHC_MIX_CTRL_FBCLK_SEL_FBCLK_SEL_1 = 0x1

	// FORCE_EVENT: Force Event
	// Position of FEVTAC12NE field.
	USDHC_FORCE_EVENT_FEVTAC12NE_Pos = 0x0
	// Bit mask of FEVTAC12NE field.
	USDHC_FORCE_EVENT_FEVTAC12NE_Msk = 0x1
	// Bit FEVTAC12NE.
	USDHC_FORCE_EVENT_FEVTAC12NE = 0x1
	// Position of FEVTAC12TOE field.
	USDHC_FORCE_EVENT_FEVTAC12TOE_Pos = 0x1
	// Bit mask of FEVTAC12TOE field.
	USDHC_FORCE_EVENT_FEVTAC12TOE_Msk = 0x2
	// Bit FEVTAC12TOE.
	USDHC_FORCE_EVENT_FEVTAC12TOE = 0x2
	// Position of FEVTAC12CE field.
	USDHC_FORCE_EVENT_FEVTAC12CE_Pos = 0x2
	// Bit mask of FEVTAC12CE field.
	USDHC_FORCE_EVENT_FEVTAC12CE_Msk = 0x4
	// Bit FEVTAC12CE.
	USDHC_FORCE_EVENT_FEVTAC12CE = 0x4
	// Position of FEVTAC12EBE field.
	USDHC_FORCE_EVENT_FEVTAC12EBE_Pos = 0x3
	// Bit mask of FEVTAC12EBE field.
	USDHC_FORCE_EVENT_FEVTAC12EBE_Msk = 0x8
	// Bit FEVTAC12EBE.
	USDHC_FORCE_EVENT_FEVTAC12EBE = 0x8
	// Position of FEVTAC12IE field.
	USDHC_FORCE_EVENT_FEVTAC12IE_Pos = 0x4
	// Bit mask of FEVTAC12IE field.
	USDHC_FORCE_EVENT_FEVTAC12IE_Msk = 0x10
	// Bit FEVTAC12IE.
	USDHC_FORCE_EVENT_FEVTAC12IE = 0x10
	// Position of FEVTCNIBAC12E field.
	USDHC_FORCE_EVENT_FEVTCNIBAC12E_Pos = 0x7
	// Bit mask of FEVTCNIBAC12E field.
	USDHC_FORCE_EVENT_FEVTCNIBAC12E_Msk = 0x80
	// Bit FEVTCNIBAC12E.
	USDHC_FORCE_EVENT_FEVTCNIBAC12E = 0x80
	// Position of FEVTCTOE field.
	USDHC_FORCE_EVENT_FEVTCTOE_Pos = 0x10
	// Bit mask of FEVTCTOE field.
	USDHC_FORCE_EVENT_FEVTCTOE_Msk = 0x10000
	// Bit FEVTCTOE.
	USDHC_FORCE_EVENT_FEVTCTOE = 0x10000
	// Position of FEVTCCE field.
	USDHC_FORCE_EVENT_FEVTCCE_Pos = 0x11
	// Bit mask of FEVTCCE field.
	USDHC_FORCE_EVENT_FEVTCCE_Msk = 0x20000
	// Bit FEVTCCE.
	USDHC_FORCE_EVENT_FEVTCCE = 0x20000
	// Position of FEVTCEBE field.
	USDHC_FORCE_EVENT_FEVTCEBE_Pos = 0x12
	// Bit mask of FEVTCEBE field.
	USDHC_FORCE_EVENT_FEVTCEBE_Msk = 0x40000
	// Bit FEVTCEBE.
	USDHC_FORCE_EVENT_FEVTCEBE = 0x40000
	// Position of FEVTCIE field.
	USDHC_FORCE_EVENT_FEVTCIE_Pos = 0x13
	// Bit mask of FEVTCIE field.
	USDHC_FORCE_EVENT_FEVTCIE_Msk = 0x80000
	// Bit FEVTCIE.
	USDHC_FORCE_EVENT_FEVTCIE = 0x80000
	// Position of FEVTDTOE field.
	USDHC_FORCE_EVENT_FEVTDTOE_Pos = 0x14
	// Bit mask of FEVTDTOE field.
	USDHC_FORCE_EVENT_FEVTDTOE_Msk = 0x100000
	// Bit FEVTDTOE.
	USDHC_FORCE_EVENT_FEVTDTOE = 0x100000
	// Position of FEVTDCE field.
	USDHC_FORCE_EVENT_FEVTDCE_Pos = 0x15
	// Bit mask of FEVTDCE field.
	USDHC_FORCE_EVENT_FEVTDCE_Msk = 0x200000
	// Bit FEVTDCE.
	USDHC_FORCE_EVENT_FEVTDCE = 0x200000
	// Position of FEVTDEBE field.
	USDHC_FORCE_EVENT_FEVTDEBE_Pos = 0x16
	// Bit mask of FEVTDEBE field.
	USDHC_FORCE_EVENT_FEVTDEBE_Msk = 0x400000
	// Bit FEVTDEBE.
	USDHC_FORCE_EVENT_FEVTDEBE = 0x400000
	// Position of FEVTAC12E field.
	USDHC_FORCE_EVENT_FEVTAC12E_Pos = 0x18
	// Bit mask of FEVTAC12E field.
	USDHC_FORCE_EVENT_FEVTAC12E_Msk = 0x1000000
	// Bit FEVTAC12E.
	USDHC_FORCE_EVENT_FEVTAC12E = 0x1000000
	// Position of FEVTTNE field.
	USDHC_FORCE_EVENT_FEVTTNE_Pos = 0x1a
	// Bit mask of FEVTTNE field.
	USDHC_FORCE_EVENT_FEVTTNE_Msk = 0x4000000
	// Bit FEVTTNE.
	USDHC_FORCE_EVENT_FEVTTNE = 0x4000000
	// Position of FEVTDMAE field.
	USDHC_FORCE_EVENT_FEVTDMAE_Pos = 0x1c
	// Bit mask of FEVTDMAE field.
	USDHC_FORCE_EVENT_FEVTDMAE_Msk = 0x10000000
	// Bit FEVTDMAE.
	USDHC_FORCE_EVENT_FEVTDMAE = 0x10000000
	// Position of FEVTCINT field.
	USDHC_FORCE_EVENT_FEVTCINT_Pos = 0x1f
	// Bit mask of FEVTCINT field.
	USDHC_FORCE_EVENT_FEVTCINT_Msk = 0x80000000
	// Bit FEVTCINT.
	USDHC_FORCE_EVENT_FEVTCINT = 0x80000000

	// ADMA_ERR_STATUS: ADMA Error Status Register
	// Position of ADMAES field.
	USDHC_ADMA_ERR_STATUS_ADMAES_Pos = 0x0
	// Bit mask of ADMAES field.
	USDHC_ADMA_ERR_STATUS_ADMAES_Msk = 0x3
	// Position of ADMALME field.
	USDHC_ADMA_ERR_STATUS_ADMALME_Pos = 0x2
	// Bit mask of ADMALME field.
	USDHC_ADMA_ERR_STATUS_ADMALME_Msk = 0x4
	// Bit ADMALME.
	USDHC_ADMA_ERR_STATUS_ADMALME = 0x4
	// No Error
	USDHC_ADMA_ERR_STATUS_ADMALME_ADMALME_0 = 0x0
	// Error
	USDHC_ADMA_ERR_STATUS_ADMALME_ADMALME_1 = 0x1
	// Position of ADMADCE field.
	USDHC_ADMA_ERR_STATUS_ADMADCE_Pos = 0x3
	// Bit mask of ADMADCE field.
	USDHC_ADMA_ERR_STATUS_ADMADCE_Msk = 0x8
	// Bit ADMADCE.
	USDHC_ADMA_ERR_STATUS_ADMADCE = 0x8
	// No Error
	USDHC_ADMA_ERR_STATUS_ADMADCE_ADMADCE_0 = 0x0
	// Error
	USDHC_ADMA_ERR_STATUS_ADMADCE_ADMADCE_1 = 0x1

	// ADMA_SYS_ADDR: ADMA System Address
	// Position of ADS_ADDR field.
	USDHC_ADMA_SYS_ADDR_ADS_ADDR_Pos = 0x2
	// Bit mask of ADS_ADDR field.
	USDHC_ADMA_SYS_ADDR_ADS_ADDR_Msk = 0xfffffffc

	// DLL_CTRL: DLL (Delay Line) Control
	// Position of DLL_CTRL_ENABLE field.
	USDHC_DLL_CTRL_DLL_CTRL_ENABLE_Pos = 0x0
	// Bit mask of DLL_CTRL_ENABLE field.
	USDHC_DLL_CTRL_DLL_CTRL_ENABLE_Msk = 0x1
	// Bit DLL_CTRL_ENABLE.
	USDHC_DLL_CTRL_DLL_CTRL_ENABLE = 0x1
	// Position of DLL_CTRL_RESET field.
	USDHC_DLL_CTRL_DLL_CTRL_RESET_Pos = 0x1
	// Bit mask of DLL_CTRL_RESET field.
	USDHC_DLL_CTRL_DLL_CTRL_RESET_Msk = 0x2
	// Bit DLL_CTRL_RESET.
	USDHC_DLL_CTRL_DLL_CTRL_RESET = 0x2
	// Position of DLL_CTRL_SLV_FORCE_UPD field.
	USDHC_DLL_CTRL_DLL_CTRL_SLV_FORCE_UPD_Pos = 0x2
	// Bit mask of DLL_CTRL_SLV_FORCE_UPD field.
	USDHC_DLL_CTRL_DLL_CTRL_SLV_FORCE_UPD_Msk = 0x4
	// Bit DLL_CTRL_SLV_FORCE_UPD.
	USDHC_DLL_CTRL_DLL_CTRL_SLV_FORCE_UPD = 0x4
	// Position of DLL_CTRL_SLV_DLY_TARGET0 field.
	USDHC_DLL_CTRL_DLL_CTRL_SLV_DLY_TARGET0_Pos = 0x3
	// Bit mask of DLL_CTRL_SLV_DLY_TARGET0 field.
	USDHC_DLL_CTRL_DLL_CTRL_SLV_DLY_TARGET0_Msk = 0x78
	// Position of DLL_CTRL_GATE_UPDATE field.
	USDHC_DLL_CTRL_DLL_CTRL_GATE_UPDATE_Pos = 0x7
	// Bit mask of DLL_CTRL_GATE_UPDATE field.
	USDHC_DLL_CTRL_DLL_CTRL_GATE_UPDATE_Msk = 0x80
	// Bit DLL_CTRL_GATE_UPDATE.
	USDHC_DLL_CTRL_DLL_CTRL_GATE_UPDATE = 0x80
	// Position of DLL_CTRL_SLV_OVERRIDE field.
	USDHC_DLL_CTRL_DLL_CTRL_SLV_OVERRIDE_Pos = 0x8
	// Bit mask of DLL_CTRL_SLV_OVERRIDE field.
	USDHC_DLL_CTRL_DLL_CTRL_SLV_OVERRIDE_Msk = 0x100
	// Bit DLL_CTRL_SLV_OVERRIDE.
	USDHC_DLL_CTRL_DLL_CTRL_SLV_OVERRIDE = 0x100
	// Position of DLL_CTRL_SLV_OVERRIDE_VAL field.
	USDHC_DLL_CTRL_DLL_CTRL_SLV_OVERRIDE_VAL_Pos = 0x9
	// Bit mask of DLL_CTRL_SLV_OVERRIDE_VAL field.
	USDHC_DLL_CTRL_DLL_CTRL_SLV_OVERRIDE_VAL_Msk = 0xfe00
	// Position of DLL_CTRL_SLV_DLY_TARGET1 field.
	USDHC_DLL_CTRL_DLL_CTRL_SLV_DLY_TARGET1_Pos = 0x10
	// Bit mask of DLL_CTRL_SLV_DLY_TARGET1 field.
	USDHC_DLL_CTRL_DLL_CTRL_SLV_DLY_TARGET1_Msk = 0x70000
	// Position of DLL_CTRL_SLV_UPDATE_INT field.
	USDHC_DLL_CTRL_DLL_CTRL_SLV_UPDATE_INT_Pos = 0x14
	// Bit mask of DLL_CTRL_SLV_UPDATE_INT field.
	USDHC_DLL_CTRL_DLL_CTRL_SLV_UPDATE_INT_Msk = 0xff00000
	// Position of DLL_CTRL_REF_UPDATE_INT field.
	USDHC_DLL_CTRL_DLL_CTRL_REF_UPDATE_INT_Pos = 0x1c
	// Bit mask of DLL_CTRL_REF_UPDATE_INT field.
	USDHC_DLL_CTRL_DLL_CTRL_REF_UPDATE_INT_Msk = 0xf0000000

	// DLL_STATUS: DLL Status
	// Position of DLL_STS_SLV_LOCK field.
	USDHC_DLL_STATUS_DLL_STS_SLV_LOCK_Pos = 0x0
	// Bit mask of DLL_STS_SLV_LOCK field.
	USDHC_DLL_STATUS_DLL_STS_SLV_LOCK_Msk = 0x1
	// Bit DLL_STS_SLV_LOCK.
	USDHC_DLL_STATUS_DLL_STS_SLV_LOCK = 0x1
	// Position of DLL_STS_REF_LOCK field.
	USDHC_DLL_STATUS_DLL_STS_REF_LOCK_Pos = 0x1
	// Bit mask of DLL_STS_REF_LOCK field.
	USDHC_DLL_STATUS_DLL_STS_REF_LOCK_Msk = 0x2
	// Bit DLL_STS_REF_LOCK.
	USDHC_DLL_STATUS_DLL_STS_REF_LOCK = 0x2
	// Position of DLL_STS_SLV_SEL field.
	USDHC_DLL_STATUS_DLL_STS_SLV_SEL_Pos = 0x2
	// Bit mask of DLL_STS_SLV_SEL field.
	USDHC_DLL_STATUS_DLL_STS_SLV_SEL_Msk = 0x1fc
	// Position of DLL_STS_REF_SEL field.
	USDHC_DLL_STATUS_DLL_STS_REF_SEL_Pos = 0x9
	// Bit mask of DLL_STS_REF_SEL field.
	USDHC_DLL_STATUS_DLL_STS_REF_SEL_Msk = 0xfe00

	// CLK_TUNE_CTRL_STATUS: CLK Tuning Control and Status
	// Position of DLY_CELL_SET_POST field.
	USDHC_CLK_TUNE_CTRL_STATUS_DLY_CELL_SET_POST_Pos = 0x0
	// Bit mask of DLY_CELL_SET_POST field.
	USDHC_CLK_TUNE_CTRL_STATUS_DLY_CELL_SET_POST_Msk = 0xf
	// Position of DLY_CELL_SET_OUT field.
	USDHC_CLK_TUNE_CTRL_STATUS_DLY_CELL_SET_OUT_Pos = 0x4
	// Bit mask of DLY_CELL_SET_OUT field.
	USDHC_CLK_TUNE_CTRL_STATUS_DLY_CELL_SET_OUT_Msk = 0xf0
	// Position of DLY_CELL_SET_PRE field.
	USDHC_CLK_TUNE_CTRL_STATUS_DLY_CELL_SET_PRE_Pos = 0x8
	// Bit mask of DLY_CELL_SET_PRE field.
	USDHC_CLK_TUNE_CTRL_STATUS_DLY_CELL_SET_PRE_Msk = 0x7f00
	// Position of NXT_ERR field.
	USDHC_CLK_TUNE_CTRL_STATUS_NXT_ERR_Pos = 0xf
	// Bit mask of NXT_ERR field.
	USDHC_CLK_TUNE_CTRL_STATUS_NXT_ERR_Msk = 0x8000
	// Bit NXT_ERR.
	USDHC_CLK_TUNE_CTRL_STATUS_NXT_ERR = 0x8000
	// Position of TAP_SEL_POST field.
	USDHC_CLK_TUNE_CTRL_STATUS_TAP_SEL_POST_Pos = 0x10
	// Bit mask of TAP_SEL_POST field.
	USDHC_CLK_TUNE_CTRL_STATUS_TAP_SEL_POST_Msk = 0xf0000
	// Position of TAP_SEL_OUT field.
	USDHC_CLK_TUNE_CTRL_STATUS_TAP_SEL_OUT_Pos = 0x14
	// Bit mask of TAP_SEL_OUT field.
	USDHC_CLK_TUNE_CTRL_STATUS_TAP_SEL_OUT_Msk = 0xf00000
	// Position of TAP_SEL_PRE field.
	USDHC_CLK_TUNE_CTRL_STATUS_TAP_SEL_PRE_Pos = 0x18
	// Bit mask of TAP_SEL_PRE field.
	USDHC_CLK_TUNE_CTRL_STATUS_TAP_SEL_PRE_Msk = 0x7f000000
	// Position of PRE_ERR field.
	USDHC_CLK_TUNE_CTRL_STATUS_PRE_ERR_Pos = 0x1f
	// Bit mask of PRE_ERR field.
	USDHC_CLK_TUNE_CTRL_STATUS_PRE_ERR_Msk = 0x80000000
	// Bit PRE_ERR.
	USDHC_CLK_TUNE_CTRL_STATUS_PRE_ERR = 0x80000000

	// VEND_SPEC: Vendor Specific Register
	// Position of VSELECT field.
	USDHC_VEND_SPEC_VSELECT_Pos = 0x1
	// Bit mask of VSELECT field.
	USDHC_VEND_SPEC_VSELECT_Msk = 0x2
	// Bit VSELECT.
	USDHC_VEND_SPEC_VSELECT = 0x2
	// Change the voltage to high voltage range, around 3.0 V
	USDHC_VEND_SPEC_VSELECT_VSELECT_0 = 0x0
	// Change the voltage to low voltage range, around 1.8 V
	USDHC_VEND_SPEC_VSELECT_VSELECT_1 = 0x1
	// Position of CONFLICT_CHK_EN field.
	USDHC_VEND_SPEC_CONFLICT_CHK_EN_Pos = 0x2
	// Bit mask of CONFLICT_CHK_EN field.
	USDHC_VEND_SPEC_CONFLICT_CHK_EN_Msk = 0x4
	// Bit CONFLICT_CHK_EN.
	USDHC_VEND_SPEC_CONFLICT_CHK_EN = 0x4
	// Conflict check disable
	USDHC_VEND_SPEC_CONFLICT_CHK_EN_CONFLICT_CHK_EN_0 = 0x0
	// Conflict check enable
	USDHC_VEND_SPEC_CONFLICT_CHK_EN_CONFLICT_CHK_EN_1 = 0x1
	// Position of AC12_WR_CHKBUSY_EN field.
	USDHC_VEND_SPEC_AC12_WR_CHKBUSY_EN_Pos = 0x3
	// Bit mask of AC12_WR_CHKBUSY_EN field.
	USDHC_VEND_SPEC_AC12_WR_CHKBUSY_EN_Msk = 0x8
	// Bit AC12_WR_CHKBUSY_EN.
	USDHC_VEND_SPEC_AC12_WR_CHKBUSY_EN = 0x8
	// Do not check busy after auto CMD12 for write data packet
	USDHC_VEND_SPEC_AC12_WR_CHKBUSY_EN_AC12_WR_CHKBUSY_EN_0 = 0x0
	// Check busy after auto CMD12 for write data packet
	USDHC_VEND_SPEC_AC12_WR_CHKBUSY_EN_AC12_WR_CHKBUSY_EN_1 = 0x1
	// Position of FRC_SDCLK_ON field.
	USDHC_VEND_SPEC_FRC_SDCLK_ON_Pos = 0x8
	// Bit mask of FRC_SDCLK_ON field.
	USDHC_VEND_SPEC_FRC_SDCLK_ON_Msk = 0x100
	// Bit FRC_SDCLK_ON.
	USDHC_VEND_SPEC_FRC_SDCLK_ON = 0x100
	// CLK active or inactive is fully controlled by the hardware.
	USDHC_VEND_SPEC_FRC_SDCLK_ON_FRC_SDCLK_ON_0 = 0x0
	// Force CLK active.
	USDHC_VEND_SPEC_FRC_SDCLK_ON_FRC_SDCLK_ON_1 = 0x1
	// Position of CRC_CHK_DIS field.
	USDHC_VEND_SPEC_CRC_CHK_DIS_Pos = 0xf
	// Bit mask of CRC_CHK_DIS field.
	USDHC_VEND_SPEC_CRC_CHK_DIS_Msk = 0x8000
	// Bit CRC_CHK_DIS.
	USDHC_VEND_SPEC_CRC_CHK_DIS = 0x8000
	// Check CRC16 for every read data packet and check CRC bits for every write data packet
	USDHC_VEND_SPEC_CRC_CHK_DIS_CRC_CHK_DIS_0 = 0x0
	// Ignore CRC16 check for every read data packet and ignore CRC bits check for every write data packet
	USDHC_VEND_SPEC_CRC_CHK_DIS_CRC_CHK_DIS_1 = 0x1
	// Position of CMD_BYTE_EN field.
	USDHC_VEND_SPEC_CMD_BYTE_EN_Pos = 0x1f
	// Bit mask of CMD_BYTE_EN field.
	USDHC_VEND_SPEC_CMD_BYTE_EN_Msk = 0x80000000
	// Bit CMD_BYTE_EN.
	USDHC_VEND_SPEC_CMD_BYTE_EN = 0x80000000
	// Disable
	USDHC_VEND_SPEC_CMD_BYTE_EN_CMD_BYTE_EN_0 = 0x0
	// Enable
	USDHC_VEND_SPEC_CMD_BYTE_EN_CMD_BYTE_EN_1 = 0x1

	// MMC_BOOT: MMC Boot Register
	// Position of DTOCV_ACK field.
	USDHC_MMC_BOOT_DTOCV_ACK_Pos = 0x0
	// Bit mask of DTOCV_ACK field.
	USDHC_MMC_BOOT_DTOCV_ACK_Msk = 0xf
	// SDCLK x 2^14
	USDHC_MMC_BOOT_DTOCV_ACK_DTOCV_ACK_0 = 0x0
	// SDCLK x 2^15
	USDHC_MMC_BOOT_DTOCV_ACK_DTOCV_ACK_1 = 0x1
	// SDCLK x 2^16
	USDHC_MMC_BOOT_DTOCV_ACK_DTOCV_ACK_2 = 0x2
	// SDCLK x 2^17
	USDHC_MMC_BOOT_DTOCV_ACK_DTOCV_ACK_3 = 0x3
	// SDCLK x 2^18
	USDHC_MMC_BOOT_DTOCV_ACK_DTOCV_ACK_4 = 0x4
	// SDCLK x 2^19
	USDHC_MMC_BOOT_DTOCV_ACK_DTOCV_ACK_5 = 0x5
	// SDCLK x 2^20
	USDHC_MMC_BOOT_DTOCV_ACK_DTOCV_ACK_6 = 0x6
	// SDCLK x 2^21
	USDHC_MMC_BOOT_DTOCV_ACK_DTOCV_ACK_7 = 0x7
	// SDCLK x 2^28
	USDHC_MMC_BOOT_DTOCV_ACK_DTOCV_ACK_14 = 0xe
	// SDCLK x 2^29
	USDHC_MMC_BOOT_DTOCV_ACK_DTOCV_ACK_15 = 0xf
	// Position of BOOT_ACK field.
	USDHC_MMC_BOOT_BOOT_ACK_Pos = 0x4
	// Bit mask of BOOT_ACK field.
	USDHC_MMC_BOOT_BOOT_ACK_Msk = 0x10
	// Bit BOOT_ACK.
	USDHC_MMC_BOOT_BOOT_ACK = 0x10
	// No ack
	USDHC_MMC_BOOT_BOOT_ACK_BOOT_ACK_0 = 0x0
	// Ack
	USDHC_MMC_BOOT_BOOT_ACK_BOOT_ACK_1 = 0x1
	// Position of BOOT_MODE field.
	USDHC_MMC_BOOT_BOOT_MODE_Pos = 0x5
	// Bit mask of BOOT_MODE field.
	USDHC_MMC_BOOT_BOOT_MODE_Msk = 0x20
	// Bit BOOT_MODE.
	USDHC_MMC_BOOT_BOOT_MODE = 0x20
	// Normal boot
	USDHC_MMC_BOOT_BOOT_MODE_BOOT_MODE_0 = 0x0
	// Alternative boot
	USDHC_MMC_BOOT_BOOT_MODE_BOOT_MODE_1 = 0x1
	// Position of BOOT_EN field.
	USDHC_MMC_BOOT_BOOT_EN_Pos = 0x6
	// Bit mask of BOOT_EN field.
	USDHC_MMC_BOOT_BOOT_EN_Msk = 0x40
	// Bit BOOT_EN.
	USDHC_MMC_BOOT_BOOT_EN = 0x40
	// Fast boot disable
	USDHC_MMC_BOOT_BOOT_EN_BOOT_EN_0 = 0x0
	// Fast boot enable
	USDHC_MMC_BOOT_BOOT_EN_BOOT_EN_1 = 0x1
	// Position of AUTO_SABG_EN field.
	USDHC_MMC_BOOT_AUTO_SABG_EN_Pos = 0x7
	// Bit mask of AUTO_SABG_EN field.
	USDHC_MMC_BOOT_AUTO_SABG_EN_Msk = 0x80
	// Bit AUTO_SABG_EN.
	USDHC_MMC_BOOT_AUTO_SABG_EN = 0x80
	// Position of DISABLE_TIME_OUT field.
	USDHC_MMC_BOOT_DISABLE_TIME_OUT_Pos = 0x8
	// Bit mask of DISABLE_TIME_OUT field.
	USDHC_MMC_BOOT_DISABLE_TIME_OUT_Msk = 0x100
	// Bit DISABLE_TIME_OUT.
	USDHC_MMC_BOOT_DISABLE_TIME_OUT = 0x100
	// Enable time out
	USDHC_MMC_BOOT_DISABLE_TIME_OUT_DISABLE_TIME_OUT_0 = 0x0
	// Disable time out
	USDHC_MMC_BOOT_DISABLE_TIME_OUT_DISABLE_TIME_OUT_1 = 0x1
	// Position of BOOT_BLK_CNT field.
	USDHC_MMC_BOOT_BOOT_BLK_CNT_Pos = 0x10
	// Bit mask of BOOT_BLK_CNT field.
	USDHC_MMC_BOOT_BOOT_BLK_CNT_Msk = 0xffff0000

	// VEND_SPEC2: Vendor Specific 2 Register
	// Position of CARD_INT_D3_TEST field.
	USDHC_VEND_SPEC2_CARD_INT_D3_TEST_Pos = 0x3
	// Bit mask of CARD_INT_D3_TEST field.
	USDHC_VEND_SPEC2_CARD_INT_D3_TEST_Msk = 0x8
	// Bit CARD_INT_D3_TEST.
	USDHC_VEND_SPEC2_CARD_INT_D3_TEST = 0x8
	// Check the card interrupt only when DATA3 is high.
	USDHC_VEND_SPEC2_CARD_INT_D3_TEST_CARD_INT_D3_TEST_0 = 0x0
	// Check the card interrupt by ignoring the status of DATA3.
	USDHC_VEND_SPEC2_CARD_INT_D3_TEST_CARD_INT_D3_TEST_1 = 0x1
	// Position of TUNING_8bit_EN field.
	USDHC_VEND_SPEC2_TUNING_8bit_EN_Pos = 0x4
	// Bit mask of TUNING_8bit_EN field.
	USDHC_VEND_SPEC2_TUNING_8bit_EN_Msk = 0x10
	// Bit TUNING_8bit_EN.
	USDHC_VEND_SPEC2_TUNING_8bit_EN = 0x10
	// Position of TUNING_1bit_EN field.
	USDHC_VEND_SPEC2_TUNING_1bit_EN_Pos = 0x5
	// Bit mask of TUNING_1bit_EN field.
	USDHC_VEND_SPEC2_TUNING_1bit_EN_Msk = 0x20
	// Bit TUNING_1bit_EN.
	USDHC_VEND_SPEC2_TUNING_1bit_EN = 0x20
	// Position of TUNING_CMD_EN field.
	USDHC_VEND_SPEC2_TUNING_CMD_EN_Pos = 0x6
	// Bit mask of TUNING_CMD_EN field.
	USDHC_VEND_SPEC2_TUNING_CMD_EN_Msk = 0x40
	// Bit TUNING_CMD_EN.
	USDHC_VEND_SPEC2_TUNING_CMD_EN = 0x40
	// Auto tuning circuit does not check the CMD line.
	USDHC_VEND_SPEC2_TUNING_CMD_EN_TUNING_CMD_EN_0 = 0x0
	// Auto tuning circuit checks the CMD line.
	USDHC_VEND_SPEC2_TUNING_CMD_EN_TUNING_CMD_EN_1 = 0x1
	// Position of ACMD23_ARGU2_EN field.
	USDHC_VEND_SPEC2_ACMD23_ARGU2_EN_Pos = 0xc
	// Bit mask of ACMD23_ARGU2_EN field.
	USDHC_VEND_SPEC2_ACMD23_ARGU2_EN_Msk = 0x1000
	// Bit ACMD23_ARGU2_EN.
	USDHC_VEND_SPEC2_ACMD23_ARGU2_EN = 0x1000
	// Disable
	USDHC_VEND_SPEC2_ACMD23_ARGU2_EN_ACMD23_ARGU2_EN_0 = 0x0
	// Argument2 register enable for ACMD23 sharing with SDMA system address register. Default is enable.
	USDHC_VEND_SPEC2_ACMD23_ARGU2_EN_ACMD23_ARGU2_EN_1 = 0x1
	// Position of PART_DLL_DEBUG field.
	USDHC_VEND_SPEC2_PART_DLL_DEBUG_Pos = 0xd
	// Bit mask of PART_DLL_DEBUG field.
	USDHC_VEND_SPEC2_PART_DLL_DEBUG_Msk = 0x2000
	// Bit PART_DLL_DEBUG.
	USDHC_VEND_SPEC2_PART_DLL_DEBUG = 0x2000
	// Position of BUS_RST field.
	USDHC_VEND_SPEC2_BUS_RST_Pos = 0xe
	// Bit mask of BUS_RST field.
	USDHC_VEND_SPEC2_BUS_RST_Msk = 0x4000
	// Bit BUS_RST.
	USDHC_VEND_SPEC2_BUS_RST = 0x4000

	// TUNING_CTRL: Tuning Control Register
	// Position of TUNING_START_TAP field.
	USDHC_TUNING_CTRL_TUNING_START_TAP_Pos = 0x0
	// Bit mask of TUNING_START_TAP field.
	USDHC_TUNING_CTRL_TUNING_START_TAP_Msk = 0xff
	// Position of TUNING_COUNTER field.
	USDHC_TUNING_CTRL_TUNING_COUNTER_Pos = 0x8
	// Bit mask of TUNING_COUNTER field.
	USDHC_TUNING_CTRL_TUNING_COUNTER_Msk = 0xff00
	// Position of TUNING_STEP field.
	USDHC_TUNING_CTRL_TUNING_STEP_Pos = 0x10
	// Bit mask of TUNING_STEP field.
	USDHC_TUNING_CTRL_TUNING_STEP_Msk = 0x70000
	// Position of TUNING_WINDOW field.
	USDHC_TUNING_CTRL_TUNING_WINDOW_Pos = 0x14
	// Bit mask of TUNING_WINDOW field.
	USDHC_TUNING_CTRL_TUNING_WINDOW_Msk = 0x700000
	// Position of STD_TUNING_EN field.
	USDHC_TUNING_CTRL_STD_TUNING_EN_Pos = 0x18
	// Bit mask of STD_TUNING_EN field.
	USDHC_TUNING_CTRL_STD_TUNING_EN_Msk = 0x1000000
	// Bit STD_TUNING_EN.
	USDHC_TUNING_CTRL_STD_TUNING_EN = 0x1000000
)

// Bitfields for ENET: Ethernet MAC-NET Core
const (
	// EIR: Interrupt Event Register
	// Position of TS_TIMER field.
	ENET_EIR_TS_TIMER_Pos = 0xf
	// Bit mask of TS_TIMER field.
	ENET_EIR_TS_TIMER_Msk = 0x8000
	// Bit TS_TIMER.
	ENET_EIR_TS_TIMER = 0x8000
	// Position of TS_AVAIL field.
	ENET_EIR_TS_AVAIL_Pos = 0x10
	// Bit mask of TS_AVAIL field.
	ENET_EIR_TS_AVAIL_Msk = 0x10000
	// Bit TS_AVAIL.
	ENET_EIR_TS_AVAIL = 0x10000
	// Position of WAKEUP field.
	ENET_EIR_WAKEUP_Pos = 0x11
	// Bit mask of WAKEUP field.
	ENET_EIR_WAKEUP_Msk = 0x20000
	// Bit WAKEUP.
	ENET_EIR_WAKEUP = 0x20000
	// Position of PLR field.
	ENET_EIR_PLR_Pos = 0x12
	// Bit mask of PLR field.
	ENET_EIR_PLR_Msk = 0x40000
	// Bit PLR.
	ENET_EIR_PLR = 0x40000
	// Position of UN field.
	ENET_EIR_UN_Pos = 0x13
	// Bit mask of UN field.
	ENET_EIR_UN_Msk = 0x80000
	// Bit UN.
	ENET_EIR_UN = 0x80000
	// Position of RL field.
	ENET_EIR_RL_Pos = 0x14
	// Bit mask of RL field.
	ENET_EIR_RL_Msk = 0x100000
	// Bit RL.
	ENET_EIR_RL = 0x100000
	// Position of LC field.
	ENET_EIR_LC_Pos = 0x15
	// Bit mask of LC field.
	ENET_EIR_LC_Msk = 0x200000
	// Bit LC.
	ENET_EIR_LC = 0x200000
	// Position of EBERR field.
	ENET_EIR_EBERR_Pos = 0x16
	// Bit mask of EBERR field.
	ENET_EIR_EBERR_Msk = 0x400000
	// Bit EBERR.
	ENET_EIR_EBERR = 0x400000
	// Position of MII field.
	ENET_EIR_MII_Pos = 0x17
	// Bit mask of MII field.
	ENET_EIR_MII_Msk = 0x800000
	// Bit MII.
	ENET_EIR_MII = 0x800000
	// Position of RXB field.
	ENET_EIR_RXB_Pos = 0x18
	// Bit mask of RXB field.
	ENET_EIR_RXB_Msk = 0x1000000
	// Bit RXB.
	ENET_EIR_RXB = 0x1000000
	// Position of RXF field.
	ENET_EIR_RXF_Pos = 0x19
	// Bit mask of RXF field.
	ENET_EIR_RXF_Msk = 0x2000000
	// Bit RXF.
	ENET_EIR_RXF = 0x2000000
	// Position of TXB field.
	ENET_EIR_TXB_Pos = 0x1a
	// Bit mask of TXB field.
	ENET_EIR_TXB_Msk = 0x4000000
	// Bit TXB.
	ENET_EIR_TXB = 0x4000000
	// Position of TXF field.
	ENET_EIR_TXF_Pos = 0x1b
	// Bit mask of TXF field.
	ENET_EIR_TXF_Msk = 0x8000000
	// Bit TXF.
	ENET_EIR_TXF = 0x8000000
	// Position of GRA field.
	ENET_EIR_GRA_Pos = 0x1c
	// Bit mask of GRA field.
	ENET_EIR_GRA_Msk = 0x10000000
	// Bit GRA.
	ENET_EIR_GRA = 0x10000000
	// Position of BABT field.
	ENET_EIR_BABT_Pos = 0x1d
	// Bit mask of BABT field.
	ENET_EIR_BABT_Msk = 0x20000000
	// Bit BABT.
	ENET_EIR_BABT = 0x20000000
	// Position of BABR field.
	ENET_EIR_BABR_Pos = 0x1e
	// Bit mask of BABR field.
	ENET_EIR_BABR_Msk = 0x40000000
	// Bit BABR.
	ENET_EIR_BABR = 0x40000000

	// EIMR: Interrupt Mask Register
	// Position of TS_TIMER field.
	ENET_EIMR_TS_TIMER_Pos = 0xf
	// Bit mask of TS_TIMER field.
	ENET_EIMR_TS_TIMER_Msk = 0x8000
	// Bit TS_TIMER.
	ENET_EIMR_TS_TIMER = 0x8000
	// Position of TS_AVAIL field.
	ENET_EIMR_TS_AVAIL_Pos = 0x10
	// Bit mask of TS_AVAIL field.
	ENET_EIMR_TS_AVAIL_Msk = 0x10000
	// Bit TS_AVAIL.
	ENET_EIMR_TS_AVAIL = 0x10000
	// Position of WAKEUP field.
	ENET_EIMR_WAKEUP_Pos = 0x11
	// Bit mask of WAKEUP field.
	ENET_EIMR_WAKEUP_Msk = 0x20000
	// Bit WAKEUP.
	ENET_EIMR_WAKEUP = 0x20000
	// Position of PLR field.
	ENET_EIMR_PLR_Pos = 0x12
	// Bit mask of PLR field.
	ENET_EIMR_PLR_Msk = 0x40000
	// Bit PLR.
	ENET_EIMR_PLR = 0x40000
	// Position of UN field.
	ENET_EIMR_UN_Pos = 0x13
	// Bit mask of UN field.
	ENET_EIMR_UN_Msk = 0x80000
	// Bit UN.
	ENET_EIMR_UN = 0x80000
	// Position of RL field.
	ENET_EIMR_RL_Pos = 0x14
	// Bit mask of RL field.
	ENET_EIMR_RL_Msk = 0x100000
	// Bit RL.
	ENET_EIMR_RL = 0x100000
	// Position of LC field.
	ENET_EIMR_LC_Pos = 0x15
	// Bit mask of LC field.
	ENET_EIMR_LC_Msk = 0x200000
	// Bit LC.
	ENET_EIMR_LC = 0x200000
	// Position of EBERR field.
	ENET_EIMR_EBERR_Pos = 0x16
	// Bit mask of EBERR field.
	ENET_EIMR_EBERR_Msk = 0x400000
	// Bit EBERR.
	ENET_EIMR_EBERR = 0x400000
	// Position of MII field.
	ENET_EIMR_MII_Pos = 0x17
	// Bit mask of MII field.
	ENET_EIMR_MII_Msk = 0x800000
	// Bit MII.
	ENET_EIMR_MII = 0x800000
	// Position of RXB field.
	ENET_EIMR_RXB_Pos = 0x18
	// Bit mask of RXB field.
	ENET_EIMR_RXB_Msk = 0x1000000
	// Bit RXB.
	ENET_EIMR_RXB = 0x1000000
	// Position of RXF field.
	ENET_EIMR_RXF_Pos = 0x19
	// Bit mask of RXF field.
	ENET_EIMR_RXF_Msk = 0x2000000
	// Bit RXF.
	ENET_EIMR_RXF = 0x2000000
	// Position of TXB field.
	ENET_EIMR_TXB_Pos = 0x1a
	// Bit mask of TXB field.
	ENET_EIMR_TXB_Msk = 0x4000000
	// Bit TXB.
	ENET_EIMR_TXB = 0x4000000
	// The corresponding interrupt source is masked.
	ENET_EIMR_TXB_TXB_0 = 0x0
	// The corresponding interrupt source is not masked.
	ENET_EIMR_TXB_TXB_1 = 0x1
	// Position of TXF field.
	ENET_EIMR_TXF_Pos = 0x1b
	// Bit mask of TXF field.
	ENET_EIMR_TXF_Msk = 0x8000000
	// Bit TXF.
	ENET_EIMR_TXF = 0x8000000
	// The corresponding interrupt source is masked.
	ENET_EIMR_TXF_TXF_0 = 0x0
	// The corresponding interrupt source is not masked.
	ENET_EIMR_TXF_TXF_1 = 0x1
	// Position of GRA field.
	ENET_EIMR_GRA_Pos = 0x1c
	// Bit mask of GRA field.
	ENET_EIMR_GRA_Msk = 0x10000000
	// Bit GRA.
	ENET_EIMR_GRA = 0x10000000
	// The corresponding interrupt source is masked.
	ENET_EIMR_GRA_GRA_0 = 0x0
	// The corresponding interrupt source is not masked.
	ENET_EIMR_GRA_GRA_1 = 0x1
	// Position of BABT field.
	ENET_EIMR_BABT_Pos = 0x1d
	// Bit mask of BABT field.
	ENET_EIMR_BABT_Msk = 0x20000000
	// Bit BABT.
	ENET_EIMR_BABT = 0x20000000
	// The corresponding interrupt source is masked.
	ENET_EIMR_BABT_BABT_0 = 0x0
	// The corresponding interrupt source is not masked.
	ENET_EIMR_BABT_BABT_1 = 0x1
	// Position of BABR field.
	ENET_EIMR_BABR_Pos = 0x1e
	// Bit mask of BABR field.
	ENET_EIMR_BABR_Msk = 0x40000000
	// Bit BABR.
	ENET_EIMR_BABR = 0x40000000
	// The corresponding interrupt source is masked.
	ENET_EIMR_BABR_BABR_0 = 0x0
	// The corresponding interrupt source is not masked.
	ENET_EIMR_BABR_BABR_1 = 0x1

	// RDAR: Receive Descriptor Active Register
	// Position of RDAR field.
	ENET_RDAR_RDAR_Pos = 0x18
	// Bit mask of RDAR field.
	ENET_RDAR_RDAR_Msk = 0x1000000
	// Bit RDAR.
	ENET_RDAR_RDAR = 0x1000000

	// TDAR: Transmit Descriptor Active Register
	// Position of TDAR field.
	ENET_TDAR_TDAR_Pos = 0x18
	// Bit mask of TDAR field.
	ENET_TDAR_TDAR_Msk = 0x1000000
	// Bit TDAR.
	ENET_TDAR_TDAR = 0x1000000

	// ECR: Ethernet Control Register
	// Position of RESET field.
	ENET_ECR_RESET_Pos = 0x0
	// Bit mask of RESET field.
	ENET_ECR_RESET_Msk = 0x1
	// Bit RESET.
	ENET_ECR_RESET = 0x1
	// Position of ETHEREN field.
	ENET_ECR_ETHEREN_Pos = 0x1
	// Bit mask of ETHEREN field.
	ENET_ECR_ETHEREN_Msk = 0x2
	// Bit ETHEREN.
	ENET_ECR_ETHEREN = 0x2
	// Reception immediately stops and transmission stops after a bad CRC is appended to any currently transmitted frame.
	ENET_ECR_ETHEREN_ETHEREN_0 = 0x0
	// MAC is enabled, and reception and transmission are possible.
	ENET_ECR_ETHEREN_ETHEREN_1 = 0x1
	// Position of MAGICEN field.
	ENET_ECR_MAGICEN_Pos = 0x2
	// Bit mask of MAGICEN field.
	ENET_ECR_MAGICEN_Msk = 0x4
	// Bit MAGICEN.
	ENET_ECR_MAGICEN = 0x4
	// Magic detection logic disabled.
	ENET_ECR_MAGICEN_MAGICEN_0 = 0x0
	// The MAC core detects magic packets and asserts EIR[WAKEUP] when a frame is detected.
	ENET_ECR_MAGICEN_MAGICEN_1 = 0x1
	// Position of SLEEP field.
	ENET_ECR_SLEEP_Pos = 0x3
	// Bit mask of SLEEP field.
	ENET_ECR_SLEEP_Msk = 0x8
	// Bit SLEEP.
	ENET_ECR_SLEEP = 0x8
	// Normal operating mode.
	ENET_ECR_SLEEP_SLEEP_0 = 0x0
	// Sleep mode.
	ENET_ECR_SLEEP_SLEEP_1 = 0x1
	// Position of EN1588 field.
	ENET_ECR_EN1588_Pos = 0x4
	// Bit mask of EN1588 field.
	ENET_ECR_EN1588_Msk = 0x10
	// Bit EN1588.
	ENET_ECR_EN1588 = 0x10
	// Legacy FEC buffer descriptors and functions enabled.
	ENET_ECR_EN1588_EN1588_0 = 0x0
	// Enhanced frame time-stamping functions enabled.
	ENET_ECR_EN1588_EN1588_1 = 0x1
	// Position of DBGEN field.
	ENET_ECR_DBGEN_Pos = 0x6
	// Bit mask of DBGEN field.
	ENET_ECR_DBGEN_Msk = 0x40
	// Bit DBGEN.
	ENET_ECR_DBGEN = 0x40
	// MAC continues operation in debug mode.
	ENET_ECR_DBGEN_DBGEN_0 = 0x0
	// MAC enters hardware freeze mode when the processor is in debug mode.
	ENET_ECR_DBGEN_DBGEN_1 = 0x1
	// Position of DBSWP field.
	ENET_ECR_DBSWP_Pos = 0x8
	// Bit mask of DBSWP field.
	ENET_ECR_DBSWP_Msk = 0x100
	// Bit DBSWP.
	ENET_ECR_DBSWP = 0x100
	// The buffer descriptor bytes are not swapped to support big-endian devices.
	ENET_ECR_DBSWP_DBSWP_0 = 0x0
	// The buffer descriptor bytes are swapped to support little-endian devices.
	ENET_ECR_DBSWP_DBSWP_1 = 0x1

	// MMFR: MII Management Frame Register
	// Position of DATA field.
	ENET_MMFR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	ENET_MMFR_DATA_Msk = 0xffff
	// Position of TA field.
	ENET_MMFR_TA_Pos = 0x10
	// Bit mask of TA field.
	ENET_MMFR_TA_Msk = 0x30000
	// Position of RA field.
	ENET_MMFR_RA_Pos = 0x12
	// Bit mask of RA field.
	ENET_MMFR_RA_Msk = 0x7c0000
	// Position of PA field.
	ENET_MMFR_PA_Pos = 0x17
	// Bit mask of PA field.
	ENET_MMFR_PA_Msk = 0xf800000
	// Position of OP field.
	ENET_MMFR_OP_Pos = 0x1c
	// Bit mask of OP field.
	ENET_MMFR_OP_Msk = 0x30000000
	// Position of ST field.
	ENET_MMFR_ST_Pos = 0x1e
	// Bit mask of ST field.
	ENET_MMFR_ST_Msk = 0xc0000000

	// MSCR: MII Speed Control Register
	// Position of MII_SPEED field.
	ENET_MSCR_MII_SPEED_Pos = 0x1
	// Bit mask of MII_SPEED field.
	ENET_MSCR_MII_SPEED_Msk = 0x7e
	// Position of DIS_PRE field.
	ENET_MSCR_DIS_PRE_Pos = 0x7
	// Bit mask of DIS_PRE field.
	ENET_MSCR_DIS_PRE_Msk = 0x80
	// Bit DIS_PRE.
	ENET_MSCR_DIS_PRE = 0x80
	// Preamble enabled.
	ENET_MSCR_DIS_PRE_DIS_PRE_0 = 0x0
	// Preamble (32 ones) is not prepended to the MII management frame.
	ENET_MSCR_DIS_PRE_DIS_PRE_1 = 0x1
	// Position of HOLDTIME field.
	ENET_MSCR_HOLDTIME_Pos = 0x8
	// Bit mask of HOLDTIME field.
	ENET_MSCR_HOLDTIME_Msk = 0x700
	// 1 internal module clock cycle
	ENET_MSCR_HOLDTIME_HOLDTIME_0 = 0x0
	// 2 internal module clock cycles
	ENET_MSCR_HOLDTIME_HOLDTIME_1 = 0x1
	// 3 internal module clock cycles
	ENET_MSCR_HOLDTIME_HOLDTIME_2 = 0x2
	// 8 internal module clock cycles
	ENET_MSCR_HOLDTIME_HOLDTIME_7 = 0x7

	// MIBC: MIB Control Register
	// Position of MIB_CLEAR field.
	ENET_MIBC_MIB_CLEAR_Pos = 0x1d
	// Bit mask of MIB_CLEAR field.
	ENET_MIBC_MIB_CLEAR_Msk = 0x20000000
	// Bit MIB_CLEAR.
	ENET_MIBC_MIB_CLEAR = 0x20000000
	// See note above.
	ENET_MIBC_MIB_CLEAR_MIB_CLEAR_0 = 0x0
	// All statistics counters are reset to 0.
	ENET_MIBC_MIB_CLEAR_MIB_CLEAR_1 = 0x1
	// Position of MIB_IDLE field.
	ENET_MIBC_MIB_IDLE_Pos = 0x1e
	// Bit mask of MIB_IDLE field.
	ENET_MIBC_MIB_IDLE_Msk = 0x40000000
	// Bit MIB_IDLE.
	ENET_MIBC_MIB_IDLE = 0x40000000
	// The MIB block is updating MIB counters.
	ENET_MIBC_MIB_IDLE_MIB_IDLE_0 = 0x0
	// The MIB block is not currently updating any MIB counters.
	ENET_MIBC_MIB_IDLE_MIB_IDLE_1 = 0x1
	// Position of MIB_DIS field.
	ENET_MIBC_MIB_DIS_Pos = 0x1f
	// Bit mask of MIB_DIS field.
	ENET_MIBC_MIB_DIS_Msk = 0x80000000
	// Bit MIB_DIS.
	ENET_MIBC_MIB_DIS = 0x80000000
	// MIB logic is enabled.
	ENET_MIBC_MIB_DIS_MIB_DIS_0 = 0x0
	// MIB logic is disabled. The MIB logic halts and does not update any MIB counters.
	ENET_MIBC_MIB_DIS_MIB_DIS_1 = 0x1

	// RCR: Receive Control Register
	// Position of LOOP field.
	ENET_RCR_LOOP_Pos = 0x0
	// Bit mask of LOOP field.
	ENET_RCR_LOOP_Msk = 0x1
	// Bit LOOP.
	ENET_RCR_LOOP = 0x1
	// Loopback disabled.
	ENET_RCR_LOOP_LOOP_0 = 0x0
	// Transmitted frames are looped back internal to the device and transmit MII output signals are not asserted. DRT must be cleared.
	ENET_RCR_LOOP_LOOP_1 = 0x1
	// Position of DRT field.
	ENET_RCR_DRT_Pos = 0x1
	// Bit mask of DRT field.
	ENET_RCR_DRT_Msk = 0x2
	// Bit DRT.
	ENET_RCR_DRT = 0x2
	// Receive path operates independently of transmit (i.e., full-duplex mode). Can also be used to monitor transmit activity in half-duplex mode.
	ENET_RCR_DRT_DRT_0 = 0x0
	// Disable reception of frames while transmitting. (Normally used for half-duplex mode.)
	ENET_RCR_DRT_DRT_1 = 0x1
	// Position of MII_MODE field.
	ENET_RCR_MII_MODE_Pos = 0x2
	// Bit mask of MII_MODE field.
	ENET_RCR_MII_MODE_Msk = 0x4
	// Bit MII_MODE.
	ENET_RCR_MII_MODE = 0x4
	// MII or RMII mode, as indicated by the RMII_MODE field.
	ENET_RCR_MII_MODE_MII_MODE_1 = 0x1
	// Position of PROM field.
	ENET_RCR_PROM_Pos = 0x3
	// Bit mask of PROM field.
	ENET_RCR_PROM_Msk = 0x8
	// Bit PROM.
	ENET_RCR_PROM = 0x8
	// Disabled.
	ENET_RCR_PROM_PROM_0 = 0x0
	// Enabled.
	ENET_RCR_PROM_PROM_1 = 0x1
	// Position of BC_REJ field.
	ENET_RCR_BC_REJ_Pos = 0x4
	// Bit mask of BC_REJ field.
	ENET_RCR_BC_REJ_Msk = 0x10
	// Bit BC_REJ.
	ENET_RCR_BC_REJ = 0x10
	// Position of FCE field.
	ENET_RCR_FCE_Pos = 0x5
	// Bit mask of FCE field.
	ENET_RCR_FCE_Msk = 0x20
	// Bit FCE.
	ENET_RCR_FCE = 0x20
	// Position of RMII_MODE field.
	ENET_RCR_RMII_MODE_Pos = 0x8
	// Bit mask of RMII_MODE field.
	ENET_RCR_RMII_MODE_Msk = 0x100
	// Bit RMII_MODE.
	ENET_RCR_RMII_MODE = 0x100
	// MAC configured for MII mode.
	ENET_RCR_RMII_MODE_RMII_MODE_0 = 0x0
	// MAC configured for RMII operation.
	ENET_RCR_RMII_MODE_RMII_MODE_1 = 0x1
	// Position of RMII_10T field.
	ENET_RCR_RMII_10T_Pos = 0x9
	// Bit mask of RMII_10T field.
	ENET_RCR_RMII_10T_Msk = 0x200
	// Bit RMII_10T.
	ENET_RCR_RMII_10T = 0x200
	// 100-Mbit/s operation.
	ENET_RCR_RMII_10T_RMII_10T_0 = 0x0
	// 10-Mbit/s operation.
	ENET_RCR_RMII_10T_RMII_10T_1 = 0x1
	// Position of PADEN field.
	ENET_RCR_PADEN_Pos = 0xc
	// Bit mask of PADEN field.
	ENET_RCR_PADEN_Msk = 0x1000
	// Bit PADEN.
	ENET_RCR_PADEN = 0x1000
	// No padding is removed on receive by the MAC.
	ENET_RCR_PADEN_PADEN_0 = 0x0
	// Padding is removed from received frames.
	ENET_RCR_PADEN_PADEN_1 = 0x1
	// Position of PAUFWD field.
	ENET_RCR_PAUFWD_Pos = 0xd
	// Bit mask of PAUFWD field.
	ENET_RCR_PAUFWD_Msk = 0x2000
	// Bit PAUFWD.
	ENET_RCR_PAUFWD = 0x2000
	// Pause frames are terminated and discarded in the MAC.
	ENET_RCR_PAUFWD_PAUFWD_0 = 0x0
	// Pause frames are forwarded to the user application.
	ENET_RCR_PAUFWD_PAUFWD_1 = 0x1
	// Position of CRCFWD field.
	ENET_RCR_CRCFWD_Pos = 0xe
	// Bit mask of CRCFWD field.
	ENET_RCR_CRCFWD_Msk = 0x4000
	// Bit CRCFWD.
	ENET_RCR_CRCFWD = 0x4000
	// The CRC field of received frames is transmitted to the user application.
	ENET_RCR_CRCFWD_CRCFWD_0 = 0x0
	// The CRC field is stripped from the frame.
	ENET_RCR_CRCFWD_CRCFWD_1 = 0x1
	// Position of CFEN field.
	ENET_RCR_CFEN_Pos = 0xf
	// Bit mask of CFEN field.
	ENET_RCR_CFEN_Msk = 0x8000
	// Bit CFEN.
	ENET_RCR_CFEN = 0x8000
	// MAC control frames with any opcode other than 0x0001 (pause frame) are accepted and forwarded to the client interface.
	ENET_RCR_CFEN_CFEN_0 = 0x0
	// MAC control frames with any opcode other than 0x0001 (pause frame) are silently discarded.
	ENET_RCR_CFEN_CFEN_1 = 0x1
	// Position of MAX_FL field.
	ENET_RCR_MAX_FL_Pos = 0x10
	// Bit mask of MAX_FL field.
	ENET_RCR_MAX_FL_Msk = 0x3fff0000
	// Position of NLC field.
	ENET_RCR_NLC_Pos = 0x1e
	// Bit mask of NLC field.
	ENET_RCR_NLC_Msk = 0x40000000
	// Bit NLC.
	ENET_RCR_NLC = 0x40000000
	// The payload length check is disabled.
	ENET_RCR_NLC_NLC_0 = 0x0
	// The core checks the frame's payload length with the frame length/type field. Errors are indicated in the EIR[PLR] field.
	ENET_RCR_NLC_NLC_1 = 0x1
	// Position of GRS field.
	ENET_RCR_GRS_Pos = 0x1f
	// Bit mask of GRS field.
	ENET_RCR_GRS_Msk = 0x80000000
	// Bit GRS.
	ENET_RCR_GRS = 0x80000000

	// TCR: Transmit Control Register
	// Position of GTS field.
	ENET_TCR_GTS_Pos = 0x0
	// Bit mask of GTS field.
	ENET_TCR_GTS_Msk = 0x1
	// Bit GTS.
	ENET_TCR_GTS = 0x1
	// Position of FDEN field.
	ENET_TCR_FDEN_Pos = 0x2
	// Bit mask of FDEN field.
	ENET_TCR_FDEN_Msk = 0x4
	// Bit FDEN.
	ENET_TCR_FDEN = 0x4
	// Position of TFC_PAUSE field.
	ENET_TCR_TFC_PAUSE_Pos = 0x3
	// Bit mask of TFC_PAUSE field.
	ENET_TCR_TFC_PAUSE_Msk = 0x8
	// Bit TFC_PAUSE.
	ENET_TCR_TFC_PAUSE = 0x8
	// No PAUSE frame transmitted.
	ENET_TCR_TFC_PAUSE_TFC_PAUSE_0 = 0x0
	// The MAC stops transmission of data frames after the current transmission is complete.
	ENET_TCR_TFC_PAUSE_TFC_PAUSE_1 = 0x1
	// Position of RFC_PAUSE field.
	ENET_TCR_RFC_PAUSE_Pos = 0x4
	// Bit mask of RFC_PAUSE field.
	ENET_TCR_RFC_PAUSE_Msk = 0x10
	// Bit RFC_PAUSE.
	ENET_TCR_RFC_PAUSE = 0x10
	// Position of ADDSEL field.
	ENET_TCR_ADDSEL_Pos = 0x5
	// Bit mask of ADDSEL field.
	ENET_TCR_ADDSEL_Msk = 0xe0
	// Node MAC address programmed on PADDR1/2 registers.
	ENET_TCR_ADDSEL_ADDSEL_0 = 0x0
	// Position of ADDINS field.
	ENET_TCR_ADDINS_Pos = 0x8
	// Bit mask of ADDINS field.
	ENET_TCR_ADDINS_Msk = 0x100
	// Bit ADDINS.
	ENET_TCR_ADDINS = 0x100
	// The source MAC address is not modified by the MAC.
	ENET_TCR_ADDINS_ADDINS_0 = 0x0
	// The MAC overwrites the source MAC address with the programmed MAC address according to ADDSEL.
	ENET_TCR_ADDINS_ADDINS_1 = 0x1
	// Position of CRCFWD field.
	ENET_TCR_CRCFWD_Pos = 0x9
	// Bit mask of CRCFWD field.
	ENET_TCR_CRCFWD_Msk = 0x200
	// Bit CRCFWD.
	ENET_TCR_CRCFWD = 0x200
	// TxBD[TC] controls whether the frame has a CRC from the application.
	ENET_TCR_CRCFWD_CRCFWD_0 = 0x0
	// The transmitter does not append any CRC to transmitted frames, as it is expecting a frame with CRC from the application.
	ENET_TCR_CRCFWD_CRCFWD_1 = 0x1

	// PALR: Physical Address Lower Register
	// Position of PADDR1 field.
	ENET_PALR_PADDR1_Pos = 0x0
	// Bit mask of PADDR1 field.
	ENET_PALR_PADDR1_Msk = 0xffffffff

	// PAUR: Physical Address Upper Register
	// Position of TYPE field.
	ENET_PAUR_TYPE_Pos = 0x0
	// Bit mask of TYPE field.
	ENET_PAUR_TYPE_Msk = 0xffff
	// Position of PADDR2 field.
	ENET_PAUR_PADDR2_Pos = 0x10
	// Bit mask of PADDR2 field.
	ENET_PAUR_PADDR2_Msk = 0xffff0000

	// OPD: Opcode/Pause Duration Register
	// Position of PAUSE_DUR field.
	ENET_OPD_PAUSE_DUR_Pos = 0x0
	// Bit mask of PAUSE_DUR field.
	ENET_OPD_PAUSE_DUR_Msk = 0xffff
	// Position of OPCODE field.
	ENET_OPD_OPCODE_Pos = 0x10
	// Bit mask of OPCODE field.
	ENET_OPD_OPCODE_Msk = 0xffff0000

	// TXIC: Transmit Interrupt Coalescing Register
	// Position of ICTT field.
	ENET_TXIC_ICTT_Pos = 0x0
	// Bit mask of ICTT field.
	ENET_TXIC_ICTT_Msk = 0xffff
	// Position of ICFT field.
	ENET_TXIC_ICFT_Pos = 0x14
	// Bit mask of ICFT field.
	ENET_TXIC_ICFT_Msk = 0xff00000
	// Position of ICCS field.
	ENET_TXIC_ICCS_Pos = 0x1e
	// Bit mask of ICCS field.
	ENET_TXIC_ICCS_Msk = 0x40000000
	// Bit ICCS.
	ENET_TXIC_ICCS = 0x40000000
	// Use MII/GMII TX clocks.
	ENET_TXIC_ICCS_ICCS_0 = 0x0
	// Use ENET system clock.
	ENET_TXIC_ICCS_ICCS_1 = 0x1
	// Position of ICEN field.
	ENET_TXIC_ICEN_Pos = 0x1f
	// Bit mask of ICEN field.
	ENET_TXIC_ICEN_Msk = 0x80000000
	// Bit ICEN.
	ENET_TXIC_ICEN = 0x80000000
	// Disable Interrupt coalescing.
	ENET_TXIC_ICEN_ICEN_0 = 0x0
	// Enable Interrupt coalescing.
	ENET_TXIC_ICEN_ICEN_1 = 0x1

	// RXIC: Receive Interrupt Coalescing Register
	// Position of ICTT field.
	ENET_RXIC_ICTT_Pos = 0x0
	// Bit mask of ICTT field.
	ENET_RXIC_ICTT_Msk = 0xffff
	// Position of ICFT field.
	ENET_RXIC_ICFT_Pos = 0x14
	// Bit mask of ICFT field.
	ENET_RXIC_ICFT_Msk = 0xff00000
	// Position of ICCS field.
	ENET_RXIC_ICCS_Pos = 0x1e
	// Bit mask of ICCS field.
	ENET_RXIC_ICCS_Msk = 0x40000000
	// Bit ICCS.
	ENET_RXIC_ICCS = 0x40000000
	// Use MII/GMII TX clocks.
	ENET_RXIC_ICCS_ICCS_0 = 0x0
	// Use ENET system clock.
	ENET_RXIC_ICCS_ICCS_1 = 0x1
	// Position of ICEN field.
	ENET_RXIC_ICEN_Pos = 0x1f
	// Bit mask of ICEN field.
	ENET_RXIC_ICEN_Msk = 0x80000000
	// Bit ICEN.
	ENET_RXIC_ICEN = 0x80000000
	// Disable Interrupt coalescing.
	ENET_RXIC_ICEN_ICEN_0 = 0x0
	// Enable Interrupt coalescing.
	ENET_RXIC_ICEN_ICEN_1 = 0x1

	// IAUR: Descriptor Individual Upper Address Register
	// Position of IADDR1 field.
	ENET_IAUR_IADDR1_Pos = 0x0
	// Bit mask of IADDR1 field.
	ENET_IAUR_IADDR1_Msk = 0xffffffff

	// IALR: Descriptor Individual Lower Address Register
	// Position of IADDR2 field.
	ENET_IALR_IADDR2_Pos = 0x0
	// Bit mask of IADDR2 field.
	ENET_IALR_IADDR2_Msk = 0xffffffff

	// GAUR: Descriptor Group Upper Address Register
	// Position of GADDR1 field.
	ENET_GAUR_GADDR1_Pos = 0x0
	// Bit mask of GADDR1 field.
	ENET_GAUR_GADDR1_Msk = 0xffffffff

	// GALR: Descriptor Group Lower Address Register
	// Position of GADDR2 field.
	ENET_GALR_GADDR2_Pos = 0x0
	// Bit mask of GADDR2 field.
	ENET_GALR_GADDR2_Msk = 0xffffffff

	// TFWR: Transmit FIFO Watermark Register
	// Position of TFWR field.
	ENET_TFWR_TFWR_Pos = 0x0
	// Bit mask of TFWR field.
	ENET_TFWR_TFWR_Msk = 0x3f
	// 64 bytes written.
	ENET_TFWR_TFWR_TFWR_0 = 0x0
	// 64 bytes written.
	ENET_TFWR_TFWR_TFWR_1 = 0x1
	// 128 bytes written.
	ENET_TFWR_TFWR_TFWR_2 = 0x2
	// 192 bytes written.
	ENET_TFWR_TFWR_TFWR_3 = 0x3
	// 1984 bytes written.
	ENET_TFWR_TFWR_TFWR_31 = 0x1f
	// Position of STRFWD field.
	ENET_TFWR_STRFWD_Pos = 0x8
	// Bit mask of STRFWD field.
	ENET_TFWR_STRFWD_Msk = 0x100
	// Bit STRFWD.
	ENET_TFWR_STRFWD = 0x100
	// Reset. The transmission start threshold is programmed in TFWR[TFWR].
	ENET_TFWR_STRFWD_STRFWD_0 = 0x0
	// Enabled.
	ENET_TFWR_STRFWD_STRFWD_1 = 0x1

	// RDSR: Receive Descriptor Ring Start Register
	// Position of R_DES_START field.
	ENET_RDSR_R_DES_START_Pos = 0x3
	// Bit mask of R_DES_START field.
	ENET_RDSR_R_DES_START_Msk = 0xfffffff8

	// TDSR: Transmit Buffer Descriptor Ring Start Register
	// Position of X_DES_START field.
	ENET_TDSR_X_DES_START_Pos = 0x3
	// Bit mask of X_DES_START field.
	ENET_TDSR_X_DES_START_Msk = 0xfffffff8

	// MRBR: Maximum Receive Buffer Size Register
	// Position of R_BUF_SIZE field.
	ENET_MRBR_R_BUF_SIZE_Pos = 0x4
	// Bit mask of R_BUF_SIZE field.
	ENET_MRBR_R_BUF_SIZE_Msk = 0x3ff0

	// RSFL: Receive FIFO Section Full Threshold
	// Position of RX_SECTION_FULL field.
	ENET_RSFL_RX_SECTION_FULL_Pos = 0x0
	// Bit mask of RX_SECTION_FULL field.
	ENET_RSFL_RX_SECTION_FULL_Msk = 0xff

	// RSEM: Receive FIFO Section Empty Threshold
	// Position of RX_SECTION_EMPTY field.
	ENET_RSEM_RX_SECTION_EMPTY_Pos = 0x0
	// Bit mask of RX_SECTION_EMPTY field.
	ENET_RSEM_RX_SECTION_EMPTY_Msk = 0xff
	// Position of STAT_SECTION_EMPTY field.
	ENET_RSEM_STAT_SECTION_EMPTY_Pos = 0x10
	// Bit mask of STAT_SECTION_EMPTY field.
	ENET_RSEM_STAT_SECTION_EMPTY_Msk = 0x1f0000

	// RAEM: Receive FIFO Almost Empty Threshold
	// Position of RX_ALMOST_EMPTY field.
	ENET_RAEM_RX_ALMOST_EMPTY_Pos = 0x0
	// Bit mask of RX_ALMOST_EMPTY field.
	ENET_RAEM_RX_ALMOST_EMPTY_Msk = 0xff

	// RAFL: Receive FIFO Almost Full Threshold
	// Position of RX_ALMOST_FULL field.
	ENET_RAFL_RX_ALMOST_FULL_Pos = 0x0
	// Bit mask of RX_ALMOST_FULL field.
	ENET_RAFL_RX_ALMOST_FULL_Msk = 0xff

	// TSEM: Transmit FIFO Section Empty Threshold
	// Position of TX_SECTION_EMPTY field.
	ENET_TSEM_TX_SECTION_EMPTY_Pos = 0x0
	// Bit mask of TX_SECTION_EMPTY field.
	ENET_TSEM_TX_SECTION_EMPTY_Msk = 0xff

	// TAEM: Transmit FIFO Almost Empty Threshold
	// Position of TX_ALMOST_EMPTY field.
	ENET_TAEM_TX_ALMOST_EMPTY_Pos = 0x0
	// Bit mask of TX_ALMOST_EMPTY field.
	ENET_TAEM_TX_ALMOST_EMPTY_Msk = 0xff

	// TAFL: Transmit FIFO Almost Full Threshold
	// Position of TX_ALMOST_FULL field.
	ENET_TAFL_TX_ALMOST_FULL_Pos = 0x0
	// Bit mask of TX_ALMOST_FULL field.
	ENET_TAFL_TX_ALMOST_FULL_Msk = 0xff

	// TIPG: Transmit Inter-Packet Gap
	// Position of IPG field.
	ENET_TIPG_IPG_Pos = 0x0
	// Bit mask of IPG field.
	ENET_TIPG_IPG_Msk = 0x1f

	// FTRL: Frame Truncation Length
	// Position of TRUNC_FL field.
	ENET_FTRL_TRUNC_FL_Pos = 0x0
	// Bit mask of TRUNC_FL field.
	ENET_FTRL_TRUNC_FL_Msk = 0x3fff

	// TACC: Transmit Accelerator Function Configuration
	// Position of SHIFT16 field.
	ENET_TACC_SHIFT16_Pos = 0x0
	// Bit mask of SHIFT16 field.
	ENET_TACC_SHIFT16_Msk = 0x1
	// Bit SHIFT16.
	ENET_TACC_SHIFT16 = 0x1
	// Disabled.
	ENET_TACC_SHIFT16_SHIFT16_0 = 0x0
	// Indicates to the transmit data FIFO that the written frames contain two additional octets before the frame data. This means the actual frame begins at bit 16 of the first word written into the FIFO. This function allows putting the frame payload on a 32-bit boundary in memory, as the 14-byte Ethernet header is extended to a 16-byte header.
	ENET_TACC_SHIFT16_SHIFT16_1 = 0x1
	// Position of IPCHK field.
	ENET_TACC_IPCHK_Pos = 0x3
	// Bit mask of IPCHK field.
	ENET_TACC_IPCHK_Msk = 0x8
	// Bit IPCHK.
	ENET_TACC_IPCHK = 0x8
	// Checksum is not inserted.
	ENET_TACC_IPCHK_IPCHK_0 = 0x0
	// If an IP frame is transmitted, the checksum is inserted automatically. The IP header checksum field must be cleared. If a non-IP frame is transmitted the frame is not modified.
	ENET_TACC_IPCHK_IPCHK_1 = 0x1
	// Position of PROCHK field.
	ENET_TACC_PROCHK_Pos = 0x4
	// Bit mask of PROCHK field.
	ENET_TACC_PROCHK_Msk = 0x10
	// Bit PROCHK.
	ENET_TACC_PROCHK = 0x10
	// Checksum not inserted.
	ENET_TACC_PROCHK_PROCHK_0 = 0x0
	// If an IP frame with a known protocol is transmitted, the checksum is inserted automatically into the frame. The checksum field must be cleared. The other frames are not modified.
	ENET_TACC_PROCHK_PROCHK_1 = 0x1

	// RACC: Receive Accelerator Function Configuration
	// Position of PADREM field.
	ENET_RACC_PADREM_Pos = 0x0
	// Bit mask of PADREM field.
	ENET_RACC_PADREM_Msk = 0x1
	// Bit PADREM.
	ENET_RACC_PADREM = 0x1
	// Padding not removed.
	ENET_RACC_PADREM_PADREM_0 = 0x0
	// Any bytes following the IP payload section of the frame are removed from the frame.
	ENET_RACC_PADREM_PADREM_1 = 0x1
	// Position of IPDIS field.
	ENET_RACC_IPDIS_Pos = 0x1
	// Bit mask of IPDIS field.
	ENET_RACC_IPDIS_Msk = 0x2
	// Bit IPDIS.
	ENET_RACC_IPDIS = 0x2
	// Frames with wrong IPv4 header checksum are not discarded.
	ENET_RACC_IPDIS_IPDIS_0 = 0x0
	// If an IPv4 frame is received with a mismatching header checksum, the frame is discarded. IPv6 has no header checksum and is not affected by this setting. Discarding is only available when the RX FIFO operates in store and forward mode (RSFL cleared).
	ENET_RACC_IPDIS_IPDIS_1 = 0x1
	// Position of PRODIS field.
	ENET_RACC_PRODIS_Pos = 0x2
	// Bit mask of PRODIS field.
	ENET_RACC_PRODIS_Msk = 0x4
	// Bit PRODIS.
	ENET_RACC_PRODIS = 0x4
	// Frames with wrong checksum are not discarded.
	ENET_RACC_PRODIS_PRODIS_0 = 0x0
	// If a TCP/IP, UDP/IP, or ICMP/IP frame is received that has a wrong TCP, UDP, or ICMP checksum, the frame is discarded. Discarding is only available when the RX FIFO operates in store and forward mode (RSFL cleared).
	ENET_RACC_PRODIS_PRODIS_1 = 0x1
	// Position of LINEDIS field.
	ENET_RACC_LINEDIS_Pos = 0x6
	// Bit mask of LINEDIS field.
	ENET_RACC_LINEDIS_Msk = 0x40
	// Bit LINEDIS.
	ENET_RACC_LINEDIS = 0x40
	// Frames with errors are not discarded.
	ENET_RACC_LINEDIS_LINEDIS_0 = 0x0
	// Any frame received with a CRC, length, or PHY error is automatically discarded and not forwarded to the user application interface.
	ENET_RACC_LINEDIS_LINEDIS_1 = 0x1
	// Position of SHIFT16 field.
	ENET_RACC_SHIFT16_Pos = 0x7
	// Bit mask of SHIFT16 field.
	ENET_RACC_SHIFT16_Msk = 0x80
	// Bit SHIFT16.
	ENET_RACC_SHIFT16 = 0x80
	// Disabled.
	ENET_RACC_SHIFT16_SHIFT16_0 = 0x0
	// Instructs the MAC to write two additional bytes in front of each frame received into the RX FIFO.
	ENET_RACC_SHIFT16_SHIFT16_1 = 0x1

	// RMON_T_PACKETS: Tx Packet Count Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_PACKETS_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_PACKETS_TXPKTS_Msk = 0xffff

	// RMON_T_BC_PKT: Tx Broadcast Packets Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_BC_PKT_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_BC_PKT_TXPKTS_Msk = 0xffff

	// RMON_T_MC_PKT: Tx Multicast Packets Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_MC_PKT_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_MC_PKT_TXPKTS_Msk = 0xffff

	// RMON_T_CRC_ALIGN: Tx Packets with CRC/Align Error Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_CRC_ALIGN_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_CRC_ALIGN_TXPKTS_Msk = 0xffff

	// RMON_T_UNDERSIZE: Tx Packets Less Than Bytes and Good CRC Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_UNDERSIZE_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_UNDERSIZE_TXPKTS_Msk = 0xffff

	// RMON_T_OVERSIZE: Tx Packets GT MAX_FL bytes and Good CRC Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_OVERSIZE_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_OVERSIZE_TXPKTS_Msk = 0xffff

	// RMON_T_FRAG: Tx Packets Less Than 64 Bytes and Bad CRC Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_FRAG_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_FRAG_TXPKTS_Msk = 0xffff

	// RMON_T_JAB: Tx Packets Greater Than MAX_FL bytes and Bad CRC Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_JAB_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_JAB_TXPKTS_Msk = 0xffff

	// RMON_T_COL: Tx Collision Count Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_COL_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_COL_TXPKTS_Msk = 0xffff

	// RMON_T_P64: Tx 64-Byte Packets Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_P64_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_P64_TXPKTS_Msk = 0xffff

	// RMON_T_P65TO127: Tx 65- to 127-byte Packets Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_P65TO127_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_P65TO127_TXPKTS_Msk = 0xffff

	// RMON_T_P128TO255: Tx 128- to 255-byte Packets Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_P128TO255_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_P128TO255_TXPKTS_Msk = 0xffff

	// RMON_T_P256TO511: Tx 256- to 511-byte Packets Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_P256TO511_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_P256TO511_TXPKTS_Msk = 0xffff

	// RMON_T_P512TO1023: Tx 512- to 1023-byte Packets Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_P512TO1023_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_P512TO1023_TXPKTS_Msk = 0xffff

	// RMON_T_P1024TO2047: Tx 1024- to 2047-byte Packets Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_P1024TO2047_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_P1024TO2047_TXPKTS_Msk = 0xffff

	// RMON_T_P_GTE2048: Tx Packets Greater Than 2048 Bytes Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_P_GTE2048_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_P_GTE2048_TXPKTS_Msk = 0xffff

	// RMON_T_OCTETS: Tx Octets Statistic Register
	// Position of TXOCTS field.
	ENET_RMON_T_OCTETS_TXOCTS_Pos = 0x0
	// Bit mask of TXOCTS field.
	ENET_RMON_T_OCTETS_TXOCTS_Msk = 0xffffffff

	// IEEE_T_FRAME_OK: Frames Transmitted OK Statistic Register
	// Position of COUNT field.
	ENET_IEEE_T_FRAME_OK_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_T_FRAME_OK_COUNT_Msk = 0xffff

	// IEEE_T_1COL: Frames Transmitted with Single Collision Statistic Register
	// Position of COUNT field.
	ENET_IEEE_T_1COL_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_T_1COL_COUNT_Msk = 0xffff

	// IEEE_T_MCOL: Frames Transmitted with Multiple Collisions Statistic Register
	// Position of COUNT field.
	ENET_IEEE_T_MCOL_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_T_MCOL_COUNT_Msk = 0xffff

	// IEEE_T_DEF: Frames Transmitted after Deferral Delay Statistic Register
	// Position of COUNT field.
	ENET_IEEE_T_DEF_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_T_DEF_COUNT_Msk = 0xffff

	// IEEE_T_LCOL: Frames Transmitted with Late Collision Statistic Register
	// Position of COUNT field.
	ENET_IEEE_T_LCOL_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_T_LCOL_COUNT_Msk = 0xffff

	// IEEE_T_EXCOL: Frames Transmitted with Excessive Collisions Statistic Register
	// Position of COUNT field.
	ENET_IEEE_T_EXCOL_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_T_EXCOL_COUNT_Msk = 0xffff

	// IEEE_T_MACERR: Frames Transmitted with Tx FIFO Underrun Statistic Register
	// Position of COUNT field.
	ENET_IEEE_T_MACERR_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_T_MACERR_COUNT_Msk = 0xffff

	// IEEE_T_CSERR: Frames Transmitted with Carrier Sense Error Statistic Register
	// Position of COUNT field.
	ENET_IEEE_T_CSERR_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_T_CSERR_COUNT_Msk = 0xffff

	// IEEE_T_SQE: Reserved Statistic Register
	// Position of COUNT field.
	ENET_IEEE_T_SQE_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_T_SQE_COUNT_Msk = 0xffff

	// IEEE_T_FDXFC: Flow Control Pause Frames Transmitted Statistic Register
	// Position of COUNT field.
	ENET_IEEE_T_FDXFC_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_T_FDXFC_COUNT_Msk = 0xffff

	// IEEE_T_OCTETS_OK: Octet Count for Frames Transmitted w/o Error Statistic Register
	// Position of COUNT field.
	ENET_IEEE_T_OCTETS_OK_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_T_OCTETS_OK_COUNT_Msk = 0xffffffff

	// RMON_R_PACKETS: Rx Packet Count Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_PACKETS_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_PACKETS_COUNT_Msk = 0xffff

	// RMON_R_BC_PKT: Rx Broadcast Packets Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_BC_PKT_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_BC_PKT_COUNT_Msk = 0xffff

	// RMON_R_MC_PKT: Rx Multicast Packets Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_MC_PKT_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_MC_PKT_COUNT_Msk = 0xffff

	// RMON_R_CRC_ALIGN: Rx Packets with CRC/Align Error Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_CRC_ALIGN_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_CRC_ALIGN_COUNT_Msk = 0xffff

	// RMON_R_UNDERSIZE: Rx Packets with Less Than 64 Bytes and Good CRC Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_UNDERSIZE_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_UNDERSIZE_COUNT_Msk = 0xffff

	// RMON_R_OVERSIZE: Rx Packets Greater Than MAX_FL and Good CRC Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_OVERSIZE_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_OVERSIZE_COUNT_Msk = 0xffff

	// RMON_R_FRAG: Rx Packets Less Than 64 Bytes and Bad CRC Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_FRAG_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_FRAG_COUNT_Msk = 0xffff

	// RMON_R_JAB: Rx Packets Greater Than MAX_FL Bytes and Bad CRC Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_JAB_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_JAB_COUNT_Msk = 0xffff

	// RMON_R_P64: Rx 64-Byte Packets Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_P64_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_P64_COUNT_Msk = 0xffff

	// RMON_R_P65TO127: Rx 65- to 127-Byte Packets Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_P65TO127_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_P65TO127_COUNT_Msk = 0xffff

	// RMON_R_P128TO255: Rx 128- to 255-Byte Packets Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_P128TO255_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_P128TO255_COUNT_Msk = 0xffff

	// RMON_R_P256TO511: Rx 256- to 511-Byte Packets Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_P256TO511_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_P256TO511_COUNT_Msk = 0xffff

	// RMON_R_P512TO1023: Rx 512- to 1023-Byte Packets Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_P512TO1023_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_P512TO1023_COUNT_Msk = 0xffff

	// RMON_R_P1024TO2047: Rx 1024- to 2047-Byte Packets Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_P1024TO2047_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_P1024TO2047_COUNT_Msk = 0xffff

	// RMON_R_P_GTE2048: Rx Packets Greater than 2048 Bytes Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_P_GTE2048_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_P_GTE2048_COUNT_Msk = 0xffff

	// RMON_R_OCTETS: Rx Octets Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_OCTETS_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_OCTETS_COUNT_Msk = 0xffffffff

	// IEEE_R_DROP: Frames not Counted Correctly Statistic Register
	// Position of COUNT field.
	ENET_IEEE_R_DROP_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_R_DROP_COUNT_Msk = 0xffff

	// IEEE_R_FRAME_OK: Frames Received OK Statistic Register
	// Position of COUNT field.
	ENET_IEEE_R_FRAME_OK_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_R_FRAME_OK_COUNT_Msk = 0xffff

	// IEEE_R_CRC: Frames Received with CRC Error Statistic Register
	// Position of COUNT field.
	ENET_IEEE_R_CRC_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_R_CRC_COUNT_Msk = 0xffff

	// IEEE_R_ALIGN: Frames Received with Alignment Error Statistic Register
	// Position of COUNT field.
	ENET_IEEE_R_ALIGN_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_R_ALIGN_COUNT_Msk = 0xffff

	// IEEE_R_MACERR: Receive FIFO Overflow Count Statistic Register
	// Position of COUNT field.
	ENET_IEEE_R_MACERR_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_R_MACERR_COUNT_Msk = 0xffff

	// IEEE_R_FDXFC: Flow Control Pause Frames Received Statistic Register
	// Position of COUNT field.
	ENET_IEEE_R_FDXFC_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_R_FDXFC_COUNT_Msk = 0xffff

	// IEEE_R_OCTETS_OK: Octet Count for Frames Received without Error Statistic Register
	// Position of COUNT field.
	ENET_IEEE_R_OCTETS_OK_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_R_OCTETS_OK_COUNT_Msk = 0xffffffff

	// ATCR: Adjustable Timer Control Register
	// Position of EN field.
	ENET_ATCR_EN_Pos = 0x0
	// Bit mask of EN field.
	ENET_ATCR_EN_Msk = 0x1
	// Bit EN.
	ENET_ATCR_EN = 0x1
	// The timer stops at the current value.
	ENET_ATCR_EN_EN_0 = 0x0
	// The timer starts incrementing.
	ENET_ATCR_EN_EN_1 = 0x1
	// Position of OFFEN field.
	ENET_ATCR_OFFEN_Pos = 0x2
	// Bit mask of OFFEN field.
	ENET_ATCR_OFFEN_Msk = 0x4
	// Bit OFFEN.
	ENET_ATCR_OFFEN = 0x4
	// Disable.
	ENET_ATCR_OFFEN_OFFEN_0 = 0x0
	// The timer can be reset to zero when the given offset time is reached (offset event). The field is cleared when the offset event is reached, so no further event occurs until the field is set again. The timer offset value must be set before setting this field.
	ENET_ATCR_OFFEN_OFFEN_1 = 0x1
	// Position of OFFRST field.
	ENET_ATCR_OFFRST_Pos = 0x3
	// Bit mask of OFFRST field.
	ENET_ATCR_OFFRST_Msk = 0x8
	// Bit OFFRST.
	ENET_ATCR_OFFRST = 0x8
	// The timer is not affected and no action occurs, besides clearing OFFEN, when the offset is reached.
	ENET_ATCR_OFFRST_OFFRST_0 = 0x0
	// If OFFEN is set, the timer resets to zero when the offset setting is reached. The offset event does not cause a timer interrupt.
	ENET_ATCR_OFFRST_OFFRST_1 = 0x1
	// Position of PEREN field.
	ENET_ATCR_PEREN_Pos = 0x4
	// Bit mask of PEREN field.
	ENET_ATCR_PEREN_Msk = 0x10
	// Bit PEREN.
	ENET_ATCR_PEREN = 0x10
	// Disable.
	ENET_ATCR_PEREN_PEREN_0 = 0x0
	// A period event interrupt can be generated (EIR[TS_TIMER]) and the event signal output is asserted when the timer wraps around according to the periodic setting ATPER. The timer period value must be set before setting this bit. Not all devices contain the event signal output. See the chip configuration details.
	ENET_ATCR_PEREN_PEREN_1 = 0x1
	// Position of PINPER field.
	ENET_ATCR_PINPER_Pos = 0x7
	// Bit mask of PINPER field.
	ENET_ATCR_PINPER_Msk = 0x80
	// Bit PINPER.
	ENET_ATCR_PINPER = 0x80
	// Disable.
	ENET_ATCR_PINPER_PINPER_0 = 0x0
	// Enable.
	ENET_ATCR_PINPER_PINPER_1 = 0x1
	// Position of RESTART field.
	ENET_ATCR_RESTART_Pos = 0x9
	// Bit mask of RESTART field.
	ENET_ATCR_RESTART_Msk = 0x200
	// Bit RESTART.
	ENET_ATCR_RESTART = 0x200
	// Position of CAPTURE field.
	ENET_ATCR_CAPTURE_Pos = 0xb
	// Bit mask of CAPTURE field.
	ENET_ATCR_CAPTURE_Msk = 0x800
	// Bit CAPTURE.
	ENET_ATCR_CAPTURE = 0x800
	// No effect.
	ENET_ATCR_CAPTURE_CAPTURE_0 = 0x0
	// The current time is captured and can be read from the ATVR register.
	ENET_ATCR_CAPTURE_CAPTURE_1 = 0x1
	// Position of SLAVE field.
	ENET_ATCR_SLAVE_Pos = 0xd
	// Bit mask of SLAVE field.
	ENET_ATCR_SLAVE_Msk = 0x2000
	// Bit SLAVE.
	ENET_ATCR_SLAVE = 0x2000
	// The timer is active and all configuration fields in this register are relevant.
	ENET_ATCR_SLAVE_SLAVE_0 = 0x0
	// The internal timer is disabled and the externally provided timer value is used. All other fields, except CAPTURE, in this register have no effect. CAPTURE can still be used to capture the current timer value.
	ENET_ATCR_SLAVE_SLAVE_1 = 0x1

	// ATVR: Timer Value Register
	// Position of ATIME field.
	ENET_ATVR_ATIME_Pos = 0x0
	// Bit mask of ATIME field.
	ENET_ATVR_ATIME_Msk = 0xffffffff

	// ATOFF: Timer Offset Register
	// Position of OFFSET field.
	ENET_ATOFF_OFFSET_Pos = 0x0
	// Bit mask of OFFSET field.
	ENET_ATOFF_OFFSET_Msk = 0xffffffff

	// ATPER: Timer Period Register
	// Position of PERIOD field.
	ENET_ATPER_PERIOD_Pos = 0x0
	// Bit mask of PERIOD field.
	ENET_ATPER_PERIOD_Msk = 0xffffffff

	// ATCOR: Timer Correction Register
	// Position of COR field.
	ENET_ATCOR_COR_Pos = 0x0
	// Bit mask of COR field.
	ENET_ATCOR_COR_Msk = 0x7fffffff

	// ATINC: Time-Stamping Clock Period Register
	// Position of INC field.
	ENET_ATINC_INC_Pos = 0x0
	// Bit mask of INC field.
	ENET_ATINC_INC_Msk = 0x7f
	// Position of INC_CORR field.
	ENET_ATINC_INC_CORR_Pos = 0x8
	// Bit mask of INC_CORR field.
	ENET_ATINC_INC_CORR_Msk = 0x7f00

	// ATSTMP: Timestamp of Last Transmitted Frame
	// Position of TIMESTAMP field.
	ENET_ATSTMP_TIMESTAMP_Pos = 0x0
	// Bit mask of TIMESTAMP field.
	ENET_ATSTMP_TIMESTAMP_Msk = 0xffffffff

	// TGSR: Timer Global Status Register
	// Position of TF0 field.
	ENET_TGSR_TF0_Pos = 0x0
	// Bit mask of TF0 field.
	ENET_TGSR_TF0_Msk = 0x1
	// Bit TF0.
	ENET_TGSR_TF0 = 0x1
	// Timer Flag for Channel 0 is clear
	ENET_TGSR_TF0_TF0_0 = 0x0
	// Timer Flag for Channel 0 is set
	ENET_TGSR_TF0_TF0_1 = 0x1
	// Position of TF1 field.
	ENET_TGSR_TF1_Pos = 0x1
	// Bit mask of TF1 field.
	ENET_TGSR_TF1_Msk = 0x2
	// Bit TF1.
	ENET_TGSR_TF1 = 0x2
	// Timer Flag for Channel 1 is clear
	ENET_TGSR_TF1_TF1_0 = 0x0
	// Timer Flag for Channel 1 is set
	ENET_TGSR_TF1_TF1_1 = 0x1
	// Position of TF2 field.
	ENET_TGSR_TF2_Pos = 0x2
	// Bit mask of TF2 field.
	ENET_TGSR_TF2_Msk = 0x4
	// Bit TF2.
	ENET_TGSR_TF2 = 0x4
	// Timer Flag for Channel 2 is clear
	ENET_TGSR_TF2_TF2_0 = 0x0
	// Timer Flag for Channel 2 is set
	ENET_TGSR_TF2_TF2_1 = 0x1
	// Position of TF3 field.
	ENET_TGSR_TF3_Pos = 0x3
	// Bit mask of TF3 field.
	ENET_TGSR_TF3_Msk = 0x8
	// Bit TF3.
	ENET_TGSR_TF3 = 0x8
	// Timer Flag for Channel 3 is clear
	ENET_TGSR_TF3_TF3_0 = 0x0
	// Timer Flag for Channel 3 is set
	ENET_TGSR_TF3_TF3_1 = 0x1

	// TCSR0: Timer Control Status Register
	// Position of TDRE field.
	ENET_TCSR_TDRE_Pos = 0x0
	// Bit mask of TDRE field.
	ENET_TCSR_TDRE_Msk = 0x1
	// Bit TDRE.
	ENET_TCSR_TDRE = 0x1
	// DMA request is disabled
	ENET_TCSR_TDRE_TDRE_0 = 0x0
	// DMA request is enabled
	ENET_TCSR_TDRE_TDRE_1 = 0x1
	// Position of TMODE field.
	ENET_TCSR_TMODE_Pos = 0x2
	// Bit mask of TMODE field.
	ENET_TCSR_TMODE_Msk = 0x3c
	// Timer Channel is disabled.
	ENET_TCSR_TMODE_TMODE_0 = 0x0
	// Timer Channel is configured for Input Capture on rising edge.
	ENET_TCSR_TMODE_TMODE_1 = 0x1
	// Timer Channel is configured for Input Capture on falling edge.
	ENET_TCSR_TMODE_TMODE_2 = 0x2
	// Timer Channel is configured for Input Capture on both edges.
	ENET_TCSR_TMODE_TMODE_3 = 0x3
	// Timer Channel is configured for Output Compare - software only.
	ENET_TCSR_TMODE_TMODE_4 = 0x4
	// Timer Channel is configured for Output Compare - toggle output on compare.
	ENET_TCSR_TMODE_TMODE_5 = 0x5
	// Timer Channel is configured for Output Compare - clear output on compare.
	ENET_TCSR_TMODE_TMODE_6 = 0x6
	// Timer Channel is configured for Output Compare - set output on compare.
	ENET_TCSR_TMODE_TMODE_7 = 0x7
	// Timer Channel is configured for Output Compare - set output on compare, clear output on overflow.
	ENET_TCSR_TMODE_TMODE_9 = 0x9
	// Timer Channel is configured for Output Compare - clear output on compare, set output on overflow.
	ENET_TCSR_TMODE_TMODE_10 = 0xa
	// Timer Channel is configured for Output Compare - pulse output low on compare for 1 to 32 1588-clock cycles as specified by TPWC.
	ENET_TCSR_TMODE_TMODE_14 = 0xe
	// Timer Channel is configured for Output Compare - pulse output high on compare for 1 to 32 1588-clock cycles as specified by TPWC.
	ENET_TCSR_TMODE_TMODE_15 = 0xf
	// Position of TIE field.
	ENET_TCSR_TIE_Pos = 0x6
	// Bit mask of TIE field.
	ENET_TCSR_TIE_Msk = 0x40
	// Bit TIE.
	ENET_TCSR_TIE = 0x40
	// Interrupt is disabled
	ENET_TCSR_TIE_TIE_0 = 0x0
	// Interrupt is enabled
	ENET_TCSR_TIE_TIE_1 = 0x1
	// Position of TF field.
	ENET_TCSR_TF_Pos = 0x7
	// Bit mask of TF field.
	ENET_TCSR_TF_Msk = 0x80
	// Bit TF.
	ENET_TCSR_TF = 0x80
	// Input Capture or Output Compare has not occurred.
	ENET_TCSR_TF_TF_0 = 0x0
	// Input Capture or Output Compare has occurred.
	ENET_TCSR_TF_TF_1 = 0x1
	// Position of TPWC field.
	ENET_TCSR_TPWC_Pos = 0xb
	// Bit mask of TPWC field.
	ENET_TCSR_TPWC_Msk = 0xf800
	// Pulse width is one 1588-clock cycle.
	ENET_TCSR_TPWC_TPWC_0 = 0x0
	// Pulse width is two 1588-clock cycles.
	ENET_TCSR_TPWC_TPWC_1 = 0x1
	// Pulse width is three 1588-clock cycles.
	ENET_TCSR_TPWC_TPWC_2 = 0x2
	// Pulse width is four 1588-clock cycles.
	ENET_TCSR_TPWC_TPWC_3 = 0x3
	// Pulse width is 32 1588-clock cycles.
	ENET_TCSR_TPWC_TPWC_31 = 0x1f

	// TCCR0: Timer Compare Capture Register
	// Position of TCC field.
	ENET_TCCR_TCC_Pos = 0x0
	// Bit mask of TCC field.
	ENET_TCCR_TCC_Msk = 0xffffffff
)

// Bitfields for USB1: USB
const (
	// ID: Identification register
	// Position of ID field.
	USB_ID_ID_Pos = 0x0
	// Bit mask of ID field.
	USB_ID_ID_Msk = 0x3f
	// Position of NID field.
	USB_ID_NID_Pos = 0x8
	// Bit mask of NID field.
	USB_ID_NID_Msk = 0x3f00
	// Position of REVISION field.
	USB_ID_REVISION_Pos = 0x10
	// Bit mask of REVISION field.
	USB_ID_REVISION_Msk = 0xff0000

	// HWGENERAL: Hardware General
	// Position of PHYW field.
	USB_HWGENERAL_PHYW_Pos = 0x4
	// Bit mask of PHYW field.
	USB_HWGENERAL_PHYW_Msk = 0x30
	// 8 bit wide data bus Software non-programmable
	USB_HWGENERAL_PHYW_PHYW_0 = 0x0
	// 16 bit wide data bus Software non-programmable
	USB_HWGENERAL_PHYW_PHYW_1 = 0x1
	// Reset to 8 bit wide data bus Software programmable
	USB_HWGENERAL_PHYW_PHYW_2 = 0x2
	// Reset to 16 bit wide data bus Software programmable
	USB_HWGENERAL_PHYW_PHYW_3 = 0x3
	// Position of PHYM field.
	USB_HWGENERAL_PHYM_Pos = 0x6
	// Bit mask of PHYM field.
	USB_HWGENERAL_PHYM_Msk = 0x1c0
	// UTMI/UMTI+
	USB_HWGENERAL_PHYM_PHYM_0 = 0x0
	// ULPI DDR
	USB_HWGENERAL_PHYM_PHYM_1 = 0x1
	// ULPI
	USB_HWGENERAL_PHYM_PHYM_2 = 0x2
	// Serial Only
	USB_HWGENERAL_PHYM_PHYM_3 = 0x3
	// Software programmable - reset to UTMI/UTMI+
	USB_HWGENERAL_PHYM_PHYM_4 = 0x4
	// Software programmable - reset to ULPI DDR
	USB_HWGENERAL_PHYM_PHYM_5 = 0x5
	// Software programmable - reset to ULPI
	USB_HWGENERAL_PHYM_PHYM_6 = 0x6
	// Software programmable - reset to Serial
	USB_HWGENERAL_PHYM_PHYM_7 = 0x7
	// Position of SM field.
	USB_HWGENERAL_SM_Pos = 0x9
	// Bit mask of SM field.
	USB_HWGENERAL_SM_Msk = 0x600
	// No Serial Engine, always use parallel signalling.
	USB_HWGENERAL_SM_SM_0 = 0x0
	// Serial Engine present, always use serial signalling for FS/LS.
	USB_HWGENERAL_SM_SM_1 = 0x1
	// Software programmable - Reset to use parallel signalling for FS/LS
	USB_HWGENERAL_SM_SM_2 = 0x2
	// Software programmable - Reset to use serial signalling for FS/LS
	USB_HWGENERAL_SM_SM_3 = 0x3

	// HWHOST: Host Hardware Parameters
	// Position of HC field.
	USB_HWHOST_HC_Pos = 0x0
	// Bit mask of HC field.
	USB_HWHOST_HC_Msk = 0x1
	// Bit HC.
	USB_HWHOST_HC = 0x1
	// Not supported
	USB_HWHOST_HC_HC_0 = 0x0
	// Supported
	USB_HWHOST_HC_HC_1 = 0x1
	// Position of NPORT field.
	USB_HWHOST_NPORT_Pos = 0x1
	// Bit mask of NPORT field.
	USB_HWHOST_NPORT_Msk = 0xe

	// HWDEVICE: Device Hardware Parameters
	// Position of DC field.
	USB_HWDEVICE_DC_Pos = 0x0
	// Bit mask of DC field.
	USB_HWDEVICE_DC_Msk = 0x1
	// Bit DC.
	USB_HWDEVICE_DC = 0x1
	// Not supported
	USB_HWDEVICE_DC_DC_0 = 0x0
	// Supported
	USB_HWDEVICE_DC_DC_1 = 0x1
	// Position of DEVEP field.
	USB_HWDEVICE_DEVEP_Pos = 0x1
	// Bit mask of DEVEP field.
	USB_HWDEVICE_DEVEP_Msk = 0x3e

	// HWTXBUF: TX Buffer Hardware Parameters
	// Position of TXBURST field.
	USB_HWTXBUF_TXBURST_Pos = 0x0
	// Bit mask of TXBURST field.
	USB_HWTXBUF_TXBURST_Msk = 0xff
	// Position of TXCHANADD field.
	USB_HWTXBUF_TXCHANADD_Pos = 0x10
	// Bit mask of TXCHANADD field.
	USB_HWTXBUF_TXCHANADD_Msk = 0xff0000

	// HWRXBUF: RX Buffer Hardware Parameters
	// Position of RXBURST field.
	USB_HWRXBUF_RXBURST_Pos = 0x0
	// Bit mask of RXBURST field.
	USB_HWRXBUF_RXBURST_Msk = 0xff
	// Position of RXADD field.
	USB_HWRXBUF_RXADD_Pos = 0x8
	// Bit mask of RXADD field.
	USB_HWRXBUF_RXADD_Msk = 0xff00

	// GPTIMER0LD: General Purpose Timer #0 Load
	// Position of GPTLD field.
	USB_GPTIMER0LD_GPTLD_Pos = 0x0
	// Bit mask of GPTLD field.
	USB_GPTIMER0LD_GPTLD_Msk = 0xffffff

	// GPTIMER0CTRL: General Purpose Timer #0 Controller
	// Position of GPTCNT field.
	USB_GPTIMER0CTRL_GPTCNT_Pos = 0x0
	// Bit mask of GPTCNT field.
	USB_GPTIMER0CTRL_GPTCNT_Msk = 0xffffff
	// Position of GPTMODE field.
	USB_GPTIMER0CTRL_GPTMODE_Pos = 0x18
	// Bit mask of GPTMODE field.
	USB_GPTIMER0CTRL_GPTMODE_Msk = 0x1000000
	// Bit GPTMODE.
	USB_GPTIMER0CTRL_GPTMODE = 0x1000000
	// One Shot Mode
	USB_GPTIMER0CTRL_GPTMODE_GPTMODE_0 = 0x0
	// Repeat Mode
	USB_GPTIMER0CTRL_GPTMODE_GPTMODE_1 = 0x1
	// Position of GPTRST field.
	USB_GPTIMER0CTRL_GPTRST_Pos = 0x1e
	// Bit mask of GPTRST field.
	USB_GPTIMER0CTRL_GPTRST_Msk = 0x40000000
	// Bit GPTRST.
	USB_GPTIMER0CTRL_GPTRST = 0x40000000
	// No action
	USB_GPTIMER0CTRL_GPTRST_GPTRST_0 = 0x0
	// Load counter value from GPTLD bits in n_GPTIMER0LD
	USB_GPTIMER0CTRL_GPTRST_GPTRST_1 = 0x1
	// Position of GPTRUN field.
	USB_GPTIMER0CTRL_GPTRUN_Pos = 0x1f
	// Bit mask of GPTRUN field.
	USB_GPTIMER0CTRL_GPTRUN_Msk = 0x80000000
	// Bit GPTRUN.
	USB_GPTIMER0CTRL_GPTRUN = 0x80000000
	// Stop counting
	USB_GPTIMER0CTRL_GPTRUN_GPTRUN_0 = 0x0
	// Run
	USB_GPTIMER0CTRL_GPTRUN_GPTRUN_1 = 0x1

	// GPTIMER1LD: General Purpose Timer #1 Load
	// Position of GPTLD field.
	USB_GPTIMER1LD_GPTLD_Pos = 0x0
	// Bit mask of GPTLD field.
	USB_GPTIMER1LD_GPTLD_Msk = 0xffffff

	// GPTIMER1CTRL: General Purpose Timer #1 Controller
	// Position of GPTCNT field.
	USB_GPTIMER1CTRL_GPTCNT_Pos = 0x0
	// Bit mask of GPTCNT field.
	USB_GPTIMER1CTRL_GPTCNT_Msk = 0xffffff
	// Position of GPTMODE field.
	USB_GPTIMER1CTRL_GPTMODE_Pos = 0x18
	// Bit mask of GPTMODE field.
	USB_GPTIMER1CTRL_GPTMODE_Msk = 0x1000000
	// Bit GPTMODE.
	USB_GPTIMER1CTRL_GPTMODE = 0x1000000
	// One Shot Mode
	USB_GPTIMER1CTRL_GPTMODE_GPTMODE_0 = 0x0
	// Repeat Mode
	USB_GPTIMER1CTRL_GPTMODE_GPTMODE_1 = 0x1
	// Position of GPTRST field.
	USB_GPTIMER1CTRL_GPTRST_Pos = 0x1e
	// Bit mask of GPTRST field.
	USB_GPTIMER1CTRL_GPTRST_Msk = 0x40000000
	// Bit GPTRST.
	USB_GPTIMER1CTRL_GPTRST = 0x40000000
	// No action
	USB_GPTIMER1CTRL_GPTRST_GPTRST_0 = 0x0
	// Load counter value from GPTLD bits in USB_n_GPTIMER0LD
	USB_GPTIMER1CTRL_GPTRST_GPTRST_1 = 0x1
	// Position of GPTRUN field.
	USB_GPTIMER1CTRL_GPTRUN_Pos = 0x1f
	// Bit mask of GPTRUN field.
	USB_GPTIMER1CTRL_GPTRUN_Msk = 0x80000000
	// Bit GPTRUN.
	USB_GPTIMER1CTRL_GPTRUN = 0x80000000
	// Stop counting
	USB_GPTIMER1CTRL_GPTRUN_GPTRUN_0 = 0x0
	// Run
	USB_GPTIMER1CTRL_GPTRUN_GPTRUN_1 = 0x1

	// SBUSCFG: System Bus Config
	// Position of AHBBRST field.
	USB_SBUSCFG_AHBBRST_Pos = 0x0
	// Bit mask of AHBBRST field.
	USB_SBUSCFG_AHBBRST_Msk = 0x7
	// Incremental burst of unspecified length only
	USB_SBUSCFG_AHBBRST_AHBBRST_0 = 0x0
	// INCR4 burst, then single transfer
	USB_SBUSCFG_AHBBRST_AHBBRST_1 = 0x1
	// INCR8 burst, INCR4 burst, then single transfer
	USB_SBUSCFG_AHBBRST_AHBBRST_2 = 0x2
	// INCR16 burst, INCR8 burst, INCR4 burst, then single transfer
	USB_SBUSCFG_AHBBRST_AHBBRST_3 = 0x3
	// INCR4 burst, then incremental burst of unspecified length
	USB_SBUSCFG_AHBBRST_AHBBRST_5 = 0x5
	// INCR8 burst, INCR4 burst, then incremental burst of unspecified length
	USB_SBUSCFG_AHBBRST_AHBBRST_6 = 0x6
	// INCR16 burst, INCR8 burst, INCR4 burst, then incremental burst of unspecified length
	USB_SBUSCFG_AHBBRST_AHBBRST_7 = 0x7

	// CAPLENGTH: Capability Registers Length
	// Position of CAPLENGTH field.
	USB_CAPLENGTH_CAPLENGTH_Pos = 0x0
	// Bit mask of CAPLENGTH field.
	USB_CAPLENGTH_CAPLENGTH_Msk = 0xff

	// HCIVERSION: Host Controller Interface Version
	// Position of HCIVERSION field.
	USB_HCIVERSION_HCIVERSION_Pos = 0x0
	// Bit mask of HCIVERSION field.
	USB_HCIVERSION_HCIVERSION_Msk = 0xffff

	// HCSPARAMS: Host Controller Structural Parameters
	// Position of N_PORTS field.
	USB_HCSPARAMS_N_PORTS_Pos = 0x0
	// Bit mask of N_PORTS field.
	USB_HCSPARAMS_N_PORTS_Msk = 0xf
	// Position of PPC field.
	USB_HCSPARAMS_PPC_Pos = 0x4
	// Bit mask of PPC field.
	USB_HCSPARAMS_PPC_Msk = 0x10
	// Bit PPC.
	USB_HCSPARAMS_PPC = 0x10
	// Position of N_PCC field.
	USB_HCSPARAMS_N_PCC_Pos = 0x8
	// Bit mask of N_PCC field.
	USB_HCSPARAMS_N_PCC_Msk = 0xf00
	// Position of N_CC field.
	USB_HCSPARAMS_N_CC_Pos = 0xc
	// Bit mask of N_CC field.
	USB_HCSPARAMS_N_CC_Msk = 0xf000
	// There is no internal Companion Controller and port-ownership hand-off is not supported.
	USB_HCSPARAMS_N_CC_N_CC_0 = 0x0
	// There are internal companion controller(s) and port-ownership hand-offs is supported.
	USB_HCSPARAMS_N_CC_N_CC_1 = 0x1
	// Position of PI field.
	USB_HCSPARAMS_PI_Pos = 0x10
	// Bit mask of PI field.
	USB_HCSPARAMS_PI_Msk = 0x10000
	// Bit PI.
	USB_HCSPARAMS_PI = 0x10000
	// Position of N_PTT field.
	USB_HCSPARAMS_N_PTT_Pos = 0x14
	// Bit mask of N_PTT field.
	USB_HCSPARAMS_N_PTT_Msk = 0xf00000
	// Position of N_TT field.
	USB_HCSPARAMS_N_TT_Pos = 0x18
	// Bit mask of N_TT field.
	USB_HCSPARAMS_N_TT_Msk = 0xf000000

	// HCCPARAMS: Host Controller Capability Parameters
	// Position of ADC field.
	USB_HCCPARAMS_ADC_Pos = 0x0
	// Bit mask of ADC field.
	USB_HCCPARAMS_ADC_Msk = 0x1
	// Bit ADC.
	USB_HCCPARAMS_ADC = 0x1
	// Position of PFL field.
	USB_HCCPARAMS_PFL_Pos = 0x1
	// Bit mask of PFL field.
	USB_HCCPARAMS_PFL_Msk = 0x2
	// Bit PFL.
	USB_HCCPARAMS_PFL = 0x2
	// Position of ASP field.
	USB_HCCPARAMS_ASP_Pos = 0x2
	// Bit mask of ASP field.
	USB_HCCPARAMS_ASP_Msk = 0x4
	// Bit ASP.
	USB_HCCPARAMS_ASP = 0x4
	// Position of IST field.
	USB_HCCPARAMS_IST_Pos = 0x4
	// Bit mask of IST field.
	USB_HCCPARAMS_IST_Msk = 0xf0
	// Position of EECP field.
	USB_HCCPARAMS_EECP_Pos = 0x8
	// Bit mask of EECP field.
	USB_HCCPARAMS_EECP_Msk = 0xff00

	// DCIVERSION: Device Controller Interface Version
	// Position of DCIVERSION field.
	USB_DCIVERSION_DCIVERSION_Pos = 0x0
	// Bit mask of DCIVERSION field.
	USB_DCIVERSION_DCIVERSION_Msk = 0xffff

	// DCCPARAMS: Device Controller Capability Parameters
	// Position of DEN field.
	USB_DCCPARAMS_DEN_Pos = 0x0
	// Bit mask of DEN field.
	USB_DCCPARAMS_DEN_Msk = 0x1f
	// Position of DC field.
	USB_DCCPARAMS_DC_Pos = 0x7
	// Bit mask of DC field.
	USB_DCCPARAMS_DC_Msk = 0x80
	// Bit DC.
	USB_DCCPARAMS_DC = 0x80
	// Position of HC field.
	USB_DCCPARAMS_HC_Pos = 0x8
	// Bit mask of HC field.
	USB_DCCPARAMS_HC_Msk = 0x100
	// Bit HC.
	USB_DCCPARAMS_HC = 0x100

	// USBCMD: USB Command Register
	// Position of RS field.
	USB_USBCMD_RS_Pos = 0x0
	// Bit mask of RS field.
	USB_USBCMD_RS_Msk = 0x1
	// Bit RS.
	USB_USBCMD_RS = 0x1
	// Position of RST field.
	USB_USBCMD_RST_Pos = 0x1
	// Bit mask of RST field.
	USB_USBCMD_RST_Msk = 0x2
	// Bit RST.
	USB_USBCMD_RST = 0x2
	// Position of FS_1 field.
	USB_USBCMD_FS_1_Pos = 0x2
	// Bit mask of FS_1 field.
	USB_USBCMD_FS_1_Msk = 0xc
	// Position of PSE field.
	USB_USBCMD_PSE_Pos = 0x4
	// Bit mask of PSE field.
	USB_USBCMD_PSE_Msk = 0x10
	// Bit PSE.
	USB_USBCMD_PSE = 0x10
	// Do not process the Periodic Schedule
	USB_USBCMD_PSE_PSE_0 = 0x0
	// Use the PERIODICLISTBASE register to access the Periodic Schedule.
	USB_USBCMD_PSE_PSE_1 = 0x1
	// Position of ASE field.
	USB_USBCMD_ASE_Pos = 0x5
	// Bit mask of ASE field.
	USB_USBCMD_ASE_Msk = 0x20
	// Bit ASE.
	USB_USBCMD_ASE = 0x20
	// Do not process the Asynchronous Schedule.
	USB_USBCMD_ASE_ASE_0 = 0x0
	// Use the ASYNCLISTADDR register to access the Asynchronous Schedule.
	USB_USBCMD_ASE_ASE_1 = 0x1
	// Position of IAA field.
	USB_USBCMD_IAA_Pos = 0x6
	// Bit mask of IAA field.
	USB_USBCMD_IAA_Msk = 0x40
	// Bit IAA.
	USB_USBCMD_IAA = 0x40
	// Position of ASP field.
	USB_USBCMD_ASP_Pos = 0x8
	// Bit mask of ASP field.
	USB_USBCMD_ASP_Msk = 0x300
	// Position of ASPE field.
	USB_USBCMD_ASPE_Pos = 0xb
	// Bit mask of ASPE field.
	USB_USBCMD_ASPE_Msk = 0x800
	// Bit ASPE.
	USB_USBCMD_ASPE = 0x800
	// Position of ATDTW field.
	USB_USBCMD_ATDTW_Pos = 0xc
	// Bit mask of ATDTW field.
	USB_USBCMD_ATDTW_Msk = 0x1000
	// Bit ATDTW.
	USB_USBCMD_ATDTW = 0x1000
	// Position of SUTW field.
	USB_USBCMD_SUTW_Pos = 0xd
	// Bit mask of SUTW field.
	USB_USBCMD_SUTW_Msk = 0x2000
	// Bit SUTW.
	USB_USBCMD_SUTW = 0x2000
	// Position of FS_2 field.
	USB_USBCMD_FS_2_Pos = 0xf
	// Bit mask of FS_2 field.
	USB_USBCMD_FS_2_Msk = 0x8000
	// Bit FS_2.
	USB_USBCMD_FS_2 = 0x8000
	// 1024 elements (4096 bytes) Default value
	USB_USBCMD_FS_2_FS_2_0 = 0x0
	// 512 elements (2048 bytes)
	USB_USBCMD_FS_2_FS_2_1 = 0x1
	// Position of ITC field.
	USB_USBCMD_ITC_Pos = 0x10
	// Bit mask of ITC field.
	USB_USBCMD_ITC_Msk = 0xff0000
	// Immediate (no threshold)
	USB_USBCMD_ITC_ITC_0 = 0x0
	// 1 micro-frame
	USB_USBCMD_ITC_ITC_1 = 0x1
	// 2 micro-frames
	USB_USBCMD_ITC_ITC_2 = 0x2
	// 4 micro-frames
	USB_USBCMD_ITC_ITC_4 = 0x4
	// 8 micro-frames
	USB_USBCMD_ITC_ITC_8 = 0x8
	// 16 micro-frames
	USB_USBCMD_ITC_ITC_16 = 0x10
	// 32 micro-frames
	USB_USBCMD_ITC_ITC_32 = 0x20
	// 64 micro-frames
	USB_USBCMD_ITC_ITC_64 = 0x40

	// USBSTS: USB Status Register
	// Position of UI field.
	USB_USBSTS_UI_Pos = 0x0
	// Bit mask of UI field.
	USB_USBSTS_UI_Msk = 0x1
	// Bit UI.
	USB_USBSTS_UI = 0x1
	// Position of UEI field.
	USB_USBSTS_UEI_Pos = 0x1
	// Bit mask of UEI field.
	USB_USBSTS_UEI_Msk = 0x2
	// Bit UEI.
	USB_USBSTS_UEI = 0x2
	// Position of PCI field.
	USB_USBSTS_PCI_Pos = 0x2
	// Bit mask of PCI field.
	USB_USBSTS_PCI_Msk = 0x4
	// Bit PCI.
	USB_USBSTS_PCI = 0x4
	// Position of FRI field.
	USB_USBSTS_FRI_Pos = 0x3
	// Bit mask of FRI field.
	USB_USBSTS_FRI_Msk = 0x8
	// Bit FRI.
	USB_USBSTS_FRI = 0x8
	// Position of SEI field.
	USB_USBSTS_SEI_Pos = 0x4
	// Bit mask of SEI field.
	USB_USBSTS_SEI_Msk = 0x10
	// Bit SEI.
	USB_USBSTS_SEI = 0x10
	// Position of AAI field.
	USB_USBSTS_AAI_Pos = 0x5
	// Bit mask of AAI field.
	USB_USBSTS_AAI_Msk = 0x20
	// Bit AAI.
	USB_USBSTS_AAI = 0x20
	// Position of URI field.
	USB_USBSTS_URI_Pos = 0x6
	// Bit mask of URI field.
	USB_USBSTS_URI_Msk = 0x40
	// Bit URI.
	USB_USBSTS_URI = 0x40
	// Position of SRI field.
	USB_USBSTS_SRI_Pos = 0x7
	// Bit mask of SRI field.
	USB_USBSTS_SRI_Msk = 0x80
	// Bit SRI.
	USB_USBSTS_SRI = 0x80
	// Position of SLI field.
	USB_USBSTS_SLI_Pos = 0x8
	// Bit mask of SLI field.
	USB_USBSTS_SLI_Msk = 0x100
	// Bit SLI.
	USB_USBSTS_SLI = 0x100
	// Position of ULPII field.
	USB_USBSTS_ULPII_Pos = 0xa
	// Bit mask of ULPII field.
	USB_USBSTS_ULPII_Msk = 0x400
	// Bit ULPII.
	USB_USBSTS_ULPII = 0x400
	// Position of HCH field.
	USB_USBSTS_HCH_Pos = 0xc
	// Bit mask of HCH field.
	USB_USBSTS_HCH_Msk = 0x1000
	// Bit HCH.
	USB_USBSTS_HCH = 0x1000
	// Position of RCL field.
	USB_USBSTS_RCL_Pos = 0xd
	// Bit mask of RCL field.
	USB_USBSTS_RCL_Msk = 0x2000
	// Bit RCL.
	USB_USBSTS_RCL = 0x2000
	// Position of PS field.
	USB_USBSTS_PS_Pos = 0xe
	// Bit mask of PS field.
	USB_USBSTS_PS_Msk = 0x4000
	// Bit PS.
	USB_USBSTS_PS = 0x4000
	// Position of AS field.
	USB_USBSTS_AS_Pos = 0xf
	// Bit mask of AS field.
	USB_USBSTS_AS_Msk = 0x8000
	// Bit AS.
	USB_USBSTS_AS = 0x8000
	// Position of NAKI field.
	USB_USBSTS_NAKI_Pos = 0x10
	// Bit mask of NAKI field.
	USB_USBSTS_NAKI_Msk = 0x10000
	// Bit NAKI.
	USB_USBSTS_NAKI = 0x10000
	// Position of TI0 field.
	USB_USBSTS_TI0_Pos = 0x18
	// Bit mask of TI0 field.
	USB_USBSTS_TI0_Msk = 0x1000000
	// Bit TI0.
	USB_USBSTS_TI0 = 0x1000000
	// Position of TI1 field.
	USB_USBSTS_TI1_Pos = 0x19
	// Bit mask of TI1 field.
	USB_USBSTS_TI1_Msk = 0x2000000
	// Bit TI1.
	USB_USBSTS_TI1 = 0x2000000

	// USBINTR: Interrupt Enable Register
	// Position of UE field.
	USB_USBINTR_UE_Pos = 0x0
	// Bit mask of UE field.
	USB_USBINTR_UE_Msk = 0x1
	// Bit UE.
	USB_USBINTR_UE = 0x1
	// Position of UEE field.
	USB_USBINTR_UEE_Pos = 0x1
	// Bit mask of UEE field.
	USB_USBINTR_UEE_Msk = 0x2
	// Bit UEE.
	USB_USBINTR_UEE = 0x2
	// Position of PCE field.
	USB_USBINTR_PCE_Pos = 0x2
	// Bit mask of PCE field.
	USB_USBINTR_PCE_Msk = 0x4
	// Bit PCE.
	USB_USBINTR_PCE = 0x4
	// Position of FRE field.
	USB_USBINTR_FRE_Pos = 0x3
	// Bit mask of FRE field.
	USB_USBINTR_FRE_Msk = 0x8
	// Bit FRE.
	USB_USBINTR_FRE = 0x8
	// Position of SEE field.
	USB_USBINTR_SEE_Pos = 0x4
	// Bit mask of SEE field.
	USB_USBINTR_SEE_Msk = 0x10
	// Bit SEE.
	USB_USBINTR_SEE = 0x10
	// Position of AAE field.
	USB_USBINTR_AAE_Pos = 0x5
	// Bit mask of AAE field.
	USB_USBINTR_AAE_Msk = 0x20
	// Bit AAE.
	USB_USBINTR_AAE = 0x20
	// Position of URE field.
	USB_USBINTR_URE_Pos = 0x6
	// Bit mask of URE field.
	USB_USBINTR_URE_Msk = 0x40
	// Bit URE.
	USB_USBINTR_URE = 0x40
	// Position of SRE field.
	USB_USBINTR_SRE_Pos = 0x7
	// Bit mask of SRE field.
	USB_USBINTR_SRE_Msk = 0x80
	// Bit SRE.
	USB_USBINTR_SRE = 0x80
	// Position of SLE field.
	USB_USBINTR_SLE_Pos = 0x8
	// Bit mask of SLE field.
	USB_USBINTR_SLE_Msk = 0x100
	// Bit SLE.
	USB_USBINTR_SLE = 0x100
	// Position of ULPIE field.
	USB_USBINTR_ULPIE_Pos = 0xa
	// Bit mask of ULPIE field.
	USB_USBINTR_ULPIE_Msk = 0x400
	// Bit ULPIE.
	USB_USBINTR_ULPIE = 0x400
	// Position of NAKE field.
	USB_USBINTR_NAKE_Pos = 0x10
	// Bit mask of NAKE field.
	USB_USBINTR_NAKE_Msk = 0x10000
	// Bit NAKE.
	USB_USBINTR_NAKE = 0x10000
	// Position of UAIE field.
	USB_USBINTR_UAIE_Pos = 0x12
	// Bit mask of UAIE field.
	USB_USBINTR_UAIE_Msk = 0x40000
	// Bit UAIE.
	USB_USBINTR_UAIE = 0x40000
	// Position of UPIE field.
	USB_USBINTR_UPIE_Pos = 0x13
	// Bit mask of UPIE field.
	USB_USBINTR_UPIE_Msk = 0x80000
	// Bit UPIE.
	USB_USBINTR_UPIE = 0x80000
	// Position of TIE0 field.
	USB_USBINTR_TIE0_Pos = 0x18
	// Bit mask of TIE0 field.
	USB_USBINTR_TIE0_Msk = 0x1000000
	// Bit TIE0.
	USB_USBINTR_TIE0 = 0x1000000
	// Position of TIE1 field.
	USB_USBINTR_TIE1_Pos = 0x19
	// Bit mask of TIE1 field.
	USB_USBINTR_TIE1_Msk = 0x2000000
	// Bit TIE1.
	USB_USBINTR_TIE1 = 0x2000000

	// FRINDEX: USB Frame Index
	// Position of FRINDEX field.
	USB_FRINDEX_FRINDEX_Pos = 0x0
	// Bit mask of FRINDEX field.
	USB_FRINDEX_FRINDEX_Msk = 0x3fff
	// (1024) 12
	USB_FRINDEX_FRINDEX_FRINDEX_0 = 0x0
	// (512) 11
	USB_FRINDEX_FRINDEX_FRINDEX_1 = 0x1
	// (256) 10
	USB_FRINDEX_FRINDEX_FRINDEX_2 = 0x2
	// (128) 9
	USB_FRINDEX_FRINDEX_FRINDEX_3 = 0x3
	// (64) 8
	USB_FRINDEX_FRINDEX_FRINDEX_4 = 0x4
	// (32) 7
	USB_FRINDEX_FRINDEX_FRINDEX_5 = 0x5
	// (16) 6
	USB_FRINDEX_FRINDEX_FRINDEX_6 = 0x6
	// (8) 5
	USB_FRINDEX_FRINDEX_FRINDEX_7 = 0x7

	// DEVICEADDR: Device Address
	// Position of USBADRA field.
	USB_DEVICEADDR_USBADRA_Pos = 0x18
	// Bit mask of USBADRA field.
	USB_DEVICEADDR_USBADRA_Msk = 0x1000000
	// Bit USBADRA.
	USB_DEVICEADDR_USBADRA = 0x1000000
	// Position of USBADR field.
	USB_DEVICEADDR_USBADR_Pos = 0x19
	// Bit mask of USBADR field.
	USB_DEVICEADDR_USBADR_Msk = 0xfe000000

	// PERIODICLISTBASE: Frame List Base Address
	// Position of BASEADR field.
	USB_PERIODICLISTBASE_BASEADR_Pos = 0xc
	// Bit mask of BASEADR field.
	USB_PERIODICLISTBASE_BASEADR_Msk = 0xfffff000

	// ASYNCLISTADDR: Next Asynch. Address
	// Position of ASYBASE field.
	USB_ASYNCLISTADDR_ASYBASE_Pos = 0x5
	// Bit mask of ASYBASE field.
	USB_ASYNCLISTADDR_ASYBASE_Msk = 0xffffffe0

	// ENDPTLISTADDR: Endpoint List Address
	// Position of EPBASE field.
	USB_ENDPTLISTADDR_EPBASE_Pos = 0xb
	// Bit mask of EPBASE field.
	USB_ENDPTLISTADDR_EPBASE_Msk = 0xfffff800

	// BURSTSIZE: Programmable Burst Size
	// Position of RXPBURST field.
	USB_BURSTSIZE_RXPBURST_Pos = 0x0
	// Bit mask of RXPBURST field.
	USB_BURSTSIZE_RXPBURST_Msk = 0xff
	// Position of TXPBURST field.
	USB_BURSTSIZE_TXPBURST_Pos = 0x8
	// Bit mask of TXPBURST field.
	USB_BURSTSIZE_TXPBURST_Msk = 0x1ff00

	// TXFILLTUNING: TX FIFO Fill Tuning
	// Position of TXSCHOH field.
	USB_TXFILLTUNING_TXSCHOH_Pos = 0x0
	// Bit mask of TXSCHOH field.
	USB_TXFILLTUNING_TXSCHOH_Msk = 0xff
	// Position of TXSCHHEALTH field.
	USB_TXFILLTUNING_TXSCHHEALTH_Pos = 0x8
	// Bit mask of TXSCHHEALTH field.
	USB_TXFILLTUNING_TXSCHHEALTH_Msk = 0x1f00
	// Position of TXFIFOTHRES field.
	USB_TXFILLTUNING_TXFIFOTHRES_Pos = 0x10
	// Bit mask of TXFIFOTHRES field.
	USB_TXFILLTUNING_TXFIFOTHRES_Msk = 0x3f0000

	// ENDPTNAK: Endpoint NAK
	// Position of EPRN field.
	USB_ENDPTNAK_EPRN_Pos = 0x0
	// Bit mask of EPRN field.
	USB_ENDPTNAK_EPRN_Msk = 0xff
	// Position of EPTN field.
	USB_ENDPTNAK_EPTN_Pos = 0x10
	// Bit mask of EPTN field.
	USB_ENDPTNAK_EPTN_Msk = 0xff0000

	// ENDPTNAKEN: Endpoint NAK Enable
	// Position of EPRNE field.
	USB_ENDPTNAKEN_EPRNE_Pos = 0x0
	// Bit mask of EPRNE field.
	USB_ENDPTNAKEN_EPRNE_Msk = 0xff
	// Position of EPTNE field.
	USB_ENDPTNAKEN_EPTNE_Pos = 0x10
	// Bit mask of EPTNE field.
	USB_ENDPTNAKEN_EPTNE_Msk = 0xff0000

	// CONFIGFLAG: Configure Flag Register
	// Position of CF field.
	USB_CONFIGFLAG_CF_Pos = 0x0
	// Bit mask of CF field.
	USB_CONFIGFLAG_CF_Msk = 0x1
	// Bit CF.
	USB_CONFIGFLAG_CF = 0x1
	// Port routing control logic default-routes each port to an implementation dependent classic host controller.
	USB_CONFIGFLAG_CF_CF_0 = 0x0
	// Port routing control logic default-routes all ports to this host controller.
	USB_CONFIGFLAG_CF_CF_1 = 0x1

	// PORTSC1: Port Status & Control
	// Position of CCS field.
	USB_PORTSC1_CCS_Pos = 0x0
	// Bit mask of CCS field.
	USB_PORTSC1_CCS_Msk = 0x1
	// Bit CCS.
	USB_PORTSC1_CCS = 0x1
	// Position of CSC field.
	USB_PORTSC1_CSC_Pos = 0x1
	// Bit mask of CSC field.
	USB_PORTSC1_CSC_Msk = 0x2
	// Bit CSC.
	USB_PORTSC1_CSC = 0x2
	// Position of PE field.
	USB_PORTSC1_PE_Pos = 0x2
	// Bit mask of PE field.
	USB_PORTSC1_PE_Msk = 0x4
	// Bit PE.
	USB_PORTSC1_PE = 0x4
	// Position of PEC field.
	USB_PORTSC1_PEC_Pos = 0x3
	// Bit mask of PEC field.
	USB_PORTSC1_PEC_Msk = 0x8
	// Bit PEC.
	USB_PORTSC1_PEC = 0x8
	// Position of OCA field.
	USB_PORTSC1_OCA_Pos = 0x4
	// Bit mask of OCA field.
	USB_PORTSC1_OCA_Msk = 0x10
	// Bit OCA.
	USB_PORTSC1_OCA = 0x10
	// This port does not have an over-current condition.
	USB_PORTSC1_OCA_OCA_0 = 0x0
	// This port currently has an over-current condition
	USB_PORTSC1_OCA_OCA_1 = 0x1
	// Position of OCC field.
	USB_PORTSC1_OCC_Pos = 0x5
	// Bit mask of OCC field.
	USB_PORTSC1_OCC_Msk = 0x20
	// Bit OCC.
	USB_PORTSC1_OCC = 0x20
	// Position of FPR field.
	USB_PORTSC1_FPR_Pos = 0x6
	// Bit mask of FPR field.
	USB_PORTSC1_FPR_Msk = 0x40
	// Bit FPR.
	USB_PORTSC1_FPR = 0x40
	// Position of SUSP field.
	USB_PORTSC1_SUSP_Pos = 0x7
	// Bit mask of SUSP field.
	USB_PORTSC1_SUSP_Msk = 0x80
	// Bit SUSP.
	USB_PORTSC1_SUSP = 0x80
	// Position of PR field.
	USB_PORTSC1_PR_Pos = 0x8
	// Bit mask of PR field.
	USB_PORTSC1_PR_Msk = 0x100
	// Bit PR.
	USB_PORTSC1_PR = 0x100
	// Position of HSP field.
	USB_PORTSC1_HSP_Pos = 0x9
	// Bit mask of HSP field.
	USB_PORTSC1_HSP_Msk = 0x200
	// Bit HSP.
	USB_PORTSC1_HSP = 0x200
	// Position of LS field.
	USB_PORTSC1_LS_Pos = 0xa
	// Bit mask of LS field.
	USB_PORTSC1_LS_Msk = 0xc00
	// SE0
	USB_PORTSC1_LS_LS_0 = 0x0
	// K-state
	USB_PORTSC1_LS_LS_1 = 0x1
	// J-state
	USB_PORTSC1_LS_LS_2 = 0x2
	// Undefined
	USB_PORTSC1_LS_LS_3 = 0x3
	// Position of PP field.
	USB_PORTSC1_PP_Pos = 0xc
	// Bit mask of PP field.
	USB_PORTSC1_PP_Msk = 0x1000
	// Bit PP.
	USB_PORTSC1_PP = 0x1000
	// Position of PO field.
	USB_PORTSC1_PO_Pos = 0xd
	// Bit mask of PO field.
	USB_PORTSC1_PO_Msk = 0x2000
	// Bit PO.
	USB_PORTSC1_PO = 0x2000
	// Position of PIC field.
	USB_PORTSC1_PIC_Pos = 0xe
	// Bit mask of PIC field.
	USB_PORTSC1_PIC_Msk = 0xc000
	// Port indicators are off
	USB_PORTSC1_PIC_PIC_0 = 0x0
	// Amber
	USB_PORTSC1_PIC_PIC_1 = 0x1
	// Green
	USB_PORTSC1_PIC_PIC_2 = 0x2
	// Undefined
	USB_PORTSC1_PIC_PIC_3 = 0x3
	// Position of PTC field.
	USB_PORTSC1_PTC_Pos = 0x10
	// Bit mask of PTC field.
	USB_PORTSC1_PTC_Msk = 0xf0000
	// TEST_MODE_DISABLE
	USB_PORTSC1_PTC_PTC_0 = 0x0
	// J_STATE
	USB_PORTSC1_PTC_PTC_1 = 0x1
	// K_STATE
	USB_PORTSC1_PTC_PTC_2 = 0x2
	// SE0 (host) / NAK (device)
	USB_PORTSC1_PTC_PTC_3 = 0x3
	// Packet
	USB_PORTSC1_PTC_PTC_4 = 0x4
	// FORCE_ENABLE_HS
	USB_PORTSC1_PTC_PTC_5 = 0x5
	// FORCE_ENABLE_FS
	USB_PORTSC1_PTC_PTC_6 = 0x6
	// FORCE_ENABLE_LS
	USB_PORTSC1_PTC_PTC_7 = 0x7
	// Position of WKCN field.
	USB_PORTSC1_WKCN_Pos = 0x14
	// Bit mask of WKCN field.
	USB_PORTSC1_WKCN_Msk = 0x100000
	// Bit WKCN.
	USB_PORTSC1_WKCN = 0x100000
	// Position of WKDC field.
	USB_PORTSC1_WKDC_Pos = 0x15
	// Bit mask of WKDC field.
	USB_PORTSC1_WKDC_Msk = 0x200000
	// Bit WKDC.
	USB_PORTSC1_WKDC = 0x200000
	// Position of WKOC field.
	USB_PORTSC1_WKOC_Pos = 0x16
	// Bit mask of WKOC field.
	USB_PORTSC1_WKOC_Msk = 0x400000
	// Bit WKOC.
	USB_PORTSC1_WKOC = 0x400000
	// Position of PHCD field.
	USB_PORTSC1_PHCD_Pos = 0x17
	// Bit mask of PHCD field.
	USB_PORTSC1_PHCD_Msk = 0x800000
	// Bit PHCD.
	USB_PORTSC1_PHCD = 0x800000
	// Enable PHY clock
	USB_PORTSC1_PHCD_PHCD_0 = 0x0
	// Disable PHY clock
	USB_PORTSC1_PHCD_PHCD_1 = 0x1
	// Position of PFSC field.
	USB_PORTSC1_PFSC_Pos = 0x18
	// Bit mask of PFSC field.
	USB_PORTSC1_PFSC_Msk = 0x1000000
	// Bit PFSC.
	USB_PORTSC1_PFSC = 0x1000000
	// Normal operation
	USB_PORTSC1_PFSC_PFSC_0 = 0x0
	// Forced to full speed
	USB_PORTSC1_PFSC_PFSC_1 = 0x1
	// Position of PTS_2 field.
	USB_PORTSC1_PTS_2_Pos = 0x19
	// Bit mask of PTS_2 field.
	USB_PORTSC1_PTS_2_Msk = 0x2000000
	// Bit PTS_2.
	USB_PORTSC1_PTS_2 = 0x2000000
	// Position of PSPD field.
	USB_PORTSC1_PSPD_Pos = 0x1a
	// Bit mask of PSPD field.
	USB_PORTSC1_PSPD_Msk = 0xc000000
	// Full Speed
	USB_PORTSC1_PSPD_PSPD_0 = 0x0
	// Low Speed
	USB_PORTSC1_PSPD_PSPD_1 = 0x1
	// High Speed
	USB_PORTSC1_PSPD_PSPD_2 = 0x2
	// Undefined
	USB_PORTSC1_PSPD_PSPD_3 = 0x3
	// Position of PTW field.
	USB_PORTSC1_PTW_Pos = 0x1c
	// Bit mask of PTW field.
	USB_PORTSC1_PTW_Msk = 0x10000000
	// Bit PTW.
	USB_PORTSC1_PTW = 0x10000000
	// Select the 8-bit UTMI interface [60MHz]
	USB_PORTSC1_PTW_PTW_0 = 0x0
	// Select the 16-bit UTMI interface [30MHz]
	USB_PORTSC1_PTW_PTW_1 = 0x1
	// Position of STS field.
	USB_PORTSC1_STS_Pos = 0x1d
	// Bit mask of STS field.
	USB_PORTSC1_STS_Msk = 0x20000000
	// Bit STS.
	USB_PORTSC1_STS = 0x20000000
	// Position of PTS_1 field.
	USB_PORTSC1_PTS_1_Pos = 0x1e
	// Bit mask of PTS_1 field.
	USB_PORTSC1_PTS_1_Msk = 0xc0000000

	// OTGSC: On-The-Go Status & control
	// Position of VD field.
	USB_OTGSC_VD_Pos = 0x0
	// Bit mask of VD field.
	USB_OTGSC_VD_Msk = 0x1
	// Bit VD.
	USB_OTGSC_VD = 0x1
	// Position of VC field.
	USB_OTGSC_VC_Pos = 0x1
	// Bit mask of VC field.
	USB_OTGSC_VC_Msk = 0x2
	// Bit VC.
	USB_OTGSC_VC = 0x2
	// Position of OT field.
	USB_OTGSC_OT_Pos = 0x3
	// Bit mask of OT field.
	USB_OTGSC_OT_Msk = 0x8
	// Bit OT.
	USB_OTGSC_OT = 0x8
	// Position of DP field.
	USB_OTGSC_DP_Pos = 0x4
	// Bit mask of DP field.
	USB_OTGSC_DP_Msk = 0x10
	// Bit DP.
	USB_OTGSC_DP = 0x10
	// Position of IDPU field.
	USB_OTGSC_IDPU_Pos = 0x5
	// Bit mask of IDPU field.
	USB_OTGSC_IDPU_Msk = 0x20
	// Bit IDPU.
	USB_OTGSC_IDPU = 0x20
	// Position of ID field.
	USB_OTGSC_ID_Pos = 0x8
	// Bit mask of ID field.
	USB_OTGSC_ID_Msk = 0x100
	// Bit ID.
	USB_OTGSC_ID = 0x100
	// Position of AVV field.
	USB_OTGSC_AVV_Pos = 0x9
	// Bit mask of AVV field.
	USB_OTGSC_AVV_Msk = 0x200
	// Bit AVV.
	USB_OTGSC_AVV = 0x200
	// Position of ASV field.
	USB_OTGSC_ASV_Pos = 0xa
	// Bit mask of ASV field.
	USB_OTGSC_ASV_Msk = 0x400
	// Bit ASV.
	USB_OTGSC_ASV = 0x400
	// Position of BSV field.
	USB_OTGSC_BSV_Pos = 0xb
	// Bit mask of BSV field.
	USB_OTGSC_BSV_Msk = 0x800
	// Bit BSV.
	USB_OTGSC_BSV = 0x800
	// Position of BSE field.
	USB_OTGSC_BSE_Pos = 0xc
	// Bit mask of BSE field.
	USB_OTGSC_BSE_Msk = 0x1000
	// Bit BSE.
	USB_OTGSC_BSE = 0x1000
	// Position of TOG_1MS field.
	USB_OTGSC_TOG_1MS_Pos = 0xd
	// Bit mask of TOG_1MS field.
	USB_OTGSC_TOG_1MS_Msk = 0x2000
	// Bit TOG_1MS.
	USB_OTGSC_TOG_1MS = 0x2000
	// Position of DPS field.
	USB_OTGSC_DPS_Pos = 0xe
	// Bit mask of DPS field.
	USB_OTGSC_DPS_Msk = 0x4000
	// Bit DPS.
	USB_OTGSC_DPS = 0x4000
	// Position of IDIS field.
	USB_OTGSC_IDIS_Pos = 0x10
	// Bit mask of IDIS field.
	USB_OTGSC_IDIS_Msk = 0x10000
	// Bit IDIS.
	USB_OTGSC_IDIS = 0x10000
	// Position of AVVIS field.
	USB_OTGSC_AVVIS_Pos = 0x11
	// Bit mask of AVVIS field.
	USB_OTGSC_AVVIS_Msk = 0x20000
	// Bit AVVIS.
	USB_OTGSC_AVVIS = 0x20000
	// Position of ASVIS field.
	USB_OTGSC_ASVIS_Pos = 0x12
	// Bit mask of ASVIS field.
	USB_OTGSC_ASVIS_Msk = 0x40000
	// Bit ASVIS.
	USB_OTGSC_ASVIS = 0x40000
	// Position of BSVIS field.
	USB_OTGSC_BSVIS_Pos = 0x13
	// Bit mask of BSVIS field.
	USB_OTGSC_BSVIS_Msk = 0x80000
	// Bit BSVIS.
	USB_OTGSC_BSVIS = 0x80000
	// Position of BSEIS field.
	USB_OTGSC_BSEIS_Pos = 0x14
	// Bit mask of BSEIS field.
	USB_OTGSC_BSEIS_Msk = 0x100000
	// Bit BSEIS.
	USB_OTGSC_BSEIS = 0x100000
	// Position of STATUS_1MS field.
	USB_OTGSC_STATUS_1MS_Pos = 0x15
	// Bit mask of STATUS_1MS field.
	USB_OTGSC_STATUS_1MS_Msk = 0x200000
	// Bit STATUS_1MS.
	USB_OTGSC_STATUS_1MS = 0x200000
	// Position of DPIS field.
	USB_OTGSC_DPIS_Pos = 0x16
	// Bit mask of DPIS field.
	USB_OTGSC_DPIS_Msk = 0x400000
	// Bit DPIS.
	USB_OTGSC_DPIS = 0x400000
	// Position of IDIE field.
	USB_OTGSC_IDIE_Pos = 0x18
	// Bit mask of IDIE field.
	USB_OTGSC_IDIE_Msk = 0x1000000
	// Bit IDIE.
	USB_OTGSC_IDIE = 0x1000000
	// Position of AVVIE field.
	USB_OTGSC_AVVIE_Pos = 0x19
	// Bit mask of AVVIE field.
	USB_OTGSC_AVVIE_Msk = 0x2000000
	// Bit AVVIE.
	USB_OTGSC_AVVIE = 0x2000000
	// Position of ASVIE field.
	USB_OTGSC_ASVIE_Pos = 0x1a
	// Bit mask of ASVIE field.
	USB_OTGSC_ASVIE_Msk = 0x4000000
	// Bit ASVIE.
	USB_OTGSC_ASVIE = 0x4000000
	// Position of BSVIE field.
	USB_OTGSC_BSVIE_Pos = 0x1b
	// Bit mask of BSVIE field.
	USB_OTGSC_BSVIE_Msk = 0x8000000
	// Bit BSVIE.
	USB_OTGSC_BSVIE = 0x8000000
	// Position of BSEIE field.
	USB_OTGSC_BSEIE_Pos = 0x1c
	// Bit mask of BSEIE field.
	USB_OTGSC_BSEIE_Msk = 0x10000000
	// Bit BSEIE.
	USB_OTGSC_BSEIE = 0x10000000
	// Position of EN_1MS field.
	USB_OTGSC_EN_1MS_Pos = 0x1d
	// Bit mask of EN_1MS field.
	USB_OTGSC_EN_1MS_Msk = 0x20000000
	// Bit EN_1MS.
	USB_OTGSC_EN_1MS = 0x20000000
	// Position of DPIE field.
	USB_OTGSC_DPIE_Pos = 0x1e
	// Bit mask of DPIE field.
	USB_OTGSC_DPIE_Msk = 0x40000000
	// Bit DPIE.
	USB_OTGSC_DPIE = 0x40000000

	// USBMODE: USB Device Mode
	// Position of CM field.
	USB_USBMODE_CM_Pos = 0x0
	// Bit mask of CM field.
	USB_USBMODE_CM_Msk = 0x3
	// Idle [Default for combination host/device]
	USB_USBMODE_CM_CM_0 = 0x0
	// Device Controller [Default for device only controller]
	USB_USBMODE_CM_CM_2 = 0x2
	// Host Controller [Default for host only controller]
	USB_USBMODE_CM_CM_3 = 0x3
	// Position of ES field.
	USB_USBMODE_ES_Pos = 0x2
	// Bit mask of ES field.
	USB_USBMODE_ES_Msk = 0x4
	// Bit ES.
	USB_USBMODE_ES = 0x4
	// Little Endian [Default]
	USB_USBMODE_ES_ES_0 = 0x0
	// Big Endian
	USB_USBMODE_ES_ES_1 = 0x1
	// Position of SLOM field.
	USB_USBMODE_SLOM_Pos = 0x3
	// Bit mask of SLOM field.
	USB_USBMODE_SLOM_Msk = 0x8
	// Bit SLOM.
	USB_USBMODE_SLOM = 0x8
	// Setup Lockouts On (default);
	USB_USBMODE_SLOM_SLOM_0 = 0x0
	// Setup Lockouts Off (DCD requires use of Setup Data Buffer Tripwire in USBCMDUSB Command Register .
	USB_USBMODE_SLOM_SLOM_1 = 0x1
	// Position of SDIS field.
	USB_USBMODE_SDIS_Pos = 0x4
	// Bit mask of SDIS field.
	USB_USBMODE_SDIS_Msk = 0x10
	// Bit SDIS.
	USB_USBMODE_SDIS = 0x10

	// ENDPTSETUPSTAT: Endpoint Setup Status
	// Position of ENDPTSETUPSTAT field.
	USB_ENDPTSETUPSTAT_ENDPTSETUPSTAT_Pos = 0x0
	// Bit mask of ENDPTSETUPSTAT field.
	USB_ENDPTSETUPSTAT_ENDPTSETUPSTAT_Msk = 0xffff

	// ENDPTPRIME: Endpoint Prime
	// Position of PERB field.
	USB_ENDPTPRIME_PERB_Pos = 0x0
	// Bit mask of PERB field.
	USB_ENDPTPRIME_PERB_Msk = 0xff
	// Position of PETB field.
	USB_ENDPTPRIME_PETB_Pos = 0x10
	// Bit mask of PETB field.
	USB_ENDPTPRIME_PETB_Msk = 0xff0000

	// ENDPTFLUSH: Endpoint Flush
	// Position of FERB field.
	USB_ENDPTFLUSH_FERB_Pos = 0x0
	// Bit mask of FERB field.
	USB_ENDPTFLUSH_FERB_Msk = 0xff
	// Position of FETB field.
	USB_ENDPTFLUSH_FETB_Pos = 0x10
	// Bit mask of FETB field.
	USB_ENDPTFLUSH_FETB_Msk = 0xff0000

	// ENDPTSTAT: Endpoint Status
	// Position of ERBR field.
	USB_ENDPTSTAT_ERBR_Pos = 0x0
	// Bit mask of ERBR field.
	USB_ENDPTSTAT_ERBR_Msk = 0xff
	// Position of ETBR field.
	USB_ENDPTSTAT_ETBR_Pos = 0x10
	// Bit mask of ETBR field.
	USB_ENDPTSTAT_ETBR_Msk = 0xff0000

	// ENDPTCOMPLETE: Endpoint Complete
	// Position of ERCE field.
	USB_ENDPTCOMPLETE_ERCE_Pos = 0x0
	// Bit mask of ERCE field.
	USB_ENDPTCOMPLETE_ERCE_Msk = 0xff
	// Position of ETCE field.
	USB_ENDPTCOMPLETE_ETCE_Pos = 0x10
	// Bit mask of ETCE field.
	USB_ENDPTCOMPLETE_ETCE_Msk = 0xff0000

	// ENDPTCTRL0: Endpoint Control0
	// Position of RXS field.
	USB_ENDPTCTRL0_RXS_Pos = 0x0
	// Bit mask of RXS field.
	USB_ENDPTCTRL0_RXS_Msk = 0x1
	// Bit RXS.
	USB_ENDPTCTRL0_RXS = 0x1
	// Position of RXT field.
	USB_ENDPTCTRL0_RXT_Pos = 0x2
	// Bit mask of RXT field.
	USB_ENDPTCTRL0_RXT_Msk = 0xc
	// Position of RXE field.
	USB_ENDPTCTRL0_RXE_Pos = 0x7
	// Bit mask of RXE field.
	USB_ENDPTCTRL0_RXE_Msk = 0x80
	// Bit RXE.
	USB_ENDPTCTRL0_RXE = 0x80
	// Position of TXS field.
	USB_ENDPTCTRL0_TXS_Pos = 0x10
	// Bit mask of TXS field.
	USB_ENDPTCTRL0_TXS_Msk = 0x10000
	// Bit TXS.
	USB_ENDPTCTRL0_TXS = 0x10000
	// Position of TXT field.
	USB_ENDPTCTRL0_TXT_Pos = 0x12
	// Bit mask of TXT field.
	USB_ENDPTCTRL0_TXT_Msk = 0xc0000
	// Position of TXE field.
	USB_ENDPTCTRL0_TXE_Pos = 0x17
	// Bit mask of TXE field.
	USB_ENDPTCTRL0_TXE_Msk = 0x800000
	// Bit TXE.
	USB_ENDPTCTRL0_TXE = 0x800000

	// ENDPTCTRL1: Endpoint Control 1
	// Position of RXS field.
	USB_ENDPTCTRL1_RXS_Pos = 0x0
	// Bit mask of RXS field.
	USB_ENDPTCTRL1_RXS_Msk = 0x1
	// Bit RXS.
	USB_ENDPTCTRL1_RXS = 0x1
	// Position of RXD field.
	USB_ENDPTCTRL1_RXD_Pos = 0x1
	// Bit mask of RXD field.
	USB_ENDPTCTRL1_RXD_Msk = 0x2
	// Bit RXD.
	USB_ENDPTCTRL1_RXD = 0x2
	// Position of RXT field.
	USB_ENDPTCTRL1_RXT_Pos = 0x2
	// Bit mask of RXT field.
	USB_ENDPTCTRL1_RXT_Msk = 0xc
	// Position of RXI field.
	USB_ENDPTCTRL1_RXI_Pos = 0x5
	// Bit mask of RXI field.
	USB_ENDPTCTRL1_RXI_Msk = 0x20
	// Bit RXI.
	USB_ENDPTCTRL1_RXI = 0x20
	// Position of RXR field.
	USB_ENDPTCTRL1_RXR_Pos = 0x6
	// Bit mask of RXR field.
	USB_ENDPTCTRL1_RXR_Msk = 0x40
	// Bit RXR.
	USB_ENDPTCTRL1_RXR = 0x40
	// Position of RXE field.
	USB_ENDPTCTRL1_RXE_Pos = 0x7
	// Bit mask of RXE field.
	USB_ENDPTCTRL1_RXE_Msk = 0x80
	// Bit RXE.
	USB_ENDPTCTRL1_RXE = 0x80
	// Position of TXS field.
	USB_ENDPTCTRL1_TXS_Pos = 0x10
	// Bit mask of TXS field.
	USB_ENDPTCTRL1_TXS_Msk = 0x10000
	// Bit TXS.
	USB_ENDPTCTRL1_TXS = 0x10000
	// Position of TXD field.
	USB_ENDPTCTRL1_TXD_Pos = 0x11
	// Bit mask of TXD field.
	USB_ENDPTCTRL1_TXD_Msk = 0x20000
	// Bit TXD.
	USB_ENDPTCTRL1_TXD = 0x20000
	// Position of TXT field.
	USB_ENDPTCTRL1_TXT_Pos = 0x12
	// Bit mask of TXT field.
	USB_ENDPTCTRL1_TXT_Msk = 0xc0000
	// Position of TXI field.
	USB_ENDPTCTRL1_TXI_Pos = 0x15
	// Bit mask of TXI field.
	USB_ENDPTCTRL1_TXI_Msk = 0x200000
	// Bit TXI.
	USB_ENDPTCTRL1_TXI = 0x200000
	// Position of TXR field.
	USB_ENDPTCTRL1_TXR_Pos = 0x16
	// Bit mask of TXR field.
	USB_ENDPTCTRL1_TXR_Msk = 0x400000
	// Bit TXR.
	USB_ENDPTCTRL1_TXR = 0x400000
	// Position of TXE field.
	USB_ENDPTCTRL1_TXE_Pos = 0x17
	// Bit mask of TXE field.
	USB_ENDPTCTRL1_TXE_Msk = 0x800000
	// Bit TXE.
	USB_ENDPTCTRL1_TXE = 0x800000

	// ENDPTCTRL2: Endpoint Control 2
	// Position of RXS field.
	USB_ENDPTCTRL2_RXS_Pos = 0x0
	// Bit mask of RXS field.
	USB_ENDPTCTRL2_RXS_Msk = 0x1
	// Bit RXS.
	USB_ENDPTCTRL2_RXS = 0x1
	// Position of RXD field.
	USB_ENDPTCTRL2_RXD_Pos = 0x1
	// Bit mask of RXD field.
	USB_ENDPTCTRL2_RXD_Msk = 0x2
	// Bit RXD.
	USB_ENDPTCTRL2_RXD = 0x2
	// Position of RXT field.
	USB_ENDPTCTRL2_RXT_Pos = 0x2
	// Bit mask of RXT field.
	USB_ENDPTCTRL2_RXT_Msk = 0xc
	// Position of RXI field.
	USB_ENDPTCTRL2_RXI_Pos = 0x5
	// Bit mask of RXI field.
	USB_ENDPTCTRL2_RXI_Msk = 0x20
	// Bit RXI.
	USB_ENDPTCTRL2_RXI = 0x20
	// Position of RXR field.
	USB_ENDPTCTRL2_RXR_Pos = 0x6
	// Bit mask of RXR field.
	USB_ENDPTCTRL2_RXR_Msk = 0x40
	// Bit RXR.
	USB_ENDPTCTRL2_RXR = 0x40
	// Position of RXE field.
	USB_ENDPTCTRL2_RXE_Pos = 0x7
	// Bit mask of RXE field.
	USB_ENDPTCTRL2_RXE_Msk = 0x80
	// Bit RXE.
	USB_ENDPTCTRL2_RXE = 0x80
	// Position of TXS field.
	USB_ENDPTCTRL2_TXS_Pos = 0x10
	// Bit mask of TXS field.
	USB_ENDPTCTRL2_TXS_Msk = 0x10000
	// Bit TXS.
	USB_ENDPTCTRL2_TXS = 0x10000
	// Position of TXD field.
	USB_ENDPTCTRL2_TXD_Pos = 0x11
	// Bit mask of TXD field.
	USB_ENDPTCTRL2_TXD_Msk = 0x20000
	// Bit TXD.
	USB_ENDPTCTRL2_TXD = 0x20000
	// Position of TXT field.
	USB_ENDPTCTRL2_TXT_Pos = 0x12
	// Bit mask of TXT field.
	USB_ENDPTCTRL2_TXT_Msk = 0xc0000
	// Position of TXI field.
	USB_ENDPTCTRL2_TXI_Pos = 0x15
	// Bit mask of TXI field.
	USB_ENDPTCTRL2_TXI_Msk = 0x200000
	// Bit TXI.
	USB_ENDPTCTRL2_TXI = 0x200000
	// Position of TXR field.
	USB_ENDPTCTRL2_TXR_Pos = 0x16
	// Bit mask of TXR field.
	USB_ENDPTCTRL2_TXR_Msk = 0x400000
	// Bit TXR.
	USB_ENDPTCTRL2_TXR = 0x400000
	// Position of TXE field.
	USB_ENDPTCTRL2_TXE_Pos = 0x17
	// Bit mask of TXE field.
	USB_ENDPTCTRL2_TXE_Msk = 0x800000
	// Bit TXE.
	USB_ENDPTCTRL2_TXE = 0x800000

	// ENDPTCTRL3: Endpoint Control 3
	// Position of RXS field.
	USB_ENDPTCTRL3_RXS_Pos = 0x0
	// Bit mask of RXS field.
	USB_ENDPTCTRL3_RXS_Msk = 0x1
	// Bit RXS.
	USB_ENDPTCTRL3_RXS = 0x1
	// Position of RXD field.
	USB_ENDPTCTRL3_RXD_Pos = 0x1
	// Bit mask of RXD field.
	USB_ENDPTCTRL3_RXD_Msk = 0x2
	// Bit RXD.
	USB_ENDPTCTRL3_RXD = 0x2
	// Position of RXT field.
	USB_ENDPTCTRL3_RXT_Pos = 0x2
	// Bit mask of RXT field.
	USB_ENDPTCTRL3_RXT_Msk = 0xc
	// Position of RXI field.
	USB_ENDPTCTRL3_RXI_Pos = 0x5
	// Bit mask of RXI field.
	USB_ENDPTCTRL3_RXI_Msk = 0x20
	// Bit RXI.
	USB_ENDPTCTRL3_RXI = 0x20
	// Position of RXR field.
	USB_ENDPTCTRL3_RXR_Pos = 0x6
	// Bit mask of RXR field.
	USB_ENDPTCTRL3_RXR_Msk = 0x40
	// Bit RXR.
	USB_ENDPTCTRL3_RXR = 0x40
	// Position of RXE field.
	USB_ENDPTCTRL3_RXE_Pos = 0x7
	// Bit mask of RXE field.
	USB_ENDPTCTRL3_RXE_Msk = 0x80
	// Bit RXE.
	USB_ENDPTCTRL3_RXE = 0x80
	// Position of TXS field.
	USB_ENDPTCTRL3_TXS_Pos = 0x10
	// Bit mask of TXS field.
	USB_ENDPTCTRL3_TXS_Msk = 0x10000
	// Bit TXS.
	USB_ENDPTCTRL3_TXS = 0x10000
	// Position of TXD field.
	USB_ENDPTCTRL3_TXD_Pos = 0x11
	// Bit mask of TXD field.
	USB_ENDPTCTRL3_TXD_Msk = 0x20000
	// Bit TXD.
	USB_ENDPTCTRL3_TXD = 0x20000
	// Position of TXT field.
	USB_ENDPTCTRL3_TXT_Pos = 0x12
	// Bit mask of TXT field.
	USB_ENDPTCTRL3_TXT_Msk = 0xc0000
	// Position of TXI field.
	USB_ENDPTCTRL3_TXI_Pos = 0x15
	// Bit mask of TXI field.
	USB_ENDPTCTRL3_TXI_Msk = 0x200000
	// Bit TXI.
	USB_ENDPTCTRL3_TXI = 0x200000
	// Position of TXR field.
	USB_ENDPTCTRL3_TXR_Pos = 0x16
	// Bit mask of TXR field.
	USB_ENDPTCTRL3_TXR_Msk = 0x400000
	// Bit TXR.
	USB_ENDPTCTRL3_TXR = 0x400000
	// Position of TXE field.
	USB_ENDPTCTRL3_TXE_Pos = 0x17
	// Bit mask of TXE field.
	USB_ENDPTCTRL3_TXE_Msk = 0x800000
	// Bit TXE.
	USB_ENDPTCTRL3_TXE = 0x800000

	// ENDPTCTRL4: Endpoint Control 4
	// Position of RXS field.
	USB_ENDPTCTRL4_RXS_Pos = 0x0
	// Bit mask of RXS field.
	USB_ENDPTCTRL4_RXS_Msk = 0x1
	// Bit RXS.
	USB_ENDPTCTRL4_RXS = 0x1
	// Position of RXD field.
	USB_ENDPTCTRL4_RXD_Pos = 0x1
	// Bit mask of RXD field.
	USB_ENDPTCTRL4_RXD_Msk = 0x2
	// Bit RXD.
	USB_ENDPTCTRL4_RXD = 0x2
	// Position of RXT field.
	USB_ENDPTCTRL4_RXT_Pos = 0x2
	// Bit mask of RXT field.
	USB_ENDPTCTRL4_RXT_Msk = 0xc
	// Position of RXI field.
	USB_ENDPTCTRL4_RXI_Pos = 0x5
	// Bit mask of RXI field.
	USB_ENDPTCTRL4_RXI_Msk = 0x20
	// Bit RXI.
	USB_ENDPTCTRL4_RXI = 0x20
	// Position of RXR field.
	USB_ENDPTCTRL4_RXR_Pos = 0x6
	// Bit mask of RXR field.
	USB_ENDPTCTRL4_RXR_Msk = 0x40
	// Bit RXR.
	USB_ENDPTCTRL4_RXR = 0x40
	// Position of RXE field.
	USB_ENDPTCTRL4_RXE_Pos = 0x7
	// Bit mask of RXE field.
	USB_ENDPTCTRL4_RXE_Msk = 0x80
	// Bit RXE.
	USB_ENDPTCTRL4_RXE = 0x80
	// Position of TXS field.
	USB_ENDPTCTRL4_TXS_Pos = 0x10
	// Bit mask of TXS field.
	USB_ENDPTCTRL4_TXS_Msk = 0x10000
	// Bit TXS.
	USB_ENDPTCTRL4_TXS = 0x10000
	// Position of TXD field.
	USB_ENDPTCTRL4_TXD_Pos = 0x11
	// Bit mask of TXD field.
	USB_ENDPTCTRL4_TXD_Msk = 0x20000
	// Bit TXD.
	USB_ENDPTCTRL4_TXD = 0x20000
	// Position of TXT field.
	USB_ENDPTCTRL4_TXT_Pos = 0x12
	// Bit mask of TXT field.
	USB_ENDPTCTRL4_TXT_Msk = 0xc0000
	// Position of TXI field.
	USB_ENDPTCTRL4_TXI_Pos = 0x15
	// Bit mask of TXI field.
	USB_ENDPTCTRL4_TXI_Msk = 0x200000
	// Bit TXI.
	USB_ENDPTCTRL4_TXI = 0x200000
	// Position of TXR field.
	USB_ENDPTCTRL4_TXR_Pos = 0x16
	// Bit mask of TXR field.
	USB_ENDPTCTRL4_TXR_Msk = 0x400000
	// Bit TXR.
	USB_ENDPTCTRL4_TXR = 0x400000
	// Position of TXE field.
	USB_ENDPTCTRL4_TXE_Pos = 0x17
	// Bit mask of TXE field.
	USB_ENDPTCTRL4_TXE_Msk = 0x800000
	// Bit TXE.
	USB_ENDPTCTRL4_TXE = 0x800000

	// ENDPTCTRL5: Endpoint Control 5
	// Position of RXS field.
	USB_ENDPTCTRL5_RXS_Pos = 0x0
	// Bit mask of RXS field.
	USB_ENDPTCTRL5_RXS_Msk = 0x1
	// Bit RXS.
	USB_ENDPTCTRL5_RXS = 0x1
	// Position of RXD field.
	USB_ENDPTCTRL5_RXD_Pos = 0x1
	// Bit mask of RXD field.
	USB_ENDPTCTRL5_RXD_Msk = 0x2
	// Bit RXD.
	USB_ENDPTCTRL5_RXD = 0x2
	// Position of RXT field.
	USB_ENDPTCTRL5_RXT_Pos = 0x2
	// Bit mask of RXT field.
	USB_ENDPTCTRL5_RXT_Msk = 0xc
	// Position of RXI field.
	USB_ENDPTCTRL5_RXI_Pos = 0x5
	// Bit mask of RXI field.
	USB_ENDPTCTRL5_RXI_Msk = 0x20
	// Bit RXI.
	USB_ENDPTCTRL5_RXI = 0x20
	// Position of RXR field.
	USB_ENDPTCTRL5_RXR_Pos = 0x6
	// Bit mask of RXR field.
	USB_ENDPTCTRL5_RXR_Msk = 0x40
	// Bit RXR.
	USB_ENDPTCTRL5_RXR = 0x40
	// Position of RXE field.
	USB_ENDPTCTRL5_RXE_Pos = 0x7
	// Bit mask of RXE field.
	USB_ENDPTCTRL5_RXE_Msk = 0x80
	// Bit RXE.
	USB_ENDPTCTRL5_RXE = 0x80
	// Position of TXS field.
	USB_ENDPTCTRL5_TXS_Pos = 0x10
	// Bit mask of TXS field.
	USB_ENDPTCTRL5_TXS_Msk = 0x10000
	// Bit TXS.
	USB_ENDPTCTRL5_TXS = 0x10000
	// Position of TXD field.
	USB_ENDPTCTRL5_TXD_Pos = 0x11
	// Bit mask of TXD field.
	USB_ENDPTCTRL5_TXD_Msk = 0x20000
	// Bit TXD.
	USB_ENDPTCTRL5_TXD = 0x20000
	// Position of TXT field.
	USB_ENDPTCTRL5_TXT_Pos = 0x12
	// Bit mask of TXT field.
	USB_ENDPTCTRL5_TXT_Msk = 0xc0000
	// Position of TXI field.
	USB_ENDPTCTRL5_TXI_Pos = 0x15
	// Bit mask of TXI field.
	USB_ENDPTCTRL5_TXI_Msk = 0x200000
	// Bit TXI.
	USB_ENDPTCTRL5_TXI = 0x200000
	// Position of TXR field.
	USB_ENDPTCTRL5_TXR_Pos = 0x16
	// Bit mask of TXR field.
	USB_ENDPTCTRL5_TXR_Msk = 0x400000
	// Bit TXR.
	USB_ENDPTCTRL5_TXR = 0x400000
	// Position of TXE field.
	USB_ENDPTCTRL5_TXE_Pos = 0x17
	// Bit mask of TXE field.
	USB_ENDPTCTRL5_TXE_Msk = 0x800000
	// Bit TXE.
	USB_ENDPTCTRL5_TXE = 0x800000

	// ENDPTCTRL6: Endpoint Control 6
	// Position of RXS field.
	USB_ENDPTCTRL6_RXS_Pos = 0x0
	// Bit mask of RXS field.
	USB_ENDPTCTRL6_RXS_Msk = 0x1
	// Bit RXS.
	USB_ENDPTCTRL6_RXS = 0x1
	// Position of RXD field.
	USB_ENDPTCTRL6_RXD_Pos = 0x1
	// Bit mask of RXD field.
	USB_ENDPTCTRL6_RXD_Msk = 0x2
	// Bit RXD.
	USB_ENDPTCTRL6_RXD = 0x2
	// Position of RXT field.
	USB_ENDPTCTRL6_RXT_Pos = 0x2
	// Bit mask of RXT field.
	USB_ENDPTCTRL6_RXT_Msk = 0xc
	// Position of RXI field.
	USB_ENDPTCTRL6_RXI_Pos = 0x5
	// Bit mask of RXI field.
	USB_ENDPTCTRL6_RXI_Msk = 0x20
	// Bit RXI.
	USB_ENDPTCTRL6_RXI = 0x20
	// Position of RXR field.
	USB_ENDPTCTRL6_RXR_Pos = 0x6
	// Bit mask of RXR field.
	USB_ENDPTCTRL6_RXR_Msk = 0x40
	// Bit RXR.
	USB_ENDPTCTRL6_RXR = 0x40
	// Position of RXE field.
	USB_ENDPTCTRL6_RXE_Pos = 0x7
	// Bit mask of RXE field.
	USB_ENDPTCTRL6_RXE_Msk = 0x80
	// Bit RXE.
	USB_ENDPTCTRL6_RXE = 0x80
	// Position of TXS field.
	USB_ENDPTCTRL6_TXS_Pos = 0x10
	// Bit mask of TXS field.
	USB_ENDPTCTRL6_TXS_Msk = 0x10000
	// Bit TXS.
	USB_ENDPTCTRL6_TXS = 0x10000
	// Position of TXD field.
	USB_ENDPTCTRL6_TXD_Pos = 0x11
	// Bit mask of TXD field.
	USB_ENDPTCTRL6_TXD_Msk = 0x20000
	// Bit TXD.
	USB_ENDPTCTRL6_TXD = 0x20000
	// Position of TXT field.
	USB_ENDPTCTRL6_TXT_Pos = 0x12
	// Bit mask of TXT field.
	USB_ENDPTCTRL6_TXT_Msk = 0xc0000
	// Position of TXI field.
	USB_ENDPTCTRL6_TXI_Pos = 0x15
	// Bit mask of TXI field.
	USB_ENDPTCTRL6_TXI_Msk = 0x200000
	// Bit TXI.
	USB_ENDPTCTRL6_TXI = 0x200000
	// Position of TXR field.
	USB_ENDPTCTRL6_TXR_Pos = 0x16
	// Bit mask of TXR field.
	USB_ENDPTCTRL6_TXR_Msk = 0x400000
	// Bit TXR.
	USB_ENDPTCTRL6_TXR = 0x400000
	// Position of TXE field.
	USB_ENDPTCTRL6_TXE_Pos = 0x17
	// Bit mask of TXE field.
	USB_ENDPTCTRL6_TXE_Msk = 0x800000
	// Bit TXE.
	USB_ENDPTCTRL6_TXE = 0x800000

	// ENDPTCTRL7: Endpoint Control 7
	// Position of RXS field.
	USB_ENDPTCTRL7_RXS_Pos = 0x0
	// Bit mask of RXS field.
	USB_ENDPTCTRL7_RXS_Msk = 0x1
	// Bit RXS.
	USB_ENDPTCTRL7_RXS = 0x1
	// Position of RXD field.
	USB_ENDPTCTRL7_RXD_Pos = 0x1
	// Bit mask of RXD field.
	USB_ENDPTCTRL7_RXD_Msk = 0x2
	// Bit RXD.
	USB_ENDPTCTRL7_RXD = 0x2
	// Position of RXT field.
	USB_ENDPTCTRL7_RXT_Pos = 0x2
	// Bit mask of RXT field.
	USB_ENDPTCTRL7_RXT_Msk = 0xc
	// Position of RXI field.
	USB_ENDPTCTRL7_RXI_Pos = 0x5
	// Bit mask of RXI field.
	USB_ENDPTCTRL7_RXI_Msk = 0x20
	// Bit RXI.
	USB_ENDPTCTRL7_RXI = 0x20
	// Position of RXR field.
	USB_ENDPTCTRL7_RXR_Pos = 0x6
	// Bit mask of RXR field.
	USB_ENDPTCTRL7_RXR_Msk = 0x40
	// Bit RXR.
	USB_ENDPTCTRL7_RXR = 0x40
	// Position of RXE field.
	USB_ENDPTCTRL7_RXE_Pos = 0x7
	// Bit mask of RXE field.
	USB_ENDPTCTRL7_RXE_Msk = 0x80
	// Bit RXE.
	USB_ENDPTCTRL7_RXE = 0x80
	// Position of TXS field.
	USB_ENDPTCTRL7_TXS_Pos = 0x10
	// Bit mask of TXS field.
	USB_ENDPTCTRL7_TXS_Msk = 0x10000
	// Bit TXS.
	USB_ENDPTCTRL7_TXS = 0x10000
	// Position of TXD field.
	USB_ENDPTCTRL7_TXD_Pos = 0x11
	// Bit mask of TXD field.
	USB_ENDPTCTRL7_TXD_Msk = 0x20000
	// Bit TXD.
	USB_ENDPTCTRL7_TXD = 0x20000
	// Position of TXT field.
	USB_ENDPTCTRL7_TXT_Pos = 0x12
	// Bit mask of TXT field.
	USB_ENDPTCTRL7_TXT_Msk = 0xc0000
	// Position of TXI field.
	USB_ENDPTCTRL7_TXI_Pos = 0x15
	// Bit mask of TXI field.
	USB_ENDPTCTRL7_TXI_Msk = 0x200000
	// Bit TXI.
	USB_ENDPTCTRL7_TXI = 0x200000
	// Position of TXR field.
	USB_ENDPTCTRL7_TXR_Pos = 0x16
	// Bit mask of TXR field.
	USB_ENDPTCTRL7_TXR_Msk = 0x400000
	// Bit TXR.
	USB_ENDPTCTRL7_TXR = 0x400000
	// Position of TXE field.
	USB_ENDPTCTRL7_TXE_Pos = 0x17
	// Bit mask of TXE field.
	USB_ENDPTCTRL7_TXE_Msk = 0x800000
	// Bit TXE.
	USB_ENDPTCTRL7_TXE = 0x800000
)

// Bitfields for USBNC1: USB
const (
	// USB_OTG1_CTRL: USB OTG1 Control Register
	// Position of OVER_CUR_DIS field.
	USBNC_USB_OTG1_CTRL_OVER_CUR_DIS_Pos = 0x7
	// Bit mask of OVER_CUR_DIS field.
	USBNC_USB_OTG1_CTRL_OVER_CUR_DIS_Msk = 0x80
	// Bit OVER_CUR_DIS.
	USBNC_USB_OTG1_CTRL_OVER_CUR_DIS = 0x80
	// Enables overcurrent detection
	USBNC_USB_OTG1_CTRL_OVER_CUR_DIS_OVER_CUR_DIS_0 = 0x0
	// Disables overcurrent detection
	USBNC_USB_OTG1_CTRL_OVER_CUR_DIS_OVER_CUR_DIS_1 = 0x1
	// Position of OVER_CUR_POL field.
	USBNC_USB_OTG1_CTRL_OVER_CUR_POL_Pos = 0x8
	// Bit mask of OVER_CUR_POL field.
	USBNC_USB_OTG1_CTRL_OVER_CUR_POL_Msk = 0x100
	// Bit OVER_CUR_POL.
	USBNC_USB_OTG1_CTRL_OVER_CUR_POL = 0x100
	// High active (high on this signal represents an overcurrent condition)
	USBNC_USB_OTG1_CTRL_OVER_CUR_POL_OVER_CUR_POL_0 = 0x0
	// Low active (low on this signal represents an overcurrent condition)
	USBNC_USB_OTG1_CTRL_OVER_CUR_POL_OVER_CUR_POL_1 = 0x1
	// Position of PWR_POL field.
	USBNC_USB_OTG1_CTRL_PWR_POL_Pos = 0x9
	// Bit mask of PWR_POL field.
	USBNC_USB_OTG1_CTRL_PWR_POL_Msk = 0x200
	// Bit PWR_POL.
	USBNC_USB_OTG1_CTRL_PWR_POL = 0x200
	// PMIC Power Pin is Low active.
	USBNC_USB_OTG1_CTRL_PWR_POL_PWR_POL_0 = 0x0
	// PMIC Power Pin is High active.
	USBNC_USB_OTG1_CTRL_PWR_POL_PWR_POL_1 = 0x1
	// Position of WIE field.
	USBNC_USB_OTG1_CTRL_WIE_Pos = 0xa
	// Bit mask of WIE field.
	USBNC_USB_OTG1_CTRL_WIE_Msk = 0x400
	// Bit WIE.
	USBNC_USB_OTG1_CTRL_WIE = 0x400
	// Interrupt Disabled
	USBNC_USB_OTG1_CTRL_WIE_WIE_0 = 0x0
	// Interrupt Enabled
	USBNC_USB_OTG1_CTRL_WIE_WIE_1 = 0x1
	// Position of WKUP_SW_EN field.
	USBNC_USB_OTG1_CTRL_WKUP_SW_EN_Pos = 0xe
	// Bit mask of WKUP_SW_EN field.
	USBNC_USB_OTG1_CTRL_WKUP_SW_EN_Msk = 0x4000
	// Bit WKUP_SW_EN.
	USBNC_USB_OTG1_CTRL_WKUP_SW_EN = 0x4000
	// Disable
	USBNC_USB_OTG1_CTRL_WKUP_SW_EN_WKUP_SW_EN_0 = 0x0
	// Enable
	USBNC_USB_OTG1_CTRL_WKUP_SW_EN_WKUP_SW_EN_1 = 0x1
	// Position of WKUP_SW field.
	USBNC_USB_OTG1_CTRL_WKUP_SW_Pos = 0xf
	// Bit mask of WKUP_SW field.
	USBNC_USB_OTG1_CTRL_WKUP_SW_Msk = 0x8000
	// Bit WKUP_SW.
	USBNC_USB_OTG1_CTRL_WKUP_SW = 0x8000
	// Inactive
	USBNC_USB_OTG1_CTRL_WKUP_SW_WKUP_SW_0 = 0x0
	// Force wake-up
	USBNC_USB_OTG1_CTRL_WKUP_SW_WKUP_SW_1 = 0x1
	// Position of WKUP_ID_EN field.
	USBNC_USB_OTG1_CTRL_WKUP_ID_EN_Pos = 0x10
	// Bit mask of WKUP_ID_EN field.
	USBNC_USB_OTG1_CTRL_WKUP_ID_EN_Msk = 0x10000
	// Bit WKUP_ID_EN.
	USBNC_USB_OTG1_CTRL_WKUP_ID_EN = 0x10000
	// Disable
	USBNC_USB_OTG1_CTRL_WKUP_ID_EN_WKUP_ID_EN_0 = 0x0
	// Enable
	USBNC_USB_OTG1_CTRL_WKUP_ID_EN_WKUP_ID_EN_1 = 0x1
	// Position of WKUP_VBUS_EN field.
	USBNC_USB_OTG1_CTRL_WKUP_VBUS_EN_Pos = 0x11
	// Bit mask of WKUP_VBUS_EN field.
	USBNC_USB_OTG1_CTRL_WKUP_VBUS_EN_Msk = 0x20000
	// Bit WKUP_VBUS_EN.
	USBNC_USB_OTG1_CTRL_WKUP_VBUS_EN = 0x20000
	// Disable
	USBNC_USB_OTG1_CTRL_WKUP_VBUS_EN_WKUP_VBUS_EN_0 = 0x0
	// Enable
	USBNC_USB_OTG1_CTRL_WKUP_VBUS_EN_WKUP_VBUS_EN_1 = 0x1
	// Position of WKUP_DPDM_EN field.
	USBNC_USB_OTG1_CTRL_WKUP_DPDM_EN_Pos = 0x1d
	// Bit mask of WKUP_DPDM_EN field.
	USBNC_USB_OTG1_CTRL_WKUP_DPDM_EN_Msk = 0x20000000
	// Bit WKUP_DPDM_EN.
	USBNC_USB_OTG1_CTRL_WKUP_DPDM_EN = 0x20000000
	// DPDM changes wake-up to be disabled only when VBUS is 0.
	USBNC_USB_OTG1_CTRL_WKUP_DPDM_EN_WKUP_DPDM_EN_0 = 0x0
	// (Default) DPDM changes wake-up to be enabled, it is for device only.
	USBNC_USB_OTG1_CTRL_WKUP_DPDM_EN_WKUP_DPDM_EN_1 = 0x1
	// Position of WIR field.
	USBNC_USB_OTG1_CTRL_WIR_Pos = 0x1f
	// Bit mask of WIR field.
	USBNC_USB_OTG1_CTRL_WIR_Msk = 0x80000000
	// Bit WIR.
	USBNC_USB_OTG1_CTRL_WIR = 0x80000000
	// No wake-up interrupt request received
	USBNC_USB_OTG1_CTRL_WIR_WIR_0 = 0x0
	// Wake-up Interrupt Request received
	USBNC_USB_OTG1_CTRL_WIR_WIR_1 = 0x1

	// USB_OTG1_PHY_CTRL_0: OTG1 UTMI PHY Control 0 Register
	// Position of UTMI_CLK_VLD field.
	USBNC_USB_OTG1_PHY_CTRL_0_UTMI_CLK_VLD_Pos = 0x1f
	// Bit mask of UTMI_CLK_VLD field.
	USBNC_USB_OTG1_PHY_CTRL_0_UTMI_CLK_VLD_Msk = 0x80000000
	// Bit UTMI_CLK_VLD.
	USBNC_USB_OTG1_PHY_CTRL_0_UTMI_CLK_VLD = 0x80000000
	// Invalid
	USBNC_USB_OTG1_PHY_CTRL_0_UTMI_CLK_VLD_UTMI_CLK_VLD_0 = 0x0
	// Valid
	USBNC_USB_OTG1_PHY_CTRL_0_UTMI_CLK_VLD_UTMI_CLK_VLD_1 = 0x1
)

// Bitfields for SEMC: SEMC
const (
	// MCR: Module Control Register
	// Position of SWRST field.
	SEMC_MCR_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	SEMC_MCR_SWRST_Msk = 0x1
	// Bit SWRST.
	SEMC_MCR_SWRST = 0x1
	// Position of MDIS field.
	SEMC_MCR_MDIS_Pos = 0x1
	// Bit mask of MDIS field.
	SEMC_MCR_MDIS_Msk = 0x2
	// Bit MDIS.
	SEMC_MCR_MDIS = 0x2
	// Module enabled
	SEMC_MCR_MDIS_MDIS_0 = 0x0
	// Module disabled.
	SEMC_MCR_MDIS_MDIS_1 = 0x1
	// Position of DQSMD field.
	SEMC_MCR_DQSMD_Pos = 0x2
	// Bit mask of DQSMD field.
	SEMC_MCR_DQSMD_Msk = 0x4
	// Bit DQSMD.
	SEMC_MCR_DQSMD = 0x4
	// Dummy read strobe loopbacked internally
	SEMC_MCR_DQSMD_DQSMD_0 = 0x0
	// Dummy read strobe loopbacked from DQS pad or DLL delay chain. Details information at descriptions of DQSSEL bit.
	SEMC_MCR_DQSMD_DQSMD_1 = 0x1
	// Position of WPOL0 field.
	SEMC_MCR_WPOL0_Pos = 0x6
	// Bit mask of WPOL0 field.
	SEMC_MCR_WPOL0_Msk = 0x40
	// Bit WPOL0.
	SEMC_MCR_WPOL0 = 0x40
	// Low active
	SEMC_MCR_WPOL0_WPOL0_0 = 0x0
	// High active
	SEMC_MCR_WPOL0_WPOL0_1 = 0x1
	// Position of WPOL1 field.
	SEMC_MCR_WPOL1_Pos = 0x7
	// Bit mask of WPOL1 field.
	SEMC_MCR_WPOL1_Msk = 0x80
	// Bit WPOL1.
	SEMC_MCR_WPOL1 = 0x80
	// Low active
	SEMC_MCR_WPOL1_WPOL1_0 = 0x0
	// High active
	SEMC_MCR_WPOL1_WPOL1_1 = 0x1
	// Position of DQSSEL field.
	SEMC_MCR_DQSSEL_Pos = 0xa
	// Bit mask of DQSSEL field.
	SEMC_MCR_DQSSEL_Msk = 0x400
	// Bit DQSSEL.
	SEMC_MCR_DQSSEL = 0x400
	// SDRAM/NOR/SRAM read clock source is from DQS pad in synchronous mode.
	SEMC_MCR_DQSSEL_DQSSEL_0 = 0x0
	// SDRAM/NOR/SRAM read clock source is from DLL delay chain in synchronous mode.
	SEMC_MCR_DQSSEL_DQSSEL_1 = 0x1
	// Position of DLLSEL field.
	SEMC_MCR_DLLSEL_Pos = 0xb
	// Bit mask of DLLSEL field.
	SEMC_MCR_DLLSEL_Msk = 0x800
	// Bit DLLSEL.
	SEMC_MCR_DLLSEL = 0x800
	// DLL delay chain clock input is from NAND device's DQS pad. For NAND synchronous mode only.
	SEMC_MCR_DLLSEL_DLLSEL_0 = 0x0
	// DLL delay chain clock input is from internal clock. For SDRAM, NOR and SRAM synchronous mode only.
	SEMC_MCR_DLLSEL_DLLSEL_1 = 0x1
	// Position of CTO field.
	SEMC_MCR_CTO_Pos = 0x10
	// Bit mask of CTO field.
	SEMC_MCR_CTO_Msk = 0xff0000
	// Position of BTO field.
	SEMC_MCR_BTO_Pos = 0x18
	// Bit mask of BTO field.
	SEMC_MCR_BTO_Msk = 0x1f000000
	// 255*1
	SEMC_MCR_BTO_BTO_0 = 0x0
	// 255*2 - 255*2^30
	SEMC_MCR_BTO_BTO_1 = 0x1
	// 255*2 - 255*2^30
	SEMC_MCR_BTO_BTO_2 = 0x2
	// 255*2 - 255*2^30
	SEMC_MCR_BTO_BTO_3 = 0x3
	// 255*2 - 255*2^30
	SEMC_MCR_BTO_BTO_4 = 0x4
	// 255*2 - 255*2^30
	SEMC_MCR_BTO_BTO_5 = 0x5
	// 255*2 - 255*2^30
	SEMC_MCR_BTO_BTO_6 = 0x6
	// 255*2 - 255*2^30
	SEMC_MCR_BTO_BTO_7 = 0x7
	// 255*2 - 255*2^30
	SEMC_MCR_BTO_BTO_8 = 0x8
	// 255*2 - 255*2^30
	SEMC_MCR_BTO_BTO_9 = 0x9
	// 255*2^31
	SEMC_MCR_BTO_BTO_31 = 0x1f

	// IOCR: IO Mux Control Register
	// Position of MUX_A8 field.
	SEMC_IOCR_MUX_A8_Pos = 0x0
	// Bit mask of MUX_A8 field.
	SEMC_IOCR_MUX_A8_Msk = 0x7
	// SDRAM Address bit (A8)
	SEMC_IOCR_MUX_A8_MUX_A8_0 = 0x0
	// NAND CE#
	SEMC_IOCR_MUX_A8_MUX_A8_1 = 0x1
	// NOR CE#
	SEMC_IOCR_MUX_A8_MUX_A8_2 = 0x2
	// PSRAM CE#
	SEMC_IOCR_MUX_A8_MUX_A8_3 = 0x3
	// DBI CSX
	SEMC_IOCR_MUX_A8_MUX_A8_4 = 0x4
	// SDRAM Address bit (A8)
	SEMC_IOCR_MUX_A8_MUX_A8_5 = 0x5
	// SDRAM Address bit (A8)
	SEMC_IOCR_MUX_A8_MUX_A8_6 = 0x6
	// SDRAM Address bit (A8)
	SEMC_IOCR_MUX_A8_MUX_A8_7 = 0x7
	// Position of MUX_CSX0 field.
	SEMC_IOCR_MUX_CSX0_Pos = 0x3
	// Bit mask of MUX_CSX0 field.
	SEMC_IOCR_MUX_CSX0_Msk = 0x38
	// NOR/PSRAM Address bit 24 (A24)
	SEMC_IOCR_MUX_CSX0_MUX_CSX0_0 = 0x0
	// SDRAM CS1
	SEMC_IOCR_MUX_CSX0_MUX_CSX0_1 = 0x1
	// SDRAM CS2
	SEMC_IOCR_MUX_CSX0_MUX_CSX0_2 = 0x2
	// SDRAM CS3
	SEMC_IOCR_MUX_CSX0_MUX_CSX0_3 = 0x3
	// NAND CE#
	SEMC_IOCR_MUX_CSX0_MUX_CSX0_4 = 0x4
	// NOR CE#
	SEMC_IOCR_MUX_CSX0_MUX_CSX0_5 = 0x5
	// PSRAM CE#
	SEMC_IOCR_MUX_CSX0_MUX_CSX0_6 = 0x6
	// DBI CSX
	SEMC_IOCR_MUX_CSX0_MUX_CSX0_7 = 0x7
	// Position of MUX_CSX1 field.
	SEMC_IOCR_MUX_CSX1_Pos = 0x6
	// Bit mask of MUX_CSX1 field.
	SEMC_IOCR_MUX_CSX1_Msk = 0x1c0
	// NOR/PSRAM Address bit 25 (A25)
	SEMC_IOCR_MUX_CSX1_MUX_CSX1_0 = 0x0
	// SDRAM CS1
	SEMC_IOCR_MUX_CSX1_MUX_CSX1_1 = 0x1
	// SDRAM CS2
	SEMC_IOCR_MUX_CSX1_MUX_CSX1_2 = 0x2
	// SDRAM CS3
	SEMC_IOCR_MUX_CSX1_MUX_CSX1_3 = 0x3
	// NAND CE#
	SEMC_IOCR_MUX_CSX1_MUX_CSX1_4 = 0x4
	// NOR CE#
	SEMC_IOCR_MUX_CSX1_MUX_CSX1_5 = 0x5
	// PSRAM CE#
	SEMC_IOCR_MUX_CSX1_MUX_CSX1_6 = 0x6
	// DBI CSX
	SEMC_IOCR_MUX_CSX1_MUX_CSX1_7 = 0x7
	// Position of MUX_CSX2 field.
	SEMC_IOCR_MUX_CSX2_Pos = 0x9
	// Bit mask of MUX_CSX2 field.
	SEMC_IOCR_MUX_CSX2_Msk = 0xe00
	// NOR/PSRAM Address bit 26 (A26)
	SEMC_IOCR_MUX_CSX2_MUX_CSX2_0 = 0x0
	// SDRAM CS1
	SEMC_IOCR_MUX_CSX2_MUX_CSX2_1 = 0x1
	// SDRAM CS2
	SEMC_IOCR_MUX_CSX2_MUX_CSX2_2 = 0x2
	// SDRAM CS3
	SEMC_IOCR_MUX_CSX2_MUX_CSX2_3 = 0x3
	// NAND CE#
	SEMC_IOCR_MUX_CSX2_MUX_CSX2_4 = 0x4
	// NOR CE#
	SEMC_IOCR_MUX_CSX2_MUX_CSX2_5 = 0x5
	// PSRAM CE#
	SEMC_IOCR_MUX_CSX2_MUX_CSX2_6 = 0x6
	// DBI CSX
	SEMC_IOCR_MUX_CSX2_MUX_CSX2_7 = 0x7
	// Position of MUX_CSX3 field.
	SEMC_IOCR_MUX_CSX3_Pos = 0xc
	// Bit mask of MUX_CSX3 field.
	SEMC_IOCR_MUX_CSX3_Msk = 0x7000
	// NOR/PSRAM Address bit 27 (A27)
	SEMC_IOCR_MUX_CSX3_MUX_CSX3_0 = 0x0
	// SDRAM CS1
	SEMC_IOCR_MUX_CSX3_MUX_CSX3_1 = 0x1
	// SDRAM CS2
	SEMC_IOCR_MUX_CSX3_MUX_CSX3_2 = 0x2
	// SDRAM CS3
	SEMC_IOCR_MUX_CSX3_MUX_CSX3_3 = 0x3
	// NAND CE#
	SEMC_IOCR_MUX_CSX3_MUX_CSX3_4 = 0x4
	// NOR CE#
	SEMC_IOCR_MUX_CSX3_MUX_CSX3_5 = 0x5
	// PSRAM CE#
	SEMC_IOCR_MUX_CSX3_MUX_CSX3_6 = 0x6
	// DBI CSX
	SEMC_IOCR_MUX_CSX3_MUX_CSX3_7 = 0x7
	// Position of MUX_RDY field.
	SEMC_IOCR_MUX_RDY_Pos = 0xf
	// Bit mask of MUX_RDY field.
	SEMC_IOCR_MUX_RDY_Msk = 0x38000
	// NAND Ready/Wait# input
	SEMC_IOCR_MUX_RDY_MUX_RDY_0 = 0x0
	// SDRAM CS1
	SEMC_IOCR_MUX_RDY_MUX_RDY_1 = 0x1
	// SDRAM CS2
	SEMC_IOCR_MUX_RDY_MUX_RDY_2 = 0x2
	// SDRAM CS3
	SEMC_IOCR_MUX_RDY_MUX_RDY_3 = 0x3
	// NOR CE#
	SEMC_IOCR_MUX_RDY_MUX_RDY_4 = 0x4
	// PSRAM CE#
	SEMC_IOCR_MUX_RDY_MUX_RDY_5 = 0x5
	// DBI CSX
	SEMC_IOCR_MUX_RDY_MUX_RDY_6 = 0x6
	// NOR/PSRAM Address bit 27
	SEMC_IOCR_MUX_RDY_MUX_RDY_7 = 0x7
	// Position of MUX_CLKX0 field.
	SEMC_IOCR_MUX_CLKX0_Pos = 0x18
	// Bit mask of MUX_CLKX0 field.
	SEMC_IOCR_MUX_CLKX0_Msk = 0x1000000
	// Bit MUX_CLKX0.
	SEMC_IOCR_MUX_CLKX0 = 0x1000000
	// NOR clock
	SEMC_IOCR_MUX_CLKX0_MUX_CLKX0_0 = 0x0
	// SRAM clock
	SEMC_IOCR_MUX_CLKX0_MUX_CLKX0_1 = 0x1
	// Position of MUX_CLKX1 field.
	SEMC_IOCR_MUX_CLKX1_Pos = 0x19
	// Bit mask of MUX_CLKX1 field.
	SEMC_IOCR_MUX_CLKX1_Msk = 0x2000000
	// Bit MUX_CLKX1.
	SEMC_IOCR_MUX_CLKX1 = 0x2000000
	// NOR clock
	SEMC_IOCR_MUX_CLKX1_MUX_CLKX1_0 = 0x0
	// SRAM clock
	SEMC_IOCR_MUX_CLKX1_MUX_CLKX1_1 = 0x1

	// BMCR0: Master Bus (AXI) Control Register 0
	// Position of WQOS field.
	SEMC_BMCR0_WQOS_Pos = 0x0
	// Bit mask of WQOS field.
	SEMC_BMCR0_WQOS_Msk = 0xf
	// Position of WAGE field.
	SEMC_BMCR0_WAGE_Pos = 0x4
	// Bit mask of WAGE field.
	SEMC_BMCR0_WAGE_Msk = 0xf0
	// Position of WSH field.
	SEMC_BMCR0_WSH_Pos = 0x8
	// Bit mask of WSH field.
	SEMC_BMCR0_WSH_Msk = 0xff00
	// Position of WRWS field.
	SEMC_BMCR0_WRWS_Pos = 0x10
	// Bit mask of WRWS field.
	SEMC_BMCR0_WRWS_Msk = 0xff0000

	// BMCR1: Master Bus (AXI) Control Register 1
	// Position of WQOS field.
	SEMC_BMCR1_WQOS_Pos = 0x0
	// Bit mask of WQOS field.
	SEMC_BMCR1_WQOS_Msk = 0xf
	// Position of WAGE field.
	SEMC_BMCR1_WAGE_Pos = 0x4
	// Bit mask of WAGE field.
	SEMC_BMCR1_WAGE_Msk = 0xf0
	// Position of WPH field.
	SEMC_BMCR1_WPH_Pos = 0x8
	// Bit mask of WPH field.
	SEMC_BMCR1_WPH_Msk = 0xff00
	// Position of WRWS field.
	SEMC_BMCR1_WRWS_Pos = 0x10
	// Bit mask of WRWS field.
	SEMC_BMCR1_WRWS_Msk = 0xff0000
	// Position of WBR field.
	SEMC_BMCR1_WBR_Pos = 0x18
	// Bit mask of WBR field.
	SEMC_BMCR1_WBR_Msk = 0xff000000

	// BR0: Base Register 0 (For SDRAM CS0 device)
	// Position of VLD field.
	SEMC_BR0_VLD_Pos = 0x0
	// Bit mask of VLD field.
	SEMC_BR0_VLD_Msk = 0x1
	// Bit VLD.
	SEMC_BR0_VLD = 0x1
	// Position of MS field.
	SEMC_BR0_MS_Pos = 0x1
	// Bit mask of MS field.
	SEMC_BR0_MS_Msk = 0x3e
	// 4KB
	SEMC_BR0_MS_MS_0 = 0x0
	// 8KB
	SEMC_BR0_MS_MS_1 = 0x1
	// 16KB
	SEMC_BR0_MS_MS_2 = 0x2
	// 32KB
	SEMC_BR0_MS_MS_3 = 0x3
	// 64KB
	SEMC_BR0_MS_MS_4 = 0x4
	// 128KB
	SEMC_BR0_MS_MS_5 = 0x5
	// 256KB
	SEMC_BR0_MS_MS_6 = 0x6
	// 512KB
	SEMC_BR0_MS_MS_7 = 0x7
	// 1MB
	SEMC_BR0_MS_MS_8 = 0x8
	// 2MB
	SEMC_BR0_MS_MS_9 = 0x9
	// 4MB
	SEMC_BR0_MS_MS_10 = 0xa
	// 8MB
	SEMC_BR0_MS_MS_11 = 0xb
	// 16MB
	SEMC_BR0_MS_MS_12 = 0xc
	// 32MB
	SEMC_BR0_MS_MS_13 = 0xd
	// 64MB
	SEMC_BR0_MS_MS_14 = 0xe
	// 128MB
	SEMC_BR0_MS_MS_15 = 0xf
	// 256MB
	SEMC_BR0_MS_MS_16 = 0x10
	// 512MB
	SEMC_BR0_MS_MS_17 = 0x11
	// 1GB
	SEMC_BR0_MS_MS_18 = 0x12
	// 2GB
	SEMC_BR0_MS_MS_19 = 0x13
	// 4GB
	SEMC_BR0_MS_MS_20 = 0x14
	// 4GB
	SEMC_BR0_MS_MS_21 = 0x15
	// 4GB
	SEMC_BR0_MS_MS_22 = 0x16
	// 4GB
	SEMC_BR0_MS_MS_23 = 0x17
	// 4GB
	SEMC_BR0_MS_MS_24 = 0x18
	// 4GB
	SEMC_BR0_MS_MS_25 = 0x19
	// 4GB
	SEMC_BR0_MS_MS_26 = 0x1a
	// 4GB
	SEMC_BR0_MS_MS_27 = 0x1b
	// 4GB
	SEMC_BR0_MS_MS_28 = 0x1c
	// 4GB
	SEMC_BR0_MS_MS_29 = 0x1d
	// 4GB
	SEMC_BR0_MS_MS_30 = 0x1e
	// 4GB
	SEMC_BR0_MS_MS_31 = 0x1f
	// Position of BA field.
	SEMC_BR0_BA_Pos = 0xc
	// Bit mask of BA field.
	SEMC_BR0_BA_Msk = 0xfffff000

	// BR1: Base Register 1 (For SDRAM CS1 device)
	// Position of VLD field.
	SEMC_BR1_VLD_Pos = 0x0
	// Bit mask of VLD field.
	SEMC_BR1_VLD_Msk = 0x1
	// Bit VLD.
	SEMC_BR1_VLD = 0x1
	// Position of MS field.
	SEMC_BR1_MS_Pos = 0x1
	// Bit mask of MS field.
	SEMC_BR1_MS_Msk = 0x3e
	// 4KB
	SEMC_BR1_MS_MS_0 = 0x0
	// 8KB
	SEMC_BR1_MS_MS_1 = 0x1
	// 16KB
	SEMC_BR1_MS_MS_2 = 0x2
	// 32KB
	SEMC_BR1_MS_MS_3 = 0x3
	// 64KB
	SEMC_BR1_MS_MS_4 = 0x4
	// 128KB
	SEMC_BR1_MS_MS_5 = 0x5
	// 256KB
	SEMC_BR1_MS_MS_6 = 0x6
	// 512KB
	SEMC_BR1_MS_MS_7 = 0x7
	// 1MB
	SEMC_BR1_MS_MS_8 = 0x8
	// 2MB
	SEMC_BR1_MS_MS_9 = 0x9
	// 4MB
	SEMC_BR1_MS_MS_10 = 0xa
	// 8MB
	SEMC_BR1_MS_MS_11 = 0xb
	// 16MB
	SEMC_BR1_MS_MS_12 = 0xc
	// 32MB
	SEMC_BR1_MS_MS_13 = 0xd
	// 64MB
	SEMC_BR1_MS_MS_14 = 0xe
	// 128MB
	SEMC_BR1_MS_MS_15 = 0xf
	// 256MB
	SEMC_BR1_MS_MS_16 = 0x10
	// 512MB
	SEMC_BR1_MS_MS_17 = 0x11
	// 1GB
	SEMC_BR1_MS_MS_18 = 0x12
	// 2GB
	SEMC_BR1_MS_MS_19 = 0x13
	// 4GB
	SEMC_BR1_MS_MS_20 = 0x14
	// 4GB
	SEMC_BR1_MS_MS_21 = 0x15
	// 4GB
	SEMC_BR1_MS_MS_22 = 0x16
	// 4GB
	SEMC_BR1_MS_MS_23 = 0x17
	// 4GB
	SEMC_BR1_MS_MS_24 = 0x18
	// 4GB
	SEMC_BR1_MS_MS_25 = 0x19
	// 4GB
	SEMC_BR1_MS_MS_26 = 0x1a
	// 4GB
	SEMC_BR1_MS_MS_27 = 0x1b
	// 4GB
	SEMC_BR1_MS_MS_28 = 0x1c
	// 4GB
	SEMC_BR1_MS_MS_29 = 0x1d
	// 4GB
	SEMC_BR1_MS_MS_30 = 0x1e
	// 4GB
	SEMC_BR1_MS_MS_31 = 0x1f
	// Position of BA field.
	SEMC_BR1_BA_Pos = 0xc
	// Bit mask of BA field.
	SEMC_BR1_BA_Msk = 0xfffff000

	// BR2: Base Register 2 (For SDRAM CS2 device)
	// Position of VLD field.
	SEMC_BR2_VLD_Pos = 0x0
	// Bit mask of VLD field.
	SEMC_BR2_VLD_Msk = 0x1
	// Bit VLD.
	SEMC_BR2_VLD = 0x1
	// Position of MS field.
	SEMC_BR2_MS_Pos = 0x1
	// Bit mask of MS field.
	SEMC_BR2_MS_Msk = 0x3e
	// 4KB
	SEMC_BR2_MS_MS_0 = 0x0
	// 8KB
	SEMC_BR2_MS_MS_1 = 0x1
	// 16KB
	SEMC_BR2_MS_MS_2 = 0x2
	// 32KB
	SEMC_BR2_MS_MS_3 = 0x3
	// 64KB
	SEMC_BR2_MS_MS_4 = 0x4
	// 128KB
	SEMC_BR2_MS_MS_5 = 0x5
	// 256KB
	SEMC_BR2_MS_MS_6 = 0x6
	// 512KB
	SEMC_BR2_MS_MS_7 = 0x7
	// 1MB
	SEMC_BR2_MS_MS_8 = 0x8
	// 2MB
	SEMC_BR2_MS_MS_9 = 0x9
	// 4MB
	SEMC_BR2_MS_MS_10 = 0xa
	// 8MB
	SEMC_BR2_MS_MS_11 = 0xb
	// 16MB
	SEMC_BR2_MS_MS_12 = 0xc
	// 32MB
	SEMC_BR2_MS_MS_13 = 0xd
	// 64MB
	SEMC_BR2_MS_MS_14 = 0xe
	// 128MB
	SEMC_BR2_MS_MS_15 = 0xf
	// 256MB
	SEMC_BR2_MS_MS_16 = 0x10
	// 512MB
	SEMC_BR2_MS_MS_17 = 0x11
	// 1GB
	SEMC_BR2_MS_MS_18 = 0x12
	// 2GB
	SEMC_BR2_MS_MS_19 = 0x13
	// 4GB
	SEMC_BR2_MS_MS_20 = 0x14
	// 4GB
	SEMC_BR2_MS_MS_21 = 0x15
	// 4GB
	SEMC_BR2_MS_MS_22 = 0x16
	// 4GB
	SEMC_BR2_MS_MS_23 = 0x17
	// 4GB
	SEMC_BR2_MS_MS_24 = 0x18
	// 4GB
	SEMC_BR2_MS_MS_25 = 0x19
	// 4GB
	SEMC_BR2_MS_MS_26 = 0x1a
	// 4GB
	SEMC_BR2_MS_MS_27 = 0x1b
	// 4GB
	SEMC_BR2_MS_MS_28 = 0x1c
	// 4GB
	SEMC_BR2_MS_MS_29 = 0x1d
	// 4GB
	SEMC_BR2_MS_MS_30 = 0x1e
	// 4GB
	SEMC_BR2_MS_MS_31 = 0x1f
	// Position of BA field.
	SEMC_BR2_BA_Pos = 0xc
	// Bit mask of BA field.
	SEMC_BR2_BA_Msk = 0xfffff000

	// BR3: Base Register 3 (For SDRAM CS3 device)
	// Position of VLD field.
	SEMC_BR3_VLD_Pos = 0x0
	// Bit mask of VLD field.
	SEMC_BR3_VLD_Msk = 0x1
	// Bit VLD.
	SEMC_BR3_VLD = 0x1
	// Position of MS field.
	SEMC_BR3_MS_Pos = 0x1
	// Bit mask of MS field.
	SEMC_BR3_MS_Msk = 0x3e
	// 4KB
	SEMC_BR3_MS_MS_0 = 0x0
	// 8KB
	SEMC_BR3_MS_MS_1 = 0x1
	// 16KB
	SEMC_BR3_MS_MS_2 = 0x2
	// 32KB
	SEMC_BR3_MS_MS_3 = 0x3
	// 64KB
	SEMC_BR3_MS_MS_4 = 0x4
	// 128KB
	SEMC_BR3_MS_MS_5 = 0x5
	// 256KB
	SEMC_BR3_MS_MS_6 = 0x6
	// 512KB
	SEMC_BR3_MS_MS_7 = 0x7
	// 1MB
	SEMC_BR3_MS_MS_8 = 0x8
	// 2MB
	SEMC_BR3_MS_MS_9 = 0x9
	// 4MB
	SEMC_BR3_MS_MS_10 = 0xa
	// 8MB
	SEMC_BR3_MS_MS_11 = 0xb
	// 16MB
	SEMC_BR3_MS_MS_12 = 0xc
	// 32MB
	SEMC_BR3_MS_MS_13 = 0xd
	// 64MB
	SEMC_BR3_MS_MS_14 = 0xe
	// 128MB
	SEMC_BR3_MS_MS_15 = 0xf
	// 256MB
	SEMC_BR3_MS_MS_16 = 0x10
	// 512MB
	SEMC_BR3_MS_MS_17 = 0x11
	// 1GB
	SEMC_BR3_MS_MS_18 = 0x12
	// 2GB
	SEMC_BR3_MS_MS_19 = 0x13
	// 4GB
	SEMC_BR3_MS_MS_20 = 0x14
	// 4GB
	SEMC_BR3_MS_MS_21 = 0x15
	// 4GB
	SEMC_BR3_MS_MS_22 = 0x16
	// 4GB
	SEMC_BR3_MS_MS_23 = 0x17
	// 4GB
	SEMC_BR3_MS_MS_24 = 0x18
	// 4GB
	SEMC_BR3_MS_MS_25 = 0x19
	// 4GB
	SEMC_BR3_MS_MS_26 = 0x1a
	// 4GB
	SEMC_BR3_MS_MS_27 = 0x1b
	// 4GB
	SEMC_BR3_MS_MS_28 = 0x1c
	// 4GB
	SEMC_BR3_MS_MS_29 = 0x1d
	// 4GB
	SEMC_BR3_MS_MS_30 = 0x1e
	// 4GB
	SEMC_BR3_MS_MS_31 = 0x1f
	// Position of BA field.
	SEMC_BR3_BA_Pos = 0xc
	// Bit mask of BA field.
	SEMC_BR3_BA_Msk = 0xfffff000

	// BR4: Base Register 4 (For NAND device)
	// Position of VLD field.
	SEMC_BR4_VLD_Pos = 0x0
	// Bit mask of VLD field.
	SEMC_BR4_VLD_Msk = 0x1
	// Bit VLD.
	SEMC_BR4_VLD = 0x1
	// Position of MS field.
	SEMC_BR4_MS_Pos = 0x1
	// Bit mask of MS field.
	SEMC_BR4_MS_Msk = 0x3e
	// 4KB
	SEMC_BR4_MS_MS_0 = 0x0
	// 8KB
	SEMC_BR4_MS_MS_1 = 0x1
	// 16KB
	SEMC_BR4_MS_MS_2 = 0x2
	// 32KB
	SEMC_BR4_MS_MS_3 = 0x3
	// 64KB
	SEMC_BR4_MS_MS_4 = 0x4
	// 128KB
	SEMC_BR4_MS_MS_5 = 0x5
	// 256KB
	SEMC_BR4_MS_MS_6 = 0x6
	// 512KB
	SEMC_BR4_MS_MS_7 = 0x7
	// 1MB
	SEMC_BR4_MS_MS_8 = 0x8
	// 2MB
	SEMC_BR4_MS_MS_9 = 0x9
	// 4MB
	SEMC_BR4_MS_MS_10 = 0xa
	// 8MB
	SEMC_BR4_MS_MS_11 = 0xb
	// 16MB
	SEMC_BR4_MS_MS_12 = 0xc
	// 32MB
	SEMC_BR4_MS_MS_13 = 0xd
	// 64MB
	SEMC_BR4_MS_MS_14 = 0xe
	// 128MB
	SEMC_BR4_MS_MS_15 = 0xf
	// 256MB
	SEMC_BR4_MS_MS_16 = 0x10
	// 512MB
	SEMC_BR4_MS_MS_17 = 0x11
	// 1GB
	SEMC_BR4_MS_MS_18 = 0x12
	// 2GB
	SEMC_BR4_MS_MS_19 = 0x13
	// 4GB
	SEMC_BR4_MS_MS_20 = 0x14
	// 4GB
	SEMC_BR4_MS_MS_21 = 0x15
	// 4GB
	SEMC_BR4_MS_MS_22 = 0x16
	// 4GB
	SEMC_BR4_MS_MS_23 = 0x17
	// 4GB
	SEMC_BR4_MS_MS_24 = 0x18
	// 4GB
	SEMC_BR4_MS_MS_25 = 0x19
	// 4GB
	SEMC_BR4_MS_MS_26 = 0x1a
	// 4GB
	SEMC_BR4_MS_MS_27 = 0x1b
	// 4GB
	SEMC_BR4_MS_MS_28 = 0x1c
	// 4GB
	SEMC_BR4_MS_MS_29 = 0x1d
	// 4GB
	SEMC_BR4_MS_MS_30 = 0x1e
	// 4GB
	SEMC_BR4_MS_MS_31 = 0x1f
	// Position of BA field.
	SEMC_BR4_BA_Pos = 0xc
	// Bit mask of BA field.
	SEMC_BR4_BA_Msk = 0xfffff000

	// BR5: Base Register 5 (For NOR device)
	// Position of VLD field.
	SEMC_BR5_VLD_Pos = 0x0
	// Bit mask of VLD field.
	SEMC_BR5_VLD_Msk = 0x1
	// Bit VLD.
	SEMC_BR5_VLD = 0x1
	// Position of MS field.
	SEMC_BR5_MS_Pos = 0x1
	// Bit mask of MS field.
	SEMC_BR5_MS_Msk = 0x3e
	// 4KB
	SEMC_BR5_MS_MS_0 = 0x0
	// 8KB
	SEMC_BR5_MS_MS_1 = 0x1
	// 16KB
	SEMC_BR5_MS_MS_2 = 0x2
	// 32KB
	SEMC_BR5_MS_MS_3 = 0x3
	// 64KB
	SEMC_BR5_MS_MS_4 = 0x4
	// 128KB
	SEMC_BR5_MS_MS_5 = 0x5
	// 256KB
	SEMC_BR5_MS_MS_6 = 0x6
	// 512KB
	SEMC_BR5_MS_MS_7 = 0x7
	// 1MB
	SEMC_BR5_MS_MS_8 = 0x8
	// 2MB
	SEMC_BR5_MS_MS_9 = 0x9
	// 4MB
	SEMC_BR5_MS_MS_10 = 0xa
	// 8MB
	SEMC_BR5_MS_MS_11 = 0xb
	// 16MB
	SEMC_BR5_MS_MS_12 = 0xc
	// 32MB
	SEMC_BR5_MS_MS_13 = 0xd
	// 64MB
	SEMC_BR5_MS_MS_14 = 0xe
	// 128MB
	SEMC_BR5_MS_MS_15 = 0xf
	// 256MB
	SEMC_BR5_MS_MS_16 = 0x10
	// 512MB
	SEMC_BR5_MS_MS_17 = 0x11
	// 1GB
	SEMC_BR5_MS_MS_18 = 0x12
	// 2GB
	SEMC_BR5_MS_MS_19 = 0x13
	// 4GB
	SEMC_BR5_MS_MS_20 = 0x14
	// 4GB
	SEMC_BR5_MS_MS_21 = 0x15
	// 4GB
	SEMC_BR5_MS_MS_22 = 0x16
	// 4GB
	SEMC_BR5_MS_MS_23 = 0x17
	// 4GB
	SEMC_BR5_MS_MS_24 = 0x18
	// 4GB
	SEMC_BR5_MS_MS_25 = 0x19
	// 4GB
	SEMC_BR5_MS_MS_26 = 0x1a
	// 4GB
	SEMC_BR5_MS_MS_27 = 0x1b
	// 4GB
	SEMC_BR5_MS_MS_28 = 0x1c
	// 4GB
	SEMC_BR5_MS_MS_29 = 0x1d
	// 4GB
	SEMC_BR5_MS_MS_30 = 0x1e
	// 4GB
	SEMC_BR5_MS_MS_31 = 0x1f
	// Position of BA field.
	SEMC_BR5_BA_Pos = 0xc
	// Bit mask of BA field.
	SEMC_BR5_BA_Msk = 0xfffff000

	// BR6: Base Register 6 (For PSRAM device)
	// Position of VLD field.
	SEMC_BR6_VLD_Pos = 0x0
	// Bit mask of VLD field.
	SEMC_BR6_VLD_Msk = 0x1
	// Bit VLD.
	SEMC_BR6_VLD = 0x1
	// Position of MS field.
	SEMC_BR6_MS_Pos = 0x1
	// Bit mask of MS field.
	SEMC_BR6_MS_Msk = 0x3e
	// 4KB
	SEMC_BR6_MS_MS_0 = 0x0
	// 8KB
	SEMC_BR6_MS_MS_1 = 0x1
	// 16KB
	SEMC_BR6_MS_MS_2 = 0x2
	// 32KB
	SEMC_BR6_MS_MS_3 = 0x3
	// 64KB
	SEMC_BR6_MS_MS_4 = 0x4
	// 128KB
	SEMC_BR6_MS_MS_5 = 0x5
	// 256KB
	SEMC_BR6_MS_MS_6 = 0x6
	// 512KB
	SEMC_BR6_MS_MS_7 = 0x7
	// 1MB
	SEMC_BR6_MS_MS_8 = 0x8
	// 2MB
	SEMC_BR6_MS_MS_9 = 0x9
	// 4MB
	SEMC_BR6_MS_MS_10 = 0xa
	// 8MB
	SEMC_BR6_MS_MS_11 = 0xb
	// 16MB
	SEMC_BR6_MS_MS_12 = 0xc
	// 32MB
	SEMC_BR6_MS_MS_13 = 0xd
	// 64MB
	SEMC_BR6_MS_MS_14 = 0xe
	// 128MB
	SEMC_BR6_MS_MS_15 = 0xf
	// 256MB
	SEMC_BR6_MS_MS_16 = 0x10
	// 512MB
	SEMC_BR6_MS_MS_17 = 0x11
	// 1GB
	SEMC_BR6_MS_MS_18 = 0x12
	// 2GB
	SEMC_BR6_MS_MS_19 = 0x13
	// 4GB
	SEMC_BR6_MS_MS_20 = 0x14
	// 4GB
	SEMC_BR6_MS_MS_21 = 0x15
	// 4GB
	SEMC_BR6_MS_MS_22 = 0x16
	// 4GB
	SEMC_BR6_MS_MS_23 = 0x17
	// 4GB
	SEMC_BR6_MS_MS_24 = 0x18
	// 4GB
	SEMC_BR6_MS_MS_25 = 0x19
	// 4GB
	SEMC_BR6_MS_MS_26 = 0x1a
	// 4GB
	SEMC_BR6_MS_MS_27 = 0x1b
	// 4GB
	SEMC_BR6_MS_MS_28 = 0x1c
	// 4GB
	SEMC_BR6_MS_MS_29 = 0x1d
	// 4GB
	SEMC_BR6_MS_MS_30 = 0x1e
	// 4GB
	SEMC_BR6_MS_MS_31 = 0x1f
	// Position of BA field.
	SEMC_BR6_BA_Pos = 0xc
	// Bit mask of BA field.
	SEMC_BR6_BA_Msk = 0xfffff000

	// BR7: Base Register 7 (For DBI-B (MIPI Display Bus Interface Type B) device)
	// Position of VLD field.
	SEMC_BR7_VLD_Pos = 0x0
	// Bit mask of VLD field.
	SEMC_BR7_VLD_Msk = 0x1
	// Bit VLD.
	SEMC_BR7_VLD = 0x1
	// Position of MS field.
	SEMC_BR7_MS_Pos = 0x1
	// Bit mask of MS field.
	SEMC_BR7_MS_Msk = 0x3e
	// 4KB
	SEMC_BR7_MS_MS_0 = 0x0
	// 8KB
	SEMC_BR7_MS_MS_1 = 0x1
	// 16KB
	SEMC_BR7_MS_MS_2 = 0x2
	// 32KB
	SEMC_BR7_MS_MS_3 = 0x3
	// 64KB
	SEMC_BR7_MS_MS_4 = 0x4
	// 128KB
	SEMC_BR7_MS_MS_5 = 0x5
	// 256KB
	SEMC_BR7_MS_MS_6 = 0x6
	// 512KB
	SEMC_BR7_MS_MS_7 = 0x7
	// 1MB
	SEMC_BR7_MS_MS_8 = 0x8
	// 2MB
	SEMC_BR7_MS_MS_9 = 0x9
	// 4MB
	SEMC_BR7_MS_MS_10 = 0xa
	// 8MB
	SEMC_BR7_MS_MS_11 = 0xb
	// 16MB
	SEMC_BR7_MS_MS_12 = 0xc
	// 32MB
	SEMC_BR7_MS_MS_13 = 0xd
	// 64MB
	SEMC_BR7_MS_MS_14 = 0xe
	// 128MB
	SEMC_BR7_MS_MS_15 = 0xf
	// 256MB
	SEMC_BR7_MS_MS_16 = 0x10
	// 512MB
	SEMC_BR7_MS_MS_17 = 0x11
	// 1GB
	SEMC_BR7_MS_MS_18 = 0x12
	// 2GB
	SEMC_BR7_MS_MS_19 = 0x13
	// 4GB
	SEMC_BR7_MS_MS_20 = 0x14
	// 4GB
	SEMC_BR7_MS_MS_21 = 0x15
	// 4GB
	SEMC_BR7_MS_MS_22 = 0x16
	// 4GB
	SEMC_BR7_MS_MS_23 = 0x17
	// 4GB
	SEMC_BR7_MS_MS_24 = 0x18
	// 4GB
	SEMC_BR7_MS_MS_25 = 0x19
	// 4GB
	SEMC_BR7_MS_MS_26 = 0x1a
	// 4GB
	SEMC_BR7_MS_MS_27 = 0x1b
	// 4GB
	SEMC_BR7_MS_MS_28 = 0x1c
	// 4GB
	SEMC_BR7_MS_MS_29 = 0x1d
	// 4GB
	SEMC_BR7_MS_MS_30 = 0x1e
	// 4GB
	SEMC_BR7_MS_MS_31 = 0x1f
	// Position of BA field.
	SEMC_BR7_BA_Pos = 0xc
	// Bit mask of BA field.
	SEMC_BR7_BA_Msk = 0xfffff000

	// BR8: Base Register 8 (For NAND device)
	// Position of VLD field.
	SEMC_BR8_VLD_Pos = 0x0
	// Bit mask of VLD field.
	SEMC_BR8_VLD_Msk = 0x1
	// Bit VLD.
	SEMC_BR8_VLD = 0x1
	// Position of MS field.
	SEMC_BR8_MS_Pos = 0x1
	// Bit mask of MS field.
	SEMC_BR8_MS_Msk = 0x3e
	// 4KB
	SEMC_BR8_MS_MS_0 = 0x0
	// 8KB
	SEMC_BR8_MS_MS_1 = 0x1
	// 16KB
	SEMC_BR8_MS_MS_2 = 0x2
	// 32KB
	SEMC_BR8_MS_MS_3 = 0x3
	// 64KB
	SEMC_BR8_MS_MS_4 = 0x4
	// 128KB
	SEMC_BR8_MS_MS_5 = 0x5
	// 256KB
	SEMC_BR8_MS_MS_6 = 0x6
	// 512KB
	SEMC_BR8_MS_MS_7 = 0x7
	// 1MB
	SEMC_BR8_MS_MS_8 = 0x8
	// 2MB
	SEMC_BR8_MS_MS_9 = 0x9
	// 4MB
	SEMC_BR8_MS_MS_10 = 0xa
	// 8MB
	SEMC_BR8_MS_MS_11 = 0xb
	// 16MB
	SEMC_BR8_MS_MS_12 = 0xc
	// 32MB
	SEMC_BR8_MS_MS_13 = 0xd
	// 64MB
	SEMC_BR8_MS_MS_14 = 0xe
	// 128MB
	SEMC_BR8_MS_MS_15 = 0xf
	// 256MB
	SEMC_BR8_MS_MS_16 = 0x10
	// 512MB
	SEMC_BR8_MS_MS_17 = 0x11
	// 1GB
	SEMC_BR8_MS_MS_18 = 0x12
	// 2GB
	SEMC_BR8_MS_MS_19 = 0x13
	// 4GB
	SEMC_BR8_MS_MS_20 = 0x14
	// 4GB
	SEMC_BR8_MS_MS_21 = 0x15
	// 4GB
	SEMC_BR8_MS_MS_22 = 0x16
	// 4GB
	SEMC_BR8_MS_MS_23 = 0x17
	// 4GB
	SEMC_BR8_MS_MS_24 = 0x18
	// 4GB
	SEMC_BR8_MS_MS_25 = 0x19
	// 4GB
	SEMC_BR8_MS_MS_26 = 0x1a
	// 4GB
	SEMC_BR8_MS_MS_27 = 0x1b
	// 4GB
	SEMC_BR8_MS_MS_28 = 0x1c
	// 4GB
	SEMC_BR8_MS_MS_29 = 0x1d
	// 4GB
	SEMC_BR8_MS_MS_30 = 0x1e
	// 4GB
	SEMC_BR8_MS_MS_31 = 0x1f
	// Position of BA field.
	SEMC_BR8_BA_Pos = 0xc
	// Bit mask of BA field.
	SEMC_BR8_BA_Msk = 0xfffff000

	// DLLCR: DLL Control Register
	// Position of DLLEN field.
	SEMC_DLLCR_DLLEN_Pos = 0x0
	// Bit mask of DLLEN field.
	SEMC_DLLCR_DLLEN_Msk = 0x1
	// Bit DLLEN.
	SEMC_DLLCR_DLLEN = 0x1
	// Position of DLLRESET field.
	SEMC_DLLCR_DLLRESET_Pos = 0x1
	// Bit mask of DLLRESET field.
	SEMC_DLLCR_DLLRESET_Msk = 0x2
	// Bit DLLRESET.
	SEMC_DLLCR_DLLRESET = 0x2
	// Position of SLVDLYTARGET field.
	SEMC_DLLCR_SLVDLYTARGET_Pos = 0x3
	// Bit mask of SLVDLYTARGET field.
	SEMC_DLLCR_SLVDLYTARGET_Msk = 0x78
	// Position of OVRDEN field.
	SEMC_DLLCR_OVRDEN_Pos = 0x8
	// Bit mask of OVRDEN field.
	SEMC_DLLCR_OVRDEN_Msk = 0x100
	// Bit OVRDEN.
	SEMC_DLLCR_OVRDEN = 0x100
	// Position of OVRDVAL field.
	SEMC_DLLCR_OVRDVAL_Pos = 0x9
	// Bit mask of OVRDVAL field.
	SEMC_DLLCR_OVRDVAL_Msk = 0x7e00

	// INTEN: Interrupt Enable Register
	// Position of IPCMDDONEEN field.
	SEMC_INTEN_IPCMDDONEEN_Pos = 0x0
	// Bit mask of IPCMDDONEEN field.
	SEMC_INTEN_IPCMDDONEEN_Msk = 0x1
	// Bit IPCMDDONEEN.
	SEMC_INTEN_IPCMDDONEEN = 0x1
	// Position of IPCMDERREN field.
	SEMC_INTEN_IPCMDERREN_Pos = 0x1
	// Bit mask of IPCMDERREN field.
	SEMC_INTEN_IPCMDERREN_Msk = 0x2
	// Bit IPCMDERREN.
	SEMC_INTEN_IPCMDERREN = 0x2
	// Position of AXICMDERREN field.
	SEMC_INTEN_AXICMDERREN_Pos = 0x2
	// Bit mask of AXICMDERREN field.
	SEMC_INTEN_AXICMDERREN_Msk = 0x4
	// Bit AXICMDERREN.
	SEMC_INTEN_AXICMDERREN = 0x4
	// Position of AXIBUSERREN field.
	SEMC_INTEN_AXIBUSERREN_Pos = 0x3
	// Bit mask of AXIBUSERREN field.
	SEMC_INTEN_AXIBUSERREN_Msk = 0x8
	// Bit AXIBUSERREN.
	SEMC_INTEN_AXIBUSERREN = 0x8
	// Position of NDPAGEENDEN field.
	SEMC_INTEN_NDPAGEENDEN_Pos = 0x4
	// Bit mask of NDPAGEENDEN field.
	SEMC_INTEN_NDPAGEENDEN_Msk = 0x10
	// Bit NDPAGEENDEN.
	SEMC_INTEN_NDPAGEENDEN = 0x10
	// Disable
	SEMC_INTEN_NDPAGEENDEN_NDPAGEENDEN_0 = 0x0
	// Enable
	SEMC_INTEN_NDPAGEENDEN_NDPAGEENDEN_1 = 0x1
	// Position of NDNOPENDEN field.
	SEMC_INTEN_NDNOPENDEN_Pos = 0x5
	// Bit mask of NDNOPENDEN field.
	SEMC_INTEN_NDNOPENDEN_Msk = 0x20
	// Bit NDNOPENDEN.
	SEMC_INTEN_NDNOPENDEN = 0x20
	// Disable
	SEMC_INTEN_NDNOPENDEN_NDNOPENDEN_0 = 0x0
	// Enable
	SEMC_INTEN_NDNOPENDEN_NDNOPENDEN_1 = 0x1

	// INTR: Interrupt Enable Register
	// Position of IPCMDDONE field.
	SEMC_INTR_IPCMDDONE_Pos = 0x0
	// Bit mask of IPCMDDONE field.
	SEMC_INTR_IPCMDDONE_Msk = 0x1
	// Bit IPCMDDONE.
	SEMC_INTR_IPCMDDONE = 0x1
	// Position of IPCMDERR field.
	SEMC_INTR_IPCMDERR_Pos = 0x1
	// Bit mask of IPCMDERR field.
	SEMC_INTR_IPCMDERR_Msk = 0x2
	// Bit IPCMDERR.
	SEMC_INTR_IPCMDERR = 0x2
	// Position of AXICMDERR field.
	SEMC_INTR_AXICMDERR_Pos = 0x2
	// Bit mask of AXICMDERR field.
	SEMC_INTR_AXICMDERR_Msk = 0x4
	// Bit AXICMDERR.
	SEMC_INTR_AXICMDERR = 0x4
	// Position of AXIBUSERR field.
	SEMC_INTR_AXIBUSERR_Pos = 0x3
	// Bit mask of AXIBUSERR field.
	SEMC_INTR_AXIBUSERR_Msk = 0x8
	// Bit AXIBUSERR.
	SEMC_INTR_AXIBUSERR = 0x8
	// Position of NDPAGEEND field.
	SEMC_INTR_NDPAGEEND_Pos = 0x4
	// Bit mask of NDPAGEEND field.
	SEMC_INTR_NDPAGEEND_Msk = 0x10
	// Bit NDPAGEEND.
	SEMC_INTR_NDPAGEEND = 0x10
	// Position of NDNOPEND field.
	SEMC_INTR_NDNOPEND_Pos = 0x5
	// Bit mask of NDNOPEND field.
	SEMC_INTR_NDNOPEND_Msk = 0x20
	// Bit NDNOPEND.
	SEMC_INTR_NDNOPEND = 0x20

	// SDRAMCR0: SDRAM control register 0
	// Position of PS field.
	SEMC_SDRAMCR0_PS_Pos = 0x0
	// Bit mask of PS field.
	SEMC_SDRAMCR0_PS_Msk = 0x1
	// Bit PS.
	SEMC_SDRAMCR0_PS = 0x1
	// 8bit
	SEMC_SDRAMCR0_PS_PS_0 = 0x0
	// 16bit
	SEMC_SDRAMCR0_PS_PS_1 = 0x1
	// Position of BL field.
	SEMC_SDRAMCR0_BL_Pos = 0x4
	// Bit mask of BL field.
	SEMC_SDRAMCR0_BL_Msk = 0x70
	// 1
	SEMC_SDRAMCR0_BL_BL_0 = 0x0
	// 2
	SEMC_SDRAMCR0_BL_BL_1 = 0x1
	// 4
	SEMC_SDRAMCR0_BL_BL_2 = 0x2
	// 8
	SEMC_SDRAMCR0_BL_BL_3 = 0x3
	// 8
	SEMC_SDRAMCR0_BL_BL_4 = 0x4
	// 8
	SEMC_SDRAMCR0_BL_BL_5 = 0x5
	// 8
	SEMC_SDRAMCR0_BL_BL_6 = 0x6
	// 8
	SEMC_SDRAMCR0_BL_BL_7 = 0x7
	// Position of COL8 field.
	SEMC_SDRAMCR0_COL8_Pos = 0x7
	// Bit mask of COL8 field.
	SEMC_SDRAMCR0_COL8_Msk = 0x80
	// Bit COL8.
	SEMC_SDRAMCR0_COL8 = 0x80
	// Column address bit number is decided by COL field.
	SEMC_SDRAMCR0_COL8_COL8_0 = 0x0
	// Column address bit number is 8. COL field is ignored.
	SEMC_SDRAMCR0_COL8_COL8_1 = 0x1
	// Position of COL field.
	SEMC_SDRAMCR0_COL_Pos = 0x8
	// Bit mask of COL field.
	SEMC_SDRAMCR0_COL_Msk = 0x300
	// 12 bit
	SEMC_SDRAMCR0_COL_COL_0 = 0x0
	// 11 bit
	SEMC_SDRAMCR0_COL_COL_1 = 0x1
	// 10 bit
	SEMC_SDRAMCR0_COL_COL_2 = 0x2
	// 9 bit
	SEMC_SDRAMCR0_COL_COL_3 = 0x3
	// Position of CL field.
	SEMC_SDRAMCR0_CL_Pos = 0xa
	// Bit mask of CL field.
	SEMC_SDRAMCR0_CL_Msk = 0xc00
	// 1
	SEMC_SDRAMCR0_CL_CL_0 = 0x0
	// 1
	SEMC_SDRAMCR0_CL_CL_1 = 0x1
	// 2
	SEMC_SDRAMCR0_CL_CL_2 = 0x2
	// 3
	SEMC_SDRAMCR0_CL_CL_3 = 0x3
	// Position of BANK2 field.
	SEMC_SDRAMCR0_BANK2_Pos = 0xe
	// Bit mask of BANK2 field.
	SEMC_SDRAMCR0_BANK2_Msk = 0x4000
	// Bit BANK2.
	SEMC_SDRAMCR0_BANK2 = 0x4000
	// SDRAM device has 4 banks.
	SEMC_SDRAMCR0_BANK2_BANK2_0 = 0x0
	// SDRAM device has 2 banks.
	SEMC_SDRAMCR0_BANK2_BANK2_1 = 0x1

	// SDRAMCR1: SDRAM control register 1
	// Position of PRE2ACT field.
	SEMC_SDRAMCR1_PRE2ACT_Pos = 0x0
	// Bit mask of PRE2ACT field.
	SEMC_SDRAMCR1_PRE2ACT_Msk = 0xf
	// Position of ACT2RW field.
	SEMC_SDRAMCR1_ACT2RW_Pos = 0x4
	// Bit mask of ACT2RW field.
	SEMC_SDRAMCR1_ACT2RW_Msk = 0xf0
	// Position of RFRC field.
	SEMC_SDRAMCR1_RFRC_Pos = 0x8
	// Bit mask of RFRC field.
	SEMC_SDRAMCR1_RFRC_Msk = 0x1f00
	// Position of WRC field.
	SEMC_SDRAMCR1_WRC_Pos = 0xd
	// Bit mask of WRC field.
	SEMC_SDRAMCR1_WRC_Msk = 0xe000
	// Position of CKEOFF field.
	SEMC_SDRAMCR1_CKEOFF_Pos = 0x10
	// Bit mask of CKEOFF field.
	SEMC_SDRAMCR1_CKEOFF_Msk = 0xf0000
	// Position of ACT2PRE field.
	SEMC_SDRAMCR1_ACT2PRE_Pos = 0x14
	// Bit mask of ACT2PRE field.
	SEMC_SDRAMCR1_ACT2PRE_Msk = 0xf00000

	// SDRAMCR2: SDRAM control register 2
	// Position of SRRC field.
	SEMC_SDRAMCR2_SRRC_Pos = 0x0
	// Bit mask of SRRC field.
	SEMC_SDRAMCR2_SRRC_Msk = 0xff
	// Position of REF2REF field.
	SEMC_SDRAMCR2_REF2REF_Pos = 0x8
	// Bit mask of REF2REF field.
	SEMC_SDRAMCR2_REF2REF_Msk = 0xff00
	// Position of ACT2ACT field.
	SEMC_SDRAMCR2_ACT2ACT_Pos = 0x10
	// Bit mask of ACT2ACT field.
	SEMC_SDRAMCR2_ACT2ACT_Msk = 0xff0000
	// Position of ITO field.
	SEMC_SDRAMCR2_ITO_Pos = 0x18
	// Bit mask of ITO field.
	SEMC_SDRAMCR2_ITO_Msk = 0xff000000
	// IDLE timeout period is 256*Prescale period.
	SEMC_SDRAMCR2_ITO_ITO_0 = 0x0
	// IDLE timeout period is ITO*Prescale period.
	SEMC_SDRAMCR2_ITO_ITO_1 = 0x1
	// IDLE timeout period is ITO*Prescale period.
	SEMC_SDRAMCR2_ITO_ITO_2 = 0x2
	// IDLE timeout period is ITO*Prescale period.
	SEMC_SDRAMCR2_ITO_ITO_3 = 0x3
	// IDLE timeout period is ITO*Prescale period.
	SEMC_SDRAMCR2_ITO_ITO_4 = 0x4
	// IDLE timeout period is ITO*Prescale period.
	SEMC_SDRAMCR2_ITO_ITO_5 = 0x5
	// IDLE timeout period is ITO*Prescale period.
	SEMC_SDRAMCR2_ITO_ITO_6 = 0x6
	// IDLE timeout period is ITO*Prescale period.
	SEMC_SDRAMCR2_ITO_ITO_7 = 0x7
	// IDLE timeout period is ITO*Prescale period.
	SEMC_SDRAMCR2_ITO_ITO_8 = 0x8
	// IDLE timeout period is ITO*Prescale period.
	SEMC_SDRAMCR2_ITO_ITO_9 = 0x9

	// SDRAMCR3: SDRAM control register 3
	// Position of REN field.
	SEMC_SDRAMCR3_REN_Pos = 0x0
	// Bit mask of REN field.
	SEMC_SDRAMCR3_REN_Msk = 0x1
	// Bit REN.
	SEMC_SDRAMCR3_REN = 0x1
	// Position of REBL field.
	SEMC_SDRAMCR3_REBL_Pos = 0x1
	// Bit mask of REBL field.
	SEMC_SDRAMCR3_REBL_Msk = 0xe
	// 1
	SEMC_SDRAMCR3_REBL_REBL_0 = 0x0
	// 2
	SEMC_SDRAMCR3_REBL_REBL_1 = 0x1
	// 3
	SEMC_SDRAMCR3_REBL_REBL_2 = 0x2
	// 4
	SEMC_SDRAMCR3_REBL_REBL_3 = 0x3
	// 5
	SEMC_SDRAMCR3_REBL_REBL_4 = 0x4
	// 6
	SEMC_SDRAMCR3_REBL_REBL_5 = 0x5
	// 7
	SEMC_SDRAMCR3_REBL_REBL_6 = 0x6
	// 8
	SEMC_SDRAMCR3_REBL_REBL_7 = 0x7
	// Position of PRESCALE field.
	SEMC_SDRAMCR3_PRESCALE_Pos = 0x8
	// Bit mask of PRESCALE field.
	SEMC_SDRAMCR3_PRESCALE_Msk = 0xff00
	// 256*16 cycle
	SEMC_SDRAMCR3_PRESCALE_PRESCALE_0 = 0x0
	// PRESCALE*16 cycle
	SEMC_SDRAMCR3_PRESCALE_PRESCALE_1 = 0x1
	// PRESCALE*16 cycle
	SEMC_SDRAMCR3_PRESCALE_PRESCALE_2 = 0x2
	// PRESCALE*16 cycle
	SEMC_SDRAMCR3_PRESCALE_PRESCALE_3 = 0x3
	// PRESCALE*16 cycle
	SEMC_SDRAMCR3_PRESCALE_PRESCALE_4 = 0x4
	// PRESCALE*16 cycle
	SEMC_SDRAMCR3_PRESCALE_PRESCALE_5 = 0x5
	// PRESCALE*16 cycle
	SEMC_SDRAMCR3_PRESCALE_PRESCALE_6 = 0x6
	// PRESCALE*16 cycle
	SEMC_SDRAMCR3_PRESCALE_PRESCALE_7 = 0x7
	// PRESCALE*16 cycle
	SEMC_SDRAMCR3_PRESCALE_PRESCALE_8 = 0x8
	// PRESCALE*16 cycle
	SEMC_SDRAMCR3_PRESCALE_PRESCALE_9 = 0x9
	// Position of RT field.
	SEMC_SDRAMCR3_RT_Pos = 0x10
	// Bit mask of RT field.
	SEMC_SDRAMCR3_RT_Msk = 0xff0000
	// 256*Prescaler period
	SEMC_SDRAMCR3_RT_RT_0 = 0x0
	// RT*Prescaler period
	SEMC_SDRAMCR3_RT_RT_1 = 0x1
	// RT*Prescaler period
	SEMC_SDRAMCR3_RT_RT_2 = 0x2
	// RT*Prescaler period
	SEMC_SDRAMCR3_RT_RT_3 = 0x3
	// RT*Prescaler period
	SEMC_SDRAMCR3_RT_RT_4 = 0x4
	// RT*Prescaler period
	SEMC_SDRAMCR3_RT_RT_5 = 0x5
	// RT*Prescaler period
	SEMC_SDRAMCR3_RT_RT_6 = 0x6
	// RT*Prescaler period
	SEMC_SDRAMCR3_RT_RT_7 = 0x7
	// RT*Prescaler period
	SEMC_SDRAMCR3_RT_RT_8 = 0x8
	// RT*Prescaler period
	SEMC_SDRAMCR3_RT_RT_9 = 0x9
	// Position of UT field.
	SEMC_SDRAMCR3_UT_Pos = 0x18
	// Bit mask of UT field.
	SEMC_SDRAMCR3_UT_Msk = 0xff000000
	// 256*Prescaler period
	SEMC_SDRAMCR3_UT_UT_0 = 0x0
	// UT*Prescaler period
	SEMC_SDRAMCR3_UT_UT_1 = 0x1
	// UT*Prescaler period
	SEMC_SDRAMCR3_UT_UT_2 = 0x2
	// UT*Prescaler period
	SEMC_SDRAMCR3_UT_UT_3 = 0x3
	// UT*Prescaler period
	SEMC_SDRAMCR3_UT_UT_4 = 0x4
	// UT*Prescaler period
	SEMC_SDRAMCR3_UT_UT_5 = 0x5
	// UT*Prescaler period
	SEMC_SDRAMCR3_UT_UT_6 = 0x6
	// UT*Prescaler period
	SEMC_SDRAMCR3_UT_UT_7 = 0x7
	// UT*Prescaler period
	SEMC_SDRAMCR3_UT_UT_8 = 0x8
	// UT*Prescaler period
	SEMC_SDRAMCR3_UT_UT_9 = 0x9

	// NANDCR0: NAND control register 0
	// Position of PS field.
	SEMC_NANDCR0_PS_Pos = 0x0
	// Bit mask of PS field.
	SEMC_NANDCR0_PS_Msk = 0x1
	// Bit PS.
	SEMC_NANDCR0_PS = 0x1
	// 8bit
	SEMC_NANDCR0_PS_PS_0 = 0x0
	// 16bit
	SEMC_NANDCR0_PS_PS_1 = 0x1
	// Position of SYNCEN field.
	SEMC_NANDCR0_SYNCEN_Pos = 0x1
	// Bit mask of SYNCEN field.
	SEMC_NANDCR0_SYNCEN_Msk = 0x2
	// Bit SYNCEN.
	SEMC_NANDCR0_SYNCEN = 0x2
	// Asynchronous mode is enabled.
	SEMC_NANDCR0_SYNCEN_SYNCEN_0 = 0x0
	// Synchronous mode is enabled.
	SEMC_NANDCR0_SYNCEN_SYNCEN_1 = 0x1
	// Position of BL field.
	SEMC_NANDCR0_BL_Pos = 0x4
	// Bit mask of BL field.
	SEMC_NANDCR0_BL_Msk = 0x70
	// 1
	SEMC_NANDCR0_BL_BL_0 = 0x0
	// 2
	SEMC_NANDCR0_BL_BL_1 = 0x1
	// 4
	SEMC_NANDCR0_BL_BL_2 = 0x2
	// 8
	SEMC_NANDCR0_BL_BL_3 = 0x3
	// 16
	SEMC_NANDCR0_BL_BL_4 = 0x4
	// 32
	SEMC_NANDCR0_BL_BL_5 = 0x5
	// 64
	SEMC_NANDCR0_BL_BL_6 = 0x6
	// 64
	SEMC_NANDCR0_BL_BL_7 = 0x7
	// Position of EDO field.
	SEMC_NANDCR0_EDO_Pos = 0x7
	// Bit mask of EDO field.
	SEMC_NANDCR0_EDO_Msk = 0x80
	// Bit EDO.
	SEMC_NANDCR0_EDO = 0x80
	// EDO mode disabled
	SEMC_NANDCR0_EDO_EDO_0 = 0x0
	// EDO mode enabled
	SEMC_NANDCR0_EDO_EDO_1 = 0x1
	// Position of COL field.
	SEMC_NANDCR0_COL_Pos = 0x8
	// Bit mask of COL field.
	SEMC_NANDCR0_COL_Msk = 0x700
	// 16
	SEMC_NANDCR0_COL_COL_0 = 0x0
	// 15
	SEMC_NANDCR0_COL_COL_1 = 0x1
	// 14
	SEMC_NANDCR0_COL_COL_2 = 0x2
	// 13
	SEMC_NANDCR0_COL_COL_3 = 0x3
	// 12
	SEMC_NANDCR0_COL_COL_4 = 0x4
	// 11
	SEMC_NANDCR0_COL_COL_5 = 0x5
	// 10
	SEMC_NANDCR0_COL_COL_6 = 0x6
	// 9
	SEMC_NANDCR0_COL_COL_7 = 0x7

	// NANDCR1: NAND control register 1
	// Position of CES field.
	SEMC_NANDCR1_CES_Pos = 0x0
	// Bit mask of CES field.
	SEMC_NANDCR1_CES_Msk = 0xf
	// Position of CEH field.
	SEMC_NANDCR1_CEH_Pos = 0x4
	// Bit mask of CEH field.
	SEMC_NANDCR1_CEH_Msk = 0xf0
	// Position of WEL field.
	SEMC_NANDCR1_WEL_Pos = 0x8
	// Bit mask of WEL field.
	SEMC_NANDCR1_WEL_Msk = 0xf00
	// Position of WEH field.
	SEMC_NANDCR1_WEH_Pos = 0xc
	// Bit mask of WEH field.
	SEMC_NANDCR1_WEH_Msk = 0xf000
	// Position of REL field.
	SEMC_NANDCR1_REL_Pos = 0x10
	// Bit mask of REL field.
	SEMC_NANDCR1_REL_Msk = 0xf0000
	// Position of REH field.
	SEMC_NANDCR1_REH_Pos = 0x14
	// Bit mask of REH field.
	SEMC_NANDCR1_REH_Msk = 0xf00000
	// Position of TA field.
	SEMC_NANDCR1_TA_Pos = 0x18
	// Bit mask of TA field.
	SEMC_NANDCR1_TA_Msk = 0xf000000
	// Position of CEITV field.
	SEMC_NANDCR1_CEITV_Pos = 0x1c
	// Bit mask of CEITV field.
	SEMC_NANDCR1_CEITV_Msk = 0xf0000000

	// NANDCR2: NAND control register 2
	// Position of TWHR field.
	SEMC_NANDCR2_TWHR_Pos = 0x0
	// Bit mask of TWHR field.
	SEMC_NANDCR2_TWHR_Msk = 0x3f
	// Position of TRHW field.
	SEMC_NANDCR2_TRHW_Pos = 0x6
	// Bit mask of TRHW field.
	SEMC_NANDCR2_TRHW_Msk = 0xfc0
	// Position of TADL field.
	SEMC_NANDCR2_TADL_Pos = 0xc
	// Bit mask of TADL field.
	SEMC_NANDCR2_TADL_Msk = 0x3f000
	// Position of TRR field.
	SEMC_NANDCR2_TRR_Pos = 0x12
	// Bit mask of TRR field.
	SEMC_NANDCR2_TRR_Msk = 0xfc0000
	// Position of TWB field.
	SEMC_NANDCR2_TWB_Pos = 0x18
	// Bit mask of TWB field.
	SEMC_NANDCR2_TWB_Msk = 0x3f000000

	// NANDCR3: NAND control register 3
	// Position of NDOPT1 field.
	SEMC_NANDCR3_NDOPT1_Pos = 0x0
	// Bit mask of NDOPT1 field.
	SEMC_NANDCR3_NDOPT1_Msk = 0x1
	// Bit NDOPT1.
	SEMC_NANDCR3_NDOPT1 = 0x1
	// Position of NDOPT2 field.
	SEMC_NANDCR3_NDOPT2_Pos = 0x1
	// Bit mask of NDOPT2 field.
	SEMC_NANDCR3_NDOPT2_Msk = 0x2
	// Bit NDOPT2.
	SEMC_NANDCR3_NDOPT2 = 0x2
	// Position of NDOPT3 field.
	SEMC_NANDCR3_NDOPT3_Pos = 0x2
	// Bit mask of NDOPT3 field.
	SEMC_NANDCR3_NDOPT3_Msk = 0x4
	// Bit NDOPT3.
	SEMC_NANDCR3_NDOPT3 = 0x4
	// Position of CLE field.
	SEMC_NANDCR3_CLE_Pos = 0x3
	// Bit mask of CLE field.
	SEMC_NANDCR3_CLE_Msk = 0x8
	// Bit CLE.
	SEMC_NANDCR3_CLE = 0x8
	// Position of RDS field.
	SEMC_NANDCR3_RDS_Pos = 0x10
	// Bit mask of RDS field.
	SEMC_NANDCR3_RDS_Msk = 0xf0000
	// Position of RDH field.
	SEMC_NANDCR3_RDH_Pos = 0x14
	// Bit mask of RDH field.
	SEMC_NANDCR3_RDH_Msk = 0xf00000
	// Position of WDS field.
	SEMC_NANDCR3_WDS_Pos = 0x18
	// Bit mask of WDS field.
	SEMC_NANDCR3_WDS_Msk = 0xf000000
	// Position of WDH field.
	SEMC_NANDCR3_WDH_Pos = 0x1c
	// Bit mask of WDH field.
	SEMC_NANDCR3_WDH_Msk = 0xf0000000

	// NORCR0: NOR control register 0
	// Position of PS field.
	SEMC_NORCR0_PS_Pos = 0x0
	// Bit mask of PS field.
	SEMC_NORCR0_PS_Msk = 0x1
	// Bit PS.
	SEMC_NORCR0_PS = 0x1
	// 8bit
	SEMC_NORCR0_PS_PS_0 = 0x0
	// 16bit
	SEMC_NORCR0_PS_PS_1 = 0x1
	// Position of SYNCEN field.
	SEMC_NORCR0_SYNCEN_Pos = 0x1
	// Bit mask of SYNCEN field.
	SEMC_NORCR0_SYNCEN_Msk = 0x2
	// Bit SYNCEN.
	SEMC_NORCR0_SYNCEN = 0x2
	// Asynchronous mode is enabled.
	SEMC_NORCR0_SYNCEN_SYNCEN_0 = 0x0
	// Synchronous mode is enabled.
	SEMC_NORCR0_SYNCEN_SYNCEN_1 = 0x1
	// Position of BL field.
	SEMC_NORCR0_BL_Pos = 0x4
	// Bit mask of BL field.
	SEMC_NORCR0_BL_Msk = 0x70
	// 1
	SEMC_NORCR0_BL_BL_0 = 0x0
	// 2
	SEMC_NORCR0_BL_BL_1 = 0x1
	// 4
	SEMC_NORCR0_BL_BL_2 = 0x2
	// 8
	SEMC_NORCR0_BL_BL_3 = 0x3
	// 16
	SEMC_NORCR0_BL_BL_4 = 0x4
	// 32
	SEMC_NORCR0_BL_BL_5 = 0x5
	// 64
	SEMC_NORCR0_BL_BL_6 = 0x6
	// 64
	SEMC_NORCR0_BL_BL_7 = 0x7
	// Position of AM field.
	SEMC_NORCR0_AM_Pos = 0x8
	// Bit mask of AM field.
	SEMC_NORCR0_AM_Msk = 0x300
	// Address/Data MUX mode
	SEMC_NORCR0_AM_AM_0 = 0x0
	// Advanced Address/Data MUX mode
	SEMC_NORCR0_AM_AM_1 = 0x1
	// Address/Data non-MUX mode
	SEMC_NORCR0_AM_AM_2 = 0x2
	// Address/Data non-MUX mode
	SEMC_NORCR0_AM_AM_3 = 0x3
	// Position of ADVP field.
	SEMC_NORCR0_ADVP_Pos = 0xa
	// Bit mask of ADVP field.
	SEMC_NORCR0_ADVP_Msk = 0x400
	// Bit ADVP.
	SEMC_NORCR0_ADVP = 0x400
	// ADV# is Low Active. In ASYNC mode, device sample address with ADV# rise edge; In SYNC mode, device sample address when ADV# is LOW.
	SEMC_NORCR0_ADVP_ADVP_0 = 0x0
	// ADV# is High Active. In ASYNC mode, device sample address with ADV# fall edge; In SYNC mode, device sample address when ADV# is HIGH.
	SEMC_NORCR0_ADVP_ADVP_1 = 0x1
	// Position of ADVH field.
	SEMC_NORCR0_ADVH_Pos = 0xb
	// Bit mask of ADVH field.
	SEMC_NORCR0_ADVH_Msk = 0x800
	// Bit ADVH.
	SEMC_NORCR0_ADVH = 0x800
	// ADV# is high during address hold state.
	SEMC_NORCR0_ADVH_ADVH_0 = 0x0
	// ADV# is low during address hold state.
	SEMC_NORCR0_ADVH_ADVH_1 = 0x1
	// Position of COL field.
	SEMC_NORCR0_COL_Pos = 0xc
	// Bit mask of COL field.
	SEMC_NORCR0_COL_Msk = 0xf000
	// 12 Bits
	SEMC_NORCR0_COL_COL_0 = 0x0
	// 11 Bits
	SEMC_NORCR0_COL_COL_1 = 0x1
	// 10 Bits
	SEMC_NORCR0_COL_COL_2 = 0x2
	// 9 Bits
	SEMC_NORCR0_COL_COL_3 = 0x3
	// 8 Bits
	SEMC_NORCR0_COL_COL_4 = 0x4
	// 7 Bits
	SEMC_NORCR0_COL_COL_5 = 0x5
	// 6 Bits
	SEMC_NORCR0_COL_COL_6 = 0x6
	// 5 Bits
	SEMC_NORCR0_COL_COL_7 = 0x7
	// 4 Bits
	SEMC_NORCR0_COL_COL_8 = 0x8
	// 3 Bits
	SEMC_NORCR0_COL_COL_9 = 0x9
	// 2 Bits
	SEMC_NORCR0_COL_COL_10 = 0xa
	// 12 Bits
	SEMC_NORCR0_COL_COL_11 = 0xb
	// 12 Bits
	SEMC_NORCR0_COL_COL_12 = 0xc
	// 12 Bits
	SEMC_NORCR0_COL_COL_13 = 0xd
	// 12 Bits
	SEMC_NORCR0_COL_COL_14 = 0xe
	// 12 Bits
	SEMC_NORCR0_COL_COL_15 = 0xf

	// NORCR1: NOR control register 1
	// Position of CES field.
	SEMC_NORCR1_CES_Pos = 0x0
	// Bit mask of CES field.
	SEMC_NORCR1_CES_Msk = 0xf
	// Position of CEH field.
	SEMC_NORCR1_CEH_Pos = 0x4
	// Bit mask of CEH field.
	SEMC_NORCR1_CEH_Msk = 0xf0
	// Position of AS field.
	SEMC_NORCR1_AS_Pos = 0x8
	// Bit mask of AS field.
	SEMC_NORCR1_AS_Msk = 0xf00
	// Position of AH field.
	SEMC_NORCR1_AH_Pos = 0xc
	// Bit mask of AH field.
	SEMC_NORCR1_AH_Msk = 0xf000
	// Position of WEL field.
	SEMC_NORCR1_WEL_Pos = 0x10
	// Bit mask of WEL field.
	SEMC_NORCR1_WEL_Msk = 0xf0000
	// Position of WEH field.
	SEMC_NORCR1_WEH_Pos = 0x14
	// Bit mask of WEH field.
	SEMC_NORCR1_WEH_Msk = 0xf00000
	// Position of REL field.
	SEMC_NORCR1_REL_Pos = 0x18
	// Bit mask of REL field.
	SEMC_NORCR1_REL_Msk = 0xf000000
	// Position of REH field.
	SEMC_NORCR1_REH_Pos = 0x1c
	// Bit mask of REH field.
	SEMC_NORCR1_REH_Msk = 0xf0000000

	// NORCR2: NOR control register 2
	// Position of TA field.
	SEMC_NORCR2_TA_Pos = 0x8
	// Bit mask of TA field.
	SEMC_NORCR2_TA_Msk = 0xf00
	// Position of AWDH field.
	SEMC_NORCR2_AWDH_Pos = 0xc
	// Bit mask of AWDH field.
	SEMC_NORCR2_AWDH_Msk = 0xf000
	// Position of LC field.
	SEMC_NORCR2_LC_Pos = 0x10
	// Bit mask of LC field.
	SEMC_NORCR2_LC_Msk = 0xf0000
	// Position of RD field.
	SEMC_NORCR2_RD_Pos = 0x14
	// Bit mask of RD field.
	SEMC_NORCR2_RD_Msk = 0xf00000
	// Position of CEITV field.
	SEMC_NORCR2_CEITV_Pos = 0x18
	// Bit mask of CEITV field.
	SEMC_NORCR2_CEITV_Msk = 0xf000000
	// Position of RDH field.
	SEMC_NORCR2_RDH_Pos = 0x1c
	// Bit mask of RDH field.
	SEMC_NORCR2_RDH_Msk = 0xf0000000

	// NORCR3: NOR control register 3
	// Position of ASSR field.
	SEMC_NORCR3_ASSR_Pos = 0x0
	// Bit mask of ASSR field.
	SEMC_NORCR3_ASSR_Msk = 0xf
	// Position of AHSR field.
	SEMC_NORCR3_AHSR_Pos = 0x4
	// Bit mask of AHSR field.
	SEMC_NORCR3_AHSR_Msk = 0xf0

	// SRAMCR0: SRAM control register 0
	// Position of PS field.
	SEMC_SRAMCR0_PS_Pos = 0x0
	// Bit mask of PS field.
	SEMC_SRAMCR0_PS_Msk = 0x1
	// Bit PS.
	SEMC_SRAMCR0_PS = 0x1
	// 8bit
	SEMC_SRAMCR0_PS_PS_0 = 0x0
	// 16bit
	SEMC_SRAMCR0_PS_PS_1 = 0x1
	// Position of SYNCEN field.
	SEMC_SRAMCR0_SYNCEN_Pos = 0x1
	// Bit mask of SYNCEN field.
	SEMC_SRAMCR0_SYNCEN_Msk = 0x2
	// Bit SYNCEN.
	SEMC_SRAMCR0_SYNCEN = 0x2
	// Asynchronous mode is enabled.
	SEMC_SRAMCR0_SYNCEN_SYNCEN_0 = 0x0
	// Synchronous mode is enabled.
	SEMC_SRAMCR0_SYNCEN_SYNCEN_1 = 0x1
	// Position of BL field.
	SEMC_SRAMCR0_BL_Pos = 0x4
	// Bit mask of BL field.
	SEMC_SRAMCR0_BL_Msk = 0x70
	// 1
	SEMC_SRAMCR0_BL_BL_0 = 0x0
	// 2
	SEMC_SRAMCR0_BL_BL_1 = 0x1
	// 4
	SEMC_SRAMCR0_BL_BL_2 = 0x2
	// 8
	SEMC_SRAMCR0_BL_BL_3 = 0x3
	// 16
	SEMC_SRAMCR0_BL_BL_4 = 0x4
	// 32
	SEMC_SRAMCR0_BL_BL_5 = 0x5
	// 64
	SEMC_SRAMCR0_BL_BL_6 = 0x6
	// 64
	SEMC_SRAMCR0_BL_BL_7 = 0x7
	// Position of AM field.
	SEMC_SRAMCR0_AM_Pos = 0x8
	// Bit mask of AM field.
	SEMC_SRAMCR0_AM_Msk = 0x300
	// Address/Data MUX mode
	SEMC_SRAMCR0_AM_AM_0 = 0x0
	// Advanced Address/Data MUX mode
	SEMC_SRAMCR0_AM_AM_1 = 0x1
	// Address/Data non-MUX mode
	SEMC_SRAMCR0_AM_AM_2 = 0x2
	// Address/Data non-MUX mode
	SEMC_SRAMCR0_AM_AM_3 = 0x3
	// Position of ADVP field.
	SEMC_SRAMCR0_ADVP_Pos = 0xa
	// Bit mask of ADVP field.
	SEMC_SRAMCR0_ADVP_Msk = 0x400
	// Bit ADVP.
	SEMC_SRAMCR0_ADVP = 0x400
	// ADV# is Low Active. In ASYNC mode, device sample address with ADV# rise edge; In SYNC mode, device sample address when ADV# is LOW.
	SEMC_SRAMCR0_ADVP_ADVP_0 = 0x0
	// ADV# is High Active. In ASYNC mode, device sample address with ADV# fall edge; In SYNC mode, device sample address when ADV# is HIGH.
	SEMC_SRAMCR0_ADVP_ADVP_1 = 0x1
	// Position of ADVH field.
	SEMC_SRAMCR0_ADVH_Pos = 0xb
	// Bit mask of ADVH field.
	SEMC_SRAMCR0_ADVH_Msk = 0x800
	// Bit ADVH.
	SEMC_SRAMCR0_ADVH = 0x800
	// ADV# is high during address hold state.
	SEMC_SRAMCR0_ADVH_ADVH_0 = 0x0
	// ADV# is low during address hold state.
	SEMC_SRAMCR0_ADVH_ADVH_1 = 0x1
	// Position of COL field.
	SEMC_SRAMCR0_COL_Pos = 0xc
	// Bit mask of COL field.
	SEMC_SRAMCR0_COL_Msk = 0xf000
	// 12 Bits
	SEMC_SRAMCR0_COL_COL_0 = 0x0
	// 11 Bits
	SEMC_SRAMCR0_COL_COL_1 = 0x1
	// 10 Bits
	SEMC_SRAMCR0_COL_COL_2 = 0x2
	// 9 Bits
	SEMC_SRAMCR0_COL_COL_3 = 0x3
	// 8 Bits
	SEMC_SRAMCR0_COL_COL_4 = 0x4
	// 7 Bits
	SEMC_SRAMCR0_COL_COL_5 = 0x5
	// 6 Bits
	SEMC_SRAMCR0_COL_COL_6 = 0x6
	// 5 Bits
	SEMC_SRAMCR0_COL_COL_7 = 0x7
	// 4 Bits
	SEMC_SRAMCR0_COL_COL_8 = 0x8
	// 3 Bits
	SEMC_SRAMCR0_COL_COL_9 = 0x9
	// 2 Bits
	SEMC_SRAMCR0_COL_COL_10 = 0xa
	// 12 Bits
	SEMC_SRAMCR0_COL_COL_11 = 0xb
	// 12 Bits
	SEMC_SRAMCR0_COL_COL_12 = 0xc
	// 12 Bits
	SEMC_SRAMCR0_COL_COL_13 = 0xd
	// 12 Bits
	SEMC_SRAMCR0_COL_COL_14 = 0xe
	// 12 Bits
	SEMC_SRAMCR0_COL_COL_15 = 0xf

	// SRAMCR1: SRAM control register 1
	// Position of CES field.
	SEMC_SRAMCR1_CES_Pos = 0x0
	// Bit mask of CES field.
	SEMC_SRAMCR1_CES_Msk = 0xf
	// Position of CEH field.
	SEMC_SRAMCR1_CEH_Pos = 0x4
	// Bit mask of CEH field.
	SEMC_SRAMCR1_CEH_Msk = 0xf0
	// Position of AS field.
	SEMC_SRAMCR1_AS_Pos = 0x8
	// Bit mask of AS field.
	SEMC_SRAMCR1_AS_Msk = 0xf00
	// Position of AH field.
	SEMC_SRAMCR1_AH_Pos = 0xc
	// Bit mask of AH field.
	SEMC_SRAMCR1_AH_Msk = 0xf000
	// Position of WEL field.
	SEMC_SRAMCR1_WEL_Pos = 0x10
	// Bit mask of WEL field.
	SEMC_SRAMCR1_WEL_Msk = 0xf0000
	// Position of WEH field.
	SEMC_SRAMCR1_WEH_Pos = 0x14
	// Bit mask of WEH field.
	SEMC_SRAMCR1_WEH_Msk = 0xf00000
	// Position of REL field.
	SEMC_SRAMCR1_REL_Pos = 0x18
	// Bit mask of REL field.
	SEMC_SRAMCR1_REL_Msk = 0xf000000
	// Position of REH field.
	SEMC_SRAMCR1_REH_Pos = 0x1c
	// Bit mask of REH field.
	SEMC_SRAMCR1_REH_Msk = 0xf0000000

	// SRAMCR2: SRAM control register 2
	// Position of WDS field.
	SEMC_SRAMCR2_WDS_Pos = 0x0
	// Bit mask of WDS field.
	SEMC_SRAMCR2_WDS_Msk = 0xf
	// Position of WDH field.
	SEMC_SRAMCR2_WDH_Pos = 0x4
	// Bit mask of WDH field.
	SEMC_SRAMCR2_WDH_Msk = 0xf0
	// Position of TA field.
	SEMC_SRAMCR2_TA_Pos = 0x8
	// Bit mask of TA field.
	SEMC_SRAMCR2_TA_Msk = 0xf00
	// Position of AWDH field.
	SEMC_SRAMCR2_AWDH_Pos = 0xc
	// Bit mask of AWDH field.
	SEMC_SRAMCR2_AWDH_Msk = 0xf000
	// Position of LC field.
	SEMC_SRAMCR2_LC_Pos = 0x10
	// Bit mask of LC field.
	SEMC_SRAMCR2_LC_Msk = 0xf0000
	// Position of RD field.
	SEMC_SRAMCR2_RD_Pos = 0x14
	// Bit mask of RD field.
	SEMC_SRAMCR2_RD_Msk = 0xf00000
	// Position of CEITV field.
	SEMC_SRAMCR2_CEITV_Pos = 0x18
	// Bit mask of CEITV field.
	SEMC_SRAMCR2_CEITV_Msk = 0xf000000
	// Position of RDH field.
	SEMC_SRAMCR2_RDH_Pos = 0x1c
	// Bit mask of RDH field.
	SEMC_SRAMCR2_RDH_Msk = 0xf0000000

	// DBICR0: DBI-B control register 0
	// Position of PS field.
	SEMC_DBICR0_PS_Pos = 0x0
	// Bit mask of PS field.
	SEMC_DBICR0_PS_Msk = 0x1
	// Bit PS.
	SEMC_DBICR0_PS = 0x1
	// 8bit
	SEMC_DBICR0_PS_PS_0 = 0x0
	// 16bit
	SEMC_DBICR0_PS_PS_1 = 0x1
	// Position of BL field.
	SEMC_DBICR0_BL_Pos = 0x4
	// Bit mask of BL field.
	SEMC_DBICR0_BL_Msk = 0x70
	// 1
	SEMC_DBICR0_BL_BL_0 = 0x0
	// 2
	SEMC_DBICR0_BL_BL_1 = 0x1
	// 4
	SEMC_DBICR0_BL_BL_2 = 0x2
	// 8
	SEMC_DBICR0_BL_BL_3 = 0x3
	// 16
	SEMC_DBICR0_BL_BL_4 = 0x4
	// 32
	SEMC_DBICR0_BL_BL_5 = 0x5
	// 64
	SEMC_DBICR0_BL_BL_6 = 0x6
	// 64
	SEMC_DBICR0_BL_BL_7 = 0x7
	// Position of COL field.
	SEMC_DBICR0_COL_Pos = 0xc
	// Bit mask of COL field.
	SEMC_DBICR0_COL_Msk = 0xf000
	// 12 Bits
	SEMC_DBICR0_COL_COL_0 = 0x0
	// 11 Bits
	SEMC_DBICR0_COL_COL_1 = 0x1
	// 10 Bits
	SEMC_DBICR0_COL_COL_2 = 0x2
	// 9 Bits
	SEMC_DBICR0_COL_COL_3 = 0x3
	// 8 Bits
	SEMC_DBICR0_COL_COL_4 = 0x4
	// 7 Bits
	SEMC_DBICR0_COL_COL_5 = 0x5
	// 6 Bits
	SEMC_DBICR0_COL_COL_6 = 0x6
	// 5 Bits
	SEMC_DBICR0_COL_COL_7 = 0x7
	// 4 Bits
	SEMC_DBICR0_COL_COL_8 = 0x8
	// 3 Bits
	SEMC_DBICR0_COL_COL_9 = 0x9
	// 2 Bits
	SEMC_DBICR0_COL_COL_10 = 0xa
	// 12 Bits
	SEMC_DBICR0_COL_COL_11 = 0xb
	// 12 Bits
	SEMC_DBICR0_COL_COL_12 = 0xc
	// 12 Bits
	SEMC_DBICR0_COL_COL_13 = 0xd
	// 12 Bits
	SEMC_DBICR0_COL_COL_14 = 0xe
	// 12 Bits
	SEMC_DBICR0_COL_COL_15 = 0xf

	// DBICR1: DBI-B control register 1
	// Position of CES field.
	SEMC_DBICR1_CES_Pos = 0x0
	// Bit mask of CES field.
	SEMC_DBICR1_CES_Msk = 0xf
	// Position of CEH field.
	SEMC_DBICR1_CEH_Pos = 0x4
	// Bit mask of CEH field.
	SEMC_DBICR1_CEH_Msk = 0xf0
	// Position of WEL field.
	SEMC_DBICR1_WEL_Pos = 0x8
	// Bit mask of WEL field.
	SEMC_DBICR1_WEL_Msk = 0xf00
	// Position of WEH field.
	SEMC_DBICR1_WEH_Pos = 0xc
	// Bit mask of WEH field.
	SEMC_DBICR1_WEH_Msk = 0xf000
	// Position of REL field.
	SEMC_DBICR1_REL_Pos = 0x10
	// Bit mask of REL field.
	SEMC_DBICR1_REL_Msk = 0x3f0000
	// Position of REH field.
	SEMC_DBICR1_REH_Pos = 0x16
	// Bit mask of REH field.
	SEMC_DBICR1_REH_Msk = 0xfc00000
	// Position of CEITV field.
	SEMC_DBICR1_CEITV_Pos = 0x1c
	// Bit mask of CEITV field.
	SEMC_DBICR1_CEITV_Msk = 0xf0000000

	// IPCR0: IP Command control register 0
	// Position of SA field.
	SEMC_IPCR0_SA_Pos = 0x0
	// Bit mask of SA field.
	SEMC_IPCR0_SA_Msk = 0xffffffff

	// IPCR1: IP Command control register 1
	// Position of DATSZ field.
	SEMC_IPCR1_DATSZ_Pos = 0x0
	// Bit mask of DATSZ field.
	SEMC_IPCR1_DATSZ_Msk = 0x7
	// 4
	SEMC_IPCR1_DATSZ_DATSZ_0 = 0x0
	// 1
	SEMC_IPCR1_DATSZ_DATSZ_1 = 0x1
	// 2
	SEMC_IPCR1_DATSZ_DATSZ_2 = 0x2
	// 3
	SEMC_IPCR1_DATSZ_DATSZ_3 = 0x3
	// 4
	SEMC_IPCR1_DATSZ_DATSZ_4 = 0x4
	// 4
	SEMC_IPCR1_DATSZ_DATSZ_5 = 0x5
	// 4
	SEMC_IPCR1_DATSZ_DATSZ_6 = 0x6
	// 4
	SEMC_IPCR1_DATSZ_DATSZ_7 = 0x7
	// Position of NAND_EXT_ADDR field.
	SEMC_IPCR1_NAND_EXT_ADDR_Pos = 0x8
	// Bit mask of NAND_EXT_ADDR field.
	SEMC_IPCR1_NAND_EXT_ADDR_Msk = 0xff00

	// IPCR2: IP Command control register 2
	// Position of BM0 field.
	SEMC_IPCR2_BM0_Pos = 0x0
	// Bit mask of BM0 field.
	SEMC_IPCR2_BM0_Msk = 0x1
	// Bit BM0.
	SEMC_IPCR2_BM0 = 0x1
	// Byte Unmasked
	SEMC_IPCR2_BM0_BM0_0 = 0x0
	// Byte Masked
	SEMC_IPCR2_BM0_BM0_1 = 0x1
	// Position of BM1 field.
	SEMC_IPCR2_BM1_Pos = 0x1
	// Bit mask of BM1 field.
	SEMC_IPCR2_BM1_Msk = 0x2
	// Bit BM1.
	SEMC_IPCR2_BM1 = 0x2
	// Byte Unmasked
	SEMC_IPCR2_BM1_BM1_0 = 0x0
	// Byte Masked
	SEMC_IPCR2_BM1_BM1_1 = 0x1
	// Position of BM2 field.
	SEMC_IPCR2_BM2_Pos = 0x2
	// Bit mask of BM2 field.
	SEMC_IPCR2_BM2_Msk = 0x4
	// Bit BM2.
	SEMC_IPCR2_BM2 = 0x4
	// Byte Unmasked
	SEMC_IPCR2_BM2_BM2_0 = 0x0
	// Byte Masked
	SEMC_IPCR2_BM2_BM2_1 = 0x1
	// Position of BM3 field.
	SEMC_IPCR2_BM3_Pos = 0x3
	// Bit mask of BM3 field.
	SEMC_IPCR2_BM3_Msk = 0x8
	// Bit BM3.
	SEMC_IPCR2_BM3 = 0x8
	// Byte Unmasked
	SEMC_IPCR2_BM3_BM3_0 = 0x0
	// Byte Masked
	SEMC_IPCR2_BM3_BM3_1 = 0x1

	// IPCMD: IP Command register
	// Position of CMD field.
	SEMC_IPCMD_CMD_Pos = 0x0
	// Bit mask of CMD field.
	SEMC_IPCMD_CMD_Msk = 0xffff
	// Position of KEY field.
	SEMC_IPCMD_KEY_Pos = 0x10
	// Bit mask of KEY field.
	SEMC_IPCMD_KEY_Msk = 0xffff0000

	// IPTXDAT: TX DATA register (for IP Command)
	// Position of DAT field.
	SEMC_IPTXDAT_DAT_Pos = 0x0
	// Bit mask of DAT field.
	SEMC_IPTXDAT_DAT_Msk = 0xffffffff

	// IPRXDAT: RX DATA register (for IP Command)
	// Position of DAT field.
	SEMC_IPRXDAT_DAT_Pos = 0x0
	// Bit mask of DAT field.
	SEMC_IPRXDAT_DAT_Msk = 0xffffffff

	// STS0: Status register 0
	// Position of IDLE field.
	SEMC_STS0_IDLE_Pos = 0x0
	// Bit mask of IDLE field.
	SEMC_STS0_IDLE_Msk = 0x1
	// Bit IDLE.
	SEMC_STS0_IDLE = 0x1
	// Position of NARDY field.
	SEMC_STS0_NARDY_Pos = 0x1
	// Bit mask of NARDY field.
	SEMC_STS0_NARDY_Msk = 0x2
	// Bit NARDY.
	SEMC_STS0_NARDY = 0x2
	// NAND device is not ready
	SEMC_STS0_NARDY_NARDY_0 = 0x0
	// NAND device is ready
	SEMC_STS0_NARDY_NARDY_1 = 0x1

	// STS2: Status register 2
	// Position of NDWRPEND field.
	SEMC_STS2_NDWRPEND_Pos = 0x3
	// Bit mask of NDWRPEND field.
	SEMC_STS2_NDWRPEND_Msk = 0x8
	// Bit NDWRPEND.
	SEMC_STS2_NDWRPEND = 0x8
	// No pending
	SEMC_STS2_NDWRPEND_NDWRPEND_0 = 0x0
	// Pending
	SEMC_STS2_NDWRPEND_NDWRPEND_1 = 0x1

	// STS12: Status register 12
	// Position of NDADDR field.
	SEMC_STS12_NDADDR_Pos = 0x0
	// Bit mask of NDADDR field.
	SEMC_STS12_NDADDR_Msk = 0xffffffff

	// STS13: Status register 13
	// Position of SLVLOCK field.
	SEMC_STS13_SLVLOCK_Pos = 0x0
	// Bit mask of SLVLOCK field.
	SEMC_STS13_SLVLOCK_Msk = 0x1
	// Bit SLVLOCK.
	SEMC_STS13_SLVLOCK = 0x1
	// Position of REFLOCK field.
	SEMC_STS13_REFLOCK_Pos = 0x1
	// Bit mask of REFLOCK field.
	SEMC_STS13_REFLOCK_Msk = 0x2
	// Bit REFLOCK.
	SEMC_STS13_REFLOCK = 0x2
	// Position of SLVSEL field.
	SEMC_STS13_SLVSEL_Pos = 0x2
	// Bit mask of SLVSEL field.
	SEMC_STS13_SLVSEL_Msk = 0xfc
	// Position of REFSEL field.
	SEMC_STS13_REFSEL_Pos = 0x8
	// Bit mask of REFSEL field.
	SEMC_STS13_REFSEL_Msk = 0x3f00
)

// Bitfields for DCP: DCP register reference index
const (
	// CTRL: DCP control register 0
	// Position of CHANNEL_INTERRUPT_ENABLE field.
	DCP_CTRL_CHANNEL_INTERRUPT_ENABLE_Pos = 0x0
	// Bit mask of CHANNEL_INTERRUPT_ENABLE field.
	DCP_CTRL_CHANNEL_INTERRUPT_ENABLE_Msk = 0xff
	// CH0
	DCP_CTRL_CHANNEL_INTERRUPT_ENABLE_CH0 = 0x1
	// CH1
	DCP_CTRL_CHANNEL_INTERRUPT_ENABLE_CH1 = 0x2
	// CH2
	DCP_CTRL_CHANNEL_INTERRUPT_ENABLE_CH2 = 0x4
	// CH3
	DCP_CTRL_CHANNEL_INTERRUPT_ENABLE_CH3 = 0x8
	// Position of ENABLE_CONTEXT_SWITCHING field.
	DCP_CTRL_ENABLE_CONTEXT_SWITCHING_Pos = 0x15
	// Bit mask of ENABLE_CONTEXT_SWITCHING field.
	DCP_CTRL_ENABLE_CONTEXT_SWITCHING_Msk = 0x200000
	// Bit ENABLE_CONTEXT_SWITCHING.
	DCP_CTRL_ENABLE_CONTEXT_SWITCHING = 0x200000
	// Position of ENABLE_CONTEXT_CACHING field.
	DCP_CTRL_ENABLE_CONTEXT_CACHING_Pos = 0x16
	// Bit mask of ENABLE_CONTEXT_CACHING field.
	DCP_CTRL_ENABLE_CONTEXT_CACHING_Msk = 0x400000
	// Bit ENABLE_CONTEXT_CACHING.
	DCP_CTRL_ENABLE_CONTEXT_CACHING = 0x400000
	// Position of GATHER_RESIDUAL_WRITES field.
	DCP_CTRL_GATHER_RESIDUAL_WRITES_Pos = 0x17
	// Bit mask of GATHER_RESIDUAL_WRITES field.
	DCP_CTRL_GATHER_RESIDUAL_WRITES_Msk = 0x800000
	// Bit GATHER_RESIDUAL_WRITES.
	DCP_CTRL_GATHER_RESIDUAL_WRITES = 0x800000
	// Position of PRESENT_SHA field.
	DCP_CTRL_PRESENT_SHA_Pos = 0x1c
	// Bit mask of PRESENT_SHA field.
	DCP_CTRL_PRESENT_SHA_Msk = 0x10000000
	// Bit PRESENT_SHA.
	DCP_CTRL_PRESENT_SHA = 0x10000000
	// Absent
	DCP_CTRL_PRESENT_SHA_Absent = 0x0
	// Present
	DCP_CTRL_PRESENT_SHA_Present = 0x1
	// Position of PRESENT_CRYPTO field.
	DCP_CTRL_PRESENT_CRYPTO_Pos = 0x1d
	// Bit mask of PRESENT_CRYPTO field.
	DCP_CTRL_PRESENT_CRYPTO_Msk = 0x20000000
	// Bit PRESENT_CRYPTO.
	DCP_CTRL_PRESENT_CRYPTO = 0x20000000
	// Absent
	DCP_CTRL_PRESENT_CRYPTO_Absent = 0x0
	// Present
	DCP_CTRL_PRESENT_CRYPTO_Present = 0x1
	// Position of CLKGATE field.
	DCP_CTRL_CLKGATE_Pos = 0x1e
	// Bit mask of CLKGATE field.
	DCP_CTRL_CLKGATE_Msk = 0x40000000
	// Bit CLKGATE.
	DCP_CTRL_CLKGATE = 0x40000000
	// Position of SFTRST field.
	DCP_CTRL_SFTRST_Pos = 0x1f
	// Bit mask of SFTRST field.
	DCP_CTRL_SFTRST_Msk = 0x80000000
	// Bit SFTRST.
	DCP_CTRL_SFTRST = 0x80000000

	// CTRL_SET: DCP control register 0
	// Position of CHANNEL_INTERRUPT_ENABLE field.
	DCP_CTRL_SET_CHANNEL_INTERRUPT_ENABLE_Pos = 0x0
	// Bit mask of CHANNEL_INTERRUPT_ENABLE field.
	DCP_CTRL_SET_CHANNEL_INTERRUPT_ENABLE_Msk = 0xff
	// CH0
	DCP_CTRL_SET_CHANNEL_INTERRUPT_ENABLE_CH0 = 0x1
	// CH1
	DCP_CTRL_SET_CHANNEL_INTERRUPT_ENABLE_CH1 = 0x2
	// CH2
	DCP_CTRL_SET_CHANNEL_INTERRUPT_ENABLE_CH2 = 0x4
	// CH3
	DCP_CTRL_SET_CHANNEL_INTERRUPT_ENABLE_CH3 = 0x8
	// Position of ENABLE_CONTEXT_SWITCHING field.
	DCP_CTRL_SET_ENABLE_CONTEXT_SWITCHING_Pos = 0x15
	// Bit mask of ENABLE_CONTEXT_SWITCHING field.
	DCP_CTRL_SET_ENABLE_CONTEXT_SWITCHING_Msk = 0x200000
	// Bit ENABLE_CONTEXT_SWITCHING.
	DCP_CTRL_SET_ENABLE_CONTEXT_SWITCHING = 0x200000
	// Position of ENABLE_CONTEXT_CACHING field.
	DCP_CTRL_SET_ENABLE_CONTEXT_CACHING_Pos = 0x16
	// Bit mask of ENABLE_CONTEXT_CACHING field.
	DCP_CTRL_SET_ENABLE_CONTEXT_CACHING_Msk = 0x400000
	// Bit ENABLE_CONTEXT_CACHING.
	DCP_CTRL_SET_ENABLE_CONTEXT_CACHING = 0x400000
	// Position of GATHER_RESIDUAL_WRITES field.
	DCP_CTRL_SET_GATHER_RESIDUAL_WRITES_Pos = 0x17
	// Bit mask of GATHER_RESIDUAL_WRITES field.
	DCP_CTRL_SET_GATHER_RESIDUAL_WRITES_Msk = 0x800000
	// Bit GATHER_RESIDUAL_WRITES.
	DCP_CTRL_SET_GATHER_RESIDUAL_WRITES = 0x800000
	// Position of PRESENT_SHA field.
	DCP_CTRL_SET_PRESENT_SHA_Pos = 0x1c
	// Bit mask of PRESENT_SHA field.
	DCP_CTRL_SET_PRESENT_SHA_Msk = 0x10000000
	// Bit PRESENT_SHA.
	DCP_CTRL_SET_PRESENT_SHA = 0x10000000
	// Absent
	DCP_CTRL_SET_PRESENT_SHA_Absent = 0x0
	// Present
	DCP_CTRL_SET_PRESENT_SHA_Present = 0x1
	// Position of PRESENT_CRYPTO field.
	DCP_CTRL_SET_PRESENT_CRYPTO_Pos = 0x1d
	// Bit mask of PRESENT_CRYPTO field.
	DCP_CTRL_SET_PRESENT_CRYPTO_Msk = 0x20000000
	// Bit PRESENT_CRYPTO.
	DCP_CTRL_SET_PRESENT_CRYPTO = 0x20000000
	// Absent
	DCP_CTRL_SET_PRESENT_CRYPTO_Absent = 0x0
	// Present
	DCP_CTRL_SET_PRESENT_CRYPTO_Present = 0x1
	// Position of CLKGATE field.
	DCP_CTRL_SET_CLKGATE_Pos = 0x1e
	// Bit mask of CLKGATE field.
	DCP_CTRL_SET_CLKGATE_Msk = 0x40000000
	// Bit CLKGATE.
	DCP_CTRL_SET_CLKGATE = 0x40000000
	// Position of SFTRST field.
	DCP_CTRL_SET_SFTRST_Pos = 0x1f
	// Bit mask of SFTRST field.
	DCP_CTRL_SET_SFTRST_Msk = 0x80000000
	// Bit SFTRST.
	DCP_CTRL_SET_SFTRST = 0x80000000

	// CTRL_CLR: DCP control register 0
	// Position of CHANNEL_INTERRUPT_ENABLE field.
	DCP_CTRL_CLR_CHANNEL_INTERRUPT_ENABLE_Pos = 0x0
	// Bit mask of CHANNEL_INTERRUPT_ENABLE field.
	DCP_CTRL_CLR_CHANNEL_INTERRUPT_ENABLE_Msk = 0xff
	// CH0
	DCP_CTRL_CLR_CHANNEL_INTERRUPT_ENABLE_CH0 = 0x1
	// CH1
	DCP_CTRL_CLR_CHANNEL_INTERRUPT_ENABLE_CH1 = 0x2
	// CH2
	DCP_CTRL_CLR_CHANNEL_INTERRUPT_ENABLE_CH2 = 0x4
	// CH3
	DCP_CTRL_CLR_CHANNEL_INTERRUPT_ENABLE_CH3 = 0x8
	// Position of ENABLE_CONTEXT_SWITCHING field.
	DCP_CTRL_CLR_ENABLE_CONTEXT_SWITCHING_Pos = 0x15
	// Bit mask of ENABLE_CONTEXT_SWITCHING field.
	DCP_CTRL_CLR_ENABLE_CONTEXT_SWITCHING_Msk = 0x200000
	// Bit ENABLE_CONTEXT_SWITCHING.
	DCP_CTRL_CLR_ENABLE_CONTEXT_SWITCHING = 0x200000
	// Position of ENABLE_CONTEXT_CACHING field.
	DCP_CTRL_CLR_ENABLE_CONTEXT_CACHING_Pos = 0x16
	// Bit mask of ENABLE_CONTEXT_CACHING field.
	DCP_CTRL_CLR_ENABLE_CONTEXT_CACHING_Msk = 0x400000
	// Bit ENABLE_CONTEXT_CACHING.
	DCP_CTRL_CLR_ENABLE_CONTEXT_CACHING = 0x400000
	// Position of GATHER_RESIDUAL_WRITES field.
	DCP_CTRL_CLR_GATHER_RESIDUAL_WRITES_Pos = 0x17
	// Bit mask of GATHER_RESIDUAL_WRITES field.
	DCP_CTRL_CLR_GATHER_RESIDUAL_WRITES_Msk = 0x800000
	// Bit GATHER_RESIDUAL_WRITES.
	DCP_CTRL_CLR_GATHER_RESIDUAL_WRITES = 0x800000
	// Position of PRESENT_SHA field.
	DCP_CTRL_CLR_PRESENT_SHA_Pos = 0x1c
	// Bit mask of PRESENT_SHA field.
	DCP_CTRL_CLR_PRESENT_SHA_Msk = 0x10000000
	// Bit PRESENT_SHA.
	DCP_CTRL_CLR_PRESENT_SHA = 0x10000000
	// Absent
	DCP_CTRL_CLR_PRESENT_SHA_Absent = 0x0
	// Present
	DCP_CTRL_CLR_PRESENT_SHA_Present = 0x1
	// Position of PRESENT_CRYPTO field.
	DCP_CTRL_CLR_PRESENT_CRYPTO_Pos = 0x1d
	// Bit mask of PRESENT_CRYPTO field.
	DCP_CTRL_CLR_PRESENT_CRYPTO_Msk = 0x20000000
	// Bit PRESENT_CRYPTO.
	DCP_CTRL_CLR_PRESENT_CRYPTO = 0x20000000
	// Absent
	DCP_CTRL_CLR_PRESENT_CRYPTO_Absent = 0x0
	// Present
	DCP_CTRL_CLR_PRESENT_CRYPTO_Present = 0x1
	// Position of CLKGATE field.
	DCP_CTRL_CLR_CLKGATE_Pos = 0x1e
	// Bit mask of CLKGATE field.
	DCP_CTRL_CLR_CLKGATE_Msk = 0x40000000
	// Bit CLKGATE.
	DCP_CTRL_CLR_CLKGATE = 0x40000000
	// Position of SFTRST field.
	DCP_CTRL_CLR_SFTRST_Pos = 0x1f
	// Bit mask of SFTRST field.
	DCP_CTRL_CLR_SFTRST_Msk = 0x80000000
	// Bit SFTRST.
	DCP_CTRL_CLR_SFTRST = 0x80000000

	// CTRL_TOG: DCP control register 0
	// Position of CHANNEL_INTERRUPT_ENABLE field.
	DCP_CTRL_TOG_CHANNEL_INTERRUPT_ENABLE_Pos = 0x0
	// Bit mask of CHANNEL_INTERRUPT_ENABLE field.
	DCP_CTRL_TOG_CHANNEL_INTERRUPT_ENABLE_Msk = 0xff
	// CH0
	DCP_CTRL_TOG_CHANNEL_INTERRUPT_ENABLE_CH0 = 0x1
	// CH1
	DCP_CTRL_TOG_CHANNEL_INTERRUPT_ENABLE_CH1 = 0x2
	// CH2
	DCP_CTRL_TOG_CHANNEL_INTERRUPT_ENABLE_CH2 = 0x4
	// CH3
	DCP_CTRL_TOG_CHANNEL_INTERRUPT_ENABLE_CH3 = 0x8
	// Position of ENABLE_CONTEXT_SWITCHING field.
	DCP_CTRL_TOG_ENABLE_CONTEXT_SWITCHING_Pos = 0x15
	// Bit mask of ENABLE_CONTEXT_SWITCHING field.
	DCP_CTRL_TOG_ENABLE_CONTEXT_SWITCHING_Msk = 0x200000
	// Bit ENABLE_CONTEXT_SWITCHING.
	DCP_CTRL_TOG_ENABLE_CONTEXT_SWITCHING = 0x200000
	// Position of ENABLE_CONTEXT_CACHING field.
	DCP_CTRL_TOG_ENABLE_CONTEXT_CACHING_Pos = 0x16
	// Bit mask of ENABLE_CONTEXT_CACHING field.
	DCP_CTRL_TOG_ENABLE_CONTEXT_CACHING_Msk = 0x400000
	// Bit ENABLE_CONTEXT_CACHING.
	DCP_CTRL_TOG_ENABLE_CONTEXT_CACHING = 0x400000
	// Position of GATHER_RESIDUAL_WRITES field.
	DCP_CTRL_TOG_GATHER_RESIDUAL_WRITES_Pos = 0x17
	// Bit mask of GATHER_RESIDUAL_WRITES field.
	DCP_CTRL_TOG_GATHER_RESIDUAL_WRITES_Msk = 0x800000
	// Bit GATHER_RESIDUAL_WRITES.
	DCP_CTRL_TOG_GATHER_RESIDUAL_WRITES = 0x800000
	// Position of PRESENT_SHA field.
	DCP_CTRL_TOG_PRESENT_SHA_Pos = 0x1c
	// Bit mask of PRESENT_SHA field.
	DCP_CTRL_TOG_PRESENT_SHA_Msk = 0x10000000
	// Bit PRESENT_SHA.
	DCP_CTRL_TOG_PRESENT_SHA = 0x10000000
	// Absent
	DCP_CTRL_TOG_PRESENT_SHA_Absent = 0x0
	// Present
	DCP_CTRL_TOG_PRESENT_SHA_Present = 0x1
	// Position of PRESENT_CRYPTO field.
	DCP_CTRL_TOG_PRESENT_CRYPTO_Pos = 0x1d
	// Bit mask of PRESENT_CRYPTO field.
	DCP_CTRL_TOG_PRESENT_CRYPTO_Msk = 0x20000000
	// Bit PRESENT_CRYPTO.
	DCP_CTRL_TOG_PRESENT_CRYPTO = 0x20000000
	// Absent
	DCP_CTRL_TOG_PRESENT_CRYPTO_Absent = 0x0
	// Present
	DCP_CTRL_TOG_PRESENT_CRYPTO_Present = 0x1
	// Position of CLKGATE field.
	DCP_CTRL_TOG_CLKGATE_Pos = 0x1e
	// Bit mask of CLKGATE field.
	DCP_CTRL_TOG_CLKGATE_Msk = 0x40000000
	// Bit CLKGATE.
	DCP_CTRL_TOG_CLKGATE = 0x40000000
	// Position of SFTRST field.
	DCP_CTRL_TOG_SFTRST_Pos = 0x1f
	// Bit mask of SFTRST field.
	DCP_CTRL_TOG_SFTRST_Msk = 0x80000000
	// Bit SFTRST.
	DCP_CTRL_TOG_SFTRST = 0x80000000

	// STAT: DCP status register
	// Position of IRQ field.
	DCP_STAT_IRQ_Pos = 0x0
	// Bit mask of IRQ field.
	DCP_STAT_IRQ_Msk = 0xf
	// Position of READY_CHANNELS field.
	DCP_STAT_READY_CHANNELS_Pos = 0x10
	// Bit mask of READY_CHANNELS field.
	DCP_STAT_READY_CHANNELS_Msk = 0xff0000
	// CH0
	DCP_STAT_READY_CHANNELS_CH0 = 0x1
	// CH1
	DCP_STAT_READY_CHANNELS_CH1 = 0x2
	// CH2
	DCP_STAT_READY_CHANNELS_CH2 = 0x4
	// CH3
	DCP_STAT_READY_CHANNELS_CH3 = 0x8
	// Position of CUR_CHANNEL field.
	DCP_STAT_CUR_CHANNEL_Pos = 0x18
	// Bit mask of CUR_CHANNEL field.
	DCP_STAT_CUR_CHANNEL_Msk = 0xf000000
	// None
	DCP_STAT_CUR_CHANNEL_None = 0x0
	// CH0
	DCP_STAT_CUR_CHANNEL_CH0 = 0x1
	// CH1
	DCP_STAT_CUR_CHANNEL_CH1 = 0x2
	// CH2
	DCP_STAT_CUR_CHANNEL_CH2 = 0x3
	// CH3
	DCP_STAT_CUR_CHANNEL_CH3 = 0x4
	// Position of OTP_KEY_READY field.
	DCP_STAT_OTP_KEY_READY_Pos = 0x1c
	// Bit mask of OTP_KEY_READY field.
	DCP_STAT_OTP_KEY_READY_Msk = 0x10000000
	// Bit OTP_KEY_READY.
	DCP_STAT_OTP_KEY_READY = 0x10000000

	// STAT_SET: DCP status register
	// Position of IRQ field.
	DCP_STAT_SET_IRQ_Pos = 0x0
	// Bit mask of IRQ field.
	DCP_STAT_SET_IRQ_Msk = 0xf
	// Position of READY_CHANNELS field.
	DCP_STAT_SET_READY_CHANNELS_Pos = 0x10
	// Bit mask of READY_CHANNELS field.
	DCP_STAT_SET_READY_CHANNELS_Msk = 0xff0000
	// CH0
	DCP_STAT_SET_READY_CHANNELS_CH0 = 0x1
	// CH1
	DCP_STAT_SET_READY_CHANNELS_CH1 = 0x2
	// CH2
	DCP_STAT_SET_READY_CHANNELS_CH2 = 0x4
	// CH3
	DCP_STAT_SET_READY_CHANNELS_CH3 = 0x8
	// Position of CUR_CHANNEL field.
	DCP_STAT_SET_CUR_CHANNEL_Pos = 0x18
	// Bit mask of CUR_CHANNEL field.
	DCP_STAT_SET_CUR_CHANNEL_Msk = 0xf000000
	// None
	DCP_STAT_SET_CUR_CHANNEL_None = 0x0
	// CH0
	DCP_STAT_SET_CUR_CHANNEL_CH0 = 0x1
	// CH1
	DCP_STAT_SET_CUR_CHANNEL_CH1 = 0x2
	// CH2
	DCP_STAT_SET_CUR_CHANNEL_CH2 = 0x3
	// CH3
	DCP_STAT_SET_CUR_CHANNEL_CH3 = 0x4
	// Position of OTP_KEY_READY field.
	DCP_STAT_SET_OTP_KEY_READY_Pos = 0x1c
	// Bit mask of OTP_KEY_READY field.
	DCP_STAT_SET_OTP_KEY_READY_Msk = 0x10000000
	// Bit OTP_KEY_READY.
	DCP_STAT_SET_OTP_KEY_READY = 0x10000000

	// STAT_CLR: DCP status register
	// Position of IRQ field.
	DCP_STAT_CLR_IRQ_Pos = 0x0
	// Bit mask of IRQ field.
	DCP_STAT_CLR_IRQ_Msk = 0xf
	// Position of READY_CHANNELS field.
	DCP_STAT_CLR_READY_CHANNELS_Pos = 0x10
	// Bit mask of READY_CHANNELS field.
	DCP_STAT_CLR_READY_CHANNELS_Msk = 0xff0000
	// CH0
	DCP_STAT_CLR_READY_CHANNELS_CH0 = 0x1
	// CH1
	DCP_STAT_CLR_READY_CHANNELS_CH1 = 0x2
	// CH2
	DCP_STAT_CLR_READY_CHANNELS_CH2 = 0x4
	// CH3
	DCP_STAT_CLR_READY_CHANNELS_CH3 = 0x8
	// Position of CUR_CHANNEL field.
	DCP_STAT_CLR_CUR_CHANNEL_Pos = 0x18
	// Bit mask of CUR_CHANNEL field.
	DCP_STAT_CLR_CUR_CHANNEL_Msk = 0xf000000
	// None
	DCP_STAT_CLR_CUR_CHANNEL_None = 0x0
	// CH0
	DCP_STAT_CLR_CUR_CHANNEL_CH0 = 0x1
	// CH1
	DCP_STAT_CLR_CUR_CHANNEL_CH1 = 0x2
	// CH2
	DCP_STAT_CLR_CUR_CHANNEL_CH2 = 0x3
	// CH3
	DCP_STAT_CLR_CUR_CHANNEL_CH3 = 0x4
	// Position of OTP_KEY_READY field.
	DCP_STAT_CLR_OTP_KEY_READY_Pos = 0x1c
	// Bit mask of OTP_KEY_READY field.
	DCP_STAT_CLR_OTP_KEY_READY_Msk = 0x10000000
	// Bit OTP_KEY_READY.
	DCP_STAT_CLR_OTP_KEY_READY = 0x10000000

	// STAT_TOG: DCP status register
	// Position of IRQ field.
	DCP_STAT_TOG_IRQ_Pos = 0x0
	// Bit mask of IRQ field.
	DCP_STAT_TOG_IRQ_Msk = 0xf
	// Position of READY_CHANNELS field.
	DCP_STAT_TOG_READY_CHANNELS_Pos = 0x10
	// Bit mask of READY_CHANNELS field.
	DCP_STAT_TOG_READY_CHANNELS_Msk = 0xff0000
	// CH0
	DCP_STAT_TOG_READY_CHANNELS_CH0 = 0x1
	// CH1
	DCP_STAT_TOG_READY_CHANNELS_CH1 = 0x2
	// CH2
	DCP_STAT_TOG_READY_CHANNELS_CH2 = 0x4
	// CH3
	DCP_STAT_TOG_READY_CHANNELS_CH3 = 0x8
	// Position of CUR_CHANNEL field.
	DCP_STAT_TOG_CUR_CHANNEL_Pos = 0x18
	// Bit mask of CUR_CHANNEL field.
	DCP_STAT_TOG_CUR_CHANNEL_Msk = 0xf000000
	// None
	DCP_STAT_TOG_CUR_CHANNEL_None = 0x0
	// CH0
	DCP_STAT_TOG_CUR_CHANNEL_CH0 = 0x1
	// CH1
	DCP_STAT_TOG_CUR_CHANNEL_CH1 = 0x2
	// CH2
	DCP_STAT_TOG_CUR_CHANNEL_CH2 = 0x3
	// CH3
	DCP_STAT_TOG_CUR_CHANNEL_CH3 = 0x4
	// Position of OTP_KEY_READY field.
	DCP_STAT_TOG_OTP_KEY_READY_Pos = 0x1c
	// Bit mask of OTP_KEY_READY field.
	DCP_STAT_TOG_OTP_KEY_READY_Msk = 0x10000000
	// Bit OTP_KEY_READY.
	DCP_STAT_TOG_OTP_KEY_READY = 0x10000000

	// CHANNELCTRL: DCP channel control register
	// Position of ENABLE_CHANNEL field.
	DCP_CHANNELCTRL_ENABLE_CHANNEL_Pos = 0x0
	// Bit mask of ENABLE_CHANNEL field.
	DCP_CHANNELCTRL_ENABLE_CHANNEL_Msk = 0xff
	// CH0
	DCP_CHANNELCTRL_ENABLE_CHANNEL_CH0 = 0x1
	// CH1
	DCP_CHANNELCTRL_ENABLE_CHANNEL_CH1 = 0x2
	// CH2
	DCP_CHANNELCTRL_ENABLE_CHANNEL_CH2 = 0x4
	// CH3
	DCP_CHANNELCTRL_ENABLE_CHANNEL_CH3 = 0x8
	// Position of HIGH_PRIORITY_CHANNEL field.
	DCP_CHANNELCTRL_HIGH_PRIORITY_CHANNEL_Pos = 0x8
	// Bit mask of HIGH_PRIORITY_CHANNEL field.
	DCP_CHANNELCTRL_HIGH_PRIORITY_CHANNEL_Msk = 0xff00
	// CH0
	DCP_CHANNELCTRL_HIGH_PRIORITY_CHANNEL_CH0 = 0x1
	// CH1
	DCP_CHANNELCTRL_HIGH_PRIORITY_CHANNEL_CH1 = 0x2
	// CH2
	DCP_CHANNELCTRL_HIGH_PRIORITY_CHANNEL_CH2 = 0x4
	// CH3
	DCP_CHANNELCTRL_HIGH_PRIORITY_CHANNEL_CH3 = 0x8
	// Position of CH0_IRQ_MERGED field.
	DCP_CHANNELCTRL_CH0_IRQ_MERGED_Pos = 0x10
	// Bit mask of CH0_IRQ_MERGED field.
	DCP_CHANNELCTRL_CH0_IRQ_MERGED_Msk = 0x10000
	// Bit CH0_IRQ_MERGED.
	DCP_CHANNELCTRL_CH0_IRQ_MERGED = 0x10000

	// CHANNELCTRL_SET: DCP channel control register
	// Position of ENABLE_CHANNEL field.
	DCP_CHANNELCTRL_SET_ENABLE_CHANNEL_Pos = 0x0
	// Bit mask of ENABLE_CHANNEL field.
	DCP_CHANNELCTRL_SET_ENABLE_CHANNEL_Msk = 0xff
	// CH0
	DCP_CHANNELCTRL_SET_ENABLE_CHANNEL_CH0 = 0x1
	// CH1
	DCP_CHANNELCTRL_SET_ENABLE_CHANNEL_CH1 = 0x2
	// CH2
	DCP_CHANNELCTRL_SET_ENABLE_CHANNEL_CH2 = 0x4
	// CH3
	DCP_CHANNELCTRL_SET_ENABLE_CHANNEL_CH3 = 0x8
	// Position of HIGH_PRIORITY_CHANNEL field.
	DCP_CHANNELCTRL_SET_HIGH_PRIORITY_CHANNEL_Pos = 0x8
	// Bit mask of HIGH_PRIORITY_CHANNEL field.
	DCP_CHANNELCTRL_SET_HIGH_PRIORITY_CHANNEL_Msk = 0xff00
	// CH0
	DCP_CHANNELCTRL_SET_HIGH_PRIORITY_CHANNEL_CH0 = 0x1
	// CH1
	DCP_CHANNELCTRL_SET_HIGH_PRIORITY_CHANNEL_CH1 = 0x2
	// CH2
	DCP_CHANNELCTRL_SET_HIGH_PRIORITY_CHANNEL_CH2 = 0x4
	// CH3
	DCP_CHANNELCTRL_SET_HIGH_PRIORITY_CHANNEL_CH3 = 0x8
	// Position of CH0_IRQ_MERGED field.
	DCP_CHANNELCTRL_SET_CH0_IRQ_MERGED_Pos = 0x10
	// Bit mask of CH0_IRQ_MERGED field.
	DCP_CHANNELCTRL_SET_CH0_IRQ_MERGED_Msk = 0x10000
	// Bit CH0_IRQ_MERGED.
	DCP_CHANNELCTRL_SET_CH0_IRQ_MERGED = 0x10000

	// CHANNELCTRL_CLR: DCP channel control register
	// Position of ENABLE_CHANNEL field.
	DCP_CHANNELCTRL_CLR_ENABLE_CHANNEL_Pos = 0x0
	// Bit mask of ENABLE_CHANNEL field.
	DCP_CHANNELCTRL_CLR_ENABLE_CHANNEL_Msk = 0xff
	// CH0
	DCP_CHANNELCTRL_CLR_ENABLE_CHANNEL_CH0 = 0x1
	// CH1
	DCP_CHANNELCTRL_CLR_ENABLE_CHANNEL_CH1 = 0x2
	// CH2
	DCP_CHANNELCTRL_CLR_ENABLE_CHANNEL_CH2 = 0x4
	// CH3
	DCP_CHANNELCTRL_CLR_ENABLE_CHANNEL_CH3 = 0x8
	// Position of HIGH_PRIORITY_CHANNEL field.
	DCP_CHANNELCTRL_CLR_HIGH_PRIORITY_CHANNEL_Pos = 0x8
	// Bit mask of HIGH_PRIORITY_CHANNEL field.
	DCP_CHANNELCTRL_CLR_HIGH_PRIORITY_CHANNEL_Msk = 0xff00
	// CH0
	DCP_CHANNELCTRL_CLR_HIGH_PRIORITY_CHANNEL_CH0 = 0x1
	// CH1
	DCP_CHANNELCTRL_CLR_HIGH_PRIORITY_CHANNEL_CH1 = 0x2
	// CH2
	DCP_CHANNELCTRL_CLR_HIGH_PRIORITY_CHANNEL_CH2 = 0x4
	// CH3
	DCP_CHANNELCTRL_CLR_HIGH_PRIORITY_CHANNEL_CH3 = 0x8
	// Position of CH0_IRQ_MERGED field.
	DCP_CHANNELCTRL_CLR_CH0_IRQ_MERGED_Pos = 0x10
	// Bit mask of CH0_IRQ_MERGED field.
	DCP_CHANNELCTRL_CLR_CH0_IRQ_MERGED_Msk = 0x10000
	// Bit CH0_IRQ_MERGED.
	DCP_CHANNELCTRL_CLR_CH0_IRQ_MERGED = 0x10000

	// CHANNELCTRL_TOG: DCP channel control register
	// Position of ENABLE_CHANNEL field.
	DCP_CHANNELCTRL_TOG_ENABLE_CHANNEL_Pos = 0x0
	// Bit mask of ENABLE_CHANNEL field.
	DCP_CHANNELCTRL_TOG_ENABLE_CHANNEL_Msk = 0xff
	// CH0
	DCP_CHANNELCTRL_TOG_ENABLE_CHANNEL_CH0 = 0x1
	// CH1
	DCP_CHANNELCTRL_TOG_ENABLE_CHANNEL_CH1 = 0x2
	// CH2
	DCP_CHANNELCTRL_TOG_ENABLE_CHANNEL_CH2 = 0x4
	// CH3
	DCP_CHANNELCTRL_TOG_ENABLE_CHANNEL_CH3 = 0x8
	// Position of HIGH_PRIORITY_CHANNEL field.
	DCP_CHANNELCTRL_TOG_HIGH_PRIORITY_CHANNEL_Pos = 0x8
	// Bit mask of HIGH_PRIORITY_CHANNEL field.
	DCP_CHANNELCTRL_TOG_HIGH_PRIORITY_CHANNEL_Msk = 0xff00
	// CH0
	DCP_CHANNELCTRL_TOG_HIGH_PRIORITY_CHANNEL_CH0 = 0x1
	// CH1
	DCP_CHANNELCTRL_TOG_HIGH_PRIORITY_CHANNEL_CH1 = 0x2
	// CH2
	DCP_CHANNELCTRL_TOG_HIGH_PRIORITY_CHANNEL_CH2 = 0x4
	// CH3
	DCP_CHANNELCTRL_TOG_HIGH_PRIORITY_CHANNEL_CH3 = 0x8
	// Position of CH0_IRQ_MERGED field.
	DCP_CHANNELCTRL_TOG_CH0_IRQ_MERGED_Pos = 0x10
	// Bit mask of CH0_IRQ_MERGED field.
	DCP_CHANNELCTRL_TOG_CH0_IRQ_MERGED_Msk = 0x10000
	// Bit CH0_IRQ_MERGED.
	DCP_CHANNELCTRL_TOG_CH0_IRQ_MERGED = 0x10000

	// CAPABILITY0: DCP capability 0 register
	// Position of NUM_KEYS field.
	DCP_CAPABILITY0_NUM_KEYS_Pos = 0x0
	// Bit mask of NUM_KEYS field.
	DCP_CAPABILITY0_NUM_KEYS_Msk = 0xff
	// Position of NUM_CHANNELS field.
	DCP_CAPABILITY0_NUM_CHANNELS_Pos = 0x8
	// Bit mask of NUM_CHANNELS field.
	DCP_CAPABILITY0_NUM_CHANNELS_Msk = 0xf00
	// Position of DISABLE_UNIQUE_KEY field.
	DCP_CAPABILITY0_DISABLE_UNIQUE_KEY_Pos = 0x1d
	// Bit mask of DISABLE_UNIQUE_KEY field.
	DCP_CAPABILITY0_DISABLE_UNIQUE_KEY_Msk = 0x20000000
	// Bit DISABLE_UNIQUE_KEY.
	DCP_CAPABILITY0_DISABLE_UNIQUE_KEY = 0x20000000
	// Position of DISABLE_DECRYPT field.
	DCP_CAPABILITY0_DISABLE_DECRYPT_Pos = 0x1f
	// Bit mask of DISABLE_DECRYPT field.
	DCP_CAPABILITY0_DISABLE_DECRYPT_Msk = 0x80000000
	// Bit DISABLE_DECRYPT.
	DCP_CAPABILITY0_DISABLE_DECRYPT = 0x80000000

	// CAPABILITY1: DCP capability 1 register
	// Position of CIPHER_ALGORITHMS field.
	DCP_CAPABILITY1_CIPHER_ALGORITHMS_Pos = 0x0
	// Bit mask of CIPHER_ALGORITHMS field.
	DCP_CAPABILITY1_CIPHER_ALGORITHMS_Msk = 0xffff
	// AES128
	DCP_CAPABILITY1_CIPHER_ALGORITHMS_AES128 = 0x1
	// Position of HASH_ALGORITHMS field.
	DCP_CAPABILITY1_HASH_ALGORITHMS_Pos = 0x10
	// Bit mask of HASH_ALGORITHMS field.
	DCP_CAPABILITY1_HASH_ALGORITHMS_Msk = 0xffff0000
	// SHA1
	DCP_CAPABILITY1_HASH_ALGORITHMS_SHA1 = 0x1
	// CRC32
	DCP_CAPABILITY1_HASH_ALGORITHMS_CRC32 = 0x2
	// SHA256
	DCP_CAPABILITY1_HASH_ALGORITHMS_SHA256 = 0x4

	// CONTEXT: DCP context buffer pointer
	// Position of ADDR field.
	DCP_CONTEXT_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	DCP_CONTEXT_ADDR_Msk = 0xffffffff

	// KEY: DCP key index
	// Position of SUBWORD field.
	DCP_KEY_SUBWORD_Pos = 0x0
	// Bit mask of SUBWORD field.
	DCP_KEY_SUBWORD_Msk = 0x3
	// Position of INDEX field.
	DCP_KEY_INDEX_Pos = 0x4
	// Bit mask of INDEX field.
	DCP_KEY_INDEX_Msk = 0x30

	// KEYDATA: DCP key data
	// Position of DATA field.
	DCP_KEYDATA_DATA_Pos = 0x0
	// Bit mask of DATA field.
	DCP_KEYDATA_DATA_Msk = 0xffffffff

	// PACKET0: DCP work packet 0 status register
	// Position of ADDR field.
	DCP_PACKET0_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	DCP_PACKET0_ADDR_Msk = 0xffffffff

	// PACKET1: DCP work packet 1 status register
	// Position of INTERRUPT field.
	DCP_PACKET1_INTERRUPT_Pos = 0x0
	// Bit mask of INTERRUPT field.
	DCP_PACKET1_INTERRUPT_Msk = 0x1
	// Bit INTERRUPT.
	DCP_PACKET1_INTERRUPT = 0x1
	// Position of DECR_SEMAPHORE field.
	DCP_PACKET1_DECR_SEMAPHORE_Pos = 0x1
	// Bit mask of DECR_SEMAPHORE field.
	DCP_PACKET1_DECR_SEMAPHORE_Msk = 0x2
	// Bit DECR_SEMAPHORE.
	DCP_PACKET1_DECR_SEMAPHORE = 0x2
	// Position of CHAIN field.
	DCP_PACKET1_CHAIN_Pos = 0x2
	// Bit mask of CHAIN field.
	DCP_PACKET1_CHAIN_Msk = 0x4
	// Bit CHAIN.
	DCP_PACKET1_CHAIN = 0x4
	// Position of CHAIN_CONTIGUOUS field.
	DCP_PACKET1_CHAIN_CONTIGUOUS_Pos = 0x3
	// Bit mask of CHAIN_CONTIGUOUS field.
	DCP_PACKET1_CHAIN_CONTIGUOUS_Msk = 0x8
	// Bit CHAIN_CONTIGUOUS.
	DCP_PACKET1_CHAIN_CONTIGUOUS = 0x8
	// Position of ENABLE_MEMCOPY field.
	DCP_PACKET1_ENABLE_MEMCOPY_Pos = 0x4
	// Bit mask of ENABLE_MEMCOPY field.
	DCP_PACKET1_ENABLE_MEMCOPY_Msk = 0x10
	// Bit ENABLE_MEMCOPY.
	DCP_PACKET1_ENABLE_MEMCOPY = 0x10
	// Position of ENABLE_CIPHER field.
	DCP_PACKET1_ENABLE_CIPHER_Pos = 0x5
	// Bit mask of ENABLE_CIPHER field.
	DCP_PACKET1_ENABLE_CIPHER_Msk = 0x20
	// Bit ENABLE_CIPHER.
	DCP_PACKET1_ENABLE_CIPHER = 0x20
	// Position of ENABLE_HASH field.
	DCP_PACKET1_ENABLE_HASH_Pos = 0x6
	// Bit mask of ENABLE_HASH field.
	DCP_PACKET1_ENABLE_HASH_Msk = 0x40
	// Bit ENABLE_HASH.
	DCP_PACKET1_ENABLE_HASH = 0x40
	// Position of ENABLE_BLIT field.
	DCP_PACKET1_ENABLE_BLIT_Pos = 0x7
	// Bit mask of ENABLE_BLIT field.
	DCP_PACKET1_ENABLE_BLIT_Msk = 0x80
	// Bit ENABLE_BLIT.
	DCP_PACKET1_ENABLE_BLIT = 0x80
	// Position of CIPHER_ENCRYPT field.
	DCP_PACKET1_CIPHER_ENCRYPT_Pos = 0x8
	// Bit mask of CIPHER_ENCRYPT field.
	DCP_PACKET1_CIPHER_ENCRYPT_Msk = 0x100
	// Bit CIPHER_ENCRYPT.
	DCP_PACKET1_CIPHER_ENCRYPT = 0x100
	// DECRYPT
	DCP_PACKET1_CIPHER_ENCRYPT_DECRYPT = 0x0
	// ENCRYPT
	DCP_PACKET1_CIPHER_ENCRYPT_ENCRYPT = 0x1
	// Position of CIPHER_INIT field.
	DCP_PACKET1_CIPHER_INIT_Pos = 0x9
	// Bit mask of CIPHER_INIT field.
	DCP_PACKET1_CIPHER_INIT_Msk = 0x200
	// Bit CIPHER_INIT.
	DCP_PACKET1_CIPHER_INIT = 0x200
	// Position of OTP_KEY field.
	DCP_PACKET1_OTP_KEY_Pos = 0xa
	// Bit mask of OTP_KEY field.
	DCP_PACKET1_OTP_KEY_Msk = 0x400
	// Bit OTP_KEY.
	DCP_PACKET1_OTP_KEY = 0x400
	// Position of PAYLOAD_KEY field.
	DCP_PACKET1_PAYLOAD_KEY_Pos = 0xb
	// Bit mask of PAYLOAD_KEY field.
	DCP_PACKET1_PAYLOAD_KEY_Msk = 0x800
	// Bit PAYLOAD_KEY.
	DCP_PACKET1_PAYLOAD_KEY = 0x800
	// Position of HASH_INIT field.
	DCP_PACKET1_HASH_INIT_Pos = 0xc
	// Bit mask of HASH_INIT field.
	DCP_PACKET1_HASH_INIT_Msk = 0x1000
	// Bit HASH_INIT.
	DCP_PACKET1_HASH_INIT = 0x1000
	// Position of HASH_TERM field.
	DCP_PACKET1_HASH_TERM_Pos = 0xd
	// Bit mask of HASH_TERM field.
	DCP_PACKET1_HASH_TERM_Msk = 0x2000
	// Bit HASH_TERM.
	DCP_PACKET1_HASH_TERM = 0x2000
	// Position of CHECK_HASH field.
	DCP_PACKET1_CHECK_HASH_Pos = 0xe
	// Bit mask of CHECK_HASH field.
	DCP_PACKET1_CHECK_HASH_Msk = 0x4000
	// Bit CHECK_HASH.
	DCP_PACKET1_CHECK_HASH = 0x4000
	// Position of HASH_OUTPUT field.
	DCP_PACKET1_HASH_OUTPUT_Pos = 0xf
	// Bit mask of HASH_OUTPUT field.
	DCP_PACKET1_HASH_OUTPUT_Msk = 0x8000
	// Bit HASH_OUTPUT.
	DCP_PACKET1_HASH_OUTPUT = 0x8000
	// INPUT
	DCP_PACKET1_HASH_OUTPUT_INPUT = 0x0
	// OUTPUT
	DCP_PACKET1_HASH_OUTPUT_OUTPUT = 0x1
	// Position of CONSTANT_FILL field.
	DCP_PACKET1_CONSTANT_FILL_Pos = 0x10
	// Bit mask of CONSTANT_FILL field.
	DCP_PACKET1_CONSTANT_FILL_Msk = 0x10000
	// Bit CONSTANT_FILL.
	DCP_PACKET1_CONSTANT_FILL = 0x10000
	// Position of TEST_SEMA_IRQ field.
	DCP_PACKET1_TEST_SEMA_IRQ_Pos = 0x11
	// Bit mask of TEST_SEMA_IRQ field.
	DCP_PACKET1_TEST_SEMA_IRQ_Msk = 0x20000
	// Bit TEST_SEMA_IRQ.
	DCP_PACKET1_TEST_SEMA_IRQ = 0x20000
	// Position of KEY_BYTESWAP field.
	DCP_PACKET1_KEY_BYTESWAP_Pos = 0x12
	// Bit mask of KEY_BYTESWAP field.
	DCP_PACKET1_KEY_BYTESWAP_Msk = 0x40000
	// Bit KEY_BYTESWAP.
	DCP_PACKET1_KEY_BYTESWAP = 0x40000
	// Position of KEY_WORDSWAP field.
	DCP_PACKET1_KEY_WORDSWAP_Pos = 0x13
	// Bit mask of KEY_WORDSWAP field.
	DCP_PACKET1_KEY_WORDSWAP_Msk = 0x80000
	// Bit KEY_WORDSWAP.
	DCP_PACKET1_KEY_WORDSWAP = 0x80000
	// Position of INPUT_BYTESWAP field.
	DCP_PACKET1_INPUT_BYTESWAP_Pos = 0x14
	// Bit mask of INPUT_BYTESWAP field.
	DCP_PACKET1_INPUT_BYTESWAP_Msk = 0x100000
	// Bit INPUT_BYTESWAP.
	DCP_PACKET1_INPUT_BYTESWAP = 0x100000
	// Position of INPUT_WORDSWAP field.
	DCP_PACKET1_INPUT_WORDSWAP_Pos = 0x15
	// Bit mask of INPUT_WORDSWAP field.
	DCP_PACKET1_INPUT_WORDSWAP_Msk = 0x200000
	// Bit INPUT_WORDSWAP.
	DCP_PACKET1_INPUT_WORDSWAP = 0x200000
	// Position of OUTPUT_BYTESWAP field.
	DCP_PACKET1_OUTPUT_BYTESWAP_Pos = 0x16
	// Bit mask of OUTPUT_BYTESWAP field.
	DCP_PACKET1_OUTPUT_BYTESWAP_Msk = 0x400000
	// Bit OUTPUT_BYTESWAP.
	DCP_PACKET1_OUTPUT_BYTESWAP = 0x400000
	// Position of OUTPUT_WORDSWAP field.
	DCP_PACKET1_OUTPUT_WORDSWAP_Pos = 0x17
	// Bit mask of OUTPUT_WORDSWAP field.
	DCP_PACKET1_OUTPUT_WORDSWAP_Msk = 0x800000
	// Bit OUTPUT_WORDSWAP.
	DCP_PACKET1_OUTPUT_WORDSWAP = 0x800000
	// Position of TAG field.
	DCP_PACKET1_TAG_Pos = 0x18
	// Bit mask of TAG field.
	DCP_PACKET1_TAG_Msk = 0xff000000

	// PACKET2: DCP work packet 2 status register
	// Position of CIPHER_SELECT field.
	DCP_PACKET2_CIPHER_SELECT_Pos = 0x0
	// Bit mask of CIPHER_SELECT field.
	DCP_PACKET2_CIPHER_SELECT_Msk = 0xf
	// AES128
	DCP_PACKET2_CIPHER_SELECT_AES128 = 0x0
	// Position of CIPHER_MODE field.
	DCP_PACKET2_CIPHER_MODE_Pos = 0x4
	// Bit mask of CIPHER_MODE field.
	DCP_PACKET2_CIPHER_MODE_Msk = 0xf0
	// ECB
	DCP_PACKET2_CIPHER_MODE_ECB = 0x0
	// CBC
	DCP_PACKET2_CIPHER_MODE_CBC = 0x1
	// Position of KEY_SELECT field.
	DCP_PACKET2_KEY_SELECT_Pos = 0x8
	// Bit mask of KEY_SELECT field.
	DCP_PACKET2_KEY_SELECT_Msk = 0xff00
	// KEY0
	DCP_PACKET2_KEY_SELECT_KEY0 = 0x0
	// KEY1
	DCP_PACKET2_KEY_SELECT_KEY1 = 0x1
	// KEY2
	DCP_PACKET2_KEY_SELECT_KEY2 = 0x2
	// KEY3
	DCP_PACKET2_KEY_SELECT_KEY3 = 0x3
	// UNIQUE_KEY
	DCP_PACKET2_KEY_SELECT_UNIQUE_KEY = 0xfe
	// OTP_KEY
	DCP_PACKET2_KEY_SELECT_OTP_KEY = 0xff
	// Position of HASH_SELECT field.
	DCP_PACKET2_HASH_SELECT_Pos = 0x10
	// Bit mask of HASH_SELECT field.
	DCP_PACKET2_HASH_SELECT_Msk = 0xf0000
	// SHA1
	DCP_PACKET2_HASH_SELECT_SHA1 = 0x0
	// CRC32
	DCP_PACKET2_HASH_SELECT_CRC32 = 0x1
	// SHA256
	DCP_PACKET2_HASH_SELECT_SHA256 = 0x2
	// Position of CIPHER_CFG field.
	DCP_PACKET2_CIPHER_CFG_Pos = 0x18
	// Bit mask of CIPHER_CFG field.
	DCP_PACKET2_CIPHER_CFG_Msk = 0xff000000

	// PACKET3: DCP work packet 3 status register
	// Position of ADDR field.
	DCP_PACKET3_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	DCP_PACKET3_ADDR_Msk = 0xffffffff

	// PACKET4: DCP work packet 4 status register
	// Position of ADDR field.
	DCP_PACKET4_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	DCP_PACKET4_ADDR_Msk = 0xffffffff

	// PACKET5: DCP work packet 5 status register
	// Position of COUNT field.
	DCP_PACKET5_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	DCP_PACKET5_COUNT_Msk = 0xffffffff

	// PACKET6: DCP work packet 6 status register
	// Position of ADDR field.
	DCP_PACKET6_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	DCP_PACKET6_ADDR_Msk = 0xffffffff

	// CH0CMDPTR: DCP channel 0 command pointer address register
	// Position of ADDR field.
	DCP_CH0CMDPTR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	DCP_CH0CMDPTR_ADDR_Msk = 0xffffffff

	// CH0SEMA: DCP channel 0 semaphore register
	// Position of INCREMENT field.
	DCP_CH0SEMA_INCREMENT_Pos = 0x0
	// Bit mask of INCREMENT field.
	DCP_CH0SEMA_INCREMENT_Msk = 0xff
	// Position of VALUE field.
	DCP_CH0SEMA_VALUE_Pos = 0x10
	// Bit mask of VALUE field.
	DCP_CH0SEMA_VALUE_Msk = 0xff0000

	// CH0STAT: DCP channel 0 status register
	// Position of HASH_MISMATCH field.
	DCP_CH0STAT_HASH_MISMATCH_Pos = 0x1
	// Bit mask of HASH_MISMATCH field.
	DCP_CH0STAT_HASH_MISMATCH_Msk = 0x2
	// Bit HASH_MISMATCH.
	DCP_CH0STAT_HASH_MISMATCH = 0x2
	// Position of ERROR_SETUP field.
	DCP_CH0STAT_ERROR_SETUP_Pos = 0x2
	// Bit mask of ERROR_SETUP field.
	DCP_CH0STAT_ERROR_SETUP_Msk = 0x4
	// Bit ERROR_SETUP.
	DCP_CH0STAT_ERROR_SETUP = 0x4
	// Position of ERROR_PACKET field.
	DCP_CH0STAT_ERROR_PACKET_Pos = 0x3
	// Bit mask of ERROR_PACKET field.
	DCP_CH0STAT_ERROR_PACKET_Msk = 0x8
	// Bit ERROR_PACKET.
	DCP_CH0STAT_ERROR_PACKET = 0x8
	// Position of ERROR_SRC field.
	DCP_CH0STAT_ERROR_SRC_Pos = 0x4
	// Bit mask of ERROR_SRC field.
	DCP_CH0STAT_ERROR_SRC_Msk = 0x10
	// Bit ERROR_SRC.
	DCP_CH0STAT_ERROR_SRC = 0x10
	// Position of ERROR_DST field.
	DCP_CH0STAT_ERROR_DST_Pos = 0x5
	// Bit mask of ERROR_DST field.
	DCP_CH0STAT_ERROR_DST_Msk = 0x20
	// Bit ERROR_DST.
	DCP_CH0STAT_ERROR_DST = 0x20
	// Position of ERROR_PAGEFAULT field.
	DCP_CH0STAT_ERROR_PAGEFAULT_Pos = 0x6
	// Bit mask of ERROR_PAGEFAULT field.
	DCP_CH0STAT_ERROR_PAGEFAULT_Msk = 0x40
	// Bit ERROR_PAGEFAULT.
	DCP_CH0STAT_ERROR_PAGEFAULT = 0x40
	// Position of ERROR_CODE field.
	DCP_CH0STAT_ERROR_CODE_Pos = 0x10
	// Bit mask of ERROR_CODE field.
	DCP_CH0STAT_ERROR_CODE_Msk = 0xff0000
	// Error signalled because the next pointer is 0x00000000
	DCP_CH0STAT_ERROR_CODE_NEXT_CHAIN_IS_0 = 0x1
	// Error signalled because the semaphore is non-zero and neither chain bit is set
	DCP_CH0STAT_ERROR_CODE_NO_CHAIN = 0x2
	// Error signalled because an error is reported reading/writing the context buffer
	DCP_CH0STAT_ERROR_CODE_CONTEXT_ERROR = 0x3
	// Error signalled because an error is reported reading/writing the payload
	DCP_CH0STAT_ERROR_CODE_PAYLOAD_ERROR = 0x4
	// Error signalled because the control packet specifies an invalid mode select (for instance, blit + hash)
	DCP_CH0STAT_ERROR_CODE_INVALID_MODE = 0x5
	// Position of TAG field.
	DCP_CH0STAT_TAG_Pos = 0x18
	// Bit mask of TAG field.
	DCP_CH0STAT_TAG_Msk = 0xff000000

	// CH0STAT_SET: DCP channel 0 status register
	// Position of HASH_MISMATCH field.
	DCP_CH0STAT_SET_HASH_MISMATCH_Pos = 0x1
	// Bit mask of HASH_MISMATCH field.
	DCP_CH0STAT_SET_HASH_MISMATCH_Msk = 0x2
	// Bit HASH_MISMATCH.
	DCP_CH0STAT_SET_HASH_MISMATCH = 0x2
	// Position of ERROR_SETUP field.
	DCP_CH0STAT_SET_ERROR_SETUP_Pos = 0x2
	// Bit mask of ERROR_SETUP field.
	DCP_CH0STAT_SET_ERROR_SETUP_Msk = 0x4
	// Bit ERROR_SETUP.
	DCP_CH0STAT_SET_ERROR_SETUP = 0x4
	// Position of ERROR_PACKET field.
	DCP_CH0STAT_SET_ERROR_PACKET_Pos = 0x3
	// Bit mask of ERROR_PACKET field.
	DCP_CH0STAT_SET_ERROR_PACKET_Msk = 0x8
	// Bit ERROR_PACKET.
	DCP_CH0STAT_SET_ERROR_PACKET = 0x8
	// Position of ERROR_SRC field.
	DCP_CH0STAT_SET_ERROR_SRC_Pos = 0x4
	// Bit mask of ERROR_SRC field.
	DCP_CH0STAT_SET_ERROR_SRC_Msk = 0x10
	// Bit ERROR_SRC.
	DCP_CH0STAT_SET_ERROR_SRC = 0x10
	// Position of ERROR_DST field.
	DCP_CH0STAT_SET_ERROR_DST_Pos = 0x5
	// Bit mask of ERROR_DST field.
	DCP_CH0STAT_SET_ERROR_DST_Msk = 0x20
	// Bit ERROR_DST.
	DCP_CH0STAT_SET_ERROR_DST = 0x20
	// Position of ERROR_PAGEFAULT field.
	DCP_CH0STAT_SET_ERROR_PAGEFAULT_Pos = 0x6
	// Bit mask of ERROR_PAGEFAULT field.
	DCP_CH0STAT_SET_ERROR_PAGEFAULT_Msk = 0x40
	// Bit ERROR_PAGEFAULT.
	DCP_CH0STAT_SET_ERROR_PAGEFAULT = 0x40
	// Position of ERROR_CODE field.
	DCP_CH0STAT_SET_ERROR_CODE_Pos = 0x10
	// Bit mask of ERROR_CODE field.
	DCP_CH0STAT_SET_ERROR_CODE_Msk = 0xff0000
	// Error signalled because the next pointer is 0x00000000
	DCP_CH0STAT_SET_ERROR_CODE_NEXT_CHAIN_IS_0 = 0x1
	// Error signalled because the semaphore is non-zero and neither chain bit is set
	DCP_CH0STAT_SET_ERROR_CODE_NO_CHAIN = 0x2
	// Error signalled because an error is reported reading/writing the context buffer
	DCP_CH0STAT_SET_ERROR_CODE_CONTEXT_ERROR = 0x3
	// Error signalled because an error is reported reading/writing the payload
	DCP_CH0STAT_SET_ERROR_CODE_PAYLOAD_ERROR = 0x4
	// Error signalled because the control packet specifies an invalid mode select (for instance, blit + hash)
	DCP_CH0STAT_SET_ERROR_CODE_INVALID_MODE = 0x5
	// Position of TAG field.
	DCP_CH0STAT_SET_TAG_Pos = 0x18
	// Bit mask of TAG field.
	DCP_CH0STAT_SET_TAG_Msk = 0xff000000

	// CH0STAT_CLR: DCP channel 0 status register
	// Position of HASH_MISMATCH field.
	DCP_CH0STAT_CLR_HASH_MISMATCH_Pos = 0x1
	// Bit mask of HASH_MISMATCH field.
	DCP_CH0STAT_CLR_HASH_MISMATCH_Msk = 0x2
	// Bit HASH_MISMATCH.
	DCP_CH0STAT_CLR_HASH_MISMATCH = 0x2
	// Position of ERROR_SETUP field.
	DCP_CH0STAT_CLR_ERROR_SETUP_Pos = 0x2
	// Bit mask of ERROR_SETUP field.
	DCP_CH0STAT_CLR_ERROR_SETUP_Msk = 0x4
	// Bit ERROR_SETUP.
	DCP_CH0STAT_CLR_ERROR_SETUP = 0x4
	// Position of ERROR_PACKET field.
	DCP_CH0STAT_CLR_ERROR_PACKET_Pos = 0x3
	// Bit mask of ERROR_PACKET field.
	DCP_CH0STAT_CLR_ERROR_PACKET_Msk = 0x8
	// Bit ERROR_PACKET.
	DCP_CH0STAT_CLR_ERROR_PACKET = 0x8
	// Position of ERROR_SRC field.
	DCP_CH0STAT_CLR_ERROR_SRC_Pos = 0x4
	// Bit mask of ERROR_SRC field.
	DCP_CH0STAT_CLR_ERROR_SRC_Msk = 0x10
	// Bit ERROR_SRC.
	DCP_CH0STAT_CLR_ERROR_SRC = 0x10
	// Position of ERROR_DST field.
	DCP_CH0STAT_CLR_ERROR_DST_Pos = 0x5
	// Bit mask of ERROR_DST field.
	DCP_CH0STAT_CLR_ERROR_DST_Msk = 0x20
	// Bit ERROR_DST.
	DCP_CH0STAT_CLR_ERROR_DST = 0x20
	// Position of ERROR_PAGEFAULT field.
	DCP_CH0STAT_CLR_ERROR_PAGEFAULT_Pos = 0x6
	// Bit mask of ERROR_PAGEFAULT field.
	DCP_CH0STAT_CLR_ERROR_PAGEFAULT_Msk = 0x40
	// Bit ERROR_PAGEFAULT.
	DCP_CH0STAT_CLR_ERROR_PAGEFAULT = 0x40
	// Position of ERROR_CODE field.
	DCP_CH0STAT_CLR_ERROR_CODE_Pos = 0x10
	// Bit mask of ERROR_CODE field.
	DCP_CH0STAT_CLR_ERROR_CODE_Msk = 0xff0000
	// Error signalled because the next pointer is 0x00000000
	DCP_CH0STAT_CLR_ERROR_CODE_NEXT_CHAIN_IS_0 = 0x1
	// Error signalled because the semaphore is non-zero and neither chain bit is set
	DCP_CH0STAT_CLR_ERROR_CODE_NO_CHAIN = 0x2
	// Error signalled because an error is reported reading/writing the context buffer
	DCP_CH0STAT_CLR_ERROR_CODE_CONTEXT_ERROR = 0x3
	// Error signalled because an error is reported reading/writing the payload
	DCP_CH0STAT_CLR_ERROR_CODE_PAYLOAD_ERROR = 0x4
	// Error signalled because the control packet specifies an invalid mode select (for instance, blit + hash)
	DCP_CH0STAT_CLR_ERROR_CODE_INVALID_MODE = 0x5
	// Position of TAG field.
	DCP_CH0STAT_CLR_TAG_Pos = 0x18
	// Bit mask of TAG field.
	DCP_CH0STAT_CLR_TAG_Msk = 0xff000000

	// CH0STAT_TOG: DCP channel 0 status register
	// Position of HASH_MISMATCH field.
	DCP_CH0STAT_TOG_HASH_MISMATCH_Pos = 0x1
	// Bit mask of HASH_MISMATCH field.
	DCP_CH0STAT_TOG_HASH_MISMATCH_Msk = 0x2
	// Bit HASH_MISMATCH.
	DCP_CH0STAT_TOG_HASH_MISMATCH = 0x2
	// Position of ERROR_SETUP field.
	DCP_CH0STAT_TOG_ERROR_SETUP_Pos = 0x2
	// Bit mask of ERROR_SETUP field.
	DCP_CH0STAT_TOG_ERROR_SETUP_Msk = 0x4
	// Bit ERROR_SETUP.
	DCP_CH0STAT_TOG_ERROR_SETUP = 0x4
	// Position of ERROR_PACKET field.
	DCP_CH0STAT_TOG_ERROR_PACKET_Pos = 0x3
	// Bit mask of ERROR_PACKET field.
	DCP_CH0STAT_TOG_ERROR_PACKET_Msk = 0x8
	// Bit ERROR_PACKET.
	DCP_CH0STAT_TOG_ERROR_PACKET = 0x8
	// Position of ERROR_SRC field.
	DCP_CH0STAT_TOG_ERROR_SRC_Pos = 0x4
	// Bit mask of ERROR_SRC field.
	DCP_CH0STAT_TOG_ERROR_SRC_Msk = 0x10
	// Bit ERROR_SRC.
	DCP_CH0STAT_TOG_ERROR_SRC = 0x10
	// Position of ERROR_DST field.
	DCP_CH0STAT_TOG_ERROR_DST_Pos = 0x5
	// Bit mask of ERROR_DST field.
	DCP_CH0STAT_TOG_ERROR_DST_Msk = 0x20
	// Bit ERROR_DST.
	DCP_CH0STAT_TOG_ERROR_DST = 0x20
	// Position of ERROR_PAGEFAULT field.
	DCP_CH0STAT_TOG_ERROR_PAGEFAULT_Pos = 0x6
	// Bit mask of ERROR_PAGEFAULT field.
	DCP_CH0STAT_TOG_ERROR_PAGEFAULT_Msk = 0x40
	// Bit ERROR_PAGEFAULT.
	DCP_CH0STAT_TOG_ERROR_PAGEFAULT = 0x40
	// Position of ERROR_CODE field.
	DCP_CH0STAT_TOG_ERROR_CODE_Pos = 0x10
	// Bit mask of ERROR_CODE field.
	DCP_CH0STAT_TOG_ERROR_CODE_Msk = 0xff0000
	// Error signalled because the next pointer is 0x00000000
	DCP_CH0STAT_TOG_ERROR_CODE_NEXT_CHAIN_IS_0 = 0x1
	// Error signalled because the semaphore is non-zero and neither chain bit is set
	DCP_CH0STAT_TOG_ERROR_CODE_NO_CHAIN = 0x2
	// Error signalled because an error is reported reading/writing the context buffer
	DCP_CH0STAT_TOG_ERROR_CODE_CONTEXT_ERROR = 0x3
	// Error signalled because an error is reported reading/writing the payload
	DCP_CH0STAT_TOG_ERROR_CODE_PAYLOAD_ERROR = 0x4
	// Error signalled because the control packet specifies an invalid mode select (for instance, blit + hash)
	DCP_CH0STAT_TOG_ERROR_CODE_INVALID_MODE = 0x5
	// Position of TAG field.
	DCP_CH0STAT_TOG_TAG_Pos = 0x18
	// Bit mask of TAG field.
	DCP_CH0STAT_TOG_TAG_Msk = 0xff000000

	// CH0OPTS: DCP channel 0 options register
	// Position of RECOVERY_TIMER field.
	DCP_CH0OPTS_RECOVERY_TIMER_Pos = 0x0
	// Bit mask of RECOVERY_TIMER field.
	DCP_CH0OPTS_RECOVERY_TIMER_Msk = 0xffff

	// CH0OPTS_SET: DCP channel 0 options register
	// Position of RECOVERY_TIMER field.
	DCP_CH0OPTS_SET_RECOVERY_TIMER_Pos = 0x0
	// Bit mask of RECOVERY_TIMER field.
	DCP_CH0OPTS_SET_RECOVERY_TIMER_Msk = 0xffff

	// CH0OPTS_CLR: DCP channel 0 options register
	// Position of RECOVERY_TIMER field.
	DCP_CH0OPTS_CLR_RECOVERY_TIMER_Pos = 0x0
	// Bit mask of RECOVERY_TIMER field.
	DCP_CH0OPTS_CLR_RECOVERY_TIMER_Msk = 0xffff

	// CH0OPTS_TOG: DCP channel 0 options register
	// Position of RECOVERY_TIMER field.
	DCP_CH0OPTS_TOG_RECOVERY_TIMER_Pos = 0x0
	// Bit mask of RECOVERY_TIMER field.
	DCP_CH0OPTS_TOG_RECOVERY_TIMER_Msk = 0xffff

	// CH1CMDPTR: DCP channel 1 command pointer address register
	// Position of ADDR field.
	DCP_CH1CMDPTR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	DCP_CH1CMDPTR_ADDR_Msk = 0xffffffff

	// CH1SEMA: DCP channel 1 semaphore register
	// Position of INCREMENT field.
	DCP_CH1SEMA_INCREMENT_Pos = 0x0
	// Bit mask of INCREMENT field.
	DCP_CH1SEMA_INCREMENT_Msk = 0xff
	// Position of VALUE field.
	DCP_CH1SEMA_VALUE_Pos = 0x10
	// Bit mask of VALUE field.
	DCP_CH1SEMA_VALUE_Msk = 0xff0000

	// CH1STAT: DCP channel 1 status register
	// Position of HASH_MISMATCH field.
	DCP_CH1STAT_HASH_MISMATCH_Pos = 0x1
	// Bit mask of HASH_MISMATCH field.
	DCP_CH1STAT_HASH_MISMATCH_Msk = 0x2
	// Bit HASH_MISMATCH.
	DCP_CH1STAT_HASH_MISMATCH = 0x2
	// Position of ERROR_SETUP field.
	DCP_CH1STAT_ERROR_SETUP_Pos = 0x2
	// Bit mask of ERROR_SETUP field.
	DCP_CH1STAT_ERROR_SETUP_Msk = 0x4
	// Bit ERROR_SETUP.
	DCP_CH1STAT_ERROR_SETUP = 0x4
	// Position of ERROR_PACKET field.
	DCP_CH1STAT_ERROR_PACKET_Pos = 0x3
	// Bit mask of ERROR_PACKET field.
	DCP_CH1STAT_ERROR_PACKET_Msk = 0x8
	// Bit ERROR_PACKET.
	DCP_CH1STAT_ERROR_PACKET = 0x8
	// Position of ERROR_SRC field.
	DCP_CH1STAT_ERROR_SRC_Pos = 0x4
	// Bit mask of ERROR_SRC field.
	DCP_CH1STAT_ERROR_SRC_Msk = 0x10
	// Bit ERROR_SRC.
	DCP_CH1STAT_ERROR_SRC = 0x10
	// Position of ERROR_DST field.
	DCP_CH1STAT_ERROR_DST_Pos = 0x5
	// Bit mask of ERROR_DST field.
	DCP_CH1STAT_ERROR_DST_Msk = 0x20
	// Bit ERROR_DST.
	DCP_CH1STAT_ERROR_DST = 0x20
	// Position of ERROR_PAGEFAULT field.
	DCP_CH1STAT_ERROR_PAGEFAULT_Pos = 0x6
	// Bit mask of ERROR_PAGEFAULT field.
	DCP_CH1STAT_ERROR_PAGEFAULT_Msk = 0x40
	// Bit ERROR_PAGEFAULT.
	DCP_CH1STAT_ERROR_PAGEFAULT = 0x40
	// Position of ERROR_CODE field.
	DCP_CH1STAT_ERROR_CODE_Pos = 0x10
	// Bit mask of ERROR_CODE field.
	DCP_CH1STAT_ERROR_CODE_Msk = 0xff0000
	// Error is signalled because the next pointer is 0x00000000.
	DCP_CH1STAT_ERROR_CODE_NEXT_CHAIN_IS_0 = 0x1
	// Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
	DCP_CH1STAT_ERROR_CODE_NO_CHAIN = 0x2
	// Error is signalled because an error was reported when reading/writing the context buffer.
	DCP_CH1STAT_ERROR_CODE_CONTEXT_ERROR = 0x3
	// Error is signalled because an error was reported when reading/writing the payload.
	DCP_CH1STAT_ERROR_CODE_PAYLOAD_ERROR = 0x4
	// Error is signalled because the control packet specifies an invalid mode select (for example, blit + hash).
	DCP_CH1STAT_ERROR_CODE_INVALID_MODE = 0x5
	// Position of TAG field.
	DCP_CH1STAT_TAG_Pos = 0x18
	// Bit mask of TAG field.
	DCP_CH1STAT_TAG_Msk = 0xff000000

	// CH1STAT_SET: DCP channel 1 status register
	// Position of HASH_MISMATCH field.
	DCP_CH1STAT_SET_HASH_MISMATCH_Pos = 0x1
	// Bit mask of HASH_MISMATCH field.
	DCP_CH1STAT_SET_HASH_MISMATCH_Msk = 0x2
	// Bit HASH_MISMATCH.
	DCP_CH1STAT_SET_HASH_MISMATCH = 0x2
	// Position of ERROR_SETUP field.
	DCP_CH1STAT_SET_ERROR_SETUP_Pos = 0x2
	// Bit mask of ERROR_SETUP field.
	DCP_CH1STAT_SET_ERROR_SETUP_Msk = 0x4
	// Bit ERROR_SETUP.
	DCP_CH1STAT_SET_ERROR_SETUP = 0x4
	// Position of ERROR_PACKET field.
	DCP_CH1STAT_SET_ERROR_PACKET_Pos = 0x3
	// Bit mask of ERROR_PACKET field.
	DCP_CH1STAT_SET_ERROR_PACKET_Msk = 0x8
	// Bit ERROR_PACKET.
	DCP_CH1STAT_SET_ERROR_PACKET = 0x8
	// Position of ERROR_SRC field.
	DCP_CH1STAT_SET_ERROR_SRC_Pos = 0x4
	// Bit mask of ERROR_SRC field.
	DCP_CH1STAT_SET_ERROR_SRC_Msk = 0x10
	// Bit ERROR_SRC.
	DCP_CH1STAT_SET_ERROR_SRC = 0x10
	// Position of ERROR_DST field.
	DCP_CH1STAT_SET_ERROR_DST_Pos = 0x5
	// Bit mask of ERROR_DST field.
	DCP_CH1STAT_SET_ERROR_DST_Msk = 0x20
	// Bit ERROR_DST.
	DCP_CH1STAT_SET_ERROR_DST = 0x20
	// Position of ERROR_PAGEFAULT field.
	DCP_CH1STAT_SET_ERROR_PAGEFAULT_Pos = 0x6
	// Bit mask of ERROR_PAGEFAULT field.
	DCP_CH1STAT_SET_ERROR_PAGEFAULT_Msk = 0x40
	// Bit ERROR_PAGEFAULT.
	DCP_CH1STAT_SET_ERROR_PAGEFAULT = 0x40
	// Position of ERROR_CODE field.
	DCP_CH1STAT_SET_ERROR_CODE_Pos = 0x10
	// Bit mask of ERROR_CODE field.
	DCP_CH1STAT_SET_ERROR_CODE_Msk = 0xff0000
	// Error is signalled because the next pointer is 0x00000000.
	DCP_CH1STAT_SET_ERROR_CODE_NEXT_CHAIN_IS_0 = 0x1
	// Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
	DCP_CH1STAT_SET_ERROR_CODE_NO_CHAIN = 0x2
	// Error is signalled because an error was reported when reading/writing the context buffer.
	DCP_CH1STAT_SET_ERROR_CODE_CONTEXT_ERROR = 0x3
	// Error is signalled because an error was reported when reading/writing the payload.
	DCP_CH1STAT_SET_ERROR_CODE_PAYLOAD_ERROR = 0x4
	// Error is signalled because the control packet specifies an invalid mode select (for example, blit + hash).
	DCP_CH1STAT_SET_ERROR_CODE_INVALID_MODE = 0x5
	// Position of TAG field.
	DCP_CH1STAT_SET_TAG_Pos = 0x18
	// Bit mask of TAG field.
	DCP_CH1STAT_SET_TAG_Msk = 0xff000000

	// CH1STAT_CLR: DCP channel 1 status register
	// Position of HASH_MISMATCH field.
	DCP_CH1STAT_CLR_HASH_MISMATCH_Pos = 0x1
	// Bit mask of HASH_MISMATCH field.
	DCP_CH1STAT_CLR_HASH_MISMATCH_Msk = 0x2
	// Bit HASH_MISMATCH.
	DCP_CH1STAT_CLR_HASH_MISMATCH = 0x2
	// Position of ERROR_SETUP field.
	DCP_CH1STAT_CLR_ERROR_SETUP_Pos = 0x2
	// Bit mask of ERROR_SETUP field.
	DCP_CH1STAT_CLR_ERROR_SETUP_Msk = 0x4
	// Bit ERROR_SETUP.
	DCP_CH1STAT_CLR_ERROR_SETUP = 0x4
	// Position of ERROR_PACKET field.
	DCP_CH1STAT_CLR_ERROR_PACKET_Pos = 0x3
	// Bit mask of ERROR_PACKET field.
	DCP_CH1STAT_CLR_ERROR_PACKET_Msk = 0x8
	// Bit ERROR_PACKET.
	DCP_CH1STAT_CLR_ERROR_PACKET = 0x8
	// Position of ERROR_SRC field.
	DCP_CH1STAT_CLR_ERROR_SRC_Pos = 0x4
	// Bit mask of ERROR_SRC field.
	DCP_CH1STAT_CLR_ERROR_SRC_Msk = 0x10
	// Bit ERROR_SRC.
	DCP_CH1STAT_CLR_ERROR_SRC = 0x10
	// Position of ERROR_DST field.
	DCP_CH1STAT_CLR_ERROR_DST_Pos = 0x5
	// Bit mask of ERROR_DST field.
	DCP_CH1STAT_CLR_ERROR_DST_Msk = 0x20
	// Bit ERROR_DST.
	DCP_CH1STAT_CLR_ERROR_DST = 0x20
	// Position of ERROR_PAGEFAULT field.
	DCP_CH1STAT_CLR_ERROR_PAGEFAULT_Pos = 0x6
	// Bit mask of ERROR_PAGEFAULT field.
	DCP_CH1STAT_CLR_ERROR_PAGEFAULT_Msk = 0x40
	// Bit ERROR_PAGEFAULT.
	DCP_CH1STAT_CLR_ERROR_PAGEFAULT = 0x40
	// Position of ERROR_CODE field.
	DCP_CH1STAT_CLR_ERROR_CODE_Pos = 0x10
	// Bit mask of ERROR_CODE field.
	DCP_CH1STAT_CLR_ERROR_CODE_Msk = 0xff0000
	// Error is signalled because the next pointer is 0x00000000.
	DCP_CH1STAT_CLR_ERROR_CODE_NEXT_CHAIN_IS_0 = 0x1
	// Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
	DCP_CH1STAT_CLR_ERROR_CODE_NO_CHAIN = 0x2
	// Error is signalled because an error was reported when reading/writing the context buffer.
	DCP_CH1STAT_CLR_ERROR_CODE_CONTEXT_ERROR = 0x3
	// Error is signalled because an error was reported when reading/writing the payload.
	DCP_CH1STAT_CLR_ERROR_CODE_PAYLOAD_ERROR = 0x4
	// Error is signalled because the control packet specifies an invalid mode select (for example, blit + hash).
	DCP_CH1STAT_CLR_ERROR_CODE_INVALID_MODE = 0x5
	// Position of TAG field.
	DCP_CH1STAT_CLR_TAG_Pos = 0x18
	// Bit mask of TAG field.
	DCP_CH1STAT_CLR_TAG_Msk = 0xff000000

	// CH1STAT_TOG: DCP channel 1 status register
	// Position of HASH_MISMATCH field.
	DCP_CH1STAT_TOG_HASH_MISMATCH_Pos = 0x1
	// Bit mask of HASH_MISMATCH field.
	DCP_CH1STAT_TOG_HASH_MISMATCH_Msk = 0x2
	// Bit HASH_MISMATCH.
	DCP_CH1STAT_TOG_HASH_MISMATCH = 0x2
	// Position of ERROR_SETUP field.
	DCP_CH1STAT_TOG_ERROR_SETUP_Pos = 0x2
	// Bit mask of ERROR_SETUP field.
	DCP_CH1STAT_TOG_ERROR_SETUP_Msk = 0x4
	// Bit ERROR_SETUP.
	DCP_CH1STAT_TOG_ERROR_SETUP = 0x4
	// Position of ERROR_PACKET field.
	DCP_CH1STAT_TOG_ERROR_PACKET_Pos = 0x3
	// Bit mask of ERROR_PACKET field.
	DCP_CH1STAT_TOG_ERROR_PACKET_Msk = 0x8
	// Bit ERROR_PACKET.
	DCP_CH1STAT_TOG_ERROR_PACKET = 0x8
	// Position of ERROR_SRC field.
	DCP_CH1STAT_TOG_ERROR_SRC_Pos = 0x4
	// Bit mask of ERROR_SRC field.
	DCP_CH1STAT_TOG_ERROR_SRC_Msk = 0x10
	// Bit ERROR_SRC.
	DCP_CH1STAT_TOG_ERROR_SRC = 0x10
	// Position of ERROR_DST field.
	DCP_CH1STAT_TOG_ERROR_DST_Pos = 0x5
	// Bit mask of ERROR_DST field.
	DCP_CH1STAT_TOG_ERROR_DST_Msk = 0x20
	// Bit ERROR_DST.
	DCP_CH1STAT_TOG_ERROR_DST = 0x20
	// Position of ERROR_PAGEFAULT field.
	DCP_CH1STAT_TOG_ERROR_PAGEFAULT_Pos = 0x6
	// Bit mask of ERROR_PAGEFAULT field.
	DCP_CH1STAT_TOG_ERROR_PAGEFAULT_Msk = 0x40
	// Bit ERROR_PAGEFAULT.
	DCP_CH1STAT_TOG_ERROR_PAGEFAULT = 0x40
	// Position of ERROR_CODE field.
	DCP_CH1STAT_TOG_ERROR_CODE_Pos = 0x10
	// Bit mask of ERROR_CODE field.
	DCP_CH1STAT_TOG_ERROR_CODE_Msk = 0xff0000
	// Error is signalled because the next pointer is 0x00000000.
	DCP_CH1STAT_TOG_ERROR_CODE_NEXT_CHAIN_IS_0 = 0x1
	// Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
	DCP_CH1STAT_TOG_ERROR_CODE_NO_CHAIN = 0x2
	// Error is signalled because an error was reported when reading/writing the context buffer.
	DCP_CH1STAT_TOG_ERROR_CODE_CONTEXT_ERROR = 0x3
	// Error is signalled because an error was reported when reading/writing the payload.
	DCP_CH1STAT_TOG_ERROR_CODE_PAYLOAD_ERROR = 0x4
	// Error is signalled because the control packet specifies an invalid mode select (for example, blit + hash).
	DCP_CH1STAT_TOG_ERROR_CODE_INVALID_MODE = 0x5
	// Position of TAG field.
	DCP_CH1STAT_TOG_TAG_Pos = 0x18
	// Bit mask of TAG field.
	DCP_CH1STAT_TOG_TAG_Msk = 0xff000000

	// CH1OPTS: DCP channel 1 options register
	// Position of RECOVERY_TIMER field.
	DCP_CH1OPTS_RECOVERY_TIMER_Pos = 0x0
	// Bit mask of RECOVERY_TIMER field.
	DCP_CH1OPTS_RECOVERY_TIMER_Msk = 0xffff

	// CH1OPTS_SET: DCP channel 1 options register
	// Position of RECOVERY_TIMER field.
	DCP_CH1OPTS_SET_RECOVERY_TIMER_Pos = 0x0
	// Bit mask of RECOVERY_TIMER field.
	DCP_CH1OPTS_SET_RECOVERY_TIMER_Msk = 0xffff

	// CH1OPTS_CLR: DCP channel 1 options register
	// Position of RECOVERY_TIMER field.
	DCP_CH1OPTS_CLR_RECOVERY_TIMER_Pos = 0x0
	// Bit mask of RECOVERY_TIMER field.
	DCP_CH1OPTS_CLR_RECOVERY_TIMER_Msk = 0xffff

	// CH1OPTS_TOG: DCP channel 1 options register
	// Position of RECOVERY_TIMER field.
	DCP_CH1OPTS_TOG_RECOVERY_TIMER_Pos = 0x0
	// Bit mask of RECOVERY_TIMER field.
	DCP_CH1OPTS_TOG_RECOVERY_TIMER_Msk = 0xffff

	// CH2CMDPTR: DCP channel 2 command pointer address register
	// Position of ADDR field.
	DCP_CH2CMDPTR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	DCP_CH2CMDPTR_ADDR_Msk = 0xffffffff

	// CH2SEMA: DCP channel 2 semaphore register
	// Position of INCREMENT field.
	DCP_CH2SEMA_INCREMENT_Pos = 0x0
	// Bit mask of INCREMENT field.
	DCP_CH2SEMA_INCREMENT_Msk = 0xff
	// Position of VALUE field.
	DCP_CH2SEMA_VALUE_Pos = 0x10
	// Bit mask of VALUE field.
	DCP_CH2SEMA_VALUE_Msk = 0xff0000

	// CH2STAT: DCP channel 2 status register
	// Position of HASH_MISMATCH field.
	DCP_CH2STAT_HASH_MISMATCH_Pos = 0x1
	// Bit mask of HASH_MISMATCH field.
	DCP_CH2STAT_HASH_MISMATCH_Msk = 0x2
	// Bit HASH_MISMATCH.
	DCP_CH2STAT_HASH_MISMATCH = 0x2
	// Position of ERROR_SETUP field.
	DCP_CH2STAT_ERROR_SETUP_Pos = 0x2
	// Bit mask of ERROR_SETUP field.
	DCP_CH2STAT_ERROR_SETUP_Msk = 0x4
	// Bit ERROR_SETUP.
	DCP_CH2STAT_ERROR_SETUP = 0x4
	// Position of ERROR_PACKET field.
	DCP_CH2STAT_ERROR_PACKET_Pos = 0x3
	// Bit mask of ERROR_PACKET field.
	DCP_CH2STAT_ERROR_PACKET_Msk = 0x8
	// Bit ERROR_PACKET.
	DCP_CH2STAT_ERROR_PACKET = 0x8
	// Position of ERROR_SRC field.
	DCP_CH2STAT_ERROR_SRC_Pos = 0x4
	// Bit mask of ERROR_SRC field.
	DCP_CH2STAT_ERROR_SRC_Msk = 0x10
	// Bit ERROR_SRC.
	DCP_CH2STAT_ERROR_SRC = 0x10
	// Position of ERROR_DST field.
	DCP_CH2STAT_ERROR_DST_Pos = 0x5
	// Bit mask of ERROR_DST field.
	DCP_CH2STAT_ERROR_DST_Msk = 0x20
	// Bit ERROR_DST.
	DCP_CH2STAT_ERROR_DST = 0x20
	// Position of ERROR_PAGEFAULT field.
	DCP_CH2STAT_ERROR_PAGEFAULT_Pos = 0x6
	// Bit mask of ERROR_PAGEFAULT field.
	DCP_CH2STAT_ERROR_PAGEFAULT_Msk = 0x40
	// Bit ERROR_PAGEFAULT.
	DCP_CH2STAT_ERROR_PAGEFAULT = 0x40
	// Position of ERROR_CODE field.
	DCP_CH2STAT_ERROR_CODE_Pos = 0x10
	// Bit mask of ERROR_CODE field.
	DCP_CH2STAT_ERROR_CODE_Msk = 0xff0000
	// Error is signalled because the next pointer is 0x00000000.
	DCP_CH2STAT_ERROR_CODE_NEXT_CHAIN_IS_0 = 0x1
	// Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
	DCP_CH2STAT_ERROR_CODE_NO_CHAIN = 0x2
	// Error is signalled because an error was reported while reading/writing the context buffer.
	DCP_CH2STAT_ERROR_CODE_CONTEXT_ERROR = 0x3
	// Error is signalled because an error was reported while reading/writing the payload.
	DCP_CH2STAT_ERROR_CODE_PAYLOAD_ERROR = 0x4
	// Error is signalled because the control packet specifies an invalid mode select (for instance, blit + hash).
	DCP_CH2STAT_ERROR_CODE_INVALID_MODE = 0x5
	// Position of TAG field.
	DCP_CH2STAT_TAG_Pos = 0x18
	// Bit mask of TAG field.
	DCP_CH2STAT_TAG_Msk = 0xff000000

	// CH2STAT_SET: DCP channel 2 status register
	// Position of HASH_MISMATCH field.
	DCP_CH2STAT_SET_HASH_MISMATCH_Pos = 0x1
	// Bit mask of HASH_MISMATCH field.
	DCP_CH2STAT_SET_HASH_MISMATCH_Msk = 0x2
	// Bit HASH_MISMATCH.
	DCP_CH2STAT_SET_HASH_MISMATCH = 0x2
	// Position of ERROR_SETUP field.
	DCP_CH2STAT_SET_ERROR_SETUP_Pos = 0x2
	// Bit mask of ERROR_SETUP field.
	DCP_CH2STAT_SET_ERROR_SETUP_Msk = 0x4
	// Bit ERROR_SETUP.
	DCP_CH2STAT_SET_ERROR_SETUP = 0x4
	// Position of ERROR_PACKET field.
	DCP_CH2STAT_SET_ERROR_PACKET_Pos = 0x3
	// Bit mask of ERROR_PACKET field.
	DCP_CH2STAT_SET_ERROR_PACKET_Msk = 0x8
	// Bit ERROR_PACKET.
	DCP_CH2STAT_SET_ERROR_PACKET = 0x8
	// Position of ERROR_SRC field.
	DCP_CH2STAT_SET_ERROR_SRC_Pos = 0x4
	// Bit mask of ERROR_SRC field.
	DCP_CH2STAT_SET_ERROR_SRC_Msk = 0x10
	// Bit ERROR_SRC.
	DCP_CH2STAT_SET_ERROR_SRC = 0x10
	// Position of ERROR_DST field.
	DCP_CH2STAT_SET_ERROR_DST_Pos = 0x5
	// Bit mask of ERROR_DST field.
	DCP_CH2STAT_SET_ERROR_DST_Msk = 0x20
	// Bit ERROR_DST.
	DCP_CH2STAT_SET_ERROR_DST = 0x20
	// Position of ERROR_PAGEFAULT field.
	DCP_CH2STAT_SET_ERROR_PAGEFAULT_Pos = 0x6
	// Bit mask of ERROR_PAGEFAULT field.
	DCP_CH2STAT_SET_ERROR_PAGEFAULT_Msk = 0x40
	// Bit ERROR_PAGEFAULT.
	DCP_CH2STAT_SET_ERROR_PAGEFAULT = 0x40
	// Position of ERROR_CODE field.
	DCP_CH2STAT_SET_ERROR_CODE_Pos = 0x10
	// Bit mask of ERROR_CODE field.
	DCP_CH2STAT_SET_ERROR_CODE_Msk = 0xff0000
	// Error is signalled because the next pointer is 0x00000000.
	DCP_CH2STAT_SET_ERROR_CODE_NEXT_CHAIN_IS_0 = 0x1
	// Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
	DCP_CH2STAT_SET_ERROR_CODE_NO_CHAIN = 0x2
	// Error is signalled because an error was reported while reading/writing the context buffer.
	DCP_CH2STAT_SET_ERROR_CODE_CONTEXT_ERROR = 0x3
	// Error is signalled because an error was reported while reading/writing the payload.
	DCP_CH2STAT_SET_ERROR_CODE_PAYLOAD_ERROR = 0x4
	// Error is signalled because the control packet specifies an invalid mode select (for instance, blit + hash).
	DCP_CH2STAT_SET_ERROR_CODE_INVALID_MODE = 0x5
	// Position of TAG field.
	DCP_CH2STAT_SET_TAG_Pos = 0x18
	// Bit mask of TAG field.
	DCP_CH2STAT_SET_TAG_Msk = 0xff000000

	// CH2STAT_CLR: DCP channel 2 status register
	// Position of HASH_MISMATCH field.
	DCP_CH2STAT_CLR_HASH_MISMATCH_Pos = 0x1
	// Bit mask of HASH_MISMATCH field.
	DCP_CH2STAT_CLR_HASH_MISMATCH_Msk = 0x2
	// Bit HASH_MISMATCH.
	DCP_CH2STAT_CLR_HASH_MISMATCH = 0x2
	// Position of ERROR_SETUP field.
	DCP_CH2STAT_CLR_ERROR_SETUP_Pos = 0x2
	// Bit mask of ERROR_SETUP field.
	DCP_CH2STAT_CLR_ERROR_SETUP_Msk = 0x4
	// Bit ERROR_SETUP.
	DCP_CH2STAT_CLR_ERROR_SETUP = 0x4
	// Position of ERROR_PACKET field.
	DCP_CH2STAT_CLR_ERROR_PACKET_Pos = 0x3
	// Bit mask of ERROR_PACKET field.
	DCP_CH2STAT_CLR_ERROR_PACKET_Msk = 0x8
	// Bit ERROR_PACKET.
	DCP_CH2STAT_CLR_ERROR_PACKET = 0x8
	// Position of ERROR_SRC field.
	DCP_CH2STAT_CLR_ERROR_SRC_Pos = 0x4
	// Bit mask of ERROR_SRC field.
	DCP_CH2STAT_CLR_ERROR_SRC_Msk = 0x10
	// Bit ERROR_SRC.
	DCP_CH2STAT_CLR_ERROR_SRC = 0x10
	// Position of ERROR_DST field.
	DCP_CH2STAT_CLR_ERROR_DST_Pos = 0x5
	// Bit mask of ERROR_DST field.
	DCP_CH2STAT_CLR_ERROR_DST_Msk = 0x20
	// Bit ERROR_DST.
	DCP_CH2STAT_CLR_ERROR_DST = 0x20
	// Position of ERROR_PAGEFAULT field.
	DCP_CH2STAT_CLR_ERROR_PAGEFAULT_Pos = 0x6
	// Bit mask of ERROR_PAGEFAULT field.
	DCP_CH2STAT_CLR_ERROR_PAGEFAULT_Msk = 0x40
	// Bit ERROR_PAGEFAULT.
	DCP_CH2STAT_CLR_ERROR_PAGEFAULT = 0x40
	// Position of ERROR_CODE field.
	DCP_CH2STAT_CLR_ERROR_CODE_Pos = 0x10
	// Bit mask of ERROR_CODE field.
	DCP_CH2STAT_CLR_ERROR_CODE_Msk = 0xff0000
	// Error is signalled because the next pointer is 0x00000000.
	DCP_CH2STAT_CLR_ERROR_CODE_NEXT_CHAIN_IS_0 = 0x1
	// Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
	DCP_CH2STAT_CLR_ERROR_CODE_NO_CHAIN = 0x2
	// Error is signalled because an error was reported while reading/writing the context buffer.
	DCP_CH2STAT_CLR_ERROR_CODE_CONTEXT_ERROR = 0x3
	// Error is signalled because an error was reported while reading/writing the payload.
	DCP_CH2STAT_CLR_ERROR_CODE_PAYLOAD_ERROR = 0x4
	// Error is signalled because the control packet specifies an invalid mode select (for instance, blit + hash).
	DCP_CH2STAT_CLR_ERROR_CODE_INVALID_MODE = 0x5
	// Position of TAG field.
	DCP_CH2STAT_CLR_TAG_Pos = 0x18
	// Bit mask of TAG field.
	DCP_CH2STAT_CLR_TAG_Msk = 0xff000000

	// CH2STAT_TOG: DCP channel 2 status register
	// Position of HASH_MISMATCH field.
	DCP_CH2STAT_TOG_HASH_MISMATCH_Pos = 0x1
	// Bit mask of HASH_MISMATCH field.
	DCP_CH2STAT_TOG_HASH_MISMATCH_Msk = 0x2
	// Bit HASH_MISMATCH.
	DCP_CH2STAT_TOG_HASH_MISMATCH = 0x2
	// Position of ERROR_SETUP field.
	DCP_CH2STAT_TOG_ERROR_SETUP_Pos = 0x2
	// Bit mask of ERROR_SETUP field.
	DCP_CH2STAT_TOG_ERROR_SETUP_Msk = 0x4
	// Bit ERROR_SETUP.
	DCP_CH2STAT_TOG_ERROR_SETUP = 0x4
	// Position of ERROR_PACKET field.
	DCP_CH2STAT_TOG_ERROR_PACKET_Pos = 0x3
	// Bit mask of ERROR_PACKET field.
	DCP_CH2STAT_TOG_ERROR_PACKET_Msk = 0x8
	// Bit ERROR_PACKET.
	DCP_CH2STAT_TOG_ERROR_PACKET = 0x8
	// Position of ERROR_SRC field.
	DCP_CH2STAT_TOG_ERROR_SRC_Pos = 0x4
	// Bit mask of ERROR_SRC field.
	DCP_CH2STAT_TOG_ERROR_SRC_Msk = 0x10
	// Bit ERROR_SRC.
	DCP_CH2STAT_TOG_ERROR_SRC = 0x10
	// Position of ERROR_DST field.
	DCP_CH2STAT_TOG_ERROR_DST_Pos = 0x5
	// Bit mask of ERROR_DST field.
	DCP_CH2STAT_TOG_ERROR_DST_Msk = 0x20
	// Bit ERROR_DST.
	DCP_CH2STAT_TOG_ERROR_DST = 0x20
	// Position of ERROR_PAGEFAULT field.
	DCP_CH2STAT_TOG_ERROR_PAGEFAULT_Pos = 0x6
	// Bit mask of ERROR_PAGEFAULT field.
	DCP_CH2STAT_TOG_ERROR_PAGEFAULT_Msk = 0x40
	// Bit ERROR_PAGEFAULT.
	DCP_CH2STAT_TOG_ERROR_PAGEFAULT = 0x40
	// Position of ERROR_CODE field.
	DCP_CH2STAT_TOG_ERROR_CODE_Pos = 0x10
	// Bit mask of ERROR_CODE field.
	DCP_CH2STAT_TOG_ERROR_CODE_Msk = 0xff0000
	// Error is signalled because the next pointer is 0x00000000.
	DCP_CH2STAT_TOG_ERROR_CODE_NEXT_CHAIN_IS_0 = 0x1
	// Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
	DCP_CH2STAT_TOG_ERROR_CODE_NO_CHAIN = 0x2
	// Error is signalled because an error was reported while reading/writing the context buffer.
	DCP_CH2STAT_TOG_ERROR_CODE_CONTEXT_ERROR = 0x3
	// Error is signalled because an error was reported while reading/writing the payload.
	DCP_CH2STAT_TOG_ERROR_CODE_PAYLOAD_ERROR = 0x4
	// Error is signalled because the control packet specifies an invalid mode select (for instance, blit + hash).
	DCP_CH2STAT_TOG_ERROR_CODE_INVALID_MODE = 0x5
	// Position of TAG field.
	DCP_CH2STAT_TOG_TAG_Pos = 0x18
	// Bit mask of TAG field.
	DCP_CH2STAT_TOG_TAG_Msk = 0xff000000

	// CH2OPTS: DCP channel 2 options register
	// Position of RECOVERY_TIMER field.
	DCP_CH2OPTS_RECOVERY_TIMER_Pos = 0x0
	// Bit mask of RECOVERY_TIMER field.
	DCP_CH2OPTS_RECOVERY_TIMER_Msk = 0xffff

	// CH2OPTS_SET: DCP channel 2 options register
	// Position of RECOVERY_TIMER field.
	DCP_CH2OPTS_SET_RECOVERY_TIMER_Pos = 0x0
	// Bit mask of RECOVERY_TIMER field.
	DCP_CH2OPTS_SET_RECOVERY_TIMER_Msk = 0xffff

	// CH2OPTS_CLR: DCP channel 2 options register
	// Position of RECOVERY_TIMER field.
	DCP_CH2OPTS_CLR_RECOVERY_TIMER_Pos = 0x0
	// Bit mask of RECOVERY_TIMER field.
	DCP_CH2OPTS_CLR_RECOVERY_TIMER_Msk = 0xffff

	// CH2OPTS_TOG: DCP channel 2 options register
	// Position of RECOVERY_TIMER field.
	DCP_CH2OPTS_TOG_RECOVERY_TIMER_Pos = 0x0
	// Bit mask of RECOVERY_TIMER field.
	DCP_CH2OPTS_TOG_RECOVERY_TIMER_Msk = 0xffff

	// CH3CMDPTR: DCP channel 3 command pointer address register
	// Position of ADDR field.
	DCP_CH3CMDPTR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	DCP_CH3CMDPTR_ADDR_Msk = 0xffffffff

	// CH3SEMA: DCP channel 3 semaphore register
	// Position of INCREMENT field.
	DCP_CH3SEMA_INCREMENT_Pos = 0x0
	// Bit mask of INCREMENT field.
	DCP_CH3SEMA_INCREMENT_Msk = 0xff
	// Position of VALUE field.
	DCP_CH3SEMA_VALUE_Pos = 0x10
	// Bit mask of VALUE field.
	DCP_CH3SEMA_VALUE_Msk = 0xff0000

	// CH3STAT: DCP channel 3 status register
	// Position of HASH_MISMATCH field.
	DCP_CH3STAT_HASH_MISMATCH_Pos = 0x1
	// Bit mask of HASH_MISMATCH field.
	DCP_CH3STAT_HASH_MISMATCH_Msk = 0x2
	// Bit HASH_MISMATCH.
	DCP_CH3STAT_HASH_MISMATCH = 0x2
	// Position of ERROR_SETUP field.
	DCP_CH3STAT_ERROR_SETUP_Pos = 0x2
	// Bit mask of ERROR_SETUP field.
	DCP_CH3STAT_ERROR_SETUP_Msk = 0x4
	// Bit ERROR_SETUP.
	DCP_CH3STAT_ERROR_SETUP = 0x4
	// Position of ERROR_PACKET field.
	DCP_CH3STAT_ERROR_PACKET_Pos = 0x3
	// Bit mask of ERROR_PACKET field.
	DCP_CH3STAT_ERROR_PACKET_Msk = 0x8
	// Bit ERROR_PACKET.
	DCP_CH3STAT_ERROR_PACKET = 0x8
	// Position of ERROR_SRC field.
	DCP_CH3STAT_ERROR_SRC_Pos = 0x4
	// Bit mask of ERROR_SRC field.
	DCP_CH3STAT_ERROR_SRC_Msk = 0x10
	// Bit ERROR_SRC.
	DCP_CH3STAT_ERROR_SRC = 0x10
	// Position of ERROR_DST field.
	DCP_CH3STAT_ERROR_DST_Pos = 0x5
	// Bit mask of ERROR_DST field.
	DCP_CH3STAT_ERROR_DST_Msk = 0x20
	// Bit ERROR_DST.
	DCP_CH3STAT_ERROR_DST = 0x20
	// Position of ERROR_PAGEFAULT field.
	DCP_CH3STAT_ERROR_PAGEFAULT_Pos = 0x6
	// Bit mask of ERROR_PAGEFAULT field.
	DCP_CH3STAT_ERROR_PAGEFAULT_Msk = 0x40
	// Bit ERROR_PAGEFAULT.
	DCP_CH3STAT_ERROR_PAGEFAULT = 0x40
	// Position of ERROR_CODE field.
	DCP_CH3STAT_ERROR_CODE_Pos = 0x10
	// Bit mask of ERROR_CODE field.
	DCP_CH3STAT_ERROR_CODE_Msk = 0xff0000
	// Error is signalled because the next pointer is 0x00000000.
	DCP_CH3STAT_ERROR_CODE_NEXT_CHAIN_IS_0 = 0x1
	// Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
	DCP_CH3STAT_ERROR_CODE_NO_CHAIN = 0x2
	// Error is signalled because an error was reported while reading/writing the context buffer.
	DCP_CH3STAT_ERROR_CODE_CONTEXT_ERROR = 0x3
	// Error is signalled because an error was reported while reading/writing the payload.
	DCP_CH3STAT_ERROR_CODE_PAYLOAD_ERROR = 0x4
	// Error is signalled because the control packet specifies an invalid mode select (for example, blit + hash).
	DCP_CH3STAT_ERROR_CODE_INVALID_MODE = 0x5
	// Position of TAG field.
	DCP_CH3STAT_TAG_Pos = 0x18
	// Bit mask of TAG field.
	DCP_CH3STAT_TAG_Msk = 0xff000000

	// CH3STAT_SET: DCP channel 3 status register
	// Position of HASH_MISMATCH field.
	DCP_CH3STAT_SET_HASH_MISMATCH_Pos = 0x1
	// Bit mask of HASH_MISMATCH field.
	DCP_CH3STAT_SET_HASH_MISMATCH_Msk = 0x2
	// Bit HASH_MISMATCH.
	DCP_CH3STAT_SET_HASH_MISMATCH = 0x2
	// Position of ERROR_SETUP field.
	DCP_CH3STAT_SET_ERROR_SETUP_Pos = 0x2
	// Bit mask of ERROR_SETUP field.
	DCP_CH3STAT_SET_ERROR_SETUP_Msk = 0x4
	// Bit ERROR_SETUP.
	DCP_CH3STAT_SET_ERROR_SETUP = 0x4
	// Position of ERROR_PACKET field.
	DCP_CH3STAT_SET_ERROR_PACKET_Pos = 0x3
	// Bit mask of ERROR_PACKET field.
	DCP_CH3STAT_SET_ERROR_PACKET_Msk = 0x8
	// Bit ERROR_PACKET.
	DCP_CH3STAT_SET_ERROR_PACKET = 0x8
	// Position of ERROR_SRC field.
	DCP_CH3STAT_SET_ERROR_SRC_Pos = 0x4
	// Bit mask of ERROR_SRC field.
	DCP_CH3STAT_SET_ERROR_SRC_Msk = 0x10
	// Bit ERROR_SRC.
	DCP_CH3STAT_SET_ERROR_SRC = 0x10
	// Position of ERROR_DST field.
	DCP_CH3STAT_SET_ERROR_DST_Pos = 0x5
	// Bit mask of ERROR_DST field.
	DCP_CH3STAT_SET_ERROR_DST_Msk = 0x20
	// Bit ERROR_DST.
	DCP_CH3STAT_SET_ERROR_DST = 0x20
	// Position of ERROR_PAGEFAULT field.
	DCP_CH3STAT_SET_ERROR_PAGEFAULT_Pos = 0x6
	// Bit mask of ERROR_PAGEFAULT field.
	DCP_CH3STAT_SET_ERROR_PAGEFAULT_Msk = 0x40
	// Bit ERROR_PAGEFAULT.
	DCP_CH3STAT_SET_ERROR_PAGEFAULT = 0x40
	// Position of ERROR_CODE field.
	DCP_CH3STAT_SET_ERROR_CODE_Pos = 0x10
	// Bit mask of ERROR_CODE field.
	DCP_CH3STAT_SET_ERROR_CODE_Msk = 0xff0000
	// Error is signalled because the next pointer is 0x00000000.
	DCP_CH3STAT_SET_ERROR_CODE_NEXT_CHAIN_IS_0 = 0x1
	// Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
	DCP_CH3STAT_SET_ERROR_CODE_NO_CHAIN = 0x2
	// Error is signalled because an error was reported while reading/writing the context buffer.
	DCP_CH3STAT_SET_ERROR_CODE_CONTEXT_ERROR = 0x3
	// Error is signalled because an error was reported while reading/writing the payload.
	DCP_CH3STAT_SET_ERROR_CODE_PAYLOAD_ERROR = 0x4
	// Error is signalled because the control packet specifies an invalid mode select (for example, blit + hash).
	DCP_CH3STAT_SET_ERROR_CODE_INVALID_MODE = 0x5
	// Position of TAG field.
	DCP_CH3STAT_SET_TAG_Pos = 0x18
	// Bit mask of TAG field.
	DCP_CH3STAT_SET_TAG_Msk = 0xff000000

	// CH3STAT_CLR: DCP channel 3 status register
	// Position of HASH_MISMATCH field.
	DCP_CH3STAT_CLR_HASH_MISMATCH_Pos = 0x1
	// Bit mask of HASH_MISMATCH field.
	DCP_CH3STAT_CLR_HASH_MISMATCH_Msk = 0x2
	// Bit HASH_MISMATCH.
	DCP_CH3STAT_CLR_HASH_MISMATCH = 0x2
	// Position of ERROR_SETUP field.
	DCP_CH3STAT_CLR_ERROR_SETUP_Pos = 0x2
	// Bit mask of ERROR_SETUP field.
	DCP_CH3STAT_CLR_ERROR_SETUP_Msk = 0x4
	// Bit ERROR_SETUP.
	DCP_CH3STAT_CLR_ERROR_SETUP = 0x4
	// Position of ERROR_PACKET field.
	DCP_CH3STAT_CLR_ERROR_PACKET_Pos = 0x3
	// Bit mask of ERROR_PACKET field.
	DCP_CH3STAT_CLR_ERROR_PACKET_Msk = 0x8
	// Bit ERROR_PACKET.
	DCP_CH3STAT_CLR_ERROR_PACKET = 0x8
	// Position of ERROR_SRC field.
	DCP_CH3STAT_CLR_ERROR_SRC_Pos = 0x4
	// Bit mask of ERROR_SRC field.
	DCP_CH3STAT_CLR_ERROR_SRC_Msk = 0x10
	// Bit ERROR_SRC.
	DCP_CH3STAT_CLR_ERROR_SRC = 0x10
	// Position of ERROR_DST field.
	DCP_CH3STAT_CLR_ERROR_DST_Pos = 0x5
	// Bit mask of ERROR_DST field.
	DCP_CH3STAT_CLR_ERROR_DST_Msk = 0x20
	// Bit ERROR_DST.
	DCP_CH3STAT_CLR_ERROR_DST = 0x20
	// Position of ERROR_PAGEFAULT field.
	DCP_CH3STAT_CLR_ERROR_PAGEFAULT_Pos = 0x6
	// Bit mask of ERROR_PAGEFAULT field.
	DCP_CH3STAT_CLR_ERROR_PAGEFAULT_Msk = 0x40
	// Bit ERROR_PAGEFAULT.
	DCP_CH3STAT_CLR_ERROR_PAGEFAULT = 0x40
	// Position of ERROR_CODE field.
	DCP_CH3STAT_CLR_ERROR_CODE_Pos = 0x10
	// Bit mask of ERROR_CODE field.
	DCP_CH3STAT_CLR_ERROR_CODE_Msk = 0xff0000
	// Error is signalled because the next pointer is 0x00000000.
	DCP_CH3STAT_CLR_ERROR_CODE_NEXT_CHAIN_IS_0 = 0x1
	// Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
	DCP_CH3STAT_CLR_ERROR_CODE_NO_CHAIN = 0x2
	// Error is signalled because an error was reported while reading/writing the context buffer.
	DCP_CH3STAT_CLR_ERROR_CODE_CONTEXT_ERROR = 0x3
	// Error is signalled because an error was reported while reading/writing the payload.
	DCP_CH3STAT_CLR_ERROR_CODE_PAYLOAD_ERROR = 0x4
	// Error is signalled because the control packet specifies an invalid mode select (for example, blit + hash).
	DCP_CH3STAT_CLR_ERROR_CODE_INVALID_MODE = 0x5
	// Position of TAG field.
	DCP_CH3STAT_CLR_TAG_Pos = 0x18
	// Bit mask of TAG field.
	DCP_CH3STAT_CLR_TAG_Msk = 0xff000000

	// CH3STAT_TOG: DCP channel 3 status register
	// Position of HASH_MISMATCH field.
	DCP_CH3STAT_TOG_HASH_MISMATCH_Pos = 0x1
	// Bit mask of HASH_MISMATCH field.
	DCP_CH3STAT_TOG_HASH_MISMATCH_Msk = 0x2
	// Bit HASH_MISMATCH.
	DCP_CH3STAT_TOG_HASH_MISMATCH = 0x2
	// Position of ERROR_SETUP field.
	DCP_CH3STAT_TOG_ERROR_SETUP_Pos = 0x2
	// Bit mask of ERROR_SETUP field.
	DCP_CH3STAT_TOG_ERROR_SETUP_Msk = 0x4
	// Bit ERROR_SETUP.
	DCP_CH3STAT_TOG_ERROR_SETUP = 0x4
	// Position of ERROR_PACKET field.
	DCP_CH3STAT_TOG_ERROR_PACKET_Pos = 0x3
	// Bit mask of ERROR_PACKET field.
	DCP_CH3STAT_TOG_ERROR_PACKET_Msk = 0x8
	// Bit ERROR_PACKET.
	DCP_CH3STAT_TOG_ERROR_PACKET = 0x8
	// Position of ERROR_SRC field.
	DCP_CH3STAT_TOG_ERROR_SRC_Pos = 0x4
	// Bit mask of ERROR_SRC field.
	DCP_CH3STAT_TOG_ERROR_SRC_Msk = 0x10
	// Bit ERROR_SRC.
	DCP_CH3STAT_TOG_ERROR_SRC = 0x10
	// Position of ERROR_DST field.
	DCP_CH3STAT_TOG_ERROR_DST_Pos = 0x5
	// Bit mask of ERROR_DST field.
	DCP_CH3STAT_TOG_ERROR_DST_Msk = 0x20
	// Bit ERROR_DST.
	DCP_CH3STAT_TOG_ERROR_DST = 0x20
	// Position of ERROR_PAGEFAULT field.
	DCP_CH3STAT_TOG_ERROR_PAGEFAULT_Pos = 0x6
	// Bit mask of ERROR_PAGEFAULT field.
	DCP_CH3STAT_TOG_ERROR_PAGEFAULT_Msk = 0x40
	// Bit ERROR_PAGEFAULT.
	DCP_CH3STAT_TOG_ERROR_PAGEFAULT = 0x40
	// Position of ERROR_CODE field.
	DCP_CH3STAT_TOG_ERROR_CODE_Pos = 0x10
	// Bit mask of ERROR_CODE field.
	DCP_CH3STAT_TOG_ERROR_CODE_Msk = 0xff0000
	// Error is signalled because the next pointer is 0x00000000.
	DCP_CH3STAT_TOG_ERROR_CODE_NEXT_CHAIN_IS_0 = 0x1
	// Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
	DCP_CH3STAT_TOG_ERROR_CODE_NO_CHAIN = 0x2
	// Error is signalled because an error was reported while reading/writing the context buffer.
	DCP_CH3STAT_TOG_ERROR_CODE_CONTEXT_ERROR = 0x3
	// Error is signalled because an error was reported while reading/writing the payload.
	DCP_CH3STAT_TOG_ERROR_CODE_PAYLOAD_ERROR = 0x4
	// Error is signalled because the control packet specifies an invalid mode select (for example, blit + hash).
	DCP_CH3STAT_TOG_ERROR_CODE_INVALID_MODE = 0x5
	// Position of TAG field.
	DCP_CH3STAT_TOG_TAG_Pos = 0x18
	// Bit mask of TAG field.
	DCP_CH3STAT_TOG_TAG_Msk = 0xff000000

	// CH3OPTS: DCP channel 3 options register
	// Position of RECOVERY_TIMER field.
	DCP_CH3OPTS_RECOVERY_TIMER_Pos = 0x0
	// Bit mask of RECOVERY_TIMER field.
	DCP_CH3OPTS_RECOVERY_TIMER_Msk = 0xffff

	// CH3OPTS_SET: DCP channel 3 options register
	// Position of RECOVERY_TIMER field.
	DCP_CH3OPTS_SET_RECOVERY_TIMER_Pos = 0x0
	// Bit mask of RECOVERY_TIMER field.
	DCP_CH3OPTS_SET_RECOVERY_TIMER_Msk = 0xffff

	// CH3OPTS_CLR: DCP channel 3 options register
	// Position of RECOVERY_TIMER field.
	DCP_CH3OPTS_CLR_RECOVERY_TIMER_Pos = 0x0
	// Bit mask of RECOVERY_TIMER field.
	DCP_CH3OPTS_CLR_RECOVERY_TIMER_Msk = 0xffff

	// CH3OPTS_TOG: DCP channel 3 options register
	// Position of RECOVERY_TIMER field.
	DCP_CH3OPTS_TOG_RECOVERY_TIMER_Pos = 0x0
	// Bit mask of RECOVERY_TIMER field.
	DCP_CH3OPTS_TOG_RECOVERY_TIMER_Msk = 0xffff

	// DBGSELECT: DCP debug select register
	// Position of INDEX field.
	DCP_DBGSELECT_INDEX_Pos = 0x0
	// Bit mask of INDEX field.
	DCP_DBGSELECT_INDEX_Msk = 0xff
	// CONTROL
	DCP_DBGSELECT_INDEX_CONTROL = 0x1
	// OTPKEY0
	DCP_DBGSELECT_INDEX_OTPKEY0 = 0x10
	// OTPKEY1
	DCP_DBGSELECT_INDEX_OTPKEY1 = 0x11
	// OTPKEY2
	DCP_DBGSELECT_INDEX_OTPKEY2 = 0x12
	// OTPKEY3
	DCP_DBGSELECT_INDEX_OTPKEY3 = 0x13

	// DBGDATA: DCP debug data register
	// Position of DATA field.
	DCP_DBGDATA_DATA_Pos = 0x0
	// Bit mask of DATA field.
	DCP_DBGDATA_DATA_Msk = 0xffffffff

	// PAGETABLE: DCP page table register
	// Position of ENABLE field.
	DCP_PAGETABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	DCP_PAGETABLE_ENABLE_Msk = 0x1
	// Bit ENABLE.
	DCP_PAGETABLE_ENABLE = 0x1
	// Position of FLUSH field.
	DCP_PAGETABLE_FLUSH_Pos = 0x1
	// Bit mask of FLUSH field.
	DCP_PAGETABLE_FLUSH_Msk = 0x2
	// Bit FLUSH.
	DCP_PAGETABLE_FLUSH = 0x2
	// Position of BASE field.
	DCP_PAGETABLE_BASE_Pos = 0x2
	// Bit mask of BASE field.
	DCP_PAGETABLE_BASE_Msk = 0xfffffffc

	// VERSION: DCP version register
	// Position of STEP field.
	DCP_VERSION_STEP_Pos = 0x0
	// Bit mask of STEP field.
	DCP_VERSION_STEP_Msk = 0xffff
	// Position of MINOR field.
	DCP_VERSION_MINOR_Pos = 0x10
	// Bit mask of MINOR field.
	DCP_VERSION_MINOR_Msk = 0xff0000
	// Position of MAJOR field.
	DCP_VERSION_MAJOR_Pos = 0x18
	// Bit mask of MAJOR field.
	DCP_VERSION_MAJOR_Msk = 0xff000000
)

// Bitfields for SPDIF: SPDIF
const (
	// SCR: SPDIF Configuration Register
	// Position of USrc_Sel field.
	SPDIF_SCR_USrc_Sel_Pos = 0x0
	// Bit mask of USrc_Sel field.
	SPDIF_SCR_USrc_Sel_Msk = 0x3
	// No embedded U channel
	SPDIF_SCR_USrc_Sel_USrc_Sel_0 = 0x0
	// U channel from SPDIF receive block (CD mode)
	SPDIF_SCR_USrc_Sel_USrc_Sel_1 = 0x1
	// U channel from on chip transmitter
	SPDIF_SCR_USrc_Sel_USrc_Sel_3 = 0x3
	// Position of TxSel field.
	SPDIF_SCR_TxSel_Pos = 0x2
	// Bit mask of TxSel field.
	SPDIF_SCR_TxSel_Msk = 0x1c
	// Off and output 0
	SPDIF_SCR_TxSel_TxSel_0 = 0x0
	// Feed-through SPDIFIN
	SPDIF_SCR_TxSel_TxSel_1 = 0x1
	// Tx Normal operation
	SPDIF_SCR_TxSel_TxSel_5 = 0x5
	// Position of ValCtrl field.
	SPDIF_SCR_ValCtrl_Pos = 0x5
	// Bit mask of ValCtrl field.
	SPDIF_SCR_ValCtrl_Msk = 0x20
	// Bit ValCtrl.
	SPDIF_SCR_ValCtrl = 0x20
	// Outgoing Validity always set
	SPDIF_SCR_ValCtrl_ValCtrl_0 = 0x0
	// Outgoing Validity always clear
	SPDIF_SCR_ValCtrl_ValCtrl_1 = 0x1
	// Position of DMA_TX_En field.
	SPDIF_SCR_DMA_TX_En_Pos = 0x8
	// Bit mask of DMA_TX_En field.
	SPDIF_SCR_DMA_TX_En_Msk = 0x100
	// Bit DMA_TX_En.
	SPDIF_SCR_DMA_TX_En = 0x100
	// Position of DMA_Rx_En field.
	SPDIF_SCR_DMA_Rx_En_Pos = 0x9
	// Bit mask of DMA_Rx_En field.
	SPDIF_SCR_DMA_Rx_En_Msk = 0x200
	// Bit DMA_Rx_En.
	SPDIF_SCR_DMA_Rx_En = 0x200
	// Position of TxFIFO_Ctrl field.
	SPDIF_SCR_TxFIFO_Ctrl_Pos = 0xa
	// Bit mask of TxFIFO_Ctrl field.
	SPDIF_SCR_TxFIFO_Ctrl_Msk = 0xc00
	// Send out digital zero on SPDIF Tx
	SPDIF_SCR_TxFIFO_Ctrl_TxFIFO_Ctrl_0 = 0x0
	// Tx Normal operation
	SPDIF_SCR_TxFIFO_Ctrl_TxFIFO_Ctrl_1 = 0x1
	// Reset to 1 sample remaining
	SPDIF_SCR_TxFIFO_Ctrl_TxFIFO_Ctrl_2 = 0x2
	// Position of SOFT_RESET field.
	SPDIF_SCR_SOFT_RESET_Pos = 0xc
	// Bit mask of SOFT_RESET field.
	SPDIF_SCR_SOFT_RESET_Msk = 0x1000
	// Bit SOFT_RESET.
	SPDIF_SCR_SOFT_RESET = 0x1000
	// Position of LOW_POWER field.
	SPDIF_SCR_LOW_POWER_Pos = 0xd
	// Bit mask of LOW_POWER field.
	SPDIF_SCR_LOW_POWER_Msk = 0x2000
	// Bit LOW_POWER.
	SPDIF_SCR_LOW_POWER = 0x2000
	// Position of TxFIFOEmpty_Sel field.
	SPDIF_SCR_TxFIFOEmpty_Sel_Pos = 0xf
	// Bit mask of TxFIFOEmpty_Sel field.
	SPDIF_SCR_TxFIFOEmpty_Sel_Msk = 0x18000
	// Empty interrupt if 0 sample in Tx left and right FIFOs
	SPDIF_SCR_TxFIFOEmpty_Sel_TxFIFOEmpty_Sel_0 = 0x0
	// Empty interrupt if at most 4 sample in Tx left and right FIFOs
	SPDIF_SCR_TxFIFOEmpty_Sel_TxFIFOEmpty_Sel_1 = 0x1
	// Empty interrupt if at most 8 sample in Tx left and right FIFOs
	SPDIF_SCR_TxFIFOEmpty_Sel_TxFIFOEmpty_Sel_2 = 0x2
	// Empty interrupt if at most 12 sample in Tx left and right FIFOs
	SPDIF_SCR_TxFIFOEmpty_Sel_TxFIFOEmpty_Sel_3 = 0x3
	// Position of TxAutoSync field.
	SPDIF_SCR_TxAutoSync_Pos = 0x11
	// Bit mask of TxAutoSync field.
	SPDIF_SCR_TxAutoSync_Msk = 0x20000
	// Bit TxAutoSync.
	SPDIF_SCR_TxAutoSync = 0x20000
	// Tx FIFO auto sync off
	SPDIF_SCR_TxAutoSync_TxAutoSync_0 = 0x0
	// Tx FIFO auto sync on
	SPDIF_SCR_TxAutoSync_TxAutoSync_1 = 0x1
	// Position of RxAutoSync field.
	SPDIF_SCR_RxAutoSync_Pos = 0x12
	// Bit mask of RxAutoSync field.
	SPDIF_SCR_RxAutoSync_Msk = 0x40000
	// Bit RxAutoSync.
	SPDIF_SCR_RxAutoSync = 0x40000
	// Rx FIFO auto sync off
	SPDIF_SCR_RxAutoSync_RxAutoSync_0 = 0x0
	// RxFIFO auto sync on
	SPDIF_SCR_RxAutoSync_RxAutoSync_1 = 0x1
	// Position of RxFIFOFull_Sel field.
	SPDIF_SCR_RxFIFOFull_Sel_Pos = 0x13
	// Bit mask of RxFIFOFull_Sel field.
	SPDIF_SCR_RxFIFOFull_Sel_Msk = 0x180000
	// Full interrupt if at least 1 sample in Rx left and right FIFOs
	SPDIF_SCR_RxFIFOFull_Sel_RxFIFOFull_Sel_0 = 0x0
	// Full interrupt if at least 4 sample in Rx left and right FIFOs
	SPDIF_SCR_RxFIFOFull_Sel_RxFIFOFull_Sel_1 = 0x1
	// Full interrupt if at least 8 sample in Rx left and right FIFOs
	SPDIF_SCR_RxFIFOFull_Sel_RxFIFOFull_Sel_2 = 0x2
	// Full interrupt if at least 16 sample in Rx left and right FIFO
	SPDIF_SCR_RxFIFOFull_Sel_RxFIFOFull_Sel_3 = 0x3
	// Position of RxFIFO_Rst field.
	SPDIF_SCR_RxFIFO_Rst_Pos = 0x15
	// Bit mask of RxFIFO_Rst field.
	SPDIF_SCR_RxFIFO_Rst_Msk = 0x200000
	// Bit RxFIFO_Rst.
	SPDIF_SCR_RxFIFO_Rst = 0x200000
	// Normal operation
	SPDIF_SCR_RxFIFO_Rst_RxFIFO_Rst_0 = 0x0
	// Reset register to 1 sample remaining
	SPDIF_SCR_RxFIFO_Rst_RxFIFO_Rst_1 = 0x1
	// Position of RxFIFO_Off_On field.
	SPDIF_SCR_RxFIFO_Off_On_Pos = 0x16
	// Bit mask of RxFIFO_Off_On field.
	SPDIF_SCR_RxFIFO_Off_On_Msk = 0x400000
	// Bit RxFIFO_Off_On.
	SPDIF_SCR_RxFIFO_Off_On = 0x400000
	// SPDIF Rx FIFO is on
	SPDIF_SCR_RxFIFO_Off_On_RxFIFO_Off_On_0 = 0x0
	// SPDIF Rx FIFO is off. Does not accept data from interface
	SPDIF_SCR_RxFIFO_Off_On_RxFIFO_Off_On_1 = 0x1
	// Position of RxFIFO_Ctrl field.
	SPDIF_SCR_RxFIFO_Ctrl_Pos = 0x17
	// Bit mask of RxFIFO_Ctrl field.
	SPDIF_SCR_RxFIFO_Ctrl_Msk = 0x800000
	// Bit RxFIFO_Ctrl.
	SPDIF_SCR_RxFIFO_Ctrl = 0x800000
	// Normal operation
	SPDIF_SCR_RxFIFO_Ctrl_RxFIFO_Ctrl_0 = 0x0
	// Always read zero from Rx data register
	SPDIF_SCR_RxFIFO_Ctrl_RxFIFO_Ctrl_1 = 0x1

	// SRCD: CDText Control Register
	// Position of USyncMode field.
	SPDIF_SRCD_USyncMode_Pos = 0x1
	// Bit mask of USyncMode field.
	SPDIF_SRCD_USyncMode_Msk = 0x2
	// Bit USyncMode.
	SPDIF_SRCD_USyncMode = 0x2
	// Non-CD data
	SPDIF_SRCD_USyncMode_USyncMode_0 = 0x0
	// CD user channel subcode
	SPDIF_SRCD_USyncMode_USyncMode_1 = 0x1

	// SRPC: PhaseConfig Register
	// Position of GainSel field.
	SPDIF_SRPC_GainSel_Pos = 0x3
	// Bit mask of GainSel field.
	SPDIF_SRPC_GainSel_Msk = 0x38
	// 24*(2**10)
	SPDIF_SRPC_GainSel_GainSel_0 = 0x0
	// 16*(2**10)
	SPDIF_SRPC_GainSel_GainSel_1 = 0x1
	// 12*(2**10)
	SPDIF_SRPC_GainSel_GainSel_2 = 0x2
	// 8*(2**10)
	SPDIF_SRPC_GainSel_GainSel_3 = 0x3
	// 6*(2**10)
	SPDIF_SRPC_GainSel_GainSel_4 = 0x4
	// 4*(2**10)
	SPDIF_SRPC_GainSel_GainSel_5 = 0x5
	// 3*(2**10)
	SPDIF_SRPC_GainSel_GainSel_6 = 0x6
	// Position of LOCK field.
	SPDIF_SRPC_LOCK_Pos = 0x6
	// Bit mask of LOCK field.
	SPDIF_SRPC_LOCK_Msk = 0x40
	// Bit LOCK.
	SPDIF_SRPC_LOCK = 0x40
	// Position of ClkSrc_Sel field.
	SPDIF_SRPC_ClkSrc_Sel_Pos = 0x7
	// Bit mask of ClkSrc_Sel field.
	SPDIF_SRPC_ClkSrc_Sel_Msk = 0x780
	// if (DPLL Locked) SPDIF_RxClk else REF_CLK_32K (XTALOSC)
	SPDIF_SRPC_ClkSrc_Sel_ClkSrc_Sel_0 = 0x0
	// if (DPLL Locked) SPDIF_RxClk else tx_clk (SPDIF0_CLK_ROOT)
	SPDIF_SRPC_ClkSrc_Sel_ClkSrc_Sel_1 = 0x1
	// if (DPLL Locked) SPDIF_RxClk else SPDIF_EXT_CLK
	SPDIF_SRPC_ClkSrc_Sel_ClkSrc_Sel_3 = 0x3
	// REF_CLK_32K (XTALOSC)
	SPDIF_SRPC_ClkSrc_Sel_ClkSrc_Sel_5 = 0x5
	// tx_clk (SPDIF0_CLK_ROOT)
	SPDIF_SRPC_ClkSrc_Sel_ClkSrc_Sel_6 = 0x6
	// SPDIF_EXT_CLK
	SPDIF_SRPC_ClkSrc_Sel_ClkSrc_Sel_8 = 0x8

	// SIE: InterruptEn Register
	// Position of RxFIFOFul field.
	SPDIF_SIE_RxFIFOFul_Pos = 0x0
	// Bit mask of RxFIFOFul field.
	SPDIF_SIE_RxFIFOFul_Msk = 0x1
	// Bit RxFIFOFul.
	SPDIF_SIE_RxFIFOFul = 0x1
	// Position of TxEm field.
	SPDIF_SIE_TxEm_Pos = 0x1
	// Bit mask of TxEm field.
	SPDIF_SIE_TxEm_Msk = 0x2
	// Bit TxEm.
	SPDIF_SIE_TxEm = 0x2
	// Position of LockLoss field.
	SPDIF_SIE_LockLoss_Pos = 0x2
	// Bit mask of LockLoss field.
	SPDIF_SIE_LockLoss_Msk = 0x4
	// Bit LockLoss.
	SPDIF_SIE_LockLoss = 0x4
	// Position of RxFIFOResyn field.
	SPDIF_SIE_RxFIFOResyn_Pos = 0x3
	// Bit mask of RxFIFOResyn field.
	SPDIF_SIE_RxFIFOResyn_Msk = 0x8
	// Bit RxFIFOResyn.
	SPDIF_SIE_RxFIFOResyn = 0x8
	// Position of RxFIFOUnOv field.
	SPDIF_SIE_RxFIFOUnOv_Pos = 0x4
	// Bit mask of RxFIFOUnOv field.
	SPDIF_SIE_RxFIFOUnOv_Msk = 0x10
	// Bit RxFIFOUnOv.
	SPDIF_SIE_RxFIFOUnOv = 0x10
	// Position of UQErr field.
	SPDIF_SIE_UQErr_Pos = 0x5
	// Bit mask of UQErr field.
	SPDIF_SIE_UQErr_Msk = 0x20
	// Bit UQErr.
	SPDIF_SIE_UQErr = 0x20
	// Position of UQSync field.
	SPDIF_SIE_UQSync_Pos = 0x6
	// Bit mask of UQSync field.
	SPDIF_SIE_UQSync_Msk = 0x40
	// Bit UQSync.
	SPDIF_SIE_UQSync = 0x40
	// Position of QRxOv field.
	SPDIF_SIE_QRxOv_Pos = 0x7
	// Bit mask of QRxOv field.
	SPDIF_SIE_QRxOv_Msk = 0x80
	// Bit QRxOv.
	SPDIF_SIE_QRxOv = 0x80
	// Position of QRxFul field.
	SPDIF_SIE_QRxFul_Pos = 0x8
	// Bit mask of QRxFul field.
	SPDIF_SIE_QRxFul_Msk = 0x100
	// Bit QRxFul.
	SPDIF_SIE_QRxFul = 0x100
	// Position of URxOv field.
	SPDIF_SIE_URxOv_Pos = 0x9
	// Bit mask of URxOv field.
	SPDIF_SIE_URxOv_Msk = 0x200
	// Bit URxOv.
	SPDIF_SIE_URxOv = 0x200
	// Position of URxFul field.
	SPDIF_SIE_URxFul_Pos = 0xa
	// Bit mask of URxFul field.
	SPDIF_SIE_URxFul_Msk = 0x400
	// Bit URxFul.
	SPDIF_SIE_URxFul = 0x400
	// Position of BitErr field.
	SPDIF_SIE_BitErr_Pos = 0xe
	// Bit mask of BitErr field.
	SPDIF_SIE_BitErr_Msk = 0x4000
	// Bit BitErr.
	SPDIF_SIE_BitErr = 0x4000
	// Position of SymErr field.
	SPDIF_SIE_SymErr_Pos = 0xf
	// Bit mask of SymErr field.
	SPDIF_SIE_SymErr_Msk = 0x8000
	// Bit SymErr.
	SPDIF_SIE_SymErr = 0x8000
	// Position of ValNoGood field.
	SPDIF_SIE_ValNoGood_Pos = 0x10
	// Bit mask of ValNoGood field.
	SPDIF_SIE_ValNoGood_Msk = 0x10000
	// Bit ValNoGood.
	SPDIF_SIE_ValNoGood = 0x10000
	// Position of CNew field.
	SPDIF_SIE_CNew_Pos = 0x11
	// Bit mask of CNew field.
	SPDIF_SIE_CNew_Msk = 0x20000
	// Bit CNew.
	SPDIF_SIE_CNew = 0x20000
	// Position of TxResyn field.
	SPDIF_SIE_TxResyn_Pos = 0x12
	// Bit mask of TxResyn field.
	SPDIF_SIE_TxResyn_Msk = 0x40000
	// Bit TxResyn.
	SPDIF_SIE_TxResyn = 0x40000
	// Position of TxUnOv field.
	SPDIF_SIE_TxUnOv_Pos = 0x13
	// Bit mask of TxUnOv field.
	SPDIF_SIE_TxUnOv_Msk = 0x80000
	// Bit TxUnOv.
	SPDIF_SIE_TxUnOv = 0x80000
	// Position of Lock field.
	SPDIF_SIE_Lock_Pos = 0x14
	// Bit mask of Lock field.
	SPDIF_SIE_Lock_Msk = 0x100000
	// Bit Lock.
	SPDIF_SIE_Lock = 0x100000

	// SIC: InterruptClear Register
	// Position of LockLoss field.
	SPDIF_SIC_LockLoss_Pos = 0x2
	// Bit mask of LockLoss field.
	SPDIF_SIC_LockLoss_Msk = 0x4
	// Bit LockLoss.
	SPDIF_SIC_LockLoss = 0x4
	// Position of RxFIFOResyn field.
	SPDIF_SIC_RxFIFOResyn_Pos = 0x3
	// Bit mask of RxFIFOResyn field.
	SPDIF_SIC_RxFIFOResyn_Msk = 0x8
	// Bit RxFIFOResyn.
	SPDIF_SIC_RxFIFOResyn = 0x8
	// Position of RxFIFOUnOv field.
	SPDIF_SIC_RxFIFOUnOv_Pos = 0x4
	// Bit mask of RxFIFOUnOv field.
	SPDIF_SIC_RxFIFOUnOv_Msk = 0x10
	// Bit RxFIFOUnOv.
	SPDIF_SIC_RxFIFOUnOv = 0x10
	// Position of UQErr field.
	SPDIF_SIC_UQErr_Pos = 0x5
	// Bit mask of UQErr field.
	SPDIF_SIC_UQErr_Msk = 0x20
	// Bit UQErr.
	SPDIF_SIC_UQErr = 0x20
	// Position of UQSync field.
	SPDIF_SIC_UQSync_Pos = 0x6
	// Bit mask of UQSync field.
	SPDIF_SIC_UQSync_Msk = 0x40
	// Bit UQSync.
	SPDIF_SIC_UQSync = 0x40
	// Position of QRxOv field.
	SPDIF_SIC_QRxOv_Pos = 0x7
	// Bit mask of QRxOv field.
	SPDIF_SIC_QRxOv_Msk = 0x80
	// Bit QRxOv.
	SPDIF_SIC_QRxOv = 0x80
	// Position of URxOv field.
	SPDIF_SIC_URxOv_Pos = 0x9
	// Bit mask of URxOv field.
	SPDIF_SIC_URxOv_Msk = 0x200
	// Bit URxOv.
	SPDIF_SIC_URxOv = 0x200
	// Position of BitErr field.
	SPDIF_SIC_BitErr_Pos = 0xe
	// Bit mask of BitErr field.
	SPDIF_SIC_BitErr_Msk = 0x4000
	// Bit BitErr.
	SPDIF_SIC_BitErr = 0x4000
	// Position of SymErr field.
	SPDIF_SIC_SymErr_Pos = 0xf
	// Bit mask of SymErr field.
	SPDIF_SIC_SymErr_Msk = 0x8000
	// Bit SymErr.
	SPDIF_SIC_SymErr = 0x8000
	// Position of ValNoGood field.
	SPDIF_SIC_ValNoGood_Pos = 0x10
	// Bit mask of ValNoGood field.
	SPDIF_SIC_ValNoGood_Msk = 0x10000
	// Bit ValNoGood.
	SPDIF_SIC_ValNoGood = 0x10000
	// Position of CNew field.
	SPDIF_SIC_CNew_Pos = 0x11
	// Bit mask of CNew field.
	SPDIF_SIC_CNew_Msk = 0x20000
	// Bit CNew.
	SPDIF_SIC_CNew = 0x20000
	// Position of TxResyn field.
	SPDIF_SIC_TxResyn_Pos = 0x12
	// Bit mask of TxResyn field.
	SPDIF_SIC_TxResyn_Msk = 0x40000
	// Bit TxResyn.
	SPDIF_SIC_TxResyn = 0x40000
	// Position of TxUnOv field.
	SPDIF_SIC_TxUnOv_Pos = 0x13
	// Bit mask of TxUnOv field.
	SPDIF_SIC_TxUnOv_Msk = 0x80000
	// Bit TxUnOv.
	SPDIF_SIC_TxUnOv = 0x80000
	// Position of Lock field.
	SPDIF_SIC_Lock_Pos = 0x14
	// Bit mask of Lock field.
	SPDIF_SIC_Lock_Msk = 0x100000
	// Bit Lock.
	SPDIF_SIC_Lock = 0x100000

	// SIS: InterruptStat Register
	// Position of RxFIFOFul field.
	SPDIF_SIS_RxFIFOFul_Pos = 0x0
	// Bit mask of RxFIFOFul field.
	SPDIF_SIS_RxFIFOFul_Msk = 0x1
	// Bit RxFIFOFul.
	SPDIF_SIS_RxFIFOFul = 0x1
	// Position of TxEm field.
	SPDIF_SIS_TxEm_Pos = 0x1
	// Bit mask of TxEm field.
	SPDIF_SIS_TxEm_Msk = 0x2
	// Bit TxEm.
	SPDIF_SIS_TxEm = 0x2
	// Position of LockLoss field.
	SPDIF_SIS_LockLoss_Pos = 0x2
	// Bit mask of LockLoss field.
	SPDIF_SIS_LockLoss_Msk = 0x4
	// Bit LockLoss.
	SPDIF_SIS_LockLoss = 0x4
	// Position of RxFIFOResyn field.
	SPDIF_SIS_RxFIFOResyn_Pos = 0x3
	// Bit mask of RxFIFOResyn field.
	SPDIF_SIS_RxFIFOResyn_Msk = 0x8
	// Bit RxFIFOResyn.
	SPDIF_SIS_RxFIFOResyn = 0x8
	// Position of RxFIFOUnOv field.
	SPDIF_SIS_RxFIFOUnOv_Pos = 0x4
	// Bit mask of RxFIFOUnOv field.
	SPDIF_SIS_RxFIFOUnOv_Msk = 0x10
	// Bit RxFIFOUnOv.
	SPDIF_SIS_RxFIFOUnOv = 0x10
	// Position of UQErr field.
	SPDIF_SIS_UQErr_Pos = 0x5
	// Bit mask of UQErr field.
	SPDIF_SIS_UQErr_Msk = 0x20
	// Bit UQErr.
	SPDIF_SIS_UQErr = 0x20
	// Position of UQSync field.
	SPDIF_SIS_UQSync_Pos = 0x6
	// Bit mask of UQSync field.
	SPDIF_SIS_UQSync_Msk = 0x40
	// Bit UQSync.
	SPDIF_SIS_UQSync = 0x40
	// Position of QRxOv field.
	SPDIF_SIS_QRxOv_Pos = 0x7
	// Bit mask of QRxOv field.
	SPDIF_SIS_QRxOv_Msk = 0x80
	// Bit QRxOv.
	SPDIF_SIS_QRxOv = 0x80
	// Position of QRxFul field.
	SPDIF_SIS_QRxFul_Pos = 0x8
	// Bit mask of QRxFul field.
	SPDIF_SIS_QRxFul_Msk = 0x100
	// Bit QRxFul.
	SPDIF_SIS_QRxFul = 0x100
	// Position of URxOv field.
	SPDIF_SIS_URxOv_Pos = 0x9
	// Bit mask of URxOv field.
	SPDIF_SIS_URxOv_Msk = 0x200
	// Bit URxOv.
	SPDIF_SIS_URxOv = 0x200
	// Position of URxFul field.
	SPDIF_SIS_URxFul_Pos = 0xa
	// Bit mask of URxFul field.
	SPDIF_SIS_URxFul_Msk = 0x400
	// Bit URxFul.
	SPDIF_SIS_URxFul = 0x400
	// Position of BitErr field.
	SPDIF_SIS_BitErr_Pos = 0xe
	// Bit mask of BitErr field.
	SPDIF_SIS_BitErr_Msk = 0x4000
	// Bit BitErr.
	SPDIF_SIS_BitErr = 0x4000
	// Position of SymErr field.
	SPDIF_SIS_SymErr_Pos = 0xf
	// Bit mask of SymErr field.
	SPDIF_SIS_SymErr_Msk = 0x8000
	// Bit SymErr.
	SPDIF_SIS_SymErr = 0x8000
	// Position of ValNoGood field.
	SPDIF_SIS_ValNoGood_Pos = 0x10
	// Bit mask of ValNoGood field.
	SPDIF_SIS_ValNoGood_Msk = 0x10000
	// Bit ValNoGood.
	SPDIF_SIS_ValNoGood = 0x10000
	// Position of CNew field.
	SPDIF_SIS_CNew_Pos = 0x11
	// Bit mask of CNew field.
	SPDIF_SIS_CNew_Msk = 0x20000
	// Bit CNew.
	SPDIF_SIS_CNew = 0x20000
	// Position of TxResyn field.
	SPDIF_SIS_TxResyn_Pos = 0x12
	// Bit mask of TxResyn field.
	SPDIF_SIS_TxResyn_Msk = 0x40000
	// Bit TxResyn.
	SPDIF_SIS_TxResyn = 0x40000
	// Position of TxUnOv field.
	SPDIF_SIS_TxUnOv_Pos = 0x13
	// Bit mask of TxUnOv field.
	SPDIF_SIS_TxUnOv_Msk = 0x80000
	// Bit TxUnOv.
	SPDIF_SIS_TxUnOv = 0x80000
	// Position of Lock field.
	SPDIF_SIS_Lock_Pos = 0x14
	// Bit mask of Lock field.
	SPDIF_SIS_Lock_Msk = 0x100000
	// Bit Lock.
	SPDIF_SIS_Lock = 0x100000

	// SRL: SPDIFRxLeft Register
	// Position of RxDataLeft field.
	SPDIF_SRL_RxDataLeft_Pos = 0x0
	// Bit mask of RxDataLeft field.
	SPDIF_SRL_RxDataLeft_Msk = 0xffffff

	// SRR: SPDIFRxRight Register
	// Position of RxDataRight field.
	SPDIF_SRR_RxDataRight_Pos = 0x0
	// Bit mask of RxDataRight field.
	SPDIF_SRR_RxDataRight_Msk = 0xffffff

	// SRCSH: SPDIFRxCChannel_h Register
	// Position of RxCChannel_h field.
	SPDIF_SRCSH_RxCChannel_h_Pos = 0x0
	// Bit mask of RxCChannel_h field.
	SPDIF_SRCSH_RxCChannel_h_Msk = 0xffffff

	// SRCSL: SPDIFRxCChannel_l Register
	// Position of RxCChannel_l field.
	SPDIF_SRCSL_RxCChannel_l_Pos = 0x0
	// Bit mask of RxCChannel_l field.
	SPDIF_SRCSL_RxCChannel_l_Msk = 0xffffff

	// SRU: UchannelRx Register
	// Position of RxUChannel field.
	SPDIF_SRU_RxUChannel_Pos = 0x0
	// Bit mask of RxUChannel field.
	SPDIF_SRU_RxUChannel_Msk = 0xffffff

	// SRQ: QchannelRx Register
	// Position of RxQChannel field.
	SPDIF_SRQ_RxQChannel_Pos = 0x0
	// Bit mask of RxQChannel field.
	SPDIF_SRQ_RxQChannel_Msk = 0xffffff

	// STL: SPDIFTxLeft Register
	// Position of TxDataLeft field.
	SPDIF_STL_TxDataLeft_Pos = 0x0
	// Bit mask of TxDataLeft field.
	SPDIF_STL_TxDataLeft_Msk = 0xffffff

	// STR: SPDIFTxRight Register
	// Position of TxDataRight field.
	SPDIF_STR_TxDataRight_Pos = 0x0
	// Bit mask of TxDataRight field.
	SPDIF_STR_TxDataRight_Msk = 0xffffff

	// STCSCH: SPDIFTxCChannelCons_h Register
	// Position of TxCChannelCons_h field.
	SPDIF_STCSCH_TxCChannelCons_h_Pos = 0x0
	// Bit mask of TxCChannelCons_h field.
	SPDIF_STCSCH_TxCChannelCons_h_Msk = 0xffffff

	// STCSCL: SPDIFTxCChannelCons_l Register
	// Position of TxCChannelCons_l field.
	SPDIF_STCSCL_TxCChannelCons_l_Pos = 0x0
	// Bit mask of TxCChannelCons_l field.
	SPDIF_STCSCL_TxCChannelCons_l_Msk = 0xffffff

	// SRFM: FreqMeas Register
	// Position of FreqMeas field.
	SPDIF_SRFM_FreqMeas_Pos = 0x0
	// Bit mask of FreqMeas field.
	SPDIF_SRFM_FreqMeas_Msk = 0xffffff

	// STC: SPDIFTxClk Register
	// Position of TxClk_DF field.
	SPDIF_STC_TxClk_DF_Pos = 0x0
	// Bit mask of TxClk_DF field.
	SPDIF_STC_TxClk_DF_Msk = 0x7f
	// divider factor is 1
	SPDIF_STC_TxClk_DF_TxClk_DF_0 = 0x0
	// divider factor is 2
	SPDIF_STC_TxClk_DF_TxClk_DF_1 = 0x1
	// divider factor is 128
	SPDIF_STC_TxClk_DF_TxClk_DF_127 = 0x7f
	// Position of TX_ALL_CLK_EN field.
	SPDIF_STC_TX_ALL_CLK_EN_Pos = 0x7
	// Bit mask of TX_ALL_CLK_EN field.
	SPDIF_STC_TX_ALL_CLK_EN_Msk = 0x80
	// Bit TX_ALL_CLK_EN.
	SPDIF_STC_TX_ALL_CLK_EN = 0x80
	// disable transfer clock.
	SPDIF_STC_TX_ALL_CLK_EN_TX_ALL_CLK_EN_0 = 0x0
	// enable transfer clock.
	SPDIF_STC_TX_ALL_CLK_EN_TX_ALL_CLK_EN_1 = 0x1
	// Position of TxClk_Source field.
	SPDIF_STC_TxClk_Source_Pos = 0x8
	// Bit mask of TxClk_Source field.
	SPDIF_STC_TxClk_Source_Msk = 0x700
	// XTALOSC input (XTALOSC clock)
	SPDIF_STC_TxClk_Source_TxClk_Source_0 = 0x0
	// tx_clk input (from SPDIF0_CLK_ROOT. See CCM.)
	SPDIF_STC_TxClk_Source_TxClk_Source_1 = 0x1
	// tx_clk1 (from SAI1)
	SPDIF_STC_TxClk_Source_TxClk_Source_2 = 0x2
	// tx_clk2 SPDIF_EXT_CLK, from pads
	SPDIF_STC_TxClk_Source_TxClk_Source_3 = 0x3
	// tx_clk3 (from SAI2)
	SPDIF_STC_TxClk_Source_TxClk_Source_4 = 0x4
	// ipg_clk input (frequency divided)
	SPDIF_STC_TxClk_Source_TxClk_Source_5 = 0x5
	// tx_clk4 (from SAI3)
	SPDIF_STC_TxClk_Source_TxClk_Source_6 = 0x6
	// Position of SYSCLK_DF field.
	SPDIF_STC_SYSCLK_DF_Pos = 0xb
	// Bit mask of SYSCLK_DF field.
	SPDIF_STC_SYSCLK_DF_Msk = 0xff800
	// no clock signal
	SPDIF_STC_SYSCLK_DF_SYSCLK_DF_0 = 0x0
	// divider factor is 2
	SPDIF_STC_SYSCLK_DF_SYSCLK_DF_1 = 0x1
	// divider factor is 512
	SPDIF_STC_SYSCLK_DF_SYSCLK_DF_511 = 0x1ff
)

// Bitfields for SAI1: I2S
const (
	// VERID: Version ID Register
	// Position of FEATURE field.
	I2S_VERID_FEATURE_Pos = 0x0
	// Bit mask of FEATURE field.
	I2S_VERID_FEATURE_Msk = 0xffff
	// Standard feature set.
	I2S_VERID_FEATURE_FEATURE_0 = 0x0
	// Position of MINOR field.
	I2S_VERID_MINOR_Pos = 0x10
	// Bit mask of MINOR field.
	I2S_VERID_MINOR_Msk = 0xff0000
	// Position of MAJOR field.
	I2S_VERID_MAJOR_Pos = 0x18
	// Bit mask of MAJOR field.
	I2S_VERID_MAJOR_Msk = 0xff000000

	// PARAM: Parameter Register
	// Position of DATALINE field.
	I2S_PARAM_DATALINE_Pos = 0x0
	// Bit mask of DATALINE field.
	I2S_PARAM_DATALINE_Msk = 0xf
	// Position of FIFO field.
	I2S_PARAM_FIFO_Pos = 0x8
	// Bit mask of FIFO field.
	I2S_PARAM_FIFO_Msk = 0xf00
	// Position of FRAME field.
	I2S_PARAM_FRAME_Pos = 0x10
	// Bit mask of FRAME field.
	I2S_PARAM_FRAME_Msk = 0xf0000

	// TCSR: SAI Transmit Control Register
	// Position of FRDE field.
	I2S_TCSR_FRDE_Pos = 0x0
	// Bit mask of FRDE field.
	I2S_TCSR_FRDE_Msk = 0x1
	// Bit FRDE.
	I2S_TCSR_FRDE = 0x1
	// Disables the DMA request.
	I2S_TCSR_FRDE_FRDE_0 = 0x0
	// Enables the DMA request.
	I2S_TCSR_FRDE_FRDE_1 = 0x1
	// Position of FWDE field.
	I2S_TCSR_FWDE_Pos = 0x1
	// Bit mask of FWDE field.
	I2S_TCSR_FWDE_Msk = 0x2
	// Bit FWDE.
	I2S_TCSR_FWDE = 0x2
	// Disables the DMA request.
	I2S_TCSR_FWDE_FWDE_0 = 0x0
	// Enables the DMA request.
	I2S_TCSR_FWDE_FWDE_1 = 0x1
	// Position of FRIE field.
	I2S_TCSR_FRIE_Pos = 0x8
	// Bit mask of FRIE field.
	I2S_TCSR_FRIE_Msk = 0x100
	// Bit FRIE.
	I2S_TCSR_FRIE = 0x100
	// Disables the interrupt.
	I2S_TCSR_FRIE_FRIE_0 = 0x0
	// Enables the interrupt.
	I2S_TCSR_FRIE_FRIE_1 = 0x1
	// Position of FWIE field.
	I2S_TCSR_FWIE_Pos = 0x9
	// Bit mask of FWIE field.
	I2S_TCSR_FWIE_Msk = 0x200
	// Bit FWIE.
	I2S_TCSR_FWIE = 0x200
	// Disables the interrupt.
	I2S_TCSR_FWIE_FWIE_0 = 0x0
	// Enables the interrupt.
	I2S_TCSR_FWIE_FWIE_1 = 0x1
	// Position of FEIE field.
	I2S_TCSR_FEIE_Pos = 0xa
	// Bit mask of FEIE field.
	I2S_TCSR_FEIE_Msk = 0x400
	// Bit FEIE.
	I2S_TCSR_FEIE = 0x400
	// Disables the interrupt.
	I2S_TCSR_FEIE_FEIE_0 = 0x0
	// Enables the interrupt.
	I2S_TCSR_FEIE_FEIE_1 = 0x1
	// Position of SEIE field.
	I2S_TCSR_SEIE_Pos = 0xb
	// Bit mask of SEIE field.
	I2S_TCSR_SEIE_Msk = 0x800
	// Bit SEIE.
	I2S_TCSR_SEIE = 0x800
	// Disables interrupt.
	I2S_TCSR_SEIE_SEIE_0 = 0x0
	// Enables interrupt.
	I2S_TCSR_SEIE_SEIE_1 = 0x1
	// Position of WSIE field.
	I2S_TCSR_WSIE_Pos = 0xc
	// Bit mask of WSIE field.
	I2S_TCSR_WSIE_Msk = 0x1000
	// Bit WSIE.
	I2S_TCSR_WSIE = 0x1000
	// Disables interrupt.
	I2S_TCSR_WSIE_WSIE_0 = 0x0
	// Enables interrupt.
	I2S_TCSR_WSIE_WSIE_1 = 0x1
	// Position of FRF field.
	I2S_TCSR_FRF_Pos = 0x10
	// Bit mask of FRF field.
	I2S_TCSR_FRF_Msk = 0x10000
	// Bit FRF.
	I2S_TCSR_FRF = 0x10000
	// Transmit FIFO watermark has not been reached.
	I2S_TCSR_FRF_FRF_0 = 0x0
	// Transmit FIFO watermark has been reached.
	I2S_TCSR_FRF_FRF_1 = 0x1
	// Position of FWF field.
	I2S_TCSR_FWF_Pos = 0x11
	// Bit mask of FWF field.
	I2S_TCSR_FWF_Msk = 0x20000
	// Bit FWF.
	I2S_TCSR_FWF = 0x20000
	// No enabled transmit FIFO is empty.
	I2S_TCSR_FWF_FWF_0 = 0x0
	// Enabled transmit FIFO is empty.
	I2S_TCSR_FWF_FWF_1 = 0x1
	// Position of FEF field.
	I2S_TCSR_FEF_Pos = 0x12
	// Bit mask of FEF field.
	I2S_TCSR_FEF_Msk = 0x40000
	// Bit FEF.
	I2S_TCSR_FEF = 0x40000
	// Transmit underrun not detected.
	I2S_TCSR_FEF_FEF_0 = 0x0
	// Transmit underrun detected.
	I2S_TCSR_FEF_FEF_1 = 0x1
	// Position of SEF field.
	I2S_TCSR_SEF_Pos = 0x13
	// Bit mask of SEF field.
	I2S_TCSR_SEF_Msk = 0x80000
	// Bit SEF.
	I2S_TCSR_SEF = 0x80000
	// Sync error not detected.
	I2S_TCSR_SEF_SEF_0 = 0x0
	// Frame sync error detected.
	I2S_TCSR_SEF_SEF_1 = 0x1
	// Position of WSF field.
	I2S_TCSR_WSF_Pos = 0x14
	// Bit mask of WSF field.
	I2S_TCSR_WSF_Msk = 0x100000
	// Bit WSF.
	I2S_TCSR_WSF = 0x100000
	// Start of word not detected.
	I2S_TCSR_WSF_WSF_0 = 0x0
	// Start of word detected.
	I2S_TCSR_WSF_WSF_1 = 0x1
	// Position of SR field.
	I2S_TCSR_SR_Pos = 0x18
	// Bit mask of SR field.
	I2S_TCSR_SR_Msk = 0x1000000
	// Bit SR.
	I2S_TCSR_SR = 0x1000000
	// No effect.
	I2S_TCSR_SR_SR_0 = 0x0
	// Software reset.
	I2S_TCSR_SR_SR_1 = 0x1
	// Position of FR field.
	I2S_TCSR_FR_Pos = 0x19
	// Bit mask of FR field.
	I2S_TCSR_FR_Msk = 0x2000000
	// Bit FR.
	I2S_TCSR_FR = 0x2000000
	// No effect.
	I2S_TCSR_FR_FR_0 = 0x0
	// FIFO reset.
	I2S_TCSR_FR_FR_1 = 0x1
	// Position of BCE field.
	I2S_TCSR_BCE_Pos = 0x1c
	// Bit mask of BCE field.
	I2S_TCSR_BCE_Msk = 0x10000000
	// Bit BCE.
	I2S_TCSR_BCE = 0x10000000
	// Transmit bit clock is disabled.
	I2S_TCSR_BCE_BCE_0 = 0x0
	// Transmit bit clock is enabled.
	I2S_TCSR_BCE_BCE_1 = 0x1
	// Position of DBGE field.
	I2S_TCSR_DBGE_Pos = 0x1d
	// Bit mask of DBGE field.
	I2S_TCSR_DBGE_Msk = 0x20000000
	// Bit DBGE.
	I2S_TCSR_DBGE = 0x20000000
	// Transmitter is disabled in Debug mode, after completing the current frame.
	I2S_TCSR_DBGE_DBGE_0 = 0x0
	// Transmitter is enabled in Debug mode.
	I2S_TCSR_DBGE_DBGE_1 = 0x1
	// Position of STOPE field.
	I2S_TCSR_STOPE_Pos = 0x1e
	// Bit mask of STOPE field.
	I2S_TCSR_STOPE_Msk = 0x40000000
	// Bit STOPE.
	I2S_TCSR_STOPE = 0x40000000
	// Transmitter disabled in Stop mode.
	I2S_TCSR_STOPE_STOPE_0 = 0x0
	// Transmitter enabled in Stop mode.
	I2S_TCSR_STOPE_STOPE_1 = 0x1
	// Position of TE field.
	I2S_TCSR_TE_Pos = 0x1f
	// Bit mask of TE field.
	I2S_TCSR_TE_Msk = 0x80000000
	// Bit TE.
	I2S_TCSR_TE = 0x80000000
	// Transmitter is disabled.
	I2S_TCSR_TE_TE_0 = 0x0
	// Transmitter is enabled, or transmitter has been disabled and has not yet reached end of frame.
	I2S_TCSR_TE_TE_1 = 0x1

	// TCR1: SAI Transmit Configuration 1 Register
	// Position of TFW field.
	I2S_TCR1_TFW_Pos = 0x0
	// Bit mask of TFW field.
	I2S_TCR1_TFW_Msk = 0x1f

	// TCR2: SAI Transmit Configuration 2 Register
	// Position of DIV field.
	I2S_TCR2_DIV_Pos = 0x0
	// Bit mask of DIV field.
	I2S_TCR2_DIV_Msk = 0xff
	// Position of BCD field.
	I2S_TCR2_BCD_Pos = 0x18
	// Bit mask of BCD field.
	I2S_TCR2_BCD_Msk = 0x1000000
	// Bit BCD.
	I2S_TCR2_BCD = 0x1000000
	// Bit clock is generated externally in Slave mode.
	I2S_TCR2_BCD_BCD_0 = 0x0
	// Bit clock is generated internally in Master mode.
	I2S_TCR2_BCD_BCD_1 = 0x1
	// Position of BCP field.
	I2S_TCR2_BCP_Pos = 0x19
	// Bit mask of BCP field.
	I2S_TCR2_BCP_Msk = 0x2000000
	// Bit BCP.
	I2S_TCR2_BCP = 0x2000000
	// Bit clock is active high with drive outputs on rising edge and sample inputs on falling edge.
	I2S_TCR2_BCP_BCP_0 = 0x0
	// Bit clock is active low with drive outputs on falling edge and sample inputs on rising edge.
	I2S_TCR2_BCP_BCP_1 = 0x1
	// Position of MSEL field.
	I2S_TCR2_MSEL_Pos = 0x1a
	// Bit mask of MSEL field.
	I2S_TCR2_MSEL_Msk = 0xc000000
	// Bus Clock selected.
	I2S_TCR2_MSEL_MSEL_0 = 0x0
	// Master Clock (MCLK) 1 option selected.
	I2S_TCR2_MSEL_MSEL_1 = 0x1
	// Master Clock (MCLK) 2 option selected.
	I2S_TCR2_MSEL_MSEL_2 = 0x2
	// Master Clock (MCLK) 3 option selected.
	I2S_TCR2_MSEL_MSEL_3 = 0x3
	// Position of BCI field.
	I2S_TCR2_BCI_Pos = 0x1c
	// Bit mask of BCI field.
	I2S_TCR2_BCI_Msk = 0x10000000
	// Bit BCI.
	I2S_TCR2_BCI = 0x10000000
	// No effect.
	I2S_TCR2_BCI_BCI_0 = 0x0
	// Internal logic is clocked as if bit clock was externally generated.
	I2S_TCR2_BCI_BCI_1 = 0x1
	// Position of BCS field.
	I2S_TCR2_BCS_Pos = 0x1d
	// Bit mask of BCS field.
	I2S_TCR2_BCS_Msk = 0x20000000
	// Bit BCS.
	I2S_TCR2_BCS = 0x20000000
	// Use the normal bit clock source.
	I2S_TCR2_BCS_BCS_0 = 0x0
	// Swap the bit clock source.
	I2S_TCR2_BCS_BCS_1 = 0x1
	// Position of SYNC field.
	I2S_TCR2_SYNC_Pos = 0x1e
	// Bit mask of SYNC field.
	I2S_TCR2_SYNC_Msk = 0xc0000000
	// Asynchronous mode.
	I2S_TCR2_SYNC_SYNC_0 = 0x0
	// Synchronous with receiver.
	I2S_TCR2_SYNC_SYNC_1 = 0x1

	// TCR3: SAI Transmit Configuration 3 Register
	// Position of WDFL field.
	I2S_TCR3_WDFL_Pos = 0x0
	// Bit mask of WDFL field.
	I2S_TCR3_WDFL_Msk = 0x1f
	// Position of TCE field.
	I2S_TCR3_TCE_Pos = 0x10
	// Bit mask of TCE field.
	I2S_TCR3_TCE_Msk = 0xf0000
	// Position of CFR field.
	I2S_TCR3_CFR_Pos = 0x18
	// Bit mask of CFR field.
	I2S_TCR3_CFR_Msk = 0xf000000

	// TCR4: SAI Transmit Configuration 4 Register
	// Position of FSD field.
	I2S_TCR4_FSD_Pos = 0x0
	// Bit mask of FSD field.
	I2S_TCR4_FSD_Msk = 0x1
	// Bit FSD.
	I2S_TCR4_FSD = 0x1
	// Frame sync is generated externally in Slave mode.
	I2S_TCR4_FSD_FSD_0 = 0x0
	// Frame sync is generated internally in Master mode.
	I2S_TCR4_FSD_FSD_1 = 0x1
	// Position of FSP field.
	I2S_TCR4_FSP_Pos = 0x1
	// Bit mask of FSP field.
	I2S_TCR4_FSP_Msk = 0x2
	// Bit FSP.
	I2S_TCR4_FSP = 0x2
	// Frame sync is active high.
	I2S_TCR4_FSP_FSP_0 = 0x0
	// Frame sync is active low.
	I2S_TCR4_FSP_FSP_1 = 0x1
	// Position of ONDEM field.
	I2S_TCR4_ONDEM_Pos = 0x2
	// Bit mask of ONDEM field.
	I2S_TCR4_ONDEM_Msk = 0x4
	// Bit ONDEM.
	I2S_TCR4_ONDEM = 0x4
	// Internal frame sync is generated continuously.
	I2S_TCR4_ONDEM_ONDEM_0 = 0x0
	// Internal frame sync is generated when the FIFO warning flag is clear.
	I2S_TCR4_ONDEM_ONDEM_1 = 0x1
	// Position of FSE field.
	I2S_TCR4_FSE_Pos = 0x3
	// Bit mask of FSE field.
	I2S_TCR4_FSE_Msk = 0x8
	// Bit FSE.
	I2S_TCR4_FSE = 0x8
	// Frame sync asserts with the first bit of the frame.
	I2S_TCR4_FSE_FSE_0 = 0x0
	// Frame sync asserts one bit before the first bit of the frame.
	I2S_TCR4_FSE_FSE_1 = 0x1
	// Position of MF field.
	I2S_TCR4_MF_Pos = 0x4
	// Bit mask of MF field.
	I2S_TCR4_MF_Msk = 0x10
	// Bit MF.
	I2S_TCR4_MF = 0x10
	// LSB is transmitted first.
	I2S_TCR4_MF_MF_0 = 0x0
	// MSB is transmitted first.
	I2S_TCR4_MF_MF_1 = 0x1
	// Position of CHMOD field.
	I2S_TCR4_CHMOD_Pos = 0x5
	// Bit mask of CHMOD field.
	I2S_TCR4_CHMOD_Msk = 0x20
	// Bit CHMOD.
	I2S_TCR4_CHMOD = 0x20
	// TDM mode, transmit data pins are tri-stated when slots are masked or channels are disabled.
	I2S_TCR4_CHMOD_CHMOD_0 = 0x0
	// Output mode, transmit data pins are never tri-stated and will output zero when slots are masked or channels are disabled.
	I2S_TCR4_CHMOD_CHMOD_1 = 0x1
	// Position of SYWD field.
	I2S_TCR4_SYWD_Pos = 0x8
	// Bit mask of SYWD field.
	I2S_TCR4_SYWD_Msk = 0x1f00
	// Position of FRSZ field.
	I2S_TCR4_FRSZ_Pos = 0x10
	// Bit mask of FRSZ field.
	I2S_TCR4_FRSZ_Msk = 0x1f0000
	// Position of FPACK field.
	I2S_TCR4_FPACK_Pos = 0x18
	// Bit mask of FPACK field.
	I2S_TCR4_FPACK_Msk = 0x3000000
	// FIFO packing is disabled
	I2S_TCR4_FPACK_FPACK_0 = 0x0
	// 8-bit FIFO packing is enabled
	I2S_TCR4_FPACK_FPACK_2 = 0x2
	// 16-bit FIFO packing is enabled
	I2S_TCR4_FPACK_FPACK_3 = 0x3
	// Position of FCOMB field.
	I2S_TCR4_FCOMB_Pos = 0x1a
	// Bit mask of FCOMB field.
	I2S_TCR4_FCOMB_Msk = 0xc000000
	// FIFO combine mode disabled.
	I2S_TCR4_FCOMB_FCOMB_0 = 0x0
	// FIFO combine mode enabled on FIFO reads (from transmit shift registers).
	I2S_TCR4_FCOMB_FCOMB_1 = 0x1
	// FIFO combine mode enabled on FIFO writes (by software).
	I2S_TCR4_FCOMB_FCOMB_2 = 0x2
	// FIFO combine mode enabled on FIFO reads (from transmit shift registers) and writes (by software).
	I2S_TCR4_FCOMB_FCOMB_3 = 0x3
	// Position of FCONT field.
	I2S_TCR4_FCONT_Pos = 0x1c
	// Bit mask of FCONT field.
	I2S_TCR4_FCONT_Msk = 0x10000000
	// Bit FCONT.
	I2S_TCR4_FCONT = 0x10000000
	// On FIFO error, the SAI will continue from the start of the next frame after the FIFO error flag has been cleared.
	I2S_TCR4_FCONT_FCONT_0 = 0x0
	// On FIFO error, the SAI will continue from the same word that caused the FIFO error to set after the FIFO warning flag has been cleared.
	I2S_TCR4_FCONT_FCONT_1 = 0x1

	// TCR5: SAI Transmit Configuration 5 Register
	// Position of FBT field.
	I2S_TCR5_FBT_Pos = 0x8
	// Bit mask of FBT field.
	I2S_TCR5_FBT_Msk = 0x1f00
	// Position of W0W field.
	I2S_TCR5_W0W_Pos = 0x10
	// Bit mask of W0W field.
	I2S_TCR5_W0W_Msk = 0x1f0000
	// Position of WNW field.
	I2S_TCR5_WNW_Pos = 0x18
	// Bit mask of WNW field.
	I2S_TCR5_WNW_Msk = 0x1f000000

	// TDR: SAI Transmit Data Register
	// Position of TDR field.
	I2S_TDR_TDR_Pos = 0x0
	// Bit mask of TDR field.
	I2S_TDR_TDR_Msk = 0xffffffff

	// TFR: SAI Transmit FIFO Register
	// Position of RFP field.
	I2S_TFR_RFP_Pos = 0x0
	// Bit mask of RFP field.
	I2S_TFR_RFP_Msk = 0x3f
	// Position of WFP field.
	I2S_TFR_WFP_Pos = 0x10
	// Bit mask of WFP field.
	I2S_TFR_WFP_Msk = 0x3f0000
	// Position of WCP field.
	I2S_TFR_WCP_Pos = 0x1f
	// Bit mask of WCP field.
	I2S_TFR_WCP_Msk = 0x80000000
	// Bit WCP.
	I2S_TFR_WCP = 0x80000000
	// No effect.
	I2S_TFR_WCP_WCP_0 = 0x0
	// FIFO combine is enabled for FIFO writes and this FIFO will be written on the next FIFO write.
	I2S_TFR_WCP_WCP_1 = 0x1

	// TMR: SAI Transmit Mask Register
	// Position of TWM field.
	I2S_TMR_TWM_Pos = 0x0
	// Bit mask of TWM field.
	I2S_TMR_TWM_Msk = 0xffffffff
	// Word N is enabled.
	I2S_TMR_TWM_TWM_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated or drive zero when masked.
	I2S_TMR_TWM_TWM_1 = 0x1

	// RCSR: SAI Receive Control Register
	// Position of FRDE field.
	I2S_RCSR_FRDE_Pos = 0x0
	// Bit mask of FRDE field.
	I2S_RCSR_FRDE_Msk = 0x1
	// Bit FRDE.
	I2S_RCSR_FRDE = 0x1
	// Disables the DMA request.
	I2S_RCSR_FRDE_FRDE_0 = 0x0
	// Enables the DMA request.
	I2S_RCSR_FRDE_FRDE_1 = 0x1
	// Position of FWDE field.
	I2S_RCSR_FWDE_Pos = 0x1
	// Bit mask of FWDE field.
	I2S_RCSR_FWDE_Msk = 0x2
	// Bit FWDE.
	I2S_RCSR_FWDE = 0x2
	// Disables the DMA request.
	I2S_RCSR_FWDE_FWDE_0 = 0x0
	// Enables the DMA request.
	I2S_RCSR_FWDE_FWDE_1 = 0x1
	// Position of FRIE field.
	I2S_RCSR_FRIE_Pos = 0x8
	// Bit mask of FRIE field.
	I2S_RCSR_FRIE_Msk = 0x100
	// Bit FRIE.
	I2S_RCSR_FRIE = 0x100
	// Disables the interrupt.
	I2S_RCSR_FRIE_FRIE_0 = 0x0
	// Enables the interrupt.
	I2S_RCSR_FRIE_FRIE_1 = 0x1
	// Position of FWIE field.
	I2S_RCSR_FWIE_Pos = 0x9
	// Bit mask of FWIE field.
	I2S_RCSR_FWIE_Msk = 0x200
	// Bit FWIE.
	I2S_RCSR_FWIE = 0x200
	// Disables the interrupt.
	I2S_RCSR_FWIE_FWIE_0 = 0x0
	// Enables the interrupt.
	I2S_RCSR_FWIE_FWIE_1 = 0x1
	// Position of FEIE field.
	I2S_RCSR_FEIE_Pos = 0xa
	// Bit mask of FEIE field.
	I2S_RCSR_FEIE_Msk = 0x400
	// Bit FEIE.
	I2S_RCSR_FEIE = 0x400
	// Disables the interrupt.
	I2S_RCSR_FEIE_FEIE_0 = 0x0
	// Enables the interrupt.
	I2S_RCSR_FEIE_FEIE_1 = 0x1
	// Position of SEIE field.
	I2S_RCSR_SEIE_Pos = 0xb
	// Bit mask of SEIE field.
	I2S_RCSR_SEIE_Msk = 0x800
	// Bit SEIE.
	I2S_RCSR_SEIE = 0x800
	// Disables interrupt.
	I2S_RCSR_SEIE_SEIE_0 = 0x0
	// Enables interrupt.
	I2S_RCSR_SEIE_SEIE_1 = 0x1
	// Position of WSIE field.
	I2S_RCSR_WSIE_Pos = 0xc
	// Bit mask of WSIE field.
	I2S_RCSR_WSIE_Msk = 0x1000
	// Bit WSIE.
	I2S_RCSR_WSIE = 0x1000
	// Disables interrupt.
	I2S_RCSR_WSIE_WSIE_0 = 0x0
	// Enables interrupt.
	I2S_RCSR_WSIE_WSIE_1 = 0x1
	// Position of FRF field.
	I2S_RCSR_FRF_Pos = 0x10
	// Bit mask of FRF field.
	I2S_RCSR_FRF_Msk = 0x10000
	// Bit FRF.
	I2S_RCSR_FRF = 0x10000
	// Receive FIFO watermark not reached.
	I2S_RCSR_FRF_FRF_0 = 0x0
	// Receive FIFO watermark has been reached.
	I2S_RCSR_FRF_FRF_1 = 0x1
	// Position of FWF field.
	I2S_RCSR_FWF_Pos = 0x11
	// Bit mask of FWF field.
	I2S_RCSR_FWF_Msk = 0x20000
	// Bit FWF.
	I2S_RCSR_FWF = 0x20000
	// No enabled receive FIFO is full.
	I2S_RCSR_FWF_FWF_0 = 0x0
	// Enabled receive FIFO is full.
	I2S_RCSR_FWF_FWF_1 = 0x1
	// Position of FEF field.
	I2S_RCSR_FEF_Pos = 0x12
	// Bit mask of FEF field.
	I2S_RCSR_FEF_Msk = 0x40000
	// Bit FEF.
	I2S_RCSR_FEF = 0x40000
	// Receive overflow not detected.
	I2S_RCSR_FEF_FEF_0 = 0x0
	// Receive overflow detected.
	I2S_RCSR_FEF_FEF_1 = 0x1
	// Position of SEF field.
	I2S_RCSR_SEF_Pos = 0x13
	// Bit mask of SEF field.
	I2S_RCSR_SEF_Msk = 0x80000
	// Bit SEF.
	I2S_RCSR_SEF = 0x80000
	// Sync error not detected.
	I2S_RCSR_SEF_SEF_0 = 0x0
	// Frame sync error detected.
	I2S_RCSR_SEF_SEF_1 = 0x1
	// Position of WSF field.
	I2S_RCSR_WSF_Pos = 0x14
	// Bit mask of WSF field.
	I2S_RCSR_WSF_Msk = 0x100000
	// Bit WSF.
	I2S_RCSR_WSF = 0x100000
	// Start of word not detected.
	I2S_RCSR_WSF_WSF_0 = 0x0
	// Start of word detected.
	I2S_RCSR_WSF_WSF_1 = 0x1
	// Position of SR field.
	I2S_RCSR_SR_Pos = 0x18
	// Bit mask of SR field.
	I2S_RCSR_SR_Msk = 0x1000000
	// Bit SR.
	I2S_RCSR_SR = 0x1000000
	// No effect.
	I2S_RCSR_SR_SR_0 = 0x0
	// Software reset.
	I2S_RCSR_SR_SR_1 = 0x1
	// Position of FR field.
	I2S_RCSR_FR_Pos = 0x19
	// Bit mask of FR field.
	I2S_RCSR_FR_Msk = 0x2000000
	// Bit FR.
	I2S_RCSR_FR = 0x2000000
	// No effect.
	I2S_RCSR_FR_FR_0 = 0x0
	// FIFO reset.
	I2S_RCSR_FR_FR_1 = 0x1
	// Position of BCE field.
	I2S_RCSR_BCE_Pos = 0x1c
	// Bit mask of BCE field.
	I2S_RCSR_BCE_Msk = 0x10000000
	// Bit BCE.
	I2S_RCSR_BCE = 0x10000000
	// Receive bit clock is disabled.
	I2S_RCSR_BCE_BCE_0 = 0x0
	// Receive bit clock is enabled.
	I2S_RCSR_BCE_BCE_1 = 0x1
	// Position of DBGE field.
	I2S_RCSR_DBGE_Pos = 0x1d
	// Bit mask of DBGE field.
	I2S_RCSR_DBGE_Msk = 0x20000000
	// Bit DBGE.
	I2S_RCSR_DBGE = 0x20000000
	// Receiver is disabled in Debug mode, after completing the current frame.
	I2S_RCSR_DBGE_DBGE_0 = 0x0
	// Receiver is enabled in Debug mode.
	I2S_RCSR_DBGE_DBGE_1 = 0x1
	// Position of STOPE field.
	I2S_RCSR_STOPE_Pos = 0x1e
	// Bit mask of STOPE field.
	I2S_RCSR_STOPE_Msk = 0x40000000
	// Bit STOPE.
	I2S_RCSR_STOPE = 0x40000000
	// Receiver disabled in Stop mode.
	I2S_RCSR_STOPE_STOPE_0 = 0x0
	// Receiver enabled in Stop mode.
	I2S_RCSR_STOPE_STOPE_1 = 0x1
	// Position of RE field.
	I2S_RCSR_RE_Pos = 0x1f
	// Bit mask of RE field.
	I2S_RCSR_RE_Msk = 0x80000000
	// Bit RE.
	I2S_RCSR_RE = 0x80000000
	// Receiver is disabled.
	I2S_RCSR_RE_RE_0 = 0x0
	// Receiver is enabled, or receiver has been disabled and has not yet reached end of frame.
	I2S_RCSR_RE_RE_1 = 0x1

	// RCR1: SAI Receive Configuration 1 Register
	// Position of RFW field.
	I2S_RCR1_RFW_Pos = 0x0
	// Bit mask of RFW field.
	I2S_RCR1_RFW_Msk = 0x1f

	// RCR2: SAI Receive Configuration 2 Register
	// Position of DIV field.
	I2S_RCR2_DIV_Pos = 0x0
	// Bit mask of DIV field.
	I2S_RCR2_DIV_Msk = 0xff
	// Position of BCD field.
	I2S_RCR2_BCD_Pos = 0x18
	// Bit mask of BCD field.
	I2S_RCR2_BCD_Msk = 0x1000000
	// Bit BCD.
	I2S_RCR2_BCD = 0x1000000
	// Bit clock is generated externally in Slave mode.
	I2S_RCR2_BCD_BCD_0 = 0x0
	// Bit clock is generated internally in Master mode.
	I2S_RCR2_BCD_BCD_1 = 0x1
	// Position of BCP field.
	I2S_RCR2_BCP_Pos = 0x19
	// Bit mask of BCP field.
	I2S_RCR2_BCP_Msk = 0x2000000
	// Bit BCP.
	I2S_RCR2_BCP = 0x2000000
	// Bit Clock is active high with drive outputs on rising edge and sample inputs on falling edge.
	I2S_RCR2_BCP_BCP_0 = 0x0
	// Bit Clock is active low with drive outputs on falling edge and sample inputs on rising edge.
	I2S_RCR2_BCP_BCP_1 = 0x1
	// Position of MSEL field.
	I2S_RCR2_MSEL_Pos = 0x1a
	// Bit mask of MSEL field.
	I2S_RCR2_MSEL_Msk = 0xc000000
	// Bus Clock selected.
	I2S_RCR2_MSEL_MSEL_0 = 0x0
	// Master Clock (MCLK) 1 option selected.
	I2S_RCR2_MSEL_MSEL_1 = 0x1
	// Master Clock (MCLK) 2 option selected.
	I2S_RCR2_MSEL_MSEL_2 = 0x2
	// Master Clock (MCLK) 3 option selected.
	I2S_RCR2_MSEL_MSEL_3 = 0x3
	// Position of BCI field.
	I2S_RCR2_BCI_Pos = 0x1c
	// Bit mask of BCI field.
	I2S_RCR2_BCI_Msk = 0x10000000
	// Bit BCI.
	I2S_RCR2_BCI = 0x10000000
	// No effect.
	I2S_RCR2_BCI_BCI_0 = 0x0
	// Internal logic is clocked as if bit clock was externally generated.
	I2S_RCR2_BCI_BCI_1 = 0x1
	// Position of BCS field.
	I2S_RCR2_BCS_Pos = 0x1d
	// Bit mask of BCS field.
	I2S_RCR2_BCS_Msk = 0x20000000
	// Bit BCS.
	I2S_RCR2_BCS = 0x20000000
	// Use the normal bit clock source.
	I2S_RCR2_BCS_BCS_0 = 0x0
	// Swap the bit clock source.
	I2S_RCR2_BCS_BCS_1 = 0x1
	// Position of SYNC field.
	I2S_RCR2_SYNC_Pos = 0x1e
	// Bit mask of SYNC field.
	I2S_RCR2_SYNC_Msk = 0xc0000000
	// Asynchronous mode.
	I2S_RCR2_SYNC_SYNC_0 = 0x0
	// Synchronous with transmitter.
	I2S_RCR2_SYNC_SYNC_1 = 0x1

	// RCR3: SAI Receive Configuration 3 Register
	// Position of WDFL field.
	I2S_RCR3_WDFL_Pos = 0x0
	// Bit mask of WDFL field.
	I2S_RCR3_WDFL_Msk = 0x1f
	// Position of RCE field.
	I2S_RCR3_RCE_Pos = 0x10
	// Bit mask of RCE field.
	I2S_RCR3_RCE_Msk = 0xf0000
	// Position of CFR field.
	I2S_RCR3_CFR_Pos = 0x18
	// Bit mask of CFR field.
	I2S_RCR3_CFR_Msk = 0xf000000

	// RCR4: SAI Receive Configuration 4 Register
	// Position of FSD field.
	I2S_RCR4_FSD_Pos = 0x0
	// Bit mask of FSD field.
	I2S_RCR4_FSD_Msk = 0x1
	// Bit FSD.
	I2S_RCR4_FSD = 0x1
	// Frame Sync is generated externally in Slave mode.
	I2S_RCR4_FSD_FSD_0 = 0x0
	// Frame Sync is generated internally in Master mode.
	I2S_RCR4_FSD_FSD_1 = 0x1
	// Position of FSP field.
	I2S_RCR4_FSP_Pos = 0x1
	// Bit mask of FSP field.
	I2S_RCR4_FSP_Msk = 0x2
	// Bit FSP.
	I2S_RCR4_FSP = 0x2
	// Frame sync is active high.
	I2S_RCR4_FSP_FSP_0 = 0x0
	// Frame sync is active low.
	I2S_RCR4_FSP_FSP_1 = 0x1
	// Position of ONDEM field.
	I2S_RCR4_ONDEM_Pos = 0x2
	// Bit mask of ONDEM field.
	I2S_RCR4_ONDEM_Msk = 0x4
	// Bit ONDEM.
	I2S_RCR4_ONDEM = 0x4
	// Internal frame sync is generated continuously.
	I2S_RCR4_ONDEM_ONDEM_0 = 0x0
	// Internal frame sync is generated when the FIFO warning flag is clear.
	I2S_RCR4_ONDEM_ONDEM_1 = 0x1
	// Position of FSE field.
	I2S_RCR4_FSE_Pos = 0x3
	// Bit mask of FSE field.
	I2S_RCR4_FSE_Msk = 0x8
	// Bit FSE.
	I2S_RCR4_FSE = 0x8
	// Frame sync asserts with the first bit of the frame.
	I2S_RCR4_FSE_FSE_0 = 0x0
	// Frame sync asserts one bit before the first bit of the frame.
	I2S_RCR4_FSE_FSE_1 = 0x1
	// Position of MF field.
	I2S_RCR4_MF_Pos = 0x4
	// Bit mask of MF field.
	I2S_RCR4_MF_Msk = 0x10
	// Bit MF.
	I2S_RCR4_MF = 0x10
	// LSB is received first.
	I2S_RCR4_MF_MF_0 = 0x0
	// MSB is received first.
	I2S_RCR4_MF_MF_1 = 0x1
	// Position of SYWD field.
	I2S_RCR4_SYWD_Pos = 0x8
	// Bit mask of SYWD field.
	I2S_RCR4_SYWD_Msk = 0x1f00
	// Position of FRSZ field.
	I2S_RCR4_FRSZ_Pos = 0x10
	// Bit mask of FRSZ field.
	I2S_RCR4_FRSZ_Msk = 0x1f0000
	// Position of FPACK field.
	I2S_RCR4_FPACK_Pos = 0x18
	// Bit mask of FPACK field.
	I2S_RCR4_FPACK_Msk = 0x3000000
	// FIFO packing is disabled
	I2S_RCR4_FPACK_FPACK_0 = 0x0
	// 8-bit FIFO packing is enabled
	I2S_RCR4_FPACK_FPACK_2 = 0x2
	// 16-bit FIFO packing is enabled
	I2S_RCR4_FPACK_FPACK_3 = 0x3
	// Position of FCOMB field.
	I2S_RCR4_FCOMB_Pos = 0x1a
	// Bit mask of FCOMB field.
	I2S_RCR4_FCOMB_Msk = 0xc000000
	// FIFO combine mode disabled.
	I2S_RCR4_FCOMB_FCOMB_0 = 0x0
	// FIFO combine mode enabled on FIFO writes (from receive shift registers).
	I2S_RCR4_FCOMB_FCOMB_1 = 0x1
	// FIFO combine mode enabled on FIFO reads (by software).
	I2S_RCR4_FCOMB_FCOMB_2 = 0x2
	// FIFO combine mode enabled on FIFO writes (from receive shift registers) and reads (by software).
	I2S_RCR4_FCOMB_FCOMB_3 = 0x3
	// Position of FCONT field.
	I2S_RCR4_FCONT_Pos = 0x1c
	// Bit mask of FCONT field.
	I2S_RCR4_FCONT_Msk = 0x10000000
	// Bit FCONT.
	I2S_RCR4_FCONT = 0x10000000
	// On FIFO error, the SAI will continue from the start of the next frame after the FIFO error flag has been cleared.
	I2S_RCR4_FCONT_FCONT_0 = 0x0
	// On FIFO error, the SAI will continue from the same word that caused the FIFO error to set after the FIFO warning flag has been cleared.
	I2S_RCR4_FCONT_FCONT_1 = 0x1

	// RCR5: SAI Receive Configuration 5 Register
	// Position of FBT field.
	I2S_RCR5_FBT_Pos = 0x8
	// Bit mask of FBT field.
	I2S_RCR5_FBT_Msk = 0x1f00
	// Position of W0W field.
	I2S_RCR5_W0W_Pos = 0x10
	// Bit mask of W0W field.
	I2S_RCR5_W0W_Msk = 0x1f0000
	// Position of WNW field.
	I2S_RCR5_WNW_Pos = 0x18
	// Bit mask of WNW field.
	I2S_RCR5_WNW_Msk = 0x1f000000

	// RDR: SAI Receive Data Register
	// Position of RDR field.
	I2S_RDR_RDR_Pos = 0x0
	// Bit mask of RDR field.
	I2S_RDR_RDR_Msk = 0xffffffff

	// RFR: SAI Receive FIFO Register
	// Position of RFP field.
	I2S_RFR_RFP_Pos = 0x0
	// Bit mask of RFP field.
	I2S_RFR_RFP_Msk = 0x3f
	// Position of RCP field.
	I2S_RFR_RCP_Pos = 0xf
	// Bit mask of RCP field.
	I2S_RFR_RCP_Msk = 0x8000
	// Bit RCP.
	I2S_RFR_RCP = 0x8000
	// No effect.
	I2S_RFR_RCP_RCP_0 = 0x0
	// FIFO combine is enabled for FIFO reads and this FIFO will be read on the next FIFO read.
	I2S_RFR_RCP_RCP_1 = 0x1
	// Position of WFP field.
	I2S_RFR_WFP_Pos = 0x10
	// Bit mask of WFP field.
	I2S_RFR_WFP_Msk = 0x3f0000

	// RMR: SAI Receive Mask Register
	// Position of RWM field.
	I2S_RMR_RWM_Pos = 0x0
	// Bit mask of RWM field.
	I2S_RMR_RWM_Msk = 0xffffffff
	// Word N is enabled.
	I2S_RMR_RWM_RWM_0 = 0x0
	// Word N is masked.
	I2S_RMR_RWM_RWM_1 = 0x1
)

// Bitfields for LPSPI1: LPSPI
const (
	// VERID: Version ID Register
	// Position of FEATURE field.
	LPSPI_VERID_FEATURE_Pos = 0x0
	// Bit mask of FEATURE field.
	LPSPI_VERID_FEATURE_Msk = 0xffff
	// Standard feature set supporting a 32-bit shift register.
	LPSPI_VERID_FEATURE_FEATURE_4 = 0x4
	// Position of MINOR field.
	LPSPI_VERID_MINOR_Pos = 0x10
	// Bit mask of MINOR field.
	LPSPI_VERID_MINOR_Msk = 0xff0000
	// Position of MAJOR field.
	LPSPI_VERID_MAJOR_Pos = 0x18
	// Bit mask of MAJOR field.
	LPSPI_VERID_MAJOR_Msk = 0xff000000

	// PARAM: Parameter Register
	// Position of TXFIFO field.
	LPSPI_PARAM_TXFIFO_Pos = 0x0
	// Bit mask of TXFIFO field.
	LPSPI_PARAM_TXFIFO_Msk = 0xff
	// Position of RXFIFO field.
	LPSPI_PARAM_RXFIFO_Pos = 0x8
	// Bit mask of RXFIFO field.
	LPSPI_PARAM_RXFIFO_Msk = 0xff00
	// Position of PCSNUM field.
	LPSPI_PARAM_PCSNUM_Pos = 0x10
	// Bit mask of PCSNUM field.
	LPSPI_PARAM_PCSNUM_Msk = 0xff0000

	// CR: Control Register
	// Position of MEN field.
	LPSPI_CR_MEN_Pos = 0x0
	// Bit mask of MEN field.
	LPSPI_CR_MEN_Msk = 0x1
	// Bit MEN.
	LPSPI_CR_MEN = 0x1
	// Module is disabled
	LPSPI_CR_MEN_MEN_0 = 0x0
	// Module is enabled
	LPSPI_CR_MEN_MEN_1 = 0x1
	// Position of RST field.
	LPSPI_CR_RST_Pos = 0x1
	// Bit mask of RST field.
	LPSPI_CR_RST_Msk = 0x2
	// Bit RST.
	LPSPI_CR_RST = 0x2
	// Module is not reset
	LPSPI_CR_RST_RST_0 = 0x0
	// Module is reset
	LPSPI_CR_RST_RST_1 = 0x1
	// Position of DOZEN field.
	LPSPI_CR_DOZEN_Pos = 0x2
	// Bit mask of DOZEN field.
	LPSPI_CR_DOZEN_Msk = 0x4
	// Bit DOZEN.
	LPSPI_CR_DOZEN = 0x4
	// Module is enabled in Doze mode
	LPSPI_CR_DOZEN_DOZEN_0 = 0x0
	// Module is disabled in Doze mode
	LPSPI_CR_DOZEN_DOZEN_1 = 0x1
	// Position of DBGEN field.
	LPSPI_CR_DBGEN_Pos = 0x3
	// Bit mask of DBGEN field.
	LPSPI_CR_DBGEN_Msk = 0x8
	// Bit DBGEN.
	LPSPI_CR_DBGEN = 0x8
	// Module is disabled in debug mode
	LPSPI_CR_DBGEN_DBGEN_0 = 0x0
	// Module is enabled in debug mode
	LPSPI_CR_DBGEN_DBGEN_1 = 0x1
	// Position of RTF field.
	LPSPI_CR_RTF_Pos = 0x8
	// Bit mask of RTF field.
	LPSPI_CR_RTF_Msk = 0x100
	// Bit RTF.
	LPSPI_CR_RTF = 0x100
	// No effect
	LPSPI_CR_RTF_RTF_0 = 0x0
	// Transmit FIFO is reset
	LPSPI_CR_RTF_RTF_1 = 0x1
	// Position of RRF field.
	LPSPI_CR_RRF_Pos = 0x9
	// Bit mask of RRF field.
	LPSPI_CR_RRF_Msk = 0x200
	// Bit RRF.
	LPSPI_CR_RRF = 0x200
	// No effect
	LPSPI_CR_RRF_RRF_0 = 0x0
	// Receive FIFO is reset
	LPSPI_CR_RRF_RRF_1 = 0x1

	// SR: Status Register
	// Position of TDF field.
	LPSPI_SR_TDF_Pos = 0x0
	// Bit mask of TDF field.
	LPSPI_SR_TDF_Msk = 0x1
	// Bit TDF.
	LPSPI_SR_TDF = 0x1
	// Transmit data not requested
	LPSPI_SR_TDF_TDF_0 = 0x0
	// Transmit data is requested
	LPSPI_SR_TDF_TDF_1 = 0x1
	// Position of RDF field.
	LPSPI_SR_RDF_Pos = 0x1
	// Bit mask of RDF field.
	LPSPI_SR_RDF_Msk = 0x2
	// Bit RDF.
	LPSPI_SR_RDF = 0x2
	// Receive Data is not ready
	LPSPI_SR_RDF_RDF_0 = 0x0
	// Receive data is ready
	LPSPI_SR_RDF_RDF_1 = 0x1
	// Position of WCF field.
	LPSPI_SR_WCF_Pos = 0x8
	// Bit mask of WCF field.
	LPSPI_SR_WCF_Msk = 0x100
	// Bit WCF.
	LPSPI_SR_WCF = 0x100
	// Transfer of a received word has not yet completed
	LPSPI_SR_WCF_WCF_0 = 0x0
	// Transfer of a received word has completed
	LPSPI_SR_WCF_WCF_1 = 0x1
	// Position of FCF field.
	LPSPI_SR_FCF_Pos = 0x9
	// Bit mask of FCF field.
	LPSPI_SR_FCF_Msk = 0x200
	// Bit FCF.
	LPSPI_SR_FCF = 0x200
	// Frame transfer has not completed
	LPSPI_SR_FCF_FCF_0 = 0x0
	// Frame transfer has completed
	LPSPI_SR_FCF_FCF_1 = 0x1
	// Position of TCF field.
	LPSPI_SR_TCF_Pos = 0xa
	// Bit mask of TCF field.
	LPSPI_SR_TCF_Msk = 0x400
	// Bit TCF.
	LPSPI_SR_TCF = 0x400
	// All transfers have not completed
	LPSPI_SR_TCF_TCF_0 = 0x0
	// All transfers have completed
	LPSPI_SR_TCF_TCF_1 = 0x1
	// Position of TEF field.
	LPSPI_SR_TEF_Pos = 0xb
	// Bit mask of TEF field.
	LPSPI_SR_TEF_Msk = 0x800
	// Bit TEF.
	LPSPI_SR_TEF = 0x800
	// Transmit FIFO underrun has not occurred
	LPSPI_SR_TEF_TEF_0 = 0x0
	// Transmit FIFO underrun has occurred
	LPSPI_SR_TEF_TEF_1 = 0x1
	// Position of REF field.
	LPSPI_SR_REF_Pos = 0xc
	// Bit mask of REF field.
	LPSPI_SR_REF_Msk = 0x1000
	// Bit REF.
	LPSPI_SR_REF = 0x1000
	// Receive FIFO has not overflowed
	LPSPI_SR_REF_REF_0 = 0x0
	// Receive FIFO has overflowed
	LPSPI_SR_REF_REF_1 = 0x1
	// Position of DMF field.
	LPSPI_SR_DMF_Pos = 0xd
	// Bit mask of DMF field.
	LPSPI_SR_DMF_Msk = 0x2000
	// Bit DMF.
	LPSPI_SR_DMF = 0x2000
	// Have not received matching data
	LPSPI_SR_DMF_DMF_0 = 0x0
	// Have received matching data
	LPSPI_SR_DMF_DMF_1 = 0x1
	// Position of MBF field.
	LPSPI_SR_MBF_Pos = 0x18
	// Bit mask of MBF field.
	LPSPI_SR_MBF_Msk = 0x1000000
	// Bit MBF.
	LPSPI_SR_MBF = 0x1000000
	// LPSPI is idle
	LPSPI_SR_MBF_MBF_0 = 0x0
	// LPSPI is busy
	LPSPI_SR_MBF_MBF_1 = 0x1

	// IER: Interrupt Enable Register
	// Position of TDIE field.
	LPSPI_IER_TDIE_Pos = 0x0
	// Bit mask of TDIE field.
	LPSPI_IER_TDIE_Msk = 0x1
	// Bit TDIE.
	LPSPI_IER_TDIE = 0x1
	// Disabled
	LPSPI_IER_TDIE_TDIE_0 = 0x0
	// Enabled
	LPSPI_IER_TDIE_TDIE_1 = 0x1
	// Position of RDIE field.
	LPSPI_IER_RDIE_Pos = 0x1
	// Bit mask of RDIE field.
	LPSPI_IER_RDIE_Msk = 0x2
	// Bit RDIE.
	LPSPI_IER_RDIE = 0x2
	// Disabled
	LPSPI_IER_RDIE_RDIE_0 = 0x0
	// Enabled
	LPSPI_IER_RDIE_RDIE_1 = 0x1
	// Position of WCIE field.
	LPSPI_IER_WCIE_Pos = 0x8
	// Bit mask of WCIE field.
	LPSPI_IER_WCIE_Msk = 0x100
	// Bit WCIE.
	LPSPI_IER_WCIE = 0x100
	// Disabled
	LPSPI_IER_WCIE_WCIE_0 = 0x0
	// Enabled
	LPSPI_IER_WCIE_WCIE_1 = 0x1
	// Position of FCIE field.
	LPSPI_IER_FCIE_Pos = 0x9
	// Bit mask of FCIE field.
	LPSPI_IER_FCIE_Msk = 0x200
	// Bit FCIE.
	LPSPI_IER_FCIE = 0x200
	// Disabled
	LPSPI_IER_FCIE_FCIE_0 = 0x0
	// Enabled
	LPSPI_IER_FCIE_FCIE_1 = 0x1
	// Position of TCIE field.
	LPSPI_IER_TCIE_Pos = 0xa
	// Bit mask of TCIE field.
	LPSPI_IER_TCIE_Msk = 0x400
	// Bit TCIE.
	LPSPI_IER_TCIE = 0x400
	// Disabled
	LPSPI_IER_TCIE_TCIE_0 = 0x0
	// Enabled
	LPSPI_IER_TCIE_TCIE_1 = 0x1
	// Position of TEIE field.
	LPSPI_IER_TEIE_Pos = 0xb
	// Bit mask of TEIE field.
	LPSPI_IER_TEIE_Msk = 0x800
	// Bit TEIE.
	LPSPI_IER_TEIE = 0x800
	// Disabled
	LPSPI_IER_TEIE_TEIE_0 = 0x0
	// Enabled
	LPSPI_IER_TEIE_TEIE_1 = 0x1
	// Position of REIE field.
	LPSPI_IER_REIE_Pos = 0xc
	// Bit mask of REIE field.
	LPSPI_IER_REIE_Msk = 0x1000
	// Bit REIE.
	LPSPI_IER_REIE = 0x1000
	// Disabled
	LPSPI_IER_REIE_REIE_0 = 0x0
	// Enabled
	LPSPI_IER_REIE_REIE_1 = 0x1
	// Position of DMIE field.
	LPSPI_IER_DMIE_Pos = 0xd
	// Bit mask of DMIE field.
	LPSPI_IER_DMIE_Msk = 0x2000
	// Bit DMIE.
	LPSPI_IER_DMIE = 0x2000
	// Disabled
	LPSPI_IER_DMIE_DMIE_0 = 0x0
	// Enabled
	LPSPI_IER_DMIE_DMIE_1 = 0x1

	// DER: DMA Enable Register
	// Position of TDDE field.
	LPSPI_DER_TDDE_Pos = 0x0
	// Bit mask of TDDE field.
	LPSPI_DER_TDDE_Msk = 0x1
	// Bit TDDE.
	LPSPI_DER_TDDE = 0x1
	// DMA request is disabled
	LPSPI_DER_TDDE_TDDE_0 = 0x0
	// DMA request is enabled
	LPSPI_DER_TDDE_TDDE_1 = 0x1
	// Position of RDDE field.
	LPSPI_DER_RDDE_Pos = 0x1
	// Bit mask of RDDE field.
	LPSPI_DER_RDDE_Msk = 0x2
	// Bit RDDE.
	LPSPI_DER_RDDE = 0x2
	// DMA request is disabled
	LPSPI_DER_RDDE_RDDE_0 = 0x0
	// DMA request is enabled
	LPSPI_DER_RDDE_RDDE_1 = 0x1

	// CFGR0: Configuration Register 0
	// Position of HREN field.
	LPSPI_CFGR0_HREN_Pos = 0x0
	// Bit mask of HREN field.
	LPSPI_CFGR0_HREN_Msk = 0x1
	// Bit HREN.
	LPSPI_CFGR0_HREN = 0x1
	// Host request is disabled
	LPSPI_CFGR0_HREN_HREN_0 = 0x0
	// Host request is enabled
	LPSPI_CFGR0_HREN_HREN_1 = 0x1
	// Position of HRPOL field.
	LPSPI_CFGR0_HRPOL_Pos = 0x1
	// Bit mask of HRPOL field.
	LPSPI_CFGR0_HRPOL_Msk = 0x2
	// Bit HRPOL.
	LPSPI_CFGR0_HRPOL = 0x2
	// Active low
	LPSPI_CFGR0_HRPOL_HRPOL_0 = 0x0
	// Active high
	LPSPI_CFGR0_HRPOL_HRPOL_1 = 0x1
	// Position of HRSEL field.
	LPSPI_CFGR0_HRSEL_Pos = 0x2
	// Bit mask of HRSEL field.
	LPSPI_CFGR0_HRSEL_Msk = 0x4
	// Bit HRSEL.
	LPSPI_CFGR0_HRSEL = 0x4
	// Host request input is the LPSPI_HREQ pin
	LPSPI_CFGR0_HRSEL_HRSEL_0 = 0x0
	// Host request input is the input trigger
	LPSPI_CFGR0_HRSEL_HRSEL_1 = 0x1
	// Position of CIRFIFO field.
	LPSPI_CFGR0_CIRFIFO_Pos = 0x8
	// Bit mask of CIRFIFO field.
	LPSPI_CFGR0_CIRFIFO_Msk = 0x100
	// Bit CIRFIFO.
	LPSPI_CFGR0_CIRFIFO = 0x100
	// Circular FIFO is disabled
	LPSPI_CFGR0_CIRFIFO_CIRFIFO_0 = 0x0
	// Circular FIFO is enabled
	LPSPI_CFGR0_CIRFIFO_CIRFIFO_1 = 0x1
	// Position of RDMO field.
	LPSPI_CFGR0_RDMO_Pos = 0x9
	// Bit mask of RDMO field.
	LPSPI_CFGR0_RDMO_Msk = 0x200
	// Bit RDMO.
	LPSPI_CFGR0_RDMO = 0x200
	// Received data is stored in the receive FIFO as in normal operations
	LPSPI_CFGR0_RDMO_RDMO_0 = 0x0
	// Received data is discarded unless the Data Match Flag (DMF) is set
	LPSPI_CFGR0_RDMO_RDMO_1 = 0x1

	// CFGR1: Configuration Register 1
	// Position of MASTER field.
	LPSPI_CFGR1_MASTER_Pos = 0x0
	// Bit mask of MASTER field.
	LPSPI_CFGR1_MASTER_Msk = 0x1
	// Bit MASTER.
	LPSPI_CFGR1_MASTER = 0x1
	// Slave mode
	LPSPI_CFGR1_MASTER_MASTER_0 = 0x0
	// Master mode
	LPSPI_CFGR1_MASTER_MASTER_1 = 0x1
	// Position of SAMPLE field.
	LPSPI_CFGR1_SAMPLE_Pos = 0x1
	// Bit mask of SAMPLE field.
	LPSPI_CFGR1_SAMPLE_Msk = 0x2
	// Bit SAMPLE.
	LPSPI_CFGR1_SAMPLE = 0x2
	// Input data is sampled on SCK edge
	LPSPI_CFGR1_SAMPLE_SAMPLE_0 = 0x0
	// Input data is sampled on delayed SCK edge
	LPSPI_CFGR1_SAMPLE_SAMPLE_1 = 0x1
	// Position of AUTOPCS field.
	LPSPI_CFGR1_AUTOPCS_Pos = 0x2
	// Bit mask of AUTOPCS field.
	LPSPI_CFGR1_AUTOPCS_Msk = 0x4
	// Bit AUTOPCS.
	LPSPI_CFGR1_AUTOPCS = 0x4
	// Automatic PCS generation is disabled
	LPSPI_CFGR1_AUTOPCS_AUTOPCS_0 = 0x0
	// Automatic PCS generation is enabled
	LPSPI_CFGR1_AUTOPCS_AUTOPCS_1 = 0x1
	// Position of NOSTALL field.
	LPSPI_CFGR1_NOSTALL_Pos = 0x3
	// Bit mask of NOSTALL field.
	LPSPI_CFGR1_NOSTALL_Msk = 0x8
	// Bit NOSTALL.
	LPSPI_CFGR1_NOSTALL = 0x8
	// Transfers will stall when the transmit FIFO is empty or the receive FIFO is full
	LPSPI_CFGR1_NOSTALL_NOSTALL_0 = 0x0
	// Transfers will not stall, allowing transmit FIFO underruns or receive FIFO overruns to occur
	LPSPI_CFGR1_NOSTALL_NOSTALL_1 = 0x1
	// Position of PCSPOL field.
	LPSPI_CFGR1_PCSPOL_Pos = 0x8
	// Bit mask of PCSPOL field.
	LPSPI_CFGR1_PCSPOL_Msk = 0xf00
	// The Peripheral Chip Select pin PCSx is active low
	LPSPI_CFGR1_PCSPOL_PCSPOL_0 = 0x0
	// The Peripheral Chip Select pin PCSx is active high
	LPSPI_CFGR1_PCSPOL_PCSPOL_1 = 0x1
	// Position of MATCFG field.
	LPSPI_CFGR1_MATCFG_Pos = 0x10
	// Bit mask of MATCFG field.
	LPSPI_CFGR1_MATCFG_Msk = 0x70000
	// Match is disabled
	LPSPI_CFGR1_MATCFG_MATCFG_0 = 0x0
	// 010b - Match is enabled, if 1st data word equals MATCH0 OR MATCH1, i.e., (1st data word = MATCH0 + MATCH1)
	LPSPI_CFGR1_MATCFG_MATCFG_2 = 0x2
	// 011b - Match is enabled, if any data word equals MATCH0 OR MATCH1, i.e., (any data word = MATCH0 + MATCH1)
	LPSPI_CFGR1_MATCFG_MATCFG_3 = 0x3
	// 100b - Match is enabled, if 1st data word equals MATCH0 AND 2nd data word equals MATCH1, i.e., [(1st data word = MATCH0) * (2nd data word = MATCH1)]
	LPSPI_CFGR1_MATCFG_MATCFG_4 = 0x4
	// 101b - Match is enabled, if any data word equals MATCH0 AND the next data word equals MATCH1, i.e., [(any data word = MATCH0) * (next data word = MATCH1)]
	LPSPI_CFGR1_MATCFG_MATCFG_5 = 0x5
	// 110b - Match is enabled, if (1st data word AND MATCH1) equals (MATCH0 AND MATCH1), i.e., [(1st data word * MATCH1) = (MATCH0 * MATCH1)]
	LPSPI_CFGR1_MATCFG_MATCFG_6 = 0x6
	// 111b - Match is enabled, if (any data word AND MATCH1) equals (MATCH0 AND MATCH1), i.e., [(any data word * MATCH1) = (MATCH0 * MATCH1)]
	LPSPI_CFGR1_MATCFG_MATCFG_7 = 0x7
	// Position of PINCFG field.
	LPSPI_CFGR1_PINCFG_Pos = 0x18
	// Bit mask of PINCFG field.
	LPSPI_CFGR1_PINCFG_Msk = 0x3000000
	// SIN is used for input data and SOUT is used for output data
	LPSPI_CFGR1_PINCFG_PINCFG_0 = 0x0
	// SIN is used for both input and output data
	LPSPI_CFGR1_PINCFG_PINCFG_1 = 0x1
	// SOUT is used for both input and output data
	LPSPI_CFGR1_PINCFG_PINCFG_2 = 0x2
	// SOUT is used for input data and SIN is used for output data
	LPSPI_CFGR1_PINCFG_PINCFG_3 = 0x3
	// Position of OUTCFG field.
	LPSPI_CFGR1_OUTCFG_Pos = 0x1a
	// Bit mask of OUTCFG field.
	LPSPI_CFGR1_OUTCFG_Msk = 0x4000000
	// Bit OUTCFG.
	LPSPI_CFGR1_OUTCFG = 0x4000000
	// Output data retains last value when chip select is negated
	LPSPI_CFGR1_OUTCFG_OUTCFG_0 = 0x0
	// Output data is tristated when chip select is negated
	LPSPI_CFGR1_OUTCFG_OUTCFG_1 = 0x1
	// Position of PCSCFG field.
	LPSPI_CFGR1_PCSCFG_Pos = 0x1b
	// Bit mask of PCSCFG field.
	LPSPI_CFGR1_PCSCFG_Msk = 0x8000000
	// Bit PCSCFG.
	LPSPI_CFGR1_PCSCFG = 0x8000000
	// PCS[3:2] are enabled
	LPSPI_CFGR1_PCSCFG_PCSCFG_0 = 0x0
	// PCS[3:2] are disabled
	LPSPI_CFGR1_PCSCFG_PCSCFG_1 = 0x1

	// DMR0: Data Match Register 0
	// Position of MATCH0 field.
	LPSPI_DMR0_MATCH0_Pos = 0x0
	// Bit mask of MATCH0 field.
	LPSPI_DMR0_MATCH0_Msk = 0xffffffff

	// DMR1: Data Match Register 1
	// Position of MATCH1 field.
	LPSPI_DMR1_MATCH1_Pos = 0x0
	// Bit mask of MATCH1 field.
	LPSPI_DMR1_MATCH1_Msk = 0xffffffff

	// CCR: Clock Configuration Register
	// Position of SCKDIV field.
	LPSPI_CCR_SCKDIV_Pos = 0x0
	// Bit mask of SCKDIV field.
	LPSPI_CCR_SCKDIV_Msk = 0xff
	// Position of DBT field.
	LPSPI_CCR_DBT_Pos = 0x8
	// Bit mask of DBT field.
	LPSPI_CCR_DBT_Msk = 0xff00
	// Position of PCSSCK field.
	LPSPI_CCR_PCSSCK_Pos = 0x10
	// Bit mask of PCSSCK field.
	LPSPI_CCR_PCSSCK_Msk = 0xff0000
	// Position of SCKPCS field.
	LPSPI_CCR_SCKPCS_Pos = 0x18
	// Bit mask of SCKPCS field.
	LPSPI_CCR_SCKPCS_Msk = 0xff000000

	// FCR: FIFO Control Register
	// Position of TXWATER field.
	LPSPI_FCR_TXWATER_Pos = 0x0
	// Bit mask of TXWATER field.
	LPSPI_FCR_TXWATER_Msk = 0xf
	// Position of RXWATER field.
	LPSPI_FCR_RXWATER_Pos = 0x10
	// Bit mask of RXWATER field.
	LPSPI_FCR_RXWATER_Msk = 0xf0000

	// FSR: FIFO Status Register
	// Position of TXCOUNT field.
	LPSPI_FSR_TXCOUNT_Pos = 0x0
	// Bit mask of TXCOUNT field.
	LPSPI_FSR_TXCOUNT_Msk = 0x1f
	// Position of RXCOUNT field.
	LPSPI_FSR_RXCOUNT_Pos = 0x10
	// Bit mask of RXCOUNT field.
	LPSPI_FSR_RXCOUNT_Msk = 0x1f0000

	// TCR: Transmit Command Register
	// Position of FRAMESZ field.
	LPSPI_TCR_FRAMESZ_Pos = 0x0
	// Bit mask of FRAMESZ field.
	LPSPI_TCR_FRAMESZ_Msk = 0xfff
	// Position of WIDTH field.
	LPSPI_TCR_WIDTH_Pos = 0x10
	// Bit mask of WIDTH field.
	LPSPI_TCR_WIDTH_Msk = 0x30000
	// 1 bit transfer
	LPSPI_TCR_WIDTH_WIDTH_0 = 0x0
	// 2 bit transfer
	LPSPI_TCR_WIDTH_WIDTH_1 = 0x1
	// 4 bit transfer
	LPSPI_TCR_WIDTH_WIDTH_2 = 0x2
	// Position of TXMSK field.
	LPSPI_TCR_TXMSK_Pos = 0x12
	// Bit mask of TXMSK field.
	LPSPI_TCR_TXMSK_Msk = 0x40000
	// Bit TXMSK.
	LPSPI_TCR_TXMSK = 0x40000
	// Normal transfer
	LPSPI_TCR_TXMSK_TXMSK_0 = 0x0
	// Mask transmit data
	LPSPI_TCR_TXMSK_TXMSK_1 = 0x1
	// Position of RXMSK field.
	LPSPI_TCR_RXMSK_Pos = 0x13
	// Bit mask of RXMSK field.
	LPSPI_TCR_RXMSK_Msk = 0x80000
	// Bit RXMSK.
	LPSPI_TCR_RXMSK = 0x80000
	// Normal transfer
	LPSPI_TCR_RXMSK_RXMSK_0 = 0x0
	// Receive data is masked
	LPSPI_TCR_RXMSK_RXMSK_1 = 0x1
	// Position of CONTC field.
	LPSPI_TCR_CONTC_Pos = 0x14
	// Bit mask of CONTC field.
	LPSPI_TCR_CONTC_Msk = 0x100000
	// Bit CONTC.
	LPSPI_TCR_CONTC = 0x100000
	// Command word for start of new transfer
	LPSPI_TCR_CONTC_CONTC_0 = 0x0
	// Command word for continuing transfer
	LPSPI_TCR_CONTC_CONTC_1 = 0x1
	// Position of CONT field.
	LPSPI_TCR_CONT_Pos = 0x15
	// Bit mask of CONT field.
	LPSPI_TCR_CONT_Msk = 0x200000
	// Bit CONT.
	LPSPI_TCR_CONT = 0x200000
	// Continuous transfer is disabled
	LPSPI_TCR_CONT_CONT_0 = 0x0
	// Continuous transfer is enabled
	LPSPI_TCR_CONT_CONT_1 = 0x1
	// Position of BYSW field.
	LPSPI_TCR_BYSW_Pos = 0x16
	// Bit mask of BYSW field.
	LPSPI_TCR_BYSW_Msk = 0x400000
	// Bit BYSW.
	LPSPI_TCR_BYSW = 0x400000
	// Byte swap is disabled
	LPSPI_TCR_BYSW_BYSW_0 = 0x0
	// Byte swap is enabled
	LPSPI_TCR_BYSW_BYSW_1 = 0x1
	// Position of LSBF field.
	LPSPI_TCR_LSBF_Pos = 0x17
	// Bit mask of LSBF field.
	LPSPI_TCR_LSBF_Msk = 0x800000
	// Bit LSBF.
	LPSPI_TCR_LSBF = 0x800000
	// Data is transferred MSB first
	LPSPI_TCR_LSBF_LSBF_0 = 0x0
	// Data is transferred LSB first
	LPSPI_TCR_LSBF_LSBF_1 = 0x1
	// Position of PCS field.
	LPSPI_TCR_PCS_Pos = 0x18
	// Bit mask of PCS field.
	LPSPI_TCR_PCS_Msk = 0x3000000
	// Transfer using LPSPI_PCS[0]
	LPSPI_TCR_PCS_PCS_0 = 0x0
	// Transfer using LPSPI_PCS[1]
	LPSPI_TCR_PCS_PCS_1 = 0x1
	// Transfer using LPSPI_PCS[2]
	LPSPI_TCR_PCS_PCS_2 = 0x2
	// Transfer using LPSPI_PCS[3]
	LPSPI_TCR_PCS_PCS_3 = 0x3
	// Position of PRESCALE field.
	LPSPI_TCR_PRESCALE_Pos = 0x1b
	// Bit mask of PRESCALE field.
	LPSPI_TCR_PRESCALE_Msk = 0x38000000
	// Divide by 1
	LPSPI_TCR_PRESCALE_PRESCALE_0 = 0x0
	// Divide by 2
	LPSPI_TCR_PRESCALE_PRESCALE_1 = 0x1
	// Divide by 4
	LPSPI_TCR_PRESCALE_PRESCALE_2 = 0x2
	// Divide by 8
	LPSPI_TCR_PRESCALE_PRESCALE_3 = 0x3
	// Divide by 16
	LPSPI_TCR_PRESCALE_PRESCALE_4 = 0x4
	// Divide by 32
	LPSPI_TCR_PRESCALE_PRESCALE_5 = 0x5
	// Divide by 64
	LPSPI_TCR_PRESCALE_PRESCALE_6 = 0x6
	// Divide by 128
	LPSPI_TCR_PRESCALE_PRESCALE_7 = 0x7
	// Position of CPHA field.
	LPSPI_TCR_CPHA_Pos = 0x1e
	// Bit mask of CPHA field.
	LPSPI_TCR_CPHA_Msk = 0x40000000
	// Bit CPHA.
	LPSPI_TCR_CPHA = 0x40000000
	// Data is captured on the leading edge of SCK and changed on the following edge of SCK
	LPSPI_TCR_CPHA_CPHA_0 = 0x0
	// Data is changed on the leading edge of SCK and captured on the following edge of SCK
	LPSPI_TCR_CPHA_CPHA_1 = 0x1
	// Position of CPOL field.
	LPSPI_TCR_CPOL_Pos = 0x1f
	// Bit mask of CPOL field.
	LPSPI_TCR_CPOL_Msk = 0x80000000
	// Bit CPOL.
	LPSPI_TCR_CPOL = 0x80000000
	// The inactive state value of SCK is low
	LPSPI_TCR_CPOL_CPOL_0 = 0x0
	// The inactive state value of SCK is high
	LPSPI_TCR_CPOL_CPOL_1 = 0x1

	// TDR: Transmit Data Register
	// Position of DATA field.
	LPSPI_TDR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	LPSPI_TDR_DATA_Msk = 0xffffffff

	// RSR: Receive Status Register
	// Position of SOF field.
	LPSPI_RSR_SOF_Pos = 0x0
	// Bit mask of SOF field.
	LPSPI_RSR_SOF_Msk = 0x1
	// Bit SOF.
	LPSPI_RSR_SOF = 0x1
	// Subsequent data word received after LPSPI_PCS assertion
	LPSPI_RSR_SOF_SOF_0 = 0x0
	// First data word received after LPSPI_PCS assertion
	LPSPI_RSR_SOF_SOF_1 = 0x1
	// Position of RXEMPTY field.
	LPSPI_RSR_RXEMPTY_Pos = 0x1
	// Bit mask of RXEMPTY field.
	LPSPI_RSR_RXEMPTY_Msk = 0x2
	// Bit RXEMPTY.
	LPSPI_RSR_RXEMPTY = 0x2
	// RX FIFO is not empty
	LPSPI_RSR_RXEMPTY_RXEMPTY_0 = 0x0
	// RX FIFO is empty
	LPSPI_RSR_RXEMPTY_RXEMPTY_1 = 0x1

	// RDR: Receive Data Register
	// Position of DATA field.
	LPSPI_RDR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	LPSPI_RDR_DATA_Msk = 0xffffffff
)

// Bitfields for ADC_ETC: ADC_ETC
const (
	// CTRL: ADC_ETC Global Control Register
	// Position of TRIG_ENABLE field.
	ADC_ETC_CTRL_TRIG_ENABLE_Pos = 0x0
	// Bit mask of TRIG_ENABLE field.
	ADC_ETC_CTRL_TRIG_ENABLE_Msk = 0xff
	// Position of EXT0_TRIG_ENABLE field.
	ADC_ETC_CTRL_EXT0_TRIG_ENABLE_Pos = 0x8
	// Bit mask of EXT0_TRIG_ENABLE field.
	ADC_ETC_CTRL_EXT0_TRIG_ENABLE_Msk = 0x100
	// Bit EXT0_TRIG_ENABLE.
	ADC_ETC_CTRL_EXT0_TRIG_ENABLE = 0x100
	// Position of EXT0_TRIG_PRIORITY field.
	ADC_ETC_CTRL_EXT0_TRIG_PRIORITY_Pos = 0x9
	// Bit mask of EXT0_TRIG_PRIORITY field.
	ADC_ETC_CTRL_EXT0_TRIG_PRIORITY_Msk = 0xe00
	// Position of EXT1_TRIG_ENABLE field.
	ADC_ETC_CTRL_EXT1_TRIG_ENABLE_Pos = 0xc
	// Bit mask of EXT1_TRIG_ENABLE field.
	ADC_ETC_CTRL_EXT1_TRIG_ENABLE_Msk = 0x1000
	// Bit EXT1_TRIG_ENABLE.
	ADC_ETC_CTRL_EXT1_TRIG_ENABLE = 0x1000
	// Position of EXT1_TRIG_PRIORITY field.
	ADC_ETC_CTRL_EXT1_TRIG_PRIORITY_Pos = 0xd
	// Bit mask of EXT1_TRIG_PRIORITY field.
	ADC_ETC_CTRL_EXT1_TRIG_PRIORITY_Msk = 0xe000
	// Position of PRE_DIVIDER field.
	ADC_ETC_CTRL_PRE_DIVIDER_Pos = 0x10
	// Bit mask of PRE_DIVIDER field.
	ADC_ETC_CTRL_PRE_DIVIDER_Msk = 0xff0000
	// Position of DMA_MODE_SEL field.
	ADC_ETC_CTRL_DMA_MODE_SEL_Pos = 0x1d
	// Bit mask of DMA_MODE_SEL field.
	ADC_ETC_CTRL_DMA_MODE_SEL_Msk = 0x20000000
	// Bit DMA_MODE_SEL.
	ADC_ETC_CTRL_DMA_MODE_SEL = 0x20000000
	// Position of TSC_BYPASS field.
	ADC_ETC_CTRL_TSC_BYPASS_Pos = 0x1e
	// Bit mask of TSC_BYPASS field.
	ADC_ETC_CTRL_TSC_BYPASS_Msk = 0x40000000
	// Bit TSC_BYPASS.
	ADC_ETC_CTRL_TSC_BYPASS = 0x40000000
	// Position of SOFTRST field.
	ADC_ETC_CTRL_SOFTRST_Pos = 0x1f
	// Bit mask of SOFTRST field.
	ADC_ETC_CTRL_SOFTRST_Msk = 0x80000000
	// Bit SOFTRST.
	ADC_ETC_CTRL_SOFTRST = 0x80000000

	// DONE0_1_IRQ: ETC DONE0 and DONE1 IRQ State Register
	// Position of TRIG0_DONE0 field.
	ADC_ETC_DONE0_1_IRQ_TRIG0_DONE0_Pos = 0x0
	// Bit mask of TRIG0_DONE0 field.
	ADC_ETC_DONE0_1_IRQ_TRIG0_DONE0_Msk = 0x1
	// Bit TRIG0_DONE0.
	ADC_ETC_DONE0_1_IRQ_TRIG0_DONE0 = 0x1
	// Position of TRIG1_DONE0 field.
	ADC_ETC_DONE0_1_IRQ_TRIG1_DONE0_Pos = 0x1
	// Bit mask of TRIG1_DONE0 field.
	ADC_ETC_DONE0_1_IRQ_TRIG1_DONE0_Msk = 0x2
	// Bit TRIG1_DONE0.
	ADC_ETC_DONE0_1_IRQ_TRIG1_DONE0 = 0x2
	// Position of TRIG2_DONE0 field.
	ADC_ETC_DONE0_1_IRQ_TRIG2_DONE0_Pos = 0x2
	// Bit mask of TRIG2_DONE0 field.
	ADC_ETC_DONE0_1_IRQ_TRIG2_DONE0_Msk = 0x4
	// Bit TRIG2_DONE0.
	ADC_ETC_DONE0_1_IRQ_TRIG2_DONE0 = 0x4
	// Position of TRIG3_DONE0 field.
	ADC_ETC_DONE0_1_IRQ_TRIG3_DONE0_Pos = 0x3
	// Bit mask of TRIG3_DONE0 field.
	ADC_ETC_DONE0_1_IRQ_TRIG3_DONE0_Msk = 0x8
	// Bit TRIG3_DONE0.
	ADC_ETC_DONE0_1_IRQ_TRIG3_DONE0 = 0x8
	// Position of TRIG4_DONE0 field.
	ADC_ETC_DONE0_1_IRQ_TRIG4_DONE0_Pos = 0x4
	// Bit mask of TRIG4_DONE0 field.
	ADC_ETC_DONE0_1_IRQ_TRIG4_DONE0_Msk = 0x10
	// Bit TRIG4_DONE0.
	ADC_ETC_DONE0_1_IRQ_TRIG4_DONE0 = 0x10
	// Position of TRIG5_DONE0 field.
	ADC_ETC_DONE0_1_IRQ_TRIG5_DONE0_Pos = 0x5
	// Bit mask of TRIG5_DONE0 field.
	ADC_ETC_DONE0_1_IRQ_TRIG5_DONE0_Msk = 0x20
	// Bit TRIG5_DONE0.
	ADC_ETC_DONE0_1_IRQ_TRIG5_DONE0 = 0x20
	// Position of TRIG6_DONE0 field.
	ADC_ETC_DONE0_1_IRQ_TRIG6_DONE0_Pos = 0x6
	// Bit mask of TRIG6_DONE0 field.
	ADC_ETC_DONE0_1_IRQ_TRIG6_DONE0_Msk = 0x40
	// Bit TRIG6_DONE0.
	ADC_ETC_DONE0_1_IRQ_TRIG6_DONE0 = 0x40
	// Position of TRIG7_DONE0 field.
	ADC_ETC_DONE0_1_IRQ_TRIG7_DONE0_Pos = 0x7
	// Bit mask of TRIG7_DONE0 field.
	ADC_ETC_DONE0_1_IRQ_TRIG7_DONE0_Msk = 0x80
	// Bit TRIG7_DONE0.
	ADC_ETC_DONE0_1_IRQ_TRIG7_DONE0 = 0x80
	// Position of TRIG0_DONE1 field.
	ADC_ETC_DONE0_1_IRQ_TRIG0_DONE1_Pos = 0x10
	// Bit mask of TRIG0_DONE1 field.
	ADC_ETC_DONE0_1_IRQ_TRIG0_DONE1_Msk = 0x10000
	// Bit TRIG0_DONE1.
	ADC_ETC_DONE0_1_IRQ_TRIG0_DONE1 = 0x10000
	// Position of TRIG1_DONE1 field.
	ADC_ETC_DONE0_1_IRQ_TRIG1_DONE1_Pos = 0x11
	// Bit mask of TRIG1_DONE1 field.
	ADC_ETC_DONE0_1_IRQ_TRIG1_DONE1_Msk = 0x20000
	// Bit TRIG1_DONE1.
	ADC_ETC_DONE0_1_IRQ_TRIG1_DONE1 = 0x20000
	// Position of TRIG2_DONE1 field.
	ADC_ETC_DONE0_1_IRQ_TRIG2_DONE1_Pos = 0x12
	// Bit mask of TRIG2_DONE1 field.
	ADC_ETC_DONE0_1_IRQ_TRIG2_DONE1_Msk = 0x40000
	// Bit TRIG2_DONE1.
	ADC_ETC_DONE0_1_IRQ_TRIG2_DONE1 = 0x40000
	// Position of TRIG3_DONE1 field.
	ADC_ETC_DONE0_1_IRQ_TRIG3_DONE1_Pos = 0x13
	// Bit mask of TRIG3_DONE1 field.
	ADC_ETC_DONE0_1_IRQ_TRIG3_DONE1_Msk = 0x80000
	// Bit TRIG3_DONE1.
	ADC_ETC_DONE0_1_IRQ_TRIG3_DONE1 = 0x80000
	// Position of TRIG4_DONE1 field.
	ADC_ETC_DONE0_1_IRQ_TRIG4_DONE1_Pos = 0x14
	// Bit mask of TRIG4_DONE1 field.
	ADC_ETC_DONE0_1_IRQ_TRIG4_DONE1_Msk = 0x100000
	// Bit TRIG4_DONE1.
	ADC_ETC_DONE0_1_IRQ_TRIG4_DONE1 = 0x100000
	// Position of TRIG5_DONE1 field.
	ADC_ETC_DONE0_1_IRQ_TRIG5_DONE1_Pos = 0x15
	// Bit mask of TRIG5_DONE1 field.
	ADC_ETC_DONE0_1_IRQ_TRIG5_DONE1_Msk = 0x200000
	// Bit TRIG5_DONE1.
	ADC_ETC_DONE0_1_IRQ_TRIG5_DONE1 = 0x200000
	// Position of TRIG6_DONE1 field.
	ADC_ETC_DONE0_1_IRQ_TRIG6_DONE1_Pos = 0x16
	// Bit mask of TRIG6_DONE1 field.
	ADC_ETC_DONE0_1_IRQ_TRIG6_DONE1_Msk = 0x400000
	// Bit TRIG6_DONE1.
	ADC_ETC_DONE0_1_IRQ_TRIG6_DONE1 = 0x400000
	// Position of TRIG7_DONE1 field.
	ADC_ETC_DONE0_1_IRQ_TRIG7_DONE1_Pos = 0x17
	// Bit mask of TRIG7_DONE1 field.
	ADC_ETC_DONE0_1_IRQ_TRIG7_DONE1_Msk = 0x800000
	// Bit TRIG7_DONE1.
	ADC_ETC_DONE0_1_IRQ_TRIG7_DONE1 = 0x800000

	// DONE2_ERR_IRQ: ETC DONE_2 and DONE_ERR IRQ State Register
	// Position of TRIG0_DONE2 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG0_DONE2_Pos = 0x0
	// Bit mask of TRIG0_DONE2 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG0_DONE2_Msk = 0x1
	// Bit TRIG0_DONE2.
	ADC_ETC_DONE2_ERR_IRQ_TRIG0_DONE2 = 0x1
	// Position of TRIG1_DONE2 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG1_DONE2_Pos = 0x1
	// Bit mask of TRIG1_DONE2 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG1_DONE2_Msk = 0x2
	// Bit TRIG1_DONE2.
	ADC_ETC_DONE2_ERR_IRQ_TRIG1_DONE2 = 0x2
	// Position of TRIG2_DONE2 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG2_DONE2_Pos = 0x2
	// Bit mask of TRIG2_DONE2 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG2_DONE2_Msk = 0x4
	// Bit TRIG2_DONE2.
	ADC_ETC_DONE2_ERR_IRQ_TRIG2_DONE2 = 0x4
	// Position of TRIG3_DONE2 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG3_DONE2_Pos = 0x3
	// Bit mask of TRIG3_DONE2 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG3_DONE2_Msk = 0x8
	// Bit TRIG3_DONE2.
	ADC_ETC_DONE2_ERR_IRQ_TRIG3_DONE2 = 0x8
	// Position of TRIG4_DONE2 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG4_DONE2_Pos = 0x4
	// Bit mask of TRIG4_DONE2 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG4_DONE2_Msk = 0x10
	// Bit TRIG4_DONE2.
	ADC_ETC_DONE2_ERR_IRQ_TRIG4_DONE2 = 0x10
	// Position of TRIG5_DONE2 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG5_DONE2_Pos = 0x5
	// Bit mask of TRIG5_DONE2 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG5_DONE2_Msk = 0x20
	// Bit TRIG5_DONE2.
	ADC_ETC_DONE2_ERR_IRQ_TRIG5_DONE2 = 0x20
	// Position of TRIG6_DONE2 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG6_DONE2_Pos = 0x6
	// Bit mask of TRIG6_DONE2 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG6_DONE2_Msk = 0x40
	// Bit TRIG6_DONE2.
	ADC_ETC_DONE2_ERR_IRQ_TRIG6_DONE2 = 0x40
	// Position of TRIG7_DONE2 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG7_DONE2_Pos = 0x7
	// Bit mask of TRIG7_DONE2 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG7_DONE2_Msk = 0x80
	// Bit TRIG7_DONE2.
	ADC_ETC_DONE2_ERR_IRQ_TRIG7_DONE2 = 0x80
	// Position of TRIG0_ERR field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG0_ERR_Pos = 0x10
	// Bit mask of TRIG0_ERR field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG0_ERR_Msk = 0x10000
	// Bit TRIG0_ERR.
	ADC_ETC_DONE2_ERR_IRQ_TRIG0_ERR = 0x10000
	// Position of TRIG1_ERR field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG1_ERR_Pos = 0x11
	// Bit mask of TRIG1_ERR field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG1_ERR_Msk = 0x20000
	// Bit TRIG1_ERR.
	ADC_ETC_DONE2_ERR_IRQ_TRIG1_ERR = 0x20000
	// Position of TRIG2_ERR field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG2_ERR_Pos = 0x12
	// Bit mask of TRIG2_ERR field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG2_ERR_Msk = 0x40000
	// Bit TRIG2_ERR.
	ADC_ETC_DONE2_ERR_IRQ_TRIG2_ERR = 0x40000
	// Position of TRIG3_ERR field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG3_ERR_Pos = 0x13
	// Bit mask of TRIG3_ERR field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG3_ERR_Msk = 0x80000
	// Bit TRIG3_ERR.
	ADC_ETC_DONE2_ERR_IRQ_TRIG3_ERR = 0x80000
	// Position of TRIG4_ERR field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG4_ERR_Pos = 0x14
	// Bit mask of TRIG4_ERR field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG4_ERR_Msk = 0x100000
	// Bit TRIG4_ERR.
	ADC_ETC_DONE2_ERR_IRQ_TRIG4_ERR = 0x100000
	// Position of TRIG5_ERR field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG5_ERR_Pos = 0x15
	// Bit mask of TRIG5_ERR field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG5_ERR_Msk = 0x200000
	// Bit TRIG5_ERR.
	ADC_ETC_DONE2_ERR_IRQ_TRIG5_ERR = 0x200000
	// Position of TRIG6_ERR field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG6_ERR_Pos = 0x16
	// Bit mask of TRIG6_ERR field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG6_ERR_Msk = 0x400000
	// Bit TRIG6_ERR.
	ADC_ETC_DONE2_ERR_IRQ_TRIG6_ERR = 0x400000
	// Position of TRIG7_ERR field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG7_ERR_Pos = 0x17
	// Bit mask of TRIG7_ERR field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG7_ERR_Msk = 0x800000
	// Bit TRIG7_ERR.
	ADC_ETC_DONE2_ERR_IRQ_TRIG7_ERR = 0x800000

	// DMA_CTRL: ETC DMA control Register
	// Position of TRIG0_ENABLE field.
	ADC_ETC_DMA_CTRL_TRIG0_ENABLE_Pos = 0x0
	// Bit mask of TRIG0_ENABLE field.
	ADC_ETC_DMA_CTRL_TRIG0_ENABLE_Msk = 0x1
	// Bit TRIG0_ENABLE.
	ADC_ETC_DMA_CTRL_TRIG0_ENABLE = 0x1
	// Position of TRIG1_ENABLE field.
	ADC_ETC_DMA_CTRL_TRIG1_ENABLE_Pos = 0x1
	// Bit mask of TRIG1_ENABLE field.
	ADC_ETC_DMA_CTRL_TRIG1_ENABLE_Msk = 0x2
	// Bit TRIG1_ENABLE.
	ADC_ETC_DMA_CTRL_TRIG1_ENABLE = 0x2
	// Position of TRIG2_ENABLE field.
	ADC_ETC_DMA_CTRL_TRIG2_ENABLE_Pos = 0x2
	// Bit mask of TRIG2_ENABLE field.
	ADC_ETC_DMA_CTRL_TRIG2_ENABLE_Msk = 0x4
	// Bit TRIG2_ENABLE.
	ADC_ETC_DMA_CTRL_TRIG2_ENABLE = 0x4
	// Position of TRIG3_ENABLE field.
	ADC_ETC_DMA_CTRL_TRIG3_ENABLE_Pos = 0x3
	// Bit mask of TRIG3_ENABLE field.
	ADC_ETC_DMA_CTRL_TRIG3_ENABLE_Msk = 0x8
	// Bit TRIG3_ENABLE.
	ADC_ETC_DMA_CTRL_TRIG3_ENABLE = 0x8
	// Position of TRIG4_ENABLE field.
	ADC_ETC_DMA_CTRL_TRIG4_ENABLE_Pos = 0x4
	// Bit mask of TRIG4_ENABLE field.
	ADC_ETC_DMA_CTRL_TRIG4_ENABLE_Msk = 0x10
	// Bit TRIG4_ENABLE.
	ADC_ETC_DMA_CTRL_TRIG4_ENABLE = 0x10
	// Position of TRIG5_ENABLE field.
	ADC_ETC_DMA_CTRL_TRIG5_ENABLE_Pos = 0x5
	// Bit mask of TRIG5_ENABLE field.
	ADC_ETC_DMA_CTRL_TRIG5_ENABLE_Msk = 0x20
	// Bit TRIG5_ENABLE.
	ADC_ETC_DMA_CTRL_TRIG5_ENABLE = 0x20
	// Position of TRIG6_ENABLE field.
	ADC_ETC_DMA_CTRL_TRIG6_ENABLE_Pos = 0x6
	// Bit mask of TRIG6_ENABLE field.
	ADC_ETC_DMA_CTRL_TRIG6_ENABLE_Msk = 0x40
	// Bit TRIG6_ENABLE.
	ADC_ETC_DMA_CTRL_TRIG6_ENABLE = 0x40
	// Position of TRIG7_ENABLE field.
	ADC_ETC_DMA_CTRL_TRIG7_ENABLE_Pos = 0x7
	// Bit mask of TRIG7_ENABLE field.
	ADC_ETC_DMA_CTRL_TRIG7_ENABLE_Msk = 0x80
	// Bit TRIG7_ENABLE.
	ADC_ETC_DMA_CTRL_TRIG7_ENABLE = 0x80
	// Position of TRIG0_REQ field.
	ADC_ETC_DMA_CTRL_TRIG0_REQ_Pos = 0x10
	// Bit mask of TRIG0_REQ field.
	ADC_ETC_DMA_CTRL_TRIG0_REQ_Msk = 0x10000
	// Bit TRIG0_REQ.
	ADC_ETC_DMA_CTRL_TRIG0_REQ = 0x10000
	// Position of TRIG1_REQ field.
	ADC_ETC_DMA_CTRL_TRIG1_REQ_Pos = 0x11
	// Bit mask of TRIG1_REQ field.
	ADC_ETC_DMA_CTRL_TRIG1_REQ_Msk = 0x20000
	// Bit TRIG1_REQ.
	ADC_ETC_DMA_CTRL_TRIG1_REQ = 0x20000
	// Position of TRIG2_REQ field.
	ADC_ETC_DMA_CTRL_TRIG2_REQ_Pos = 0x12
	// Bit mask of TRIG2_REQ field.
	ADC_ETC_DMA_CTRL_TRIG2_REQ_Msk = 0x40000
	// Bit TRIG2_REQ.
	ADC_ETC_DMA_CTRL_TRIG2_REQ = 0x40000
	// Position of TRIG3_REQ field.
	ADC_ETC_DMA_CTRL_TRIG3_REQ_Pos = 0x13
	// Bit mask of TRIG3_REQ field.
	ADC_ETC_DMA_CTRL_TRIG3_REQ_Msk = 0x80000
	// Bit TRIG3_REQ.
	ADC_ETC_DMA_CTRL_TRIG3_REQ = 0x80000
	// Position of TRIG4_REQ field.
	ADC_ETC_DMA_CTRL_TRIG4_REQ_Pos = 0x14
	// Bit mask of TRIG4_REQ field.
	ADC_ETC_DMA_CTRL_TRIG4_REQ_Msk = 0x100000
	// Bit TRIG4_REQ.
	ADC_ETC_DMA_CTRL_TRIG4_REQ = 0x100000
	// Position of TRIG5_REQ field.
	ADC_ETC_DMA_CTRL_TRIG5_REQ_Pos = 0x15
	// Bit mask of TRIG5_REQ field.
	ADC_ETC_DMA_CTRL_TRIG5_REQ_Msk = 0x200000
	// Bit TRIG5_REQ.
	ADC_ETC_DMA_CTRL_TRIG5_REQ = 0x200000
	// Position of TRIG6_REQ field.
	ADC_ETC_DMA_CTRL_TRIG6_REQ_Pos = 0x16
	// Bit mask of TRIG6_REQ field.
	ADC_ETC_DMA_CTRL_TRIG6_REQ_Msk = 0x400000
	// Bit TRIG6_REQ.
	ADC_ETC_DMA_CTRL_TRIG6_REQ = 0x400000
	// Position of TRIG7_REQ field.
	ADC_ETC_DMA_CTRL_TRIG7_REQ_Pos = 0x17
	// Bit mask of TRIG7_REQ field.
	ADC_ETC_DMA_CTRL_TRIG7_REQ_Msk = 0x800000
	// Bit TRIG7_REQ.
	ADC_ETC_DMA_CTRL_TRIG7_REQ = 0x800000

	// TRIG0_CTRL: ETC_TRIG0 Control Register
	// Position of SW_TRIG field.
	ADC_ETC_TRIG0_CTRL_SW_TRIG_Pos = 0x0
	// Bit mask of SW_TRIG field.
	ADC_ETC_TRIG0_CTRL_SW_TRIG_Msk = 0x1
	// Bit SW_TRIG.
	ADC_ETC_TRIG0_CTRL_SW_TRIG = 0x1
	// Position of TRIG_MODE field.
	ADC_ETC_TRIG0_CTRL_TRIG_MODE_Pos = 0x4
	// Bit mask of TRIG_MODE field.
	ADC_ETC_TRIG0_CTRL_TRIG_MODE_Msk = 0x10
	// Bit TRIG_MODE.
	ADC_ETC_TRIG0_CTRL_TRIG_MODE = 0x10
	// Position of TRIG_CHAIN field.
	ADC_ETC_TRIG0_CTRL_TRIG_CHAIN_Pos = 0x8
	// Bit mask of TRIG_CHAIN field.
	ADC_ETC_TRIG0_CTRL_TRIG_CHAIN_Msk = 0x700
	// Position of TRIG_PRIORITY field.
	ADC_ETC_TRIG0_CTRL_TRIG_PRIORITY_Pos = 0xc
	// Bit mask of TRIG_PRIORITY field.
	ADC_ETC_TRIG0_CTRL_TRIG_PRIORITY_Msk = 0x7000
	// Position of SYNC_MODE field.
	ADC_ETC_TRIG0_CTRL_SYNC_MODE_Pos = 0x10
	// Bit mask of SYNC_MODE field.
	ADC_ETC_TRIG0_CTRL_SYNC_MODE_Msk = 0x10000
	// Bit SYNC_MODE.
	ADC_ETC_TRIG0_CTRL_SYNC_MODE = 0x10000

	// TRIG0_COUNTER: ETC_TRIG0 Counter Register
	// Position of INIT_DELAY field.
	ADC_ETC_TRIG0_COUNTER_INIT_DELAY_Pos = 0x0
	// Bit mask of INIT_DELAY field.
	ADC_ETC_TRIG0_COUNTER_INIT_DELAY_Msk = 0xffff
	// Position of SAMPLE_INTERVAL field.
	ADC_ETC_TRIG0_COUNTER_SAMPLE_INTERVAL_Pos = 0x10
	// Bit mask of SAMPLE_INTERVAL field.
	ADC_ETC_TRIG0_COUNTER_SAMPLE_INTERVAL_Msk = 0xffff0000

	// TRIG0_CHAIN_1_0: ETC_TRIG Chain 0/1 Register
	// Position of CSEL0 field.
	ADC_ETC_TRIG0_CHAIN_1_0_CSEL0_Pos = 0x0
	// Bit mask of CSEL0 field.
	ADC_ETC_TRIG0_CHAIN_1_0_CSEL0_Msk = 0xf
	// Position of HWTS0 field.
	ADC_ETC_TRIG0_CHAIN_1_0_HWTS0_Pos = 0x4
	// Bit mask of HWTS0 field.
	ADC_ETC_TRIG0_CHAIN_1_0_HWTS0_Msk = 0xff0
	// Position of B2B0 field.
	ADC_ETC_TRIG0_CHAIN_1_0_B2B0_Pos = 0xc
	// Bit mask of B2B0 field.
	ADC_ETC_TRIG0_CHAIN_1_0_B2B0_Msk = 0x1000
	// Bit B2B0.
	ADC_ETC_TRIG0_CHAIN_1_0_B2B0 = 0x1000
	// Position of IE0 field.
	ADC_ETC_TRIG0_CHAIN_1_0_IE0_Pos = 0xd
	// Bit mask of IE0 field.
	ADC_ETC_TRIG0_CHAIN_1_0_IE0_Msk = 0x6000
	// Position of CSEL1 field.
	ADC_ETC_TRIG0_CHAIN_1_0_CSEL1_Pos = 0x10
	// Bit mask of CSEL1 field.
	ADC_ETC_TRIG0_CHAIN_1_0_CSEL1_Msk = 0xf0000
	// Position of HWTS1 field.
	ADC_ETC_TRIG0_CHAIN_1_0_HWTS1_Pos = 0x14
	// Bit mask of HWTS1 field.
	ADC_ETC_TRIG0_CHAIN_1_0_HWTS1_Msk = 0xff00000
	// Position of B2B1 field.
	ADC_ETC_TRIG0_CHAIN_1_0_B2B1_Pos = 0x1c
	// Bit mask of B2B1 field.
	ADC_ETC_TRIG0_CHAIN_1_0_B2B1_Msk = 0x10000000
	// Bit B2B1.
	ADC_ETC_TRIG0_CHAIN_1_0_B2B1 = 0x10000000
	// Position of IE1 field.
	ADC_ETC_TRIG0_CHAIN_1_0_IE1_Pos = 0x1d
	// Bit mask of IE1 field.
	ADC_ETC_TRIG0_CHAIN_1_0_IE1_Msk = 0x60000000

	// TRIG0_CHAIN_3_2: ETC_TRIG Chain 2/3 Register
	// Position of CSEL2 field.
	ADC_ETC_TRIG0_CHAIN_3_2_CSEL2_Pos = 0x0
	// Bit mask of CSEL2 field.
	ADC_ETC_TRIG0_CHAIN_3_2_CSEL2_Msk = 0xf
	// Position of HWTS2 field.
	ADC_ETC_TRIG0_CHAIN_3_2_HWTS2_Pos = 0x4
	// Bit mask of HWTS2 field.
	ADC_ETC_TRIG0_CHAIN_3_2_HWTS2_Msk = 0xff0
	// Position of B2B2 field.
	ADC_ETC_TRIG0_CHAIN_3_2_B2B2_Pos = 0xc
	// Bit mask of B2B2 field.
	ADC_ETC_TRIG0_CHAIN_3_2_B2B2_Msk = 0x1000
	// Bit B2B2.
	ADC_ETC_TRIG0_CHAIN_3_2_B2B2 = 0x1000
	// Position of IE2 field.
	ADC_ETC_TRIG0_CHAIN_3_2_IE2_Pos = 0xd
	// Bit mask of IE2 field.
	ADC_ETC_TRIG0_CHAIN_3_2_IE2_Msk = 0x6000
	// Position of CSEL3 field.
	ADC_ETC_TRIG0_CHAIN_3_2_CSEL3_Pos = 0x10
	// Bit mask of CSEL3 field.
	ADC_ETC_TRIG0_CHAIN_3_2_CSEL3_Msk = 0xf0000
	// Position of HWTS3 field.
	ADC_ETC_TRIG0_CHAIN_3_2_HWTS3_Pos = 0x14
	// Bit mask of HWTS3 field.
	ADC_ETC_TRIG0_CHAIN_3_2_HWTS3_Msk = 0xff00000
	// Position of B2B3 field.
	ADC_ETC_TRIG0_CHAIN_3_2_B2B3_Pos = 0x1c
	// Bit mask of B2B3 field.
	ADC_ETC_TRIG0_CHAIN_3_2_B2B3_Msk = 0x10000000
	// Bit B2B3.
	ADC_ETC_TRIG0_CHAIN_3_2_B2B3 = 0x10000000
	// Position of IE3 field.
	ADC_ETC_TRIG0_CHAIN_3_2_IE3_Pos = 0x1d
	// Bit mask of IE3 field.
	ADC_ETC_TRIG0_CHAIN_3_2_IE3_Msk = 0x60000000

	// TRIG0_CHAIN_5_4: ETC_TRIG Chain 4/5 Register
	// Position of CSEL4 field.
	ADC_ETC_TRIG0_CHAIN_5_4_CSEL4_Pos = 0x0
	// Bit mask of CSEL4 field.
	ADC_ETC_TRIG0_CHAIN_5_4_CSEL4_Msk = 0xf
	// Position of HWTS4 field.
	ADC_ETC_TRIG0_CHAIN_5_4_HWTS4_Pos = 0x4
	// Bit mask of HWTS4 field.
	ADC_ETC_TRIG0_CHAIN_5_4_HWTS4_Msk = 0xff0
	// Position of B2B4 field.
	ADC_ETC_TRIG0_CHAIN_5_4_B2B4_Pos = 0xc
	// Bit mask of B2B4 field.
	ADC_ETC_TRIG0_CHAIN_5_4_B2B4_Msk = 0x1000
	// Bit B2B4.
	ADC_ETC_TRIG0_CHAIN_5_4_B2B4 = 0x1000
	// Position of IE4 field.
	ADC_ETC_TRIG0_CHAIN_5_4_IE4_Pos = 0xd
	// Bit mask of IE4 field.
	ADC_ETC_TRIG0_CHAIN_5_4_IE4_Msk = 0x6000
	// Position of CSEL5 field.
	ADC_ETC_TRIG0_CHAIN_5_4_CSEL5_Pos = 0x10
	// Bit mask of CSEL5 field.
	ADC_ETC_TRIG0_CHAIN_5_4_CSEL5_Msk = 0xf0000
	// Position of HWTS5 field.
	ADC_ETC_TRIG0_CHAIN_5_4_HWTS5_Pos = 0x14
	// Bit mask of HWTS5 field.
	ADC_ETC_TRIG0_CHAIN_5_4_HWTS5_Msk = 0xff00000
	// Position of B2B5 field.
	ADC_ETC_TRIG0_CHAIN_5_4_B2B5_Pos = 0x1c
	// Bit mask of B2B5 field.
	ADC_ETC_TRIG0_CHAIN_5_4_B2B5_Msk = 0x10000000
	// Bit B2B5.
	ADC_ETC_TRIG0_CHAIN_5_4_B2B5 = 0x10000000
	// Position of IE5 field.
	ADC_ETC_TRIG0_CHAIN_5_4_IE5_Pos = 0x1d
	// Bit mask of IE5 field.
	ADC_ETC_TRIG0_CHAIN_5_4_IE5_Msk = 0x60000000

	// TRIG0_CHAIN_7_6: ETC_TRIG Chain 6/7 Register
	// Position of CSEL6 field.
	ADC_ETC_TRIG0_CHAIN_7_6_CSEL6_Pos = 0x0
	// Bit mask of CSEL6 field.
	ADC_ETC_TRIG0_CHAIN_7_6_CSEL6_Msk = 0xf
	// Position of HWTS6 field.
	ADC_ETC_TRIG0_CHAIN_7_6_HWTS6_Pos = 0x4
	// Bit mask of HWTS6 field.
	ADC_ETC_TRIG0_CHAIN_7_6_HWTS6_Msk = 0xff0
	// Position of B2B6 field.
	ADC_ETC_TRIG0_CHAIN_7_6_B2B6_Pos = 0xc
	// Bit mask of B2B6 field.
	ADC_ETC_TRIG0_CHAIN_7_6_B2B6_Msk = 0x1000
	// Bit B2B6.
	ADC_ETC_TRIG0_CHAIN_7_6_B2B6 = 0x1000
	// Position of IE6 field.
	ADC_ETC_TRIG0_CHAIN_7_6_IE6_Pos = 0xd
	// Bit mask of IE6 field.
	ADC_ETC_TRIG0_CHAIN_7_6_IE6_Msk = 0x6000
	// Position of CSEL7 field.
	ADC_ETC_TRIG0_CHAIN_7_6_CSEL7_Pos = 0x10
	// Bit mask of CSEL7 field.
	ADC_ETC_TRIG0_CHAIN_7_6_CSEL7_Msk = 0xf0000
	// Position of HWTS7 field.
	ADC_ETC_TRIG0_CHAIN_7_6_HWTS7_Pos = 0x14
	// Bit mask of HWTS7 field.
	ADC_ETC_TRIG0_CHAIN_7_6_HWTS7_Msk = 0xff00000
	// Position of B2B7 field.
	ADC_ETC_TRIG0_CHAIN_7_6_B2B7_Pos = 0x1c
	// Bit mask of B2B7 field.
	ADC_ETC_TRIG0_CHAIN_7_6_B2B7_Msk = 0x10000000
	// Bit B2B7.
	ADC_ETC_TRIG0_CHAIN_7_6_B2B7 = 0x10000000
	// Position of IE7 field.
	ADC_ETC_TRIG0_CHAIN_7_6_IE7_Pos = 0x1d
	// Bit mask of IE7 field.
	ADC_ETC_TRIG0_CHAIN_7_6_IE7_Msk = 0x60000000

	// TRIG0_RESULT_1_0: ETC_TRIG Result Data 1/0 Register
	// Position of DATA0 field.
	ADC_ETC_TRIG0_RESULT_1_0_DATA0_Pos = 0x0
	// Bit mask of DATA0 field.
	ADC_ETC_TRIG0_RESULT_1_0_DATA0_Msk = 0xfff
	// Position of DATA1 field.
	ADC_ETC_TRIG0_RESULT_1_0_DATA1_Pos = 0x10
	// Bit mask of DATA1 field.
	ADC_ETC_TRIG0_RESULT_1_0_DATA1_Msk = 0xfff0000

	// TRIG0_RESULT_3_2: ETC_TRIG Result Data 3/2 Register
	// Position of DATA2 field.
	ADC_ETC_TRIG0_RESULT_3_2_DATA2_Pos = 0x0
	// Bit mask of DATA2 field.
	ADC_ETC_TRIG0_RESULT_3_2_DATA2_Msk = 0xfff
	// Position of DATA3 field.
	ADC_ETC_TRIG0_RESULT_3_2_DATA3_Pos = 0x10
	// Bit mask of DATA3 field.
	ADC_ETC_TRIG0_RESULT_3_2_DATA3_Msk = 0xfff0000

	// TRIG0_RESULT_5_4: ETC_TRIG Result Data 5/4 Register
	// Position of DATA4 field.
	ADC_ETC_TRIG0_RESULT_5_4_DATA4_Pos = 0x0
	// Bit mask of DATA4 field.
	ADC_ETC_TRIG0_RESULT_5_4_DATA4_Msk = 0xfff
	// Position of DATA5 field.
	ADC_ETC_TRIG0_RESULT_5_4_DATA5_Pos = 0x10
	// Bit mask of DATA5 field.
	ADC_ETC_TRIG0_RESULT_5_4_DATA5_Msk = 0xfff0000

	// TRIG0_RESULT_7_6: ETC_TRIG Result Data 7/6 Register
	// Position of DATA6 field.
	ADC_ETC_TRIG0_RESULT_7_6_DATA6_Pos = 0x0
	// Bit mask of DATA6 field.
	ADC_ETC_TRIG0_RESULT_7_6_DATA6_Msk = 0xfff
	// Position of DATA7 field.
	ADC_ETC_TRIG0_RESULT_7_6_DATA7_Pos = 0x10
	// Bit mask of DATA7 field.
	ADC_ETC_TRIG0_RESULT_7_6_DATA7_Msk = 0xfff0000

	// TRIG1_CTRL: ETC_TRIG1 Control Register
	// Position of SW_TRIG field.
	ADC_ETC_TRIG1_CTRL_SW_TRIG_Pos = 0x0
	// Bit mask of SW_TRIG field.
	ADC_ETC_TRIG1_CTRL_SW_TRIG_Msk = 0x1
	// Bit SW_TRIG.
	ADC_ETC_TRIG1_CTRL_SW_TRIG = 0x1
	// Position of TRIG_MODE field.
	ADC_ETC_TRIG1_CTRL_TRIG_MODE_Pos = 0x4
	// Bit mask of TRIG_MODE field.
	ADC_ETC_TRIG1_CTRL_TRIG_MODE_Msk = 0x10
	// Bit TRIG_MODE.
	ADC_ETC_TRIG1_CTRL_TRIG_MODE = 0x10
	// Position of TRIG_CHAIN field.
	ADC_ETC_TRIG1_CTRL_TRIG_CHAIN_Pos = 0x8
	// Bit mask of TRIG_CHAIN field.
	ADC_ETC_TRIG1_CTRL_TRIG_CHAIN_Msk = 0x700
	// Position of TRIG_PRIORITY field.
	ADC_ETC_TRIG1_CTRL_TRIG_PRIORITY_Pos = 0xc
	// Bit mask of TRIG_PRIORITY field.
	ADC_ETC_TRIG1_CTRL_TRIG_PRIORITY_Msk = 0x7000
	// Position of SYNC_MODE field.
	ADC_ETC_TRIG1_CTRL_SYNC_MODE_Pos = 0x10
	// Bit mask of SYNC_MODE field.
	ADC_ETC_TRIG1_CTRL_SYNC_MODE_Msk = 0x10000
	// Bit SYNC_MODE.
	ADC_ETC_TRIG1_CTRL_SYNC_MODE = 0x10000

	// TRIG1_COUNTER: ETC_TRIG1 Counter Register
	// Position of INIT_DELAY field.
	ADC_ETC_TRIG1_COUNTER_INIT_DELAY_Pos = 0x0
	// Bit mask of INIT_DELAY field.
	ADC_ETC_TRIG1_COUNTER_INIT_DELAY_Msk = 0xffff
	// Position of SAMPLE_INTERVAL field.
	ADC_ETC_TRIG1_COUNTER_SAMPLE_INTERVAL_Pos = 0x10
	// Bit mask of SAMPLE_INTERVAL field.
	ADC_ETC_TRIG1_COUNTER_SAMPLE_INTERVAL_Msk = 0xffff0000

	// TRIG1_CHAIN_1_0: ETC_TRIG Chain 0/1 Register
	// Position of CSEL0 field.
	ADC_ETC_TRIG1_CHAIN_1_0_CSEL0_Pos = 0x0
	// Bit mask of CSEL0 field.
	ADC_ETC_TRIG1_CHAIN_1_0_CSEL0_Msk = 0xf
	// Position of HWTS0 field.
	ADC_ETC_TRIG1_CHAIN_1_0_HWTS0_Pos = 0x4
	// Bit mask of HWTS0 field.
	ADC_ETC_TRIG1_CHAIN_1_0_HWTS0_Msk = 0xff0
	// Position of B2B0 field.
	ADC_ETC_TRIG1_CHAIN_1_0_B2B0_Pos = 0xc
	// Bit mask of B2B0 field.
	ADC_ETC_TRIG1_CHAIN_1_0_B2B0_Msk = 0x1000
	// Bit B2B0.
	ADC_ETC_TRIG1_CHAIN_1_0_B2B0 = 0x1000
	// Position of IE0 field.
	ADC_ETC_TRIG1_CHAIN_1_0_IE0_Pos = 0xd
	// Bit mask of IE0 field.
	ADC_ETC_TRIG1_CHAIN_1_0_IE0_Msk = 0x6000
	// Position of CSEL1 field.
	ADC_ETC_TRIG1_CHAIN_1_0_CSEL1_Pos = 0x10
	// Bit mask of CSEL1 field.
	ADC_ETC_TRIG1_CHAIN_1_0_CSEL1_Msk = 0xf0000
	// Position of HWTS1 field.
	ADC_ETC_TRIG1_CHAIN_1_0_HWTS1_Pos = 0x14
	// Bit mask of HWTS1 field.
	ADC_ETC_TRIG1_CHAIN_1_0_HWTS1_Msk = 0xff00000
	// Position of B2B1 field.
	ADC_ETC_TRIG1_CHAIN_1_0_B2B1_Pos = 0x1c
	// Bit mask of B2B1 field.
	ADC_ETC_TRIG1_CHAIN_1_0_B2B1_Msk = 0x10000000
	// Bit B2B1.
	ADC_ETC_TRIG1_CHAIN_1_0_B2B1 = 0x10000000
	// Position of IE1 field.
	ADC_ETC_TRIG1_CHAIN_1_0_IE1_Pos = 0x1d
	// Bit mask of IE1 field.
	ADC_ETC_TRIG1_CHAIN_1_0_IE1_Msk = 0x60000000

	// TRIG1_CHAIN_3_2: ETC_TRIG Chain 2/3 Register
	// Position of CSEL2 field.
	ADC_ETC_TRIG1_CHAIN_3_2_CSEL2_Pos = 0x0
	// Bit mask of CSEL2 field.
	ADC_ETC_TRIG1_CHAIN_3_2_CSEL2_Msk = 0xf
	// Position of HWTS2 field.
	ADC_ETC_TRIG1_CHAIN_3_2_HWTS2_Pos = 0x4
	// Bit mask of HWTS2 field.
	ADC_ETC_TRIG1_CHAIN_3_2_HWTS2_Msk = 0xff0
	// Position of B2B2 field.
	ADC_ETC_TRIG1_CHAIN_3_2_B2B2_Pos = 0xc
	// Bit mask of B2B2 field.
	ADC_ETC_TRIG1_CHAIN_3_2_B2B2_Msk = 0x1000
	// Bit B2B2.
	ADC_ETC_TRIG1_CHAIN_3_2_B2B2 = 0x1000
	// Position of IE2 field.
	ADC_ETC_TRIG1_CHAIN_3_2_IE2_Pos = 0xd
	// Bit mask of IE2 field.
	ADC_ETC_TRIG1_CHAIN_3_2_IE2_Msk = 0x6000
	// Position of CSEL3 field.
	ADC_ETC_TRIG1_CHAIN_3_2_CSEL3_Pos = 0x10
	// Bit mask of CSEL3 field.
	ADC_ETC_TRIG1_CHAIN_3_2_CSEL3_Msk = 0xf0000
	// Position of HWTS3 field.
	ADC_ETC_TRIG1_CHAIN_3_2_HWTS3_Pos = 0x14
	// Bit mask of HWTS3 field.
	ADC_ETC_TRIG1_CHAIN_3_2_HWTS3_Msk = 0xff00000
	// Position of B2B3 field.
	ADC_ETC_TRIG1_CHAIN_3_2_B2B3_Pos = 0x1c
	// Bit mask of B2B3 field.
	ADC_ETC_TRIG1_CHAIN_3_2_B2B3_Msk = 0x10000000
	// Bit B2B3.
	ADC_ETC_TRIG1_CHAIN_3_2_B2B3 = 0x10000000
	// Position of IE3 field.
	ADC_ETC_TRIG1_CHAIN_3_2_IE3_Pos = 0x1d
	// Bit mask of IE3 field.
	ADC_ETC_TRIG1_CHAIN_3_2_IE3_Msk = 0x60000000

	// TRIG1_CHAIN_5_4: ETC_TRIG Chain 4/5 Register
	// Position of CSEL4 field.
	ADC_ETC_TRIG1_CHAIN_5_4_CSEL4_Pos = 0x0
	// Bit mask of CSEL4 field.
	ADC_ETC_TRIG1_CHAIN_5_4_CSEL4_Msk = 0xf
	// Position of HWTS4 field.
	ADC_ETC_TRIG1_CHAIN_5_4_HWTS4_Pos = 0x4
	// Bit mask of HWTS4 field.
	ADC_ETC_TRIG1_CHAIN_5_4_HWTS4_Msk = 0xff0
	// Position of B2B4 field.
	ADC_ETC_TRIG1_CHAIN_5_4_B2B4_Pos = 0xc
	// Bit mask of B2B4 field.
	ADC_ETC_TRIG1_CHAIN_5_4_B2B4_Msk = 0x1000
	// Bit B2B4.
	ADC_ETC_TRIG1_CHAIN_5_4_B2B4 = 0x1000
	// Position of IE4 field.
	ADC_ETC_TRIG1_CHAIN_5_4_IE4_Pos = 0xd
	// Bit mask of IE4 field.
	ADC_ETC_TRIG1_CHAIN_5_4_IE4_Msk = 0x6000
	// Position of CSEL5 field.
	ADC_ETC_TRIG1_CHAIN_5_4_CSEL5_Pos = 0x10
	// Bit mask of CSEL5 field.
	ADC_ETC_TRIG1_CHAIN_5_4_CSEL5_Msk = 0xf0000
	// Position of HWTS5 field.
	ADC_ETC_TRIG1_CHAIN_5_4_HWTS5_Pos = 0x14
	// Bit mask of HWTS5 field.
	ADC_ETC_TRIG1_CHAIN_5_4_HWTS5_Msk = 0xff00000
	// Position of B2B5 field.
	ADC_ETC_TRIG1_CHAIN_5_4_B2B5_Pos = 0x1c
	// Bit mask of B2B5 field.
	ADC_ETC_TRIG1_CHAIN_5_4_B2B5_Msk = 0x10000000
	// Bit B2B5.
	ADC_ETC_TRIG1_CHAIN_5_4_B2B5 = 0x10000000
	// Position of IE5 field.
	ADC_ETC_TRIG1_CHAIN_5_4_IE5_Pos = 0x1d
	// Bit mask of IE5 field.
	ADC_ETC_TRIG1_CHAIN_5_4_IE5_Msk = 0x60000000

	// TRIG1_CHAIN_7_6: ETC_TRIG Chain 6/7 Register
	// Position of CSEL6 field.
	ADC_ETC_TRIG1_CHAIN_7_6_CSEL6_Pos = 0x0
	// Bit mask of CSEL6 field.
	ADC_ETC_TRIG1_CHAIN_7_6_CSEL6_Msk = 0xf
	// Position of HWTS6 field.
	ADC_ETC_TRIG1_CHAIN_7_6_HWTS6_Pos = 0x4
	// Bit mask of HWTS6 field.
	ADC_ETC_TRIG1_CHAIN_7_6_HWTS6_Msk = 0xff0
	// Position of B2B6 field.
	ADC_ETC_TRIG1_CHAIN_7_6_B2B6_Pos = 0xc
	// Bit mask of B2B6 field.
	ADC_ETC_TRIG1_CHAIN_7_6_B2B6_Msk = 0x1000
	// Bit B2B6.
	ADC_ETC_TRIG1_CHAIN_7_6_B2B6 = 0x1000
	// Position of IE6 field.
	ADC_ETC_TRIG1_CHAIN_7_6_IE6_Pos = 0xd
	// Bit mask of IE6 field.
	ADC_ETC_TRIG1_CHAIN_7_6_IE6_Msk = 0x6000
	// Position of CSEL7 field.
	ADC_ETC_TRIG1_CHAIN_7_6_CSEL7_Pos = 0x10
	// Bit mask of CSEL7 field.
	ADC_ETC_TRIG1_CHAIN_7_6_CSEL7_Msk = 0xf0000
	// Position of HWTS7 field.
	ADC_ETC_TRIG1_CHAIN_7_6_HWTS7_Pos = 0x14
	// Bit mask of HWTS7 field.
	ADC_ETC_TRIG1_CHAIN_7_6_HWTS7_Msk = 0xff00000
	// Position of B2B7 field.
	ADC_ETC_TRIG1_CHAIN_7_6_B2B7_Pos = 0x1c
	// Bit mask of B2B7 field.
	ADC_ETC_TRIG1_CHAIN_7_6_B2B7_Msk = 0x10000000
	// Bit B2B7.
	ADC_ETC_TRIG1_CHAIN_7_6_B2B7 = 0x10000000
	// Position of IE7 field.
	ADC_ETC_TRIG1_CHAIN_7_6_IE7_Pos = 0x1d
	// Bit mask of IE7 field.
	ADC_ETC_TRIG1_CHAIN_7_6_IE7_Msk = 0x60000000

	// TRIG1_RESULT_1_0: ETC_TRIG Result Data 1/0 Register
	// Position of DATA0 field.
	ADC_ETC_TRIG1_RESULT_1_0_DATA0_Pos = 0x0
	// Bit mask of DATA0 field.
	ADC_ETC_TRIG1_RESULT_1_0_DATA0_Msk = 0xfff
	// Position of DATA1 field.
	ADC_ETC_TRIG1_RESULT_1_0_DATA1_Pos = 0x10
	// Bit mask of DATA1 field.
	ADC_ETC_TRIG1_RESULT_1_0_DATA1_Msk = 0xfff0000

	// TRIG1_RESULT_3_2: ETC_TRIG Result Data 3/2 Register
	// Position of DATA2 field.
	ADC_ETC_TRIG1_RESULT_3_2_DATA2_Pos = 0x0
	// Bit mask of DATA2 field.
	ADC_ETC_TRIG1_RESULT_3_2_DATA2_Msk = 0xfff
	// Position of DATA3 field.
	ADC_ETC_TRIG1_RESULT_3_2_DATA3_Pos = 0x10
	// Bit mask of DATA3 field.
	ADC_ETC_TRIG1_RESULT_3_2_DATA3_Msk = 0xfff0000

	// TRIG1_RESULT_5_4: ETC_TRIG Result Data 5/4 Register
	// Position of DATA4 field.
	ADC_ETC_TRIG1_RESULT_5_4_DATA4_Pos = 0x0
	// Bit mask of DATA4 field.
	ADC_ETC_TRIG1_RESULT_5_4_DATA4_Msk = 0xfff
	// Position of DATA5 field.
	ADC_ETC_TRIG1_RESULT_5_4_DATA5_Pos = 0x10
	// Bit mask of DATA5 field.
	ADC_ETC_TRIG1_RESULT_5_4_DATA5_Msk = 0xfff0000

	// TRIG1_RESULT_7_6: ETC_TRIG Result Data 7/6 Register
	// Position of DATA6 field.
	ADC_ETC_TRIG1_RESULT_7_6_DATA6_Pos = 0x0
	// Bit mask of DATA6 field.
	ADC_ETC_TRIG1_RESULT_7_6_DATA6_Msk = 0xfff
	// Position of DATA7 field.
	ADC_ETC_TRIG1_RESULT_7_6_DATA7_Pos = 0x10
	// Bit mask of DATA7 field.
	ADC_ETC_TRIG1_RESULT_7_6_DATA7_Msk = 0xfff0000

	// TRIG2_CTRL: ETC_TRIG2 Control Register
	// Position of SW_TRIG field.
	ADC_ETC_TRIG2_CTRL_SW_TRIG_Pos = 0x0
	// Bit mask of SW_TRIG field.
	ADC_ETC_TRIG2_CTRL_SW_TRIG_Msk = 0x1
	// Bit SW_TRIG.
	ADC_ETC_TRIG2_CTRL_SW_TRIG = 0x1
	// Position of TRIG_MODE field.
	ADC_ETC_TRIG2_CTRL_TRIG_MODE_Pos = 0x4
	// Bit mask of TRIG_MODE field.
	ADC_ETC_TRIG2_CTRL_TRIG_MODE_Msk = 0x10
	// Bit TRIG_MODE.
	ADC_ETC_TRIG2_CTRL_TRIG_MODE = 0x10
	// Position of TRIG_CHAIN field.
	ADC_ETC_TRIG2_CTRL_TRIG_CHAIN_Pos = 0x8
	// Bit mask of TRIG_CHAIN field.
	ADC_ETC_TRIG2_CTRL_TRIG_CHAIN_Msk = 0x700
	// Position of TRIG_PRIORITY field.
	ADC_ETC_TRIG2_CTRL_TRIG_PRIORITY_Pos = 0xc
	// Bit mask of TRIG_PRIORITY field.
	ADC_ETC_TRIG2_CTRL_TRIG_PRIORITY_Msk = 0x7000
	// Position of SYNC_MODE field.
	ADC_ETC_TRIG2_CTRL_SYNC_MODE_Pos = 0x10
	// Bit mask of SYNC_MODE field.
	ADC_ETC_TRIG2_CTRL_SYNC_MODE_Msk = 0x10000
	// Bit SYNC_MODE.
	ADC_ETC_TRIG2_CTRL_SYNC_MODE = 0x10000

	// TRIG2_COUNTER: ETC_TRIG2 Counter Register
	// Position of INIT_DELAY field.
	ADC_ETC_TRIG2_COUNTER_INIT_DELAY_Pos = 0x0
	// Bit mask of INIT_DELAY field.
	ADC_ETC_TRIG2_COUNTER_INIT_DELAY_Msk = 0xffff
	// Position of SAMPLE_INTERVAL field.
	ADC_ETC_TRIG2_COUNTER_SAMPLE_INTERVAL_Pos = 0x10
	// Bit mask of SAMPLE_INTERVAL field.
	ADC_ETC_TRIG2_COUNTER_SAMPLE_INTERVAL_Msk = 0xffff0000

	// TRIG2_CHAIN_1_0: ETC_TRIG Chain 0/1 Register
	// Position of CSEL0 field.
	ADC_ETC_TRIG2_CHAIN_1_0_CSEL0_Pos = 0x0
	// Bit mask of CSEL0 field.
	ADC_ETC_TRIG2_CHAIN_1_0_CSEL0_Msk = 0xf
	// Position of HWTS0 field.
	ADC_ETC_TRIG2_CHAIN_1_0_HWTS0_Pos = 0x4
	// Bit mask of HWTS0 field.
	ADC_ETC_TRIG2_CHAIN_1_0_HWTS0_Msk = 0xff0
	// Position of B2B0 field.
	ADC_ETC_TRIG2_CHAIN_1_0_B2B0_Pos = 0xc
	// Bit mask of B2B0 field.
	ADC_ETC_TRIG2_CHAIN_1_0_B2B0_Msk = 0x1000
	// Bit B2B0.
	ADC_ETC_TRIG2_CHAIN_1_0_B2B0 = 0x1000
	// Position of IE0 field.
	ADC_ETC_TRIG2_CHAIN_1_0_IE0_Pos = 0xd
	// Bit mask of IE0 field.
	ADC_ETC_TRIG2_CHAIN_1_0_IE0_Msk = 0x6000
	// Position of CSEL1 field.
	ADC_ETC_TRIG2_CHAIN_1_0_CSEL1_Pos = 0x10
	// Bit mask of CSEL1 field.
	ADC_ETC_TRIG2_CHAIN_1_0_CSEL1_Msk = 0xf0000
	// Position of HWTS1 field.
	ADC_ETC_TRIG2_CHAIN_1_0_HWTS1_Pos = 0x14
	// Bit mask of HWTS1 field.
	ADC_ETC_TRIG2_CHAIN_1_0_HWTS1_Msk = 0xff00000
	// Position of B2B1 field.
	ADC_ETC_TRIG2_CHAIN_1_0_B2B1_Pos = 0x1c
	// Bit mask of B2B1 field.
	ADC_ETC_TRIG2_CHAIN_1_0_B2B1_Msk = 0x10000000
	// Bit B2B1.
	ADC_ETC_TRIG2_CHAIN_1_0_B2B1 = 0x10000000
	// Position of IE1 field.
	ADC_ETC_TRIG2_CHAIN_1_0_IE1_Pos = 0x1d
	// Bit mask of IE1 field.
	ADC_ETC_TRIG2_CHAIN_1_0_IE1_Msk = 0x60000000

	// TRIG2_CHAIN_3_2: ETC_TRIG Chain 2/3 Register
	// Position of CSEL2 field.
	ADC_ETC_TRIG2_CHAIN_3_2_CSEL2_Pos = 0x0
	// Bit mask of CSEL2 field.
	ADC_ETC_TRIG2_CHAIN_3_2_CSEL2_Msk = 0xf
	// Position of HWTS2 field.
	ADC_ETC_TRIG2_CHAIN_3_2_HWTS2_Pos = 0x4
	// Bit mask of HWTS2 field.
	ADC_ETC_TRIG2_CHAIN_3_2_HWTS2_Msk = 0xff0
	// Position of B2B2 field.
	ADC_ETC_TRIG2_CHAIN_3_2_B2B2_Pos = 0xc
	// Bit mask of B2B2 field.
	ADC_ETC_TRIG2_CHAIN_3_2_B2B2_Msk = 0x1000
	// Bit B2B2.
	ADC_ETC_TRIG2_CHAIN_3_2_B2B2 = 0x1000
	// Position of IE2 field.
	ADC_ETC_TRIG2_CHAIN_3_2_IE2_Pos = 0xd
	// Bit mask of IE2 field.
	ADC_ETC_TRIG2_CHAIN_3_2_IE2_Msk = 0x6000
	// Position of CSEL3 field.
	ADC_ETC_TRIG2_CHAIN_3_2_CSEL3_Pos = 0x10
	// Bit mask of CSEL3 field.
	ADC_ETC_TRIG2_CHAIN_3_2_CSEL3_Msk = 0xf0000
	// Position of HWTS3 field.
	ADC_ETC_TRIG2_CHAIN_3_2_HWTS3_Pos = 0x14
	// Bit mask of HWTS3 field.
	ADC_ETC_TRIG2_CHAIN_3_2_HWTS3_Msk = 0xff00000
	// Position of B2B3 field.
	ADC_ETC_TRIG2_CHAIN_3_2_B2B3_Pos = 0x1c
	// Bit mask of B2B3 field.
	ADC_ETC_TRIG2_CHAIN_3_2_B2B3_Msk = 0x10000000
	// Bit B2B3.
	ADC_ETC_TRIG2_CHAIN_3_2_B2B3 = 0x10000000
	// Position of IE3 field.
	ADC_ETC_TRIG2_CHAIN_3_2_IE3_Pos = 0x1d
	// Bit mask of IE3 field.
	ADC_ETC_TRIG2_CHAIN_3_2_IE3_Msk = 0x60000000

	// TRIG2_CHAIN_5_4: ETC_TRIG Chain 4/5 Register
	// Position of CSEL4 field.
	ADC_ETC_TRIG2_CHAIN_5_4_CSEL4_Pos = 0x0
	// Bit mask of CSEL4 field.
	ADC_ETC_TRIG2_CHAIN_5_4_CSEL4_Msk = 0xf
	// Position of HWTS4 field.
	ADC_ETC_TRIG2_CHAIN_5_4_HWTS4_Pos = 0x4
	// Bit mask of HWTS4 field.
	ADC_ETC_TRIG2_CHAIN_5_4_HWTS4_Msk = 0xff0
	// Position of B2B4 field.
	ADC_ETC_TRIG2_CHAIN_5_4_B2B4_Pos = 0xc
	// Bit mask of B2B4 field.
	ADC_ETC_TRIG2_CHAIN_5_4_B2B4_Msk = 0x1000
	// Bit B2B4.
	ADC_ETC_TRIG2_CHAIN_5_4_B2B4 = 0x1000
	// Position of IE4 field.
	ADC_ETC_TRIG2_CHAIN_5_4_IE4_Pos = 0xd
	// Bit mask of IE4 field.
	ADC_ETC_TRIG2_CHAIN_5_4_IE4_Msk = 0x6000
	// Position of CSEL5 field.
	ADC_ETC_TRIG2_CHAIN_5_4_CSEL5_Pos = 0x10
	// Bit mask of CSEL5 field.
	ADC_ETC_TRIG2_CHAIN_5_4_CSEL5_Msk = 0xf0000
	// Position of HWTS5 field.
	ADC_ETC_TRIG2_CHAIN_5_4_HWTS5_Pos = 0x14
	// Bit mask of HWTS5 field.
	ADC_ETC_TRIG2_CHAIN_5_4_HWTS5_Msk = 0xff00000
	// Position of B2B5 field.
	ADC_ETC_TRIG2_CHAIN_5_4_B2B5_Pos = 0x1c
	// Bit mask of B2B5 field.
	ADC_ETC_TRIG2_CHAIN_5_4_B2B5_Msk = 0x10000000
	// Bit B2B5.
	ADC_ETC_TRIG2_CHAIN_5_4_B2B5 = 0x10000000
	// Position of IE5 field.
	ADC_ETC_TRIG2_CHAIN_5_4_IE5_Pos = 0x1d
	// Bit mask of IE5 field.
	ADC_ETC_TRIG2_CHAIN_5_4_IE5_Msk = 0x60000000

	// TRIG2_CHAIN_7_6: ETC_TRIG Chain 6/7 Register
	// Position of CSEL6 field.
	ADC_ETC_TRIG2_CHAIN_7_6_CSEL6_Pos = 0x0
	// Bit mask of CSEL6 field.
	ADC_ETC_TRIG2_CHAIN_7_6_CSEL6_Msk = 0xf
	// Position of HWTS6 field.
	ADC_ETC_TRIG2_CHAIN_7_6_HWTS6_Pos = 0x4
	// Bit mask of HWTS6 field.
	ADC_ETC_TRIG2_CHAIN_7_6_HWTS6_Msk = 0xff0
	// Position of B2B6 field.
	ADC_ETC_TRIG2_CHAIN_7_6_B2B6_Pos = 0xc
	// Bit mask of B2B6 field.
	ADC_ETC_TRIG2_CHAIN_7_6_B2B6_Msk = 0x1000
	// Bit B2B6.
	ADC_ETC_TRIG2_CHAIN_7_6_B2B6 = 0x1000
	// Position of IE6 field.
	ADC_ETC_TRIG2_CHAIN_7_6_IE6_Pos = 0xd
	// Bit mask of IE6 field.
	ADC_ETC_TRIG2_CHAIN_7_6_IE6_Msk = 0x6000
	// Position of CSEL7 field.
	ADC_ETC_TRIG2_CHAIN_7_6_CSEL7_Pos = 0x10
	// Bit mask of CSEL7 field.
	ADC_ETC_TRIG2_CHAIN_7_6_CSEL7_Msk = 0xf0000
	// Position of HWTS7 field.
	ADC_ETC_TRIG2_CHAIN_7_6_HWTS7_Pos = 0x14
	// Bit mask of HWTS7 field.
	ADC_ETC_TRIG2_CHAIN_7_6_HWTS7_Msk = 0xff00000
	// Position of B2B7 field.
	ADC_ETC_TRIG2_CHAIN_7_6_B2B7_Pos = 0x1c
	// Bit mask of B2B7 field.
	ADC_ETC_TRIG2_CHAIN_7_6_B2B7_Msk = 0x10000000
	// Bit B2B7.
	ADC_ETC_TRIG2_CHAIN_7_6_B2B7 = 0x10000000
	// Position of IE7 field.
	ADC_ETC_TRIG2_CHAIN_7_6_IE7_Pos = 0x1d
	// Bit mask of IE7 field.
	ADC_ETC_TRIG2_CHAIN_7_6_IE7_Msk = 0x60000000

	// TRIG2_RESULT_1_0: ETC_TRIG Result Data 1/0 Register
	// Position of DATA0 field.
	ADC_ETC_TRIG2_RESULT_1_0_DATA0_Pos = 0x0
	// Bit mask of DATA0 field.
	ADC_ETC_TRIG2_RESULT_1_0_DATA0_Msk = 0xfff
	// Position of DATA1 field.
	ADC_ETC_TRIG2_RESULT_1_0_DATA1_Pos = 0x10
	// Bit mask of DATA1 field.
	ADC_ETC_TRIG2_RESULT_1_0_DATA1_Msk = 0xfff0000

	// TRIG2_RESULT_3_2: ETC_TRIG Result Data 3/2 Register
	// Position of DATA2 field.
	ADC_ETC_TRIG2_RESULT_3_2_DATA2_Pos = 0x0
	// Bit mask of DATA2 field.
	ADC_ETC_TRIG2_RESULT_3_2_DATA2_Msk = 0xfff
	// Position of DATA3 field.
	ADC_ETC_TRIG2_RESULT_3_2_DATA3_Pos = 0x10
	// Bit mask of DATA3 field.
	ADC_ETC_TRIG2_RESULT_3_2_DATA3_Msk = 0xfff0000

	// TRIG2_RESULT_5_4: ETC_TRIG Result Data 5/4 Register
	// Position of DATA4 field.
	ADC_ETC_TRIG2_RESULT_5_4_DATA4_Pos = 0x0
	// Bit mask of DATA4 field.
	ADC_ETC_TRIG2_RESULT_5_4_DATA4_Msk = 0xfff
	// Position of DATA5 field.
	ADC_ETC_TRIG2_RESULT_5_4_DATA5_Pos = 0x10
	// Bit mask of DATA5 field.
	ADC_ETC_TRIG2_RESULT_5_4_DATA5_Msk = 0xfff0000

	// TRIG2_RESULT_7_6: ETC_TRIG Result Data 7/6 Register
	// Position of DATA6 field.
	ADC_ETC_TRIG2_RESULT_7_6_DATA6_Pos = 0x0
	// Bit mask of DATA6 field.
	ADC_ETC_TRIG2_RESULT_7_6_DATA6_Msk = 0xfff
	// Position of DATA7 field.
	ADC_ETC_TRIG2_RESULT_7_6_DATA7_Pos = 0x10
	// Bit mask of DATA7 field.
	ADC_ETC_TRIG2_RESULT_7_6_DATA7_Msk = 0xfff0000

	// TRIG3_CTRL: ETC_TRIG3 Control Register
	// Position of SW_TRIG field.
	ADC_ETC_TRIG3_CTRL_SW_TRIG_Pos = 0x0
	// Bit mask of SW_TRIG field.
	ADC_ETC_TRIG3_CTRL_SW_TRIG_Msk = 0x1
	// Bit SW_TRIG.
	ADC_ETC_TRIG3_CTRL_SW_TRIG = 0x1
	// Position of TRIG_MODE field.
	ADC_ETC_TRIG3_CTRL_TRIG_MODE_Pos = 0x4
	// Bit mask of TRIG_MODE field.
	ADC_ETC_TRIG3_CTRL_TRIG_MODE_Msk = 0x10
	// Bit TRIG_MODE.
	ADC_ETC_TRIG3_CTRL_TRIG_MODE = 0x10
	// Position of TRIG_CHAIN field.
	ADC_ETC_TRIG3_CTRL_TRIG_CHAIN_Pos = 0x8
	// Bit mask of TRIG_CHAIN field.
	ADC_ETC_TRIG3_CTRL_TRIG_CHAIN_Msk = 0x700
	// Position of TRIG_PRIORITY field.
	ADC_ETC_TRIG3_CTRL_TRIG_PRIORITY_Pos = 0xc
	// Bit mask of TRIG_PRIORITY field.
	ADC_ETC_TRIG3_CTRL_TRIG_PRIORITY_Msk = 0x7000
	// Position of SYNC_MODE field.
	ADC_ETC_TRIG3_CTRL_SYNC_MODE_Pos = 0x10
	// Bit mask of SYNC_MODE field.
	ADC_ETC_TRIG3_CTRL_SYNC_MODE_Msk = 0x10000
	// Bit SYNC_MODE.
	ADC_ETC_TRIG3_CTRL_SYNC_MODE = 0x10000

	// TRIG3_COUNTER: ETC_TRIG3 Counter Register
	// Position of INIT_DELAY field.
	ADC_ETC_TRIG3_COUNTER_INIT_DELAY_Pos = 0x0
	// Bit mask of INIT_DELAY field.
	ADC_ETC_TRIG3_COUNTER_INIT_DELAY_Msk = 0xffff
	// Position of SAMPLE_INTERVAL field.
	ADC_ETC_TRIG3_COUNTER_SAMPLE_INTERVAL_Pos = 0x10
	// Bit mask of SAMPLE_INTERVAL field.
	ADC_ETC_TRIG3_COUNTER_SAMPLE_INTERVAL_Msk = 0xffff0000

	// TRIG3_CHAIN_1_0: ETC_TRIG Chain 0/1 Register
	// Position of CSEL0 field.
	ADC_ETC_TRIG3_CHAIN_1_0_CSEL0_Pos = 0x0
	// Bit mask of CSEL0 field.
	ADC_ETC_TRIG3_CHAIN_1_0_CSEL0_Msk = 0xf
	// Position of HWTS0 field.
	ADC_ETC_TRIG3_CHAIN_1_0_HWTS0_Pos = 0x4
	// Bit mask of HWTS0 field.
	ADC_ETC_TRIG3_CHAIN_1_0_HWTS0_Msk = 0xff0
	// Position of B2B0 field.
	ADC_ETC_TRIG3_CHAIN_1_0_B2B0_Pos = 0xc
	// Bit mask of B2B0 field.
	ADC_ETC_TRIG3_CHAIN_1_0_B2B0_Msk = 0x1000
	// Bit B2B0.
	ADC_ETC_TRIG3_CHAIN_1_0_B2B0 = 0x1000
	// Position of IE0 field.
	ADC_ETC_TRIG3_CHAIN_1_0_IE0_Pos = 0xd
	// Bit mask of IE0 field.
	ADC_ETC_TRIG3_CHAIN_1_0_IE0_Msk = 0x6000
	// Position of CSEL1 field.
	ADC_ETC_TRIG3_CHAIN_1_0_CSEL1_Pos = 0x10
	// Bit mask of CSEL1 field.
	ADC_ETC_TRIG3_CHAIN_1_0_CSEL1_Msk = 0xf0000
	// Position of HWTS1 field.
	ADC_ETC_TRIG3_CHAIN_1_0_HWTS1_Pos = 0x14
	// Bit mask of HWTS1 field.
	ADC_ETC_TRIG3_CHAIN_1_0_HWTS1_Msk = 0xff00000
	// Position of B2B1 field.
	ADC_ETC_TRIG3_CHAIN_1_0_B2B1_Pos = 0x1c
	// Bit mask of B2B1 field.
	ADC_ETC_TRIG3_CHAIN_1_0_B2B1_Msk = 0x10000000
	// Bit B2B1.
	ADC_ETC_TRIG3_CHAIN_1_0_B2B1 = 0x10000000
	// Position of IE1 field.
	ADC_ETC_TRIG3_CHAIN_1_0_IE1_Pos = 0x1d
	// Bit mask of IE1 field.
	ADC_ETC_TRIG3_CHAIN_1_0_IE1_Msk = 0x60000000

	// TRIG3_CHAIN_3_2: ETC_TRIG Chain 2/3 Register
	// Position of CSEL2 field.
	ADC_ETC_TRIG3_CHAIN_3_2_CSEL2_Pos = 0x0
	// Bit mask of CSEL2 field.
	ADC_ETC_TRIG3_CHAIN_3_2_CSEL2_Msk = 0xf
	// Position of HWTS2 field.
	ADC_ETC_TRIG3_CHAIN_3_2_HWTS2_Pos = 0x4
	// Bit mask of HWTS2 field.
	ADC_ETC_TRIG3_CHAIN_3_2_HWTS2_Msk = 0xff0
	// Position of B2B2 field.
	ADC_ETC_TRIG3_CHAIN_3_2_B2B2_Pos = 0xc
	// Bit mask of B2B2 field.
	ADC_ETC_TRIG3_CHAIN_3_2_B2B2_Msk = 0x1000
	// Bit B2B2.
	ADC_ETC_TRIG3_CHAIN_3_2_B2B2 = 0x1000
	// Position of IE2 field.
	ADC_ETC_TRIG3_CHAIN_3_2_IE2_Pos = 0xd
	// Bit mask of IE2 field.
	ADC_ETC_TRIG3_CHAIN_3_2_IE2_Msk = 0x6000
	// Position of CSEL3 field.
	ADC_ETC_TRIG3_CHAIN_3_2_CSEL3_Pos = 0x10
	// Bit mask of CSEL3 field.
	ADC_ETC_TRIG3_CHAIN_3_2_CSEL3_Msk = 0xf0000
	// Position of HWTS3 field.
	ADC_ETC_TRIG3_CHAIN_3_2_HWTS3_Pos = 0x14
	// Bit mask of HWTS3 field.
	ADC_ETC_TRIG3_CHAIN_3_2_HWTS3_Msk = 0xff00000
	// Position of B2B3 field.
	ADC_ETC_TRIG3_CHAIN_3_2_B2B3_Pos = 0x1c
	// Bit mask of B2B3 field.
	ADC_ETC_TRIG3_CHAIN_3_2_B2B3_Msk = 0x10000000
	// Bit B2B3.
	ADC_ETC_TRIG3_CHAIN_3_2_B2B3 = 0x10000000
	// Position of IE3 field.
	ADC_ETC_TRIG3_CHAIN_3_2_IE3_Pos = 0x1d
	// Bit mask of IE3 field.
	ADC_ETC_TRIG3_CHAIN_3_2_IE3_Msk = 0x60000000

	// TRIG3_CHAIN_5_4: ETC_TRIG Chain 4/5 Register
	// Position of CSEL4 field.
	ADC_ETC_TRIG3_CHAIN_5_4_CSEL4_Pos = 0x0
	// Bit mask of CSEL4 field.
	ADC_ETC_TRIG3_CHAIN_5_4_CSEL4_Msk = 0xf
	// Position of HWTS4 field.
	ADC_ETC_TRIG3_CHAIN_5_4_HWTS4_Pos = 0x4
	// Bit mask of HWTS4 field.
	ADC_ETC_TRIG3_CHAIN_5_4_HWTS4_Msk = 0xff0
	// Position of B2B4 field.
	ADC_ETC_TRIG3_CHAIN_5_4_B2B4_Pos = 0xc
	// Bit mask of B2B4 field.
	ADC_ETC_TRIG3_CHAIN_5_4_B2B4_Msk = 0x1000
	// Bit B2B4.
	ADC_ETC_TRIG3_CHAIN_5_4_B2B4 = 0x1000
	// Position of IE4 field.
	ADC_ETC_TRIG3_CHAIN_5_4_IE4_Pos = 0xd
	// Bit mask of IE4 field.
	ADC_ETC_TRIG3_CHAIN_5_4_IE4_Msk = 0x6000
	// Position of CSEL5 field.
	ADC_ETC_TRIG3_CHAIN_5_4_CSEL5_Pos = 0x10
	// Bit mask of CSEL5 field.
	ADC_ETC_TRIG3_CHAIN_5_4_CSEL5_Msk = 0xf0000
	// Position of HWTS5 field.
	ADC_ETC_TRIG3_CHAIN_5_4_HWTS5_Pos = 0x14
	// Bit mask of HWTS5 field.
	ADC_ETC_TRIG3_CHAIN_5_4_HWTS5_Msk = 0xff00000
	// Position of B2B5 field.
	ADC_ETC_TRIG3_CHAIN_5_4_B2B5_Pos = 0x1c
	// Bit mask of B2B5 field.
	ADC_ETC_TRIG3_CHAIN_5_4_B2B5_Msk = 0x10000000
	// Bit B2B5.
	ADC_ETC_TRIG3_CHAIN_5_4_B2B5 = 0x10000000
	// Position of IE5 field.
	ADC_ETC_TRIG3_CHAIN_5_4_IE5_Pos = 0x1d
	// Bit mask of IE5 field.
	ADC_ETC_TRIG3_CHAIN_5_4_IE5_Msk = 0x60000000

	// TRIG3_CHAIN_7_6: ETC_TRIG Chain 6/7 Register
	// Position of CSEL6 field.
	ADC_ETC_TRIG3_CHAIN_7_6_CSEL6_Pos = 0x0
	// Bit mask of CSEL6 field.
	ADC_ETC_TRIG3_CHAIN_7_6_CSEL6_Msk = 0xf
	// Position of HWTS6 field.
	ADC_ETC_TRIG3_CHAIN_7_6_HWTS6_Pos = 0x4
	// Bit mask of HWTS6 field.
	ADC_ETC_TRIG3_CHAIN_7_6_HWTS6_Msk = 0xff0
	// Position of B2B6 field.
	ADC_ETC_TRIG3_CHAIN_7_6_B2B6_Pos = 0xc
	// Bit mask of B2B6 field.
	ADC_ETC_TRIG3_CHAIN_7_6_B2B6_Msk = 0x1000
	// Bit B2B6.
	ADC_ETC_TRIG3_CHAIN_7_6_B2B6 = 0x1000
	// Position of IE6 field.
	ADC_ETC_TRIG3_CHAIN_7_6_IE6_Pos = 0xd
	// Bit mask of IE6 field.
	ADC_ETC_TRIG3_CHAIN_7_6_IE6_Msk = 0x6000
	// Position of CSEL7 field.
	ADC_ETC_TRIG3_CHAIN_7_6_CSEL7_Pos = 0x10
	// Bit mask of CSEL7 field.
	ADC_ETC_TRIG3_CHAIN_7_6_CSEL7_Msk = 0xf0000
	// Position of HWTS7 field.
	ADC_ETC_TRIG3_CHAIN_7_6_HWTS7_Pos = 0x14
	// Bit mask of HWTS7 field.
	ADC_ETC_TRIG3_CHAIN_7_6_HWTS7_Msk = 0xff00000
	// Position of B2B7 field.
	ADC_ETC_TRIG3_CHAIN_7_6_B2B7_Pos = 0x1c
	// Bit mask of B2B7 field.
	ADC_ETC_TRIG3_CHAIN_7_6_B2B7_Msk = 0x10000000
	// Bit B2B7.
	ADC_ETC_TRIG3_CHAIN_7_6_B2B7 = 0x10000000
	// Position of IE7 field.
	ADC_ETC_TRIG3_CHAIN_7_6_IE7_Pos = 0x1d
	// Bit mask of IE7 field.
	ADC_ETC_TRIG3_CHAIN_7_6_IE7_Msk = 0x60000000

	// TRIG3_RESULT_1_0: ETC_TRIG Result Data 1/0 Register
	// Position of DATA0 field.
	ADC_ETC_TRIG3_RESULT_1_0_DATA0_Pos = 0x0
	// Bit mask of DATA0 field.
	ADC_ETC_TRIG3_RESULT_1_0_DATA0_Msk = 0xfff
	// Position of DATA1 field.
	ADC_ETC_TRIG3_RESULT_1_0_DATA1_Pos = 0x10
	// Bit mask of DATA1 field.
	ADC_ETC_TRIG3_RESULT_1_0_DATA1_Msk = 0xfff0000

	// TRIG3_RESULT_3_2: ETC_TRIG Result Data 3/2 Register
	// Position of DATA2 field.
	ADC_ETC_TRIG3_RESULT_3_2_DATA2_Pos = 0x0
	// Bit mask of DATA2 field.
	ADC_ETC_TRIG3_RESULT_3_2_DATA2_Msk = 0xfff
	// Position of DATA3 field.
	ADC_ETC_TRIG3_RESULT_3_2_DATA3_Pos = 0x10
	// Bit mask of DATA3 field.
	ADC_ETC_TRIG3_RESULT_3_2_DATA3_Msk = 0xfff0000

	// TRIG3_RESULT_5_4: ETC_TRIG Result Data 5/4 Register
	// Position of DATA4 field.
	ADC_ETC_TRIG3_RESULT_5_4_DATA4_Pos = 0x0
	// Bit mask of DATA4 field.
	ADC_ETC_TRIG3_RESULT_5_4_DATA4_Msk = 0xfff
	// Position of DATA5 field.
	ADC_ETC_TRIG3_RESULT_5_4_DATA5_Pos = 0x10
	// Bit mask of DATA5 field.
	ADC_ETC_TRIG3_RESULT_5_4_DATA5_Msk = 0xfff0000

	// TRIG3_RESULT_7_6: ETC_TRIG Result Data 7/6 Register
	// Position of DATA6 field.
	ADC_ETC_TRIG3_RESULT_7_6_DATA6_Pos = 0x0
	// Bit mask of DATA6 field.
	ADC_ETC_TRIG3_RESULT_7_6_DATA6_Msk = 0xfff
	// Position of DATA7 field.
	ADC_ETC_TRIG3_RESULT_7_6_DATA7_Pos = 0x10
	// Bit mask of DATA7 field.
	ADC_ETC_TRIG3_RESULT_7_6_DATA7_Msk = 0xfff0000

	// TRIG4_CTRL: ETC_TRIG4 Control Register
	// Position of SW_TRIG field.
	ADC_ETC_TRIG4_CTRL_SW_TRIG_Pos = 0x0
	// Bit mask of SW_TRIG field.
	ADC_ETC_TRIG4_CTRL_SW_TRIG_Msk = 0x1
	// Bit SW_TRIG.
	ADC_ETC_TRIG4_CTRL_SW_TRIG = 0x1
	// Position of TRIG_MODE field.
	ADC_ETC_TRIG4_CTRL_TRIG_MODE_Pos = 0x4
	// Bit mask of TRIG_MODE field.
	ADC_ETC_TRIG4_CTRL_TRIG_MODE_Msk = 0x10
	// Bit TRIG_MODE.
	ADC_ETC_TRIG4_CTRL_TRIG_MODE = 0x10
	// Position of TRIG_CHAIN field.
	ADC_ETC_TRIG4_CTRL_TRIG_CHAIN_Pos = 0x8
	// Bit mask of TRIG_CHAIN field.
	ADC_ETC_TRIG4_CTRL_TRIG_CHAIN_Msk = 0x700
	// Position of TRIG_PRIORITY field.
	ADC_ETC_TRIG4_CTRL_TRIG_PRIORITY_Pos = 0xc
	// Bit mask of TRIG_PRIORITY field.
	ADC_ETC_TRIG4_CTRL_TRIG_PRIORITY_Msk = 0x7000
	// Position of SYNC_MODE field.
	ADC_ETC_TRIG4_CTRL_SYNC_MODE_Pos = 0x10
	// Bit mask of SYNC_MODE field.
	ADC_ETC_TRIG4_CTRL_SYNC_MODE_Msk = 0x10000
	// Bit SYNC_MODE.
	ADC_ETC_TRIG4_CTRL_SYNC_MODE = 0x10000

	// TRIG4_COUNTER: ETC_TRIG4 Counter Register
	// Position of INIT_DELAY field.
	ADC_ETC_TRIG4_COUNTER_INIT_DELAY_Pos = 0x0
	// Bit mask of INIT_DELAY field.
	ADC_ETC_TRIG4_COUNTER_INIT_DELAY_Msk = 0xffff
	// Position of SAMPLE_INTERVAL field.
	ADC_ETC_TRIG4_COUNTER_SAMPLE_INTERVAL_Pos = 0x10
	// Bit mask of SAMPLE_INTERVAL field.
	ADC_ETC_TRIG4_COUNTER_SAMPLE_INTERVAL_Msk = 0xffff0000

	// TRIG4_CHAIN_1_0: ETC_TRIG Chain 0/1 Register
	// Position of CSEL0 field.
	ADC_ETC_TRIG4_CHAIN_1_0_CSEL0_Pos = 0x0
	// Bit mask of CSEL0 field.
	ADC_ETC_TRIG4_CHAIN_1_0_CSEL0_Msk = 0xf
	// Position of HWTS0 field.
	ADC_ETC_TRIG4_CHAIN_1_0_HWTS0_Pos = 0x4
	// Bit mask of HWTS0 field.
	ADC_ETC_TRIG4_CHAIN_1_0_HWTS0_Msk = 0xff0
	// Position of B2B0 field.
	ADC_ETC_TRIG4_CHAIN_1_0_B2B0_Pos = 0xc
	// Bit mask of B2B0 field.
	ADC_ETC_TRIG4_CHAIN_1_0_B2B0_Msk = 0x1000
	// Bit B2B0.
	ADC_ETC_TRIG4_CHAIN_1_0_B2B0 = 0x1000
	// Position of IE0 field.
	ADC_ETC_TRIG4_CHAIN_1_0_IE0_Pos = 0xd
	// Bit mask of IE0 field.
	ADC_ETC_TRIG4_CHAIN_1_0_IE0_Msk = 0x6000
	// Position of CSEL1 field.
	ADC_ETC_TRIG4_CHAIN_1_0_CSEL1_Pos = 0x10
	// Bit mask of CSEL1 field.
	ADC_ETC_TRIG4_CHAIN_1_0_CSEL1_Msk = 0xf0000
	// Position of HWTS1 field.
	ADC_ETC_TRIG4_CHAIN_1_0_HWTS1_Pos = 0x14
	// Bit mask of HWTS1 field.
	ADC_ETC_TRIG4_CHAIN_1_0_HWTS1_Msk = 0xff00000
	// Position of B2B1 field.
	ADC_ETC_TRIG4_CHAIN_1_0_B2B1_Pos = 0x1c
	// Bit mask of B2B1 field.
	ADC_ETC_TRIG4_CHAIN_1_0_B2B1_Msk = 0x10000000
	// Bit B2B1.
	ADC_ETC_TRIG4_CHAIN_1_0_B2B1 = 0x10000000
	// Position of IE1 field.
	ADC_ETC_TRIG4_CHAIN_1_0_IE1_Pos = 0x1d
	// Bit mask of IE1 field.
	ADC_ETC_TRIG4_CHAIN_1_0_IE1_Msk = 0x60000000

	// TRIG4_CHAIN_3_2: ETC_TRIG Chain 2/3 Register
	// Position of CSEL2 field.
	ADC_ETC_TRIG4_CHAIN_3_2_CSEL2_Pos = 0x0
	// Bit mask of CSEL2 field.
	ADC_ETC_TRIG4_CHAIN_3_2_CSEL2_Msk = 0xf
	// Position of HWTS2 field.
	ADC_ETC_TRIG4_CHAIN_3_2_HWTS2_Pos = 0x4
	// Bit mask of HWTS2 field.
	ADC_ETC_TRIG4_CHAIN_3_2_HWTS2_Msk = 0xff0
	// Position of B2B2 field.
	ADC_ETC_TRIG4_CHAIN_3_2_B2B2_Pos = 0xc
	// Bit mask of B2B2 field.
	ADC_ETC_TRIG4_CHAIN_3_2_B2B2_Msk = 0x1000
	// Bit B2B2.
	ADC_ETC_TRIG4_CHAIN_3_2_B2B2 = 0x1000
	// Position of IE2 field.
	ADC_ETC_TRIG4_CHAIN_3_2_IE2_Pos = 0xd
	// Bit mask of IE2 field.
	ADC_ETC_TRIG4_CHAIN_3_2_IE2_Msk = 0x6000
	// Position of CSEL3 field.
	ADC_ETC_TRIG4_CHAIN_3_2_CSEL3_Pos = 0x10
	// Bit mask of CSEL3 field.
	ADC_ETC_TRIG4_CHAIN_3_2_CSEL3_Msk = 0xf0000
	// Position of HWTS3 field.
	ADC_ETC_TRIG4_CHAIN_3_2_HWTS3_Pos = 0x14
	// Bit mask of HWTS3 field.
	ADC_ETC_TRIG4_CHAIN_3_2_HWTS3_Msk = 0xff00000
	// Position of B2B3 field.
	ADC_ETC_TRIG4_CHAIN_3_2_B2B3_Pos = 0x1c
	// Bit mask of B2B3 field.
	ADC_ETC_TRIG4_CHAIN_3_2_B2B3_Msk = 0x10000000
	// Bit B2B3.
	ADC_ETC_TRIG4_CHAIN_3_2_B2B3 = 0x10000000
	// Position of IE3 field.
	ADC_ETC_TRIG4_CHAIN_3_2_IE3_Pos = 0x1d
	// Bit mask of IE3 field.
	ADC_ETC_TRIG4_CHAIN_3_2_IE3_Msk = 0x60000000

	// TRIG4_CHAIN_5_4: ETC_TRIG Chain 4/5 Register
	// Position of CSEL4 field.
	ADC_ETC_TRIG4_CHAIN_5_4_CSEL4_Pos = 0x0
	// Bit mask of CSEL4 field.
	ADC_ETC_TRIG4_CHAIN_5_4_CSEL4_Msk = 0xf
	// Position of HWTS4 field.
	ADC_ETC_TRIG4_CHAIN_5_4_HWTS4_Pos = 0x4
	// Bit mask of HWTS4 field.
	ADC_ETC_TRIG4_CHAIN_5_4_HWTS4_Msk = 0xff0
	// Position of B2B4 field.
	ADC_ETC_TRIG4_CHAIN_5_4_B2B4_Pos = 0xc
	// Bit mask of B2B4 field.
	ADC_ETC_TRIG4_CHAIN_5_4_B2B4_Msk = 0x1000
	// Bit B2B4.
	ADC_ETC_TRIG4_CHAIN_5_4_B2B4 = 0x1000
	// Position of IE4 field.
	ADC_ETC_TRIG4_CHAIN_5_4_IE4_Pos = 0xd
	// Bit mask of IE4 field.
	ADC_ETC_TRIG4_CHAIN_5_4_IE4_Msk = 0x6000
	// Position of CSEL5 field.
	ADC_ETC_TRIG4_CHAIN_5_4_CSEL5_Pos = 0x10
	// Bit mask of CSEL5 field.
	ADC_ETC_TRIG4_CHAIN_5_4_CSEL5_Msk = 0xf0000
	// Position of HWTS5 field.
	ADC_ETC_TRIG4_CHAIN_5_4_HWTS5_Pos = 0x14
	// Bit mask of HWTS5 field.
	ADC_ETC_TRIG4_CHAIN_5_4_HWTS5_Msk = 0xff00000
	// Position of B2B5 field.
	ADC_ETC_TRIG4_CHAIN_5_4_B2B5_Pos = 0x1c
	// Bit mask of B2B5 field.
	ADC_ETC_TRIG4_CHAIN_5_4_B2B5_Msk = 0x10000000
	// Bit B2B5.
	ADC_ETC_TRIG4_CHAIN_5_4_B2B5 = 0x10000000
	// Position of IE5 field.
	ADC_ETC_TRIG4_CHAIN_5_4_IE5_Pos = 0x1d
	// Bit mask of IE5 field.
	ADC_ETC_TRIG4_CHAIN_5_4_IE5_Msk = 0x60000000

	// TRIG4_CHAIN_7_6: ETC_TRIG Chain 6/7 Register
	// Position of CSEL6 field.
	ADC_ETC_TRIG4_CHAIN_7_6_CSEL6_Pos = 0x0
	// Bit mask of CSEL6 field.
	ADC_ETC_TRIG4_CHAIN_7_6_CSEL6_Msk = 0xf
	// Position of HWTS6 field.
	ADC_ETC_TRIG4_CHAIN_7_6_HWTS6_Pos = 0x4
	// Bit mask of HWTS6 field.
	ADC_ETC_TRIG4_CHAIN_7_6_HWTS6_Msk = 0xff0
	// Position of B2B6 field.
	ADC_ETC_TRIG4_CHAIN_7_6_B2B6_Pos = 0xc
	// Bit mask of B2B6 field.
	ADC_ETC_TRIG4_CHAIN_7_6_B2B6_Msk = 0x1000
	// Bit B2B6.
	ADC_ETC_TRIG4_CHAIN_7_6_B2B6 = 0x1000
	// Position of IE6 field.
	ADC_ETC_TRIG4_CHAIN_7_6_IE6_Pos = 0xd
	// Bit mask of IE6 field.
	ADC_ETC_TRIG4_CHAIN_7_6_IE6_Msk = 0x6000
	// Position of CSEL7 field.
	ADC_ETC_TRIG4_CHAIN_7_6_CSEL7_Pos = 0x10
	// Bit mask of CSEL7 field.
	ADC_ETC_TRIG4_CHAIN_7_6_CSEL7_Msk = 0xf0000
	// Position of HWTS7 field.
	ADC_ETC_TRIG4_CHAIN_7_6_HWTS7_Pos = 0x14
	// Bit mask of HWTS7 field.
	ADC_ETC_TRIG4_CHAIN_7_6_HWTS7_Msk = 0xff00000
	// Position of B2B7 field.
	ADC_ETC_TRIG4_CHAIN_7_6_B2B7_Pos = 0x1c
	// Bit mask of B2B7 field.
	ADC_ETC_TRIG4_CHAIN_7_6_B2B7_Msk = 0x10000000
	// Bit B2B7.
	ADC_ETC_TRIG4_CHAIN_7_6_B2B7 = 0x10000000
	// Position of IE7 field.
	ADC_ETC_TRIG4_CHAIN_7_6_IE7_Pos = 0x1d
	// Bit mask of IE7 field.
	ADC_ETC_TRIG4_CHAIN_7_6_IE7_Msk = 0x60000000

	// TRIG4_RESULT_1_0: ETC_TRIG Result Data 1/0 Register
	// Position of DATA0 field.
	ADC_ETC_TRIG4_RESULT_1_0_DATA0_Pos = 0x0
	// Bit mask of DATA0 field.
	ADC_ETC_TRIG4_RESULT_1_0_DATA0_Msk = 0xfff
	// Position of DATA1 field.
	ADC_ETC_TRIG4_RESULT_1_0_DATA1_Pos = 0x10
	// Bit mask of DATA1 field.
	ADC_ETC_TRIG4_RESULT_1_0_DATA1_Msk = 0xfff0000

	// TRIG4_RESULT_3_2: ETC_TRIG Result Data 3/2 Register
	// Position of DATA2 field.
	ADC_ETC_TRIG4_RESULT_3_2_DATA2_Pos = 0x0
	// Bit mask of DATA2 field.
	ADC_ETC_TRIG4_RESULT_3_2_DATA2_Msk = 0xfff
	// Position of DATA3 field.
	ADC_ETC_TRIG4_RESULT_3_2_DATA3_Pos = 0x10
	// Bit mask of DATA3 field.
	ADC_ETC_TRIG4_RESULT_3_2_DATA3_Msk = 0xfff0000

	// TRIG4_RESULT_5_4: ETC_TRIG Result Data 5/4 Register
	// Position of DATA4 field.
	ADC_ETC_TRIG4_RESULT_5_4_DATA4_Pos = 0x0
	// Bit mask of DATA4 field.
	ADC_ETC_TRIG4_RESULT_5_4_DATA4_Msk = 0xfff
	// Position of DATA5 field.
	ADC_ETC_TRIG4_RESULT_5_4_DATA5_Pos = 0x10
	// Bit mask of DATA5 field.
	ADC_ETC_TRIG4_RESULT_5_4_DATA5_Msk = 0xfff0000

	// TRIG4_RESULT_7_6: ETC_TRIG Result Data 7/6 Register
	// Position of DATA6 field.
	ADC_ETC_TRIG4_RESULT_7_6_DATA6_Pos = 0x0
	// Bit mask of DATA6 field.
	ADC_ETC_TRIG4_RESULT_7_6_DATA6_Msk = 0xfff
	// Position of DATA7 field.
	ADC_ETC_TRIG4_RESULT_7_6_DATA7_Pos = 0x10
	// Bit mask of DATA7 field.
	ADC_ETC_TRIG4_RESULT_7_6_DATA7_Msk = 0xfff0000

	// TRIG5_CTRL: ETC_TRIG5 Control Register
	// Position of SW_TRIG field.
	ADC_ETC_TRIG5_CTRL_SW_TRIG_Pos = 0x0
	// Bit mask of SW_TRIG field.
	ADC_ETC_TRIG5_CTRL_SW_TRIG_Msk = 0x1
	// Bit SW_TRIG.
	ADC_ETC_TRIG5_CTRL_SW_TRIG = 0x1
	// Position of TRIG_MODE field.
	ADC_ETC_TRIG5_CTRL_TRIG_MODE_Pos = 0x4
	// Bit mask of TRIG_MODE field.
	ADC_ETC_TRIG5_CTRL_TRIG_MODE_Msk = 0x10
	// Bit TRIG_MODE.
	ADC_ETC_TRIG5_CTRL_TRIG_MODE = 0x10
	// Position of TRIG_CHAIN field.
	ADC_ETC_TRIG5_CTRL_TRIG_CHAIN_Pos = 0x8
	// Bit mask of TRIG_CHAIN field.
	ADC_ETC_TRIG5_CTRL_TRIG_CHAIN_Msk = 0x700
	// Position of TRIG_PRIORITY field.
	ADC_ETC_TRIG5_CTRL_TRIG_PRIORITY_Pos = 0xc
	// Bit mask of TRIG_PRIORITY field.
	ADC_ETC_TRIG5_CTRL_TRIG_PRIORITY_Msk = 0x7000
	// Position of SYNC_MODE field.
	ADC_ETC_TRIG5_CTRL_SYNC_MODE_Pos = 0x10
	// Bit mask of SYNC_MODE field.
	ADC_ETC_TRIG5_CTRL_SYNC_MODE_Msk = 0x10000
	// Bit SYNC_MODE.
	ADC_ETC_TRIG5_CTRL_SYNC_MODE = 0x10000

	// TRIG5_COUNTER: ETC_TRIG5 Counter Register
	// Position of INIT_DELAY field.
	ADC_ETC_TRIG5_COUNTER_INIT_DELAY_Pos = 0x0
	// Bit mask of INIT_DELAY field.
	ADC_ETC_TRIG5_COUNTER_INIT_DELAY_Msk = 0xffff
	// Position of SAMPLE_INTERVAL field.
	ADC_ETC_TRIG5_COUNTER_SAMPLE_INTERVAL_Pos = 0x10
	// Bit mask of SAMPLE_INTERVAL field.
	ADC_ETC_TRIG5_COUNTER_SAMPLE_INTERVAL_Msk = 0xffff0000

	// TRIG5_CHAIN_1_0: ETC_TRIG Chain 0/1 Register
	// Position of CSEL0 field.
	ADC_ETC_TRIG5_CHAIN_1_0_CSEL0_Pos = 0x0
	// Bit mask of CSEL0 field.
	ADC_ETC_TRIG5_CHAIN_1_0_CSEL0_Msk = 0xf
	// Position of HWTS0 field.
	ADC_ETC_TRIG5_CHAIN_1_0_HWTS0_Pos = 0x4
	// Bit mask of HWTS0 field.
	ADC_ETC_TRIG5_CHAIN_1_0_HWTS0_Msk = 0xff0
	// Position of B2B0 field.
	ADC_ETC_TRIG5_CHAIN_1_0_B2B0_Pos = 0xc
	// Bit mask of B2B0 field.
	ADC_ETC_TRIG5_CHAIN_1_0_B2B0_Msk = 0x1000
	// Bit B2B0.
	ADC_ETC_TRIG5_CHAIN_1_0_B2B0 = 0x1000
	// Position of IE0 field.
	ADC_ETC_TRIG5_CHAIN_1_0_IE0_Pos = 0xd
	// Bit mask of IE0 field.
	ADC_ETC_TRIG5_CHAIN_1_0_IE0_Msk = 0x6000
	// Position of CSEL1 field.
	ADC_ETC_TRIG5_CHAIN_1_0_CSEL1_Pos = 0x10
	// Bit mask of CSEL1 field.
	ADC_ETC_TRIG5_CHAIN_1_0_CSEL1_Msk = 0xf0000
	// Position of HWTS1 field.
	ADC_ETC_TRIG5_CHAIN_1_0_HWTS1_Pos = 0x14
	// Bit mask of HWTS1 field.
	ADC_ETC_TRIG5_CHAIN_1_0_HWTS1_Msk = 0xff00000
	// Position of B2B1 field.
	ADC_ETC_TRIG5_CHAIN_1_0_B2B1_Pos = 0x1c
	// Bit mask of B2B1 field.
	ADC_ETC_TRIG5_CHAIN_1_0_B2B1_Msk = 0x10000000
	// Bit B2B1.
	ADC_ETC_TRIG5_CHAIN_1_0_B2B1 = 0x10000000
	// Position of IE1 field.
	ADC_ETC_TRIG5_CHAIN_1_0_IE1_Pos = 0x1d
	// Bit mask of IE1 field.
	ADC_ETC_TRIG5_CHAIN_1_0_IE1_Msk = 0x60000000

	// TRIG5_CHAIN_3_2: ETC_TRIG Chain 2/3 Register
	// Position of CSEL2 field.
	ADC_ETC_TRIG5_CHAIN_3_2_CSEL2_Pos = 0x0
	// Bit mask of CSEL2 field.
	ADC_ETC_TRIG5_CHAIN_3_2_CSEL2_Msk = 0xf
	// Position of HWTS2 field.
	ADC_ETC_TRIG5_CHAIN_3_2_HWTS2_Pos = 0x4
	// Bit mask of HWTS2 field.
	ADC_ETC_TRIG5_CHAIN_3_2_HWTS2_Msk = 0xff0
	// Position of B2B2 field.
	ADC_ETC_TRIG5_CHAIN_3_2_B2B2_Pos = 0xc
	// Bit mask of B2B2 field.
	ADC_ETC_TRIG5_CHAIN_3_2_B2B2_Msk = 0x1000
	// Bit B2B2.
	ADC_ETC_TRIG5_CHAIN_3_2_B2B2 = 0x1000
	// Position of IE2 field.
	ADC_ETC_TRIG5_CHAIN_3_2_IE2_Pos = 0xd
	// Bit mask of IE2 field.
	ADC_ETC_TRIG5_CHAIN_3_2_IE2_Msk = 0x6000
	// Position of CSEL3 field.
	ADC_ETC_TRIG5_CHAIN_3_2_CSEL3_Pos = 0x10
	// Bit mask of CSEL3 field.
	ADC_ETC_TRIG5_CHAIN_3_2_CSEL3_Msk = 0xf0000
	// Position of HWTS3 field.
	ADC_ETC_TRIG5_CHAIN_3_2_HWTS3_Pos = 0x14
	// Bit mask of HWTS3 field.
	ADC_ETC_TRIG5_CHAIN_3_2_HWTS3_Msk = 0xff00000
	// Position of B2B3 field.
	ADC_ETC_TRIG5_CHAIN_3_2_B2B3_Pos = 0x1c
	// Bit mask of B2B3 field.
	ADC_ETC_TRIG5_CHAIN_3_2_B2B3_Msk = 0x10000000
	// Bit B2B3.
	ADC_ETC_TRIG5_CHAIN_3_2_B2B3 = 0x10000000
	// Position of IE3 field.
	ADC_ETC_TRIG5_CHAIN_3_2_IE3_Pos = 0x1d
	// Bit mask of IE3 field.
	ADC_ETC_TRIG5_CHAIN_3_2_IE3_Msk = 0x60000000

	// TRIG5_CHAIN_5_4: ETC_TRIG Chain 4/5 Register
	// Position of CSEL4 field.
	ADC_ETC_TRIG5_CHAIN_5_4_CSEL4_Pos = 0x0
	// Bit mask of CSEL4 field.
	ADC_ETC_TRIG5_CHAIN_5_4_CSEL4_Msk = 0xf
	// Position of HWTS4 field.
	ADC_ETC_TRIG5_CHAIN_5_4_HWTS4_Pos = 0x4
	// Bit mask of HWTS4 field.
	ADC_ETC_TRIG5_CHAIN_5_4_HWTS4_Msk = 0xff0
	// Position of B2B4 field.
	ADC_ETC_TRIG5_CHAIN_5_4_B2B4_Pos = 0xc
	// Bit mask of B2B4 field.
	ADC_ETC_TRIG5_CHAIN_5_4_B2B4_Msk = 0x1000
	// Bit B2B4.
	ADC_ETC_TRIG5_CHAIN_5_4_B2B4 = 0x1000
	// Position of IE4 field.
	ADC_ETC_TRIG5_CHAIN_5_4_IE4_Pos = 0xd
	// Bit mask of IE4 field.
	ADC_ETC_TRIG5_CHAIN_5_4_IE4_Msk = 0x6000
	// Position of CSEL5 field.
	ADC_ETC_TRIG5_CHAIN_5_4_CSEL5_Pos = 0x10
	// Bit mask of CSEL5 field.
	ADC_ETC_TRIG5_CHAIN_5_4_CSEL5_Msk = 0xf0000
	// Position of HWTS5 field.
	ADC_ETC_TRIG5_CHAIN_5_4_HWTS5_Pos = 0x14
	// Bit mask of HWTS5 field.
	ADC_ETC_TRIG5_CHAIN_5_4_HWTS5_Msk = 0xff00000
	// Position of B2B5 field.
	ADC_ETC_TRIG5_CHAIN_5_4_B2B5_Pos = 0x1c
	// Bit mask of B2B5 field.
	ADC_ETC_TRIG5_CHAIN_5_4_B2B5_Msk = 0x10000000
	// Bit B2B5.
	ADC_ETC_TRIG5_CHAIN_5_4_B2B5 = 0x10000000
	// Position of IE5 field.
	ADC_ETC_TRIG5_CHAIN_5_4_IE5_Pos = 0x1d
	// Bit mask of IE5 field.
	ADC_ETC_TRIG5_CHAIN_5_4_IE5_Msk = 0x60000000

	// TRIG5_CHAIN_7_6: ETC_TRIG Chain 6/7 Register
	// Position of CSEL6 field.
	ADC_ETC_TRIG5_CHAIN_7_6_CSEL6_Pos = 0x0
	// Bit mask of CSEL6 field.
	ADC_ETC_TRIG5_CHAIN_7_6_CSEL6_Msk = 0xf
	// Position of HWTS6 field.
	ADC_ETC_TRIG5_CHAIN_7_6_HWTS6_Pos = 0x4
	// Bit mask of HWTS6 field.
	ADC_ETC_TRIG5_CHAIN_7_6_HWTS6_Msk = 0xff0
	// Position of B2B6 field.
	ADC_ETC_TRIG5_CHAIN_7_6_B2B6_Pos = 0xc
	// Bit mask of B2B6 field.
	ADC_ETC_TRIG5_CHAIN_7_6_B2B6_Msk = 0x1000
	// Bit B2B6.
	ADC_ETC_TRIG5_CHAIN_7_6_B2B6 = 0x1000
	// Position of IE6 field.
	ADC_ETC_TRIG5_CHAIN_7_6_IE6_Pos = 0xd
	// Bit mask of IE6 field.
	ADC_ETC_TRIG5_CHAIN_7_6_IE6_Msk = 0x6000
	// Position of CSEL7 field.
	ADC_ETC_TRIG5_CHAIN_7_6_CSEL7_Pos = 0x10
	// Bit mask of CSEL7 field.
	ADC_ETC_TRIG5_CHAIN_7_6_CSEL7_Msk = 0xf0000
	// Position of HWTS7 field.
	ADC_ETC_TRIG5_CHAIN_7_6_HWTS7_Pos = 0x14
	// Bit mask of HWTS7 field.
	ADC_ETC_TRIG5_CHAIN_7_6_HWTS7_Msk = 0xff00000
	// Position of B2B7 field.
	ADC_ETC_TRIG5_CHAIN_7_6_B2B7_Pos = 0x1c
	// Bit mask of B2B7 field.
	ADC_ETC_TRIG5_CHAIN_7_6_B2B7_Msk = 0x10000000
	// Bit B2B7.
	ADC_ETC_TRIG5_CHAIN_7_6_B2B7 = 0x10000000
	// Position of IE7 field.
	ADC_ETC_TRIG5_CHAIN_7_6_IE7_Pos = 0x1d
	// Bit mask of IE7 field.
	ADC_ETC_TRIG5_CHAIN_7_6_IE7_Msk = 0x60000000

	// TRIG5_RESULT_1_0: ETC_TRIG Result Data 1/0 Register
	// Position of DATA0 field.
	ADC_ETC_TRIG5_RESULT_1_0_DATA0_Pos = 0x0
	// Bit mask of DATA0 field.
	ADC_ETC_TRIG5_RESULT_1_0_DATA0_Msk = 0xfff
	// Position of DATA1 field.
	ADC_ETC_TRIG5_RESULT_1_0_DATA1_Pos = 0x10
	// Bit mask of DATA1 field.
	ADC_ETC_TRIG5_RESULT_1_0_DATA1_Msk = 0xfff0000

	// TRIG5_RESULT_3_2: ETC_TRIG Result Data 3/2 Register
	// Position of DATA2 field.
	ADC_ETC_TRIG5_RESULT_3_2_DATA2_Pos = 0x0
	// Bit mask of DATA2 field.
	ADC_ETC_TRIG5_RESULT_3_2_DATA2_Msk = 0xfff
	// Position of DATA3 field.
	ADC_ETC_TRIG5_RESULT_3_2_DATA3_Pos = 0x10
	// Bit mask of DATA3 field.
	ADC_ETC_TRIG5_RESULT_3_2_DATA3_Msk = 0xfff0000

	// TRIG5_RESULT_5_4: ETC_TRIG Result Data 5/4 Register
	// Position of DATA4 field.
	ADC_ETC_TRIG5_RESULT_5_4_DATA4_Pos = 0x0
	// Bit mask of DATA4 field.
	ADC_ETC_TRIG5_RESULT_5_4_DATA4_Msk = 0xfff
	// Position of DATA5 field.
	ADC_ETC_TRIG5_RESULT_5_4_DATA5_Pos = 0x10
	// Bit mask of DATA5 field.
	ADC_ETC_TRIG5_RESULT_5_4_DATA5_Msk = 0xfff0000

	// TRIG5_RESULT_7_6: ETC_TRIG Result Data 7/6 Register
	// Position of DATA6 field.
	ADC_ETC_TRIG5_RESULT_7_6_DATA6_Pos = 0x0
	// Bit mask of DATA6 field.
	ADC_ETC_TRIG5_RESULT_7_6_DATA6_Msk = 0xfff
	// Position of DATA7 field.
	ADC_ETC_TRIG5_RESULT_7_6_DATA7_Pos = 0x10
	// Bit mask of DATA7 field.
	ADC_ETC_TRIG5_RESULT_7_6_DATA7_Msk = 0xfff0000

	// TRIG6_CTRL: ETC_TRIG6 Control Register
	// Position of SW_TRIG field.
	ADC_ETC_TRIG6_CTRL_SW_TRIG_Pos = 0x0
	// Bit mask of SW_TRIG field.
	ADC_ETC_TRIG6_CTRL_SW_TRIG_Msk = 0x1
	// Bit SW_TRIG.
	ADC_ETC_TRIG6_CTRL_SW_TRIG = 0x1
	// Position of TRIG_MODE field.
	ADC_ETC_TRIG6_CTRL_TRIG_MODE_Pos = 0x4
	// Bit mask of TRIG_MODE field.
	ADC_ETC_TRIG6_CTRL_TRIG_MODE_Msk = 0x10
	// Bit TRIG_MODE.
	ADC_ETC_TRIG6_CTRL_TRIG_MODE = 0x10
	// Position of TRIG_CHAIN field.
	ADC_ETC_TRIG6_CTRL_TRIG_CHAIN_Pos = 0x8
	// Bit mask of TRIG_CHAIN field.
	ADC_ETC_TRIG6_CTRL_TRIG_CHAIN_Msk = 0x700
	// Position of TRIG_PRIORITY field.
	ADC_ETC_TRIG6_CTRL_TRIG_PRIORITY_Pos = 0xc
	// Bit mask of TRIG_PRIORITY field.
	ADC_ETC_TRIG6_CTRL_TRIG_PRIORITY_Msk = 0x7000
	// Position of SYNC_MODE field.
	ADC_ETC_TRIG6_CTRL_SYNC_MODE_Pos = 0x10
	// Bit mask of SYNC_MODE field.
	ADC_ETC_TRIG6_CTRL_SYNC_MODE_Msk = 0x10000
	// Bit SYNC_MODE.
	ADC_ETC_TRIG6_CTRL_SYNC_MODE = 0x10000

	// TRIG6_COUNTER: ETC_TRIG6 Counter Register
	// Position of INIT_DELAY field.
	ADC_ETC_TRIG6_COUNTER_INIT_DELAY_Pos = 0x0
	// Bit mask of INIT_DELAY field.
	ADC_ETC_TRIG6_COUNTER_INIT_DELAY_Msk = 0xffff
	// Position of SAMPLE_INTERVAL field.
	ADC_ETC_TRIG6_COUNTER_SAMPLE_INTERVAL_Pos = 0x10
	// Bit mask of SAMPLE_INTERVAL field.
	ADC_ETC_TRIG6_COUNTER_SAMPLE_INTERVAL_Msk = 0xffff0000

	// TRIG6_CHAIN_1_0: ETC_TRIG Chain 0/1 Register
	// Position of CSEL0 field.
	ADC_ETC_TRIG6_CHAIN_1_0_CSEL0_Pos = 0x0
	// Bit mask of CSEL0 field.
	ADC_ETC_TRIG6_CHAIN_1_0_CSEL0_Msk = 0xf
	// Position of HWTS0 field.
	ADC_ETC_TRIG6_CHAIN_1_0_HWTS0_Pos = 0x4
	// Bit mask of HWTS0 field.
	ADC_ETC_TRIG6_CHAIN_1_0_HWTS0_Msk = 0xff0
	// Position of B2B0 field.
	ADC_ETC_TRIG6_CHAIN_1_0_B2B0_Pos = 0xc
	// Bit mask of B2B0 field.
	ADC_ETC_TRIG6_CHAIN_1_0_B2B0_Msk = 0x1000
	// Bit B2B0.
	ADC_ETC_TRIG6_CHAIN_1_0_B2B0 = 0x1000
	// Position of IE0 field.
	ADC_ETC_TRIG6_CHAIN_1_0_IE0_Pos = 0xd
	// Bit mask of IE0 field.
	ADC_ETC_TRIG6_CHAIN_1_0_IE0_Msk = 0x6000
	// Position of CSEL1 field.
	ADC_ETC_TRIG6_CHAIN_1_0_CSEL1_Pos = 0x10
	// Bit mask of CSEL1 field.
	ADC_ETC_TRIG6_CHAIN_1_0_CSEL1_Msk = 0xf0000
	// Position of HWTS1 field.
	ADC_ETC_TRIG6_CHAIN_1_0_HWTS1_Pos = 0x14
	// Bit mask of HWTS1 field.
	ADC_ETC_TRIG6_CHAIN_1_0_HWTS1_Msk = 0xff00000
	// Position of B2B1 field.
	ADC_ETC_TRIG6_CHAIN_1_0_B2B1_Pos = 0x1c
	// Bit mask of B2B1 field.
	ADC_ETC_TRIG6_CHAIN_1_0_B2B1_Msk = 0x10000000
	// Bit B2B1.
	ADC_ETC_TRIG6_CHAIN_1_0_B2B1 = 0x10000000
	// Position of IE1 field.
	ADC_ETC_TRIG6_CHAIN_1_0_IE1_Pos = 0x1d
	// Bit mask of IE1 field.
	ADC_ETC_TRIG6_CHAIN_1_0_IE1_Msk = 0x60000000

	// TRIG6_CHAIN_3_2: ETC_TRIG Chain 2/3 Register
	// Position of CSEL2 field.
	ADC_ETC_TRIG6_CHAIN_3_2_CSEL2_Pos = 0x0
	// Bit mask of CSEL2 field.
	ADC_ETC_TRIG6_CHAIN_3_2_CSEL2_Msk = 0xf
	// Position of HWTS2 field.
	ADC_ETC_TRIG6_CHAIN_3_2_HWTS2_Pos = 0x4
	// Bit mask of HWTS2 field.
	ADC_ETC_TRIG6_CHAIN_3_2_HWTS2_Msk = 0xff0
	// Position of B2B2 field.
	ADC_ETC_TRIG6_CHAIN_3_2_B2B2_Pos = 0xc
	// Bit mask of B2B2 field.
	ADC_ETC_TRIG6_CHAIN_3_2_B2B2_Msk = 0x1000
	// Bit B2B2.
	ADC_ETC_TRIG6_CHAIN_3_2_B2B2 = 0x1000
	// Position of IE2 field.
	ADC_ETC_TRIG6_CHAIN_3_2_IE2_Pos = 0xd
	// Bit mask of IE2 field.
	ADC_ETC_TRIG6_CHAIN_3_2_IE2_Msk = 0x6000
	// Position of CSEL3 field.
	ADC_ETC_TRIG6_CHAIN_3_2_CSEL3_Pos = 0x10
	// Bit mask of CSEL3 field.
	ADC_ETC_TRIG6_CHAIN_3_2_CSEL3_Msk = 0xf0000
	// Position of HWTS3 field.
	ADC_ETC_TRIG6_CHAIN_3_2_HWTS3_Pos = 0x14
	// Bit mask of HWTS3 field.
	ADC_ETC_TRIG6_CHAIN_3_2_HWTS3_Msk = 0xff00000
	// Position of B2B3 field.
	ADC_ETC_TRIG6_CHAIN_3_2_B2B3_Pos = 0x1c
	// Bit mask of B2B3 field.
	ADC_ETC_TRIG6_CHAIN_3_2_B2B3_Msk = 0x10000000
	// Bit B2B3.
	ADC_ETC_TRIG6_CHAIN_3_2_B2B3 = 0x10000000
	// Position of IE3 field.
	ADC_ETC_TRIG6_CHAIN_3_2_IE3_Pos = 0x1d
	// Bit mask of IE3 field.
	ADC_ETC_TRIG6_CHAIN_3_2_IE3_Msk = 0x60000000

	// TRIG6_CHAIN_5_4: ETC_TRIG Chain 4/5 Register
	// Position of CSEL4 field.
	ADC_ETC_TRIG6_CHAIN_5_4_CSEL4_Pos = 0x0
	// Bit mask of CSEL4 field.
	ADC_ETC_TRIG6_CHAIN_5_4_CSEL4_Msk = 0xf
	// Position of HWTS4 field.
	ADC_ETC_TRIG6_CHAIN_5_4_HWTS4_Pos = 0x4
	// Bit mask of HWTS4 field.
	ADC_ETC_TRIG6_CHAIN_5_4_HWTS4_Msk = 0xff0
	// Position of B2B4 field.
	ADC_ETC_TRIG6_CHAIN_5_4_B2B4_Pos = 0xc
	// Bit mask of B2B4 field.
	ADC_ETC_TRIG6_CHAIN_5_4_B2B4_Msk = 0x1000
	// Bit B2B4.
	ADC_ETC_TRIG6_CHAIN_5_4_B2B4 = 0x1000
	// Position of IE4 field.
	ADC_ETC_TRIG6_CHAIN_5_4_IE4_Pos = 0xd
	// Bit mask of IE4 field.
	ADC_ETC_TRIG6_CHAIN_5_4_IE4_Msk = 0x6000
	// Position of CSEL5 field.
	ADC_ETC_TRIG6_CHAIN_5_4_CSEL5_Pos = 0x10
	// Bit mask of CSEL5 field.
	ADC_ETC_TRIG6_CHAIN_5_4_CSEL5_Msk = 0xf0000
	// Position of HWTS5 field.
	ADC_ETC_TRIG6_CHAIN_5_4_HWTS5_Pos = 0x14
	// Bit mask of HWTS5 field.
	ADC_ETC_TRIG6_CHAIN_5_4_HWTS5_Msk = 0xff00000
	// Position of B2B5 field.
	ADC_ETC_TRIG6_CHAIN_5_4_B2B5_Pos = 0x1c
	// Bit mask of B2B5 field.
	ADC_ETC_TRIG6_CHAIN_5_4_B2B5_Msk = 0x10000000
	// Bit B2B5.
	ADC_ETC_TRIG6_CHAIN_5_4_B2B5 = 0x10000000
	// Position of IE5 field.
	ADC_ETC_TRIG6_CHAIN_5_4_IE5_Pos = 0x1d
	// Bit mask of IE5 field.
	ADC_ETC_TRIG6_CHAIN_5_4_IE5_Msk = 0x60000000

	// TRIG6_CHAIN_7_6: ETC_TRIG Chain 6/7 Register
	// Position of CSEL6 field.
	ADC_ETC_TRIG6_CHAIN_7_6_CSEL6_Pos = 0x0
	// Bit mask of CSEL6 field.
	ADC_ETC_TRIG6_CHAIN_7_6_CSEL6_Msk = 0xf
	// Position of HWTS6 field.
	ADC_ETC_TRIG6_CHAIN_7_6_HWTS6_Pos = 0x4
	// Bit mask of HWTS6 field.
	ADC_ETC_TRIG6_CHAIN_7_6_HWTS6_Msk = 0xff0
	// Position of B2B6 field.
	ADC_ETC_TRIG6_CHAIN_7_6_B2B6_Pos = 0xc
	// Bit mask of B2B6 field.
	ADC_ETC_TRIG6_CHAIN_7_6_B2B6_Msk = 0x1000
	// Bit B2B6.
	ADC_ETC_TRIG6_CHAIN_7_6_B2B6 = 0x1000
	// Position of IE6 field.
	ADC_ETC_TRIG6_CHAIN_7_6_IE6_Pos = 0xd
	// Bit mask of IE6 field.
	ADC_ETC_TRIG6_CHAIN_7_6_IE6_Msk = 0x6000
	// Position of CSEL7 field.
	ADC_ETC_TRIG6_CHAIN_7_6_CSEL7_Pos = 0x10
	// Bit mask of CSEL7 field.
	ADC_ETC_TRIG6_CHAIN_7_6_CSEL7_Msk = 0xf0000
	// Position of HWTS7 field.
	ADC_ETC_TRIG6_CHAIN_7_6_HWTS7_Pos = 0x14
	// Bit mask of HWTS7 field.
	ADC_ETC_TRIG6_CHAIN_7_6_HWTS7_Msk = 0xff00000
	// Position of B2B7 field.
	ADC_ETC_TRIG6_CHAIN_7_6_B2B7_Pos = 0x1c
	// Bit mask of B2B7 field.
	ADC_ETC_TRIG6_CHAIN_7_6_B2B7_Msk = 0x10000000
	// Bit B2B7.
	ADC_ETC_TRIG6_CHAIN_7_6_B2B7 = 0x10000000
	// Position of IE7 field.
	ADC_ETC_TRIG6_CHAIN_7_6_IE7_Pos = 0x1d
	// Bit mask of IE7 field.
	ADC_ETC_TRIG6_CHAIN_7_6_IE7_Msk = 0x60000000

	// TRIG6_RESULT_1_0: ETC_TRIG Result Data 1/0 Register
	// Position of DATA0 field.
	ADC_ETC_TRIG6_RESULT_1_0_DATA0_Pos = 0x0
	// Bit mask of DATA0 field.
	ADC_ETC_TRIG6_RESULT_1_0_DATA0_Msk = 0xfff
	// Position of DATA1 field.
	ADC_ETC_TRIG6_RESULT_1_0_DATA1_Pos = 0x10
	// Bit mask of DATA1 field.
	ADC_ETC_TRIG6_RESULT_1_0_DATA1_Msk = 0xfff0000

	// TRIG6_RESULT_3_2: ETC_TRIG Result Data 3/2 Register
	// Position of DATA2 field.
	ADC_ETC_TRIG6_RESULT_3_2_DATA2_Pos = 0x0
	// Bit mask of DATA2 field.
	ADC_ETC_TRIG6_RESULT_3_2_DATA2_Msk = 0xfff
	// Position of DATA3 field.
	ADC_ETC_TRIG6_RESULT_3_2_DATA3_Pos = 0x10
	// Bit mask of DATA3 field.
	ADC_ETC_TRIG6_RESULT_3_2_DATA3_Msk = 0xfff0000

	// TRIG6_RESULT_5_4: ETC_TRIG Result Data 5/4 Register
	// Position of DATA4 field.
	ADC_ETC_TRIG6_RESULT_5_4_DATA4_Pos = 0x0
	// Bit mask of DATA4 field.
	ADC_ETC_TRIG6_RESULT_5_4_DATA4_Msk = 0xfff
	// Position of DATA5 field.
	ADC_ETC_TRIG6_RESULT_5_4_DATA5_Pos = 0x10
	// Bit mask of DATA5 field.
	ADC_ETC_TRIG6_RESULT_5_4_DATA5_Msk = 0xfff0000

	// TRIG6_RESULT_7_6: ETC_TRIG Result Data 7/6 Register
	// Position of DATA6 field.
	ADC_ETC_TRIG6_RESULT_7_6_DATA6_Pos = 0x0
	// Bit mask of DATA6 field.
	ADC_ETC_TRIG6_RESULT_7_6_DATA6_Msk = 0xfff
	// Position of DATA7 field.
	ADC_ETC_TRIG6_RESULT_7_6_DATA7_Pos = 0x10
	// Bit mask of DATA7 field.
	ADC_ETC_TRIG6_RESULT_7_6_DATA7_Msk = 0xfff0000

	// TRIG7_CTRL: ETC_TRIG7 Control Register
	// Position of SW_TRIG field.
	ADC_ETC_TRIG7_CTRL_SW_TRIG_Pos = 0x0
	// Bit mask of SW_TRIG field.
	ADC_ETC_TRIG7_CTRL_SW_TRIG_Msk = 0x1
	// Bit SW_TRIG.
	ADC_ETC_TRIG7_CTRL_SW_TRIG = 0x1
	// Position of TRIG_MODE field.
	ADC_ETC_TRIG7_CTRL_TRIG_MODE_Pos = 0x4
	// Bit mask of TRIG_MODE field.
	ADC_ETC_TRIG7_CTRL_TRIG_MODE_Msk = 0x10
	// Bit TRIG_MODE.
	ADC_ETC_TRIG7_CTRL_TRIG_MODE = 0x10
	// Position of TRIG_CHAIN field.
	ADC_ETC_TRIG7_CTRL_TRIG_CHAIN_Pos = 0x8
	// Bit mask of TRIG_CHAIN field.
	ADC_ETC_TRIG7_CTRL_TRIG_CHAIN_Msk = 0x700
	// Position of TRIG_PRIORITY field.
	ADC_ETC_TRIG7_CTRL_TRIG_PRIORITY_Pos = 0xc
	// Bit mask of TRIG_PRIORITY field.
	ADC_ETC_TRIG7_CTRL_TRIG_PRIORITY_Msk = 0x7000
	// Position of SYNC_MODE field.
	ADC_ETC_TRIG7_CTRL_SYNC_MODE_Pos = 0x10
	// Bit mask of SYNC_MODE field.
	ADC_ETC_TRIG7_CTRL_SYNC_MODE_Msk = 0x10000
	// Bit SYNC_MODE.
	ADC_ETC_TRIG7_CTRL_SYNC_MODE = 0x10000

	// TRIG7_COUNTER: ETC_TRIG7 Counter Register
	// Position of INIT_DELAY field.
	ADC_ETC_TRIG7_COUNTER_INIT_DELAY_Pos = 0x0
	// Bit mask of INIT_DELAY field.
	ADC_ETC_TRIG7_COUNTER_INIT_DELAY_Msk = 0xffff
	// Position of SAMPLE_INTERVAL field.
	ADC_ETC_TRIG7_COUNTER_SAMPLE_INTERVAL_Pos = 0x10
	// Bit mask of SAMPLE_INTERVAL field.
	ADC_ETC_TRIG7_COUNTER_SAMPLE_INTERVAL_Msk = 0xffff0000

	// TRIG7_CHAIN_1_0: ETC_TRIG Chain 0/1 Register
	// Position of CSEL0 field.
	ADC_ETC_TRIG7_CHAIN_1_0_CSEL0_Pos = 0x0
	// Bit mask of CSEL0 field.
	ADC_ETC_TRIG7_CHAIN_1_0_CSEL0_Msk = 0xf
	// Position of HWTS0 field.
	ADC_ETC_TRIG7_CHAIN_1_0_HWTS0_Pos = 0x4
	// Bit mask of HWTS0 field.
	ADC_ETC_TRIG7_CHAIN_1_0_HWTS0_Msk = 0xff0
	// Position of B2B0 field.
	ADC_ETC_TRIG7_CHAIN_1_0_B2B0_Pos = 0xc
	// Bit mask of B2B0 field.
	ADC_ETC_TRIG7_CHAIN_1_0_B2B0_Msk = 0x1000
	// Bit B2B0.
	ADC_ETC_TRIG7_CHAIN_1_0_B2B0 = 0x1000
	// Position of IE0 field.
	ADC_ETC_TRIG7_CHAIN_1_0_IE0_Pos = 0xd
	// Bit mask of IE0 field.
	ADC_ETC_TRIG7_CHAIN_1_0_IE0_Msk = 0x6000
	// Position of CSEL1 field.
	ADC_ETC_TRIG7_CHAIN_1_0_CSEL1_Pos = 0x10
	// Bit mask of CSEL1 field.
	ADC_ETC_TRIG7_CHAIN_1_0_CSEL1_Msk = 0xf0000
	// Position of HWTS1 field.
	ADC_ETC_TRIG7_CHAIN_1_0_HWTS1_Pos = 0x14
	// Bit mask of HWTS1 field.
	ADC_ETC_TRIG7_CHAIN_1_0_HWTS1_Msk = 0xff00000
	// Position of B2B1 field.
	ADC_ETC_TRIG7_CHAIN_1_0_B2B1_Pos = 0x1c
	// Bit mask of B2B1 field.
	ADC_ETC_TRIG7_CHAIN_1_0_B2B1_Msk = 0x10000000
	// Bit B2B1.
	ADC_ETC_TRIG7_CHAIN_1_0_B2B1 = 0x10000000
	// Position of IE1 field.
	ADC_ETC_TRIG7_CHAIN_1_0_IE1_Pos = 0x1d
	// Bit mask of IE1 field.
	ADC_ETC_TRIG7_CHAIN_1_0_IE1_Msk = 0x60000000

	// TRIG7_CHAIN_3_2: ETC_TRIG Chain 2/3 Register
	// Position of CSEL2 field.
	ADC_ETC_TRIG7_CHAIN_3_2_CSEL2_Pos = 0x0
	// Bit mask of CSEL2 field.
	ADC_ETC_TRIG7_CHAIN_3_2_CSEL2_Msk = 0xf
	// Position of HWTS2 field.
	ADC_ETC_TRIG7_CHAIN_3_2_HWTS2_Pos = 0x4
	// Bit mask of HWTS2 field.
	ADC_ETC_TRIG7_CHAIN_3_2_HWTS2_Msk = 0xff0
	// Position of B2B2 field.
	ADC_ETC_TRIG7_CHAIN_3_2_B2B2_Pos = 0xc
	// Bit mask of B2B2 field.
	ADC_ETC_TRIG7_CHAIN_3_2_B2B2_Msk = 0x1000
	// Bit B2B2.
	ADC_ETC_TRIG7_CHAIN_3_2_B2B2 = 0x1000
	// Position of IE2 field.
	ADC_ETC_TRIG7_CHAIN_3_2_IE2_Pos = 0xd
	// Bit mask of IE2 field.
	ADC_ETC_TRIG7_CHAIN_3_2_IE2_Msk = 0x6000
	// Position of CSEL3 field.
	ADC_ETC_TRIG7_CHAIN_3_2_CSEL3_Pos = 0x10
	// Bit mask of CSEL3 field.
	ADC_ETC_TRIG7_CHAIN_3_2_CSEL3_Msk = 0xf0000
	// Position of HWTS3 field.
	ADC_ETC_TRIG7_CHAIN_3_2_HWTS3_Pos = 0x14
	// Bit mask of HWTS3 field.
	ADC_ETC_TRIG7_CHAIN_3_2_HWTS3_Msk = 0xff00000
	// Position of B2B3 field.
	ADC_ETC_TRIG7_CHAIN_3_2_B2B3_Pos = 0x1c
	// Bit mask of B2B3 field.
	ADC_ETC_TRIG7_CHAIN_3_2_B2B3_Msk = 0x10000000
	// Bit B2B3.
	ADC_ETC_TRIG7_CHAIN_3_2_B2B3 = 0x10000000
	// Position of IE3 field.
	ADC_ETC_TRIG7_CHAIN_3_2_IE3_Pos = 0x1d
	// Bit mask of IE3 field.
	ADC_ETC_TRIG7_CHAIN_3_2_IE3_Msk = 0x60000000

	// TRIG7_CHAIN_5_4: ETC_TRIG Chain 4/5 Register
	// Position of CSEL4 field.
	ADC_ETC_TRIG7_CHAIN_5_4_CSEL4_Pos = 0x0
	// Bit mask of CSEL4 field.
	ADC_ETC_TRIG7_CHAIN_5_4_CSEL4_Msk = 0xf
	// Position of HWTS4 field.
	ADC_ETC_TRIG7_CHAIN_5_4_HWTS4_Pos = 0x4
	// Bit mask of HWTS4 field.
	ADC_ETC_TRIG7_CHAIN_5_4_HWTS4_Msk = 0xff0
	// Position of B2B4 field.
	ADC_ETC_TRIG7_CHAIN_5_4_B2B4_Pos = 0xc
	// Bit mask of B2B4 field.
	ADC_ETC_TRIG7_CHAIN_5_4_B2B4_Msk = 0x1000
	// Bit B2B4.
	ADC_ETC_TRIG7_CHAIN_5_4_B2B4 = 0x1000
	// Position of IE4 field.
	ADC_ETC_TRIG7_CHAIN_5_4_IE4_Pos = 0xd
	// Bit mask of IE4 field.
	ADC_ETC_TRIG7_CHAIN_5_4_IE4_Msk = 0x6000
	// Position of CSEL5 field.
	ADC_ETC_TRIG7_CHAIN_5_4_CSEL5_Pos = 0x10
	// Bit mask of CSEL5 field.
	ADC_ETC_TRIG7_CHAIN_5_4_CSEL5_Msk = 0xf0000
	// Position of HWTS5 field.
	ADC_ETC_TRIG7_CHAIN_5_4_HWTS5_Pos = 0x14
	// Bit mask of HWTS5 field.
	ADC_ETC_TRIG7_CHAIN_5_4_HWTS5_Msk = 0xff00000
	// Position of B2B5 field.
	ADC_ETC_TRIG7_CHAIN_5_4_B2B5_Pos = 0x1c
	// Bit mask of B2B5 field.
	ADC_ETC_TRIG7_CHAIN_5_4_B2B5_Msk = 0x10000000
	// Bit B2B5.
	ADC_ETC_TRIG7_CHAIN_5_4_B2B5 = 0x10000000
	// Position of IE5 field.
	ADC_ETC_TRIG7_CHAIN_5_4_IE5_Pos = 0x1d
	// Bit mask of IE5 field.
	ADC_ETC_TRIG7_CHAIN_5_4_IE5_Msk = 0x60000000

	// TRIG7_CHAIN_7_6: ETC_TRIG Chain 6/7 Register
	// Position of CSEL6 field.
	ADC_ETC_TRIG7_CHAIN_7_6_CSEL6_Pos = 0x0
	// Bit mask of CSEL6 field.
	ADC_ETC_TRIG7_CHAIN_7_6_CSEL6_Msk = 0xf
	// Position of HWTS6 field.
	ADC_ETC_TRIG7_CHAIN_7_6_HWTS6_Pos = 0x4
	// Bit mask of HWTS6 field.
	ADC_ETC_TRIG7_CHAIN_7_6_HWTS6_Msk = 0xff0
	// Position of B2B6 field.
	ADC_ETC_TRIG7_CHAIN_7_6_B2B6_Pos = 0xc
	// Bit mask of B2B6 field.
	ADC_ETC_TRIG7_CHAIN_7_6_B2B6_Msk = 0x1000
	// Bit B2B6.
	ADC_ETC_TRIG7_CHAIN_7_6_B2B6 = 0x1000
	// Position of IE6 field.
	ADC_ETC_TRIG7_CHAIN_7_6_IE6_Pos = 0xd
	// Bit mask of IE6 field.
	ADC_ETC_TRIG7_CHAIN_7_6_IE6_Msk = 0x6000
	// Position of CSEL7 field.
	ADC_ETC_TRIG7_CHAIN_7_6_CSEL7_Pos = 0x10
	// Bit mask of CSEL7 field.
	ADC_ETC_TRIG7_CHAIN_7_6_CSEL7_Msk = 0xf0000
	// Position of HWTS7 field.
	ADC_ETC_TRIG7_CHAIN_7_6_HWTS7_Pos = 0x14
	// Bit mask of HWTS7 field.
	ADC_ETC_TRIG7_CHAIN_7_6_HWTS7_Msk = 0xff00000
	// Position of B2B7 field.
	ADC_ETC_TRIG7_CHAIN_7_6_B2B7_Pos = 0x1c
	// Bit mask of B2B7 field.
	ADC_ETC_TRIG7_CHAIN_7_6_B2B7_Msk = 0x10000000
	// Bit B2B7.
	ADC_ETC_TRIG7_CHAIN_7_6_B2B7 = 0x10000000
	// Position of IE7 field.
	ADC_ETC_TRIG7_CHAIN_7_6_IE7_Pos = 0x1d
	// Bit mask of IE7 field.
	ADC_ETC_TRIG7_CHAIN_7_6_IE7_Msk = 0x60000000

	// TRIG7_RESULT_1_0: ETC_TRIG Result Data 1/0 Register
	// Position of DATA0 field.
	ADC_ETC_TRIG7_RESULT_1_0_DATA0_Pos = 0x0
	// Bit mask of DATA0 field.
	ADC_ETC_TRIG7_RESULT_1_0_DATA0_Msk = 0xfff
	// Position of DATA1 field.
	ADC_ETC_TRIG7_RESULT_1_0_DATA1_Pos = 0x10
	// Bit mask of DATA1 field.
	ADC_ETC_TRIG7_RESULT_1_0_DATA1_Msk = 0xfff0000

	// TRIG7_RESULT_3_2: ETC_TRIG Result Data 3/2 Register
	// Position of DATA2 field.
	ADC_ETC_TRIG7_RESULT_3_2_DATA2_Pos = 0x0
	// Bit mask of DATA2 field.
	ADC_ETC_TRIG7_RESULT_3_2_DATA2_Msk = 0xfff
	// Position of DATA3 field.
	ADC_ETC_TRIG7_RESULT_3_2_DATA3_Pos = 0x10
	// Bit mask of DATA3 field.
	ADC_ETC_TRIG7_RESULT_3_2_DATA3_Msk = 0xfff0000

	// TRIG7_RESULT_5_4: ETC_TRIG Result Data 5/4 Register
	// Position of DATA4 field.
	ADC_ETC_TRIG7_RESULT_5_4_DATA4_Pos = 0x0
	// Bit mask of DATA4 field.
	ADC_ETC_TRIG7_RESULT_5_4_DATA4_Msk = 0xfff
	// Position of DATA5 field.
	ADC_ETC_TRIG7_RESULT_5_4_DATA5_Pos = 0x10
	// Bit mask of DATA5 field.
	ADC_ETC_TRIG7_RESULT_5_4_DATA5_Msk = 0xfff0000

	// TRIG7_RESULT_7_6: ETC_TRIG Result Data 7/6 Register
	// Position of DATA6 field.
	ADC_ETC_TRIG7_RESULT_7_6_DATA6_Pos = 0x0
	// Bit mask of DATA6 field.
	ADC_ETC_TRIG7_RESULT_7_6_DATA6_Msk = 0xfff
	// Position of DATA7 field.
	ADC_ETC_TRIG7_RESULT_7_6_DATA7_Pos = 0x10
	// Bit mask of DATA7 field.
	ADC_ETC_TRIG7_RESULT_7_6_DATA7_Msk = 0xfff0000
)

// Bitfields for AOI1: AND/OR/INVERT module
const (
	// BFCRT010: Boolean Function Term 0 and 1 Configuration Register for EVENTn
	// Position of PT1_DC field.
	AOI_BFCRT01_PT1_DC_Pos = 0x0
	// Bit mask of PT1_DC field.
	AOI_BFCRT01_PT1_DC_Msk = 0x3
	// Force the D input in this product term to a logical zero
	AOI_BFCRT01_PT1_DC_PT1_DC_0 = 0x0
	// Pass the D input in this product term
	AOI_BFCRT01_PT1_DC_PT1_DC_1 = 0x1
	// Complement the D input in this product term
	AOI_BFCRT01_PT1_DC_PT1_DC_2 = 0x2
	// Force the D input in this product term to a logical one
	AOI_BFCRT01_PT1_DC_PT1_DC_3 = 0x3
	// Position of PT1_CC field.
	AOI_BFCRT01_PT1_CC_Pos = 0x2
	// Bit mask of PT1_CC field.
	AOI_BFCRT01_PT1_CC_Msk = 0xc
	// Force the C input in this product term to a logical zero
	AOI_BFCRT01_PT1_CC_PT1_CC_0 = 0x0
	// Pass the C input in this product term
	AOI_BFCRT01_PT1_CC_PT1_CC_1 = 0x1
	// Complement the C input in this product term
	AOI_BFCRT01_PT1_CC_PT1_CC_2 = 0x2
	// Force the C input in this product term to a logical one
	AOI_BFCRT01_PT1_CC_PT1_CC_3 = 0x3
	// Position of PT1_BC field.
	AOI_BFCRT01_PT1_BC_Pos = 0x4
	// Bit mask of PT1_BC field.
	AOI_BFCRT01_PT1_BC_Msk = 0x30
	// Force the B input in this product term to a logical zero
	AOI_BFCRT01_PT1_BC_PT1_BC_0 = 0x0
	// Pass the B input in this product term
	AOI_BFCRT01_PT1_BC_PT1_BC_1 = 0x1
	// Complement the B input in this product term
	AOI_BFCRT01_PT1_BC_PT1_BC_2 = 0x2
	// Force the B input in this product term to a logical one
	AOI_BFCRT01_PT1_BC_PT1_BC_3 = 0x3
	// Position of PT1_AC field.
	AOI_BFCRT01_PT1_AC_Pos = 0x6
	// Bit mask of PT1_AC field.
	AOI_BFCRT01_PT1_AC_Msk = 0xc0
	// Force the A input in this product term to a logical zero
	AOI_BFCRT01_PT1_AC_PT1_AC_0 = 0x0
	// Pass the A input in this product term
	AOI_BFCRT01_PT1_AC_PT1_AC_1 = 0x1
	// Complement the A input in this product term
	AOI_BFCRT01_PT1_AC_PT1_AC_2 = 0x2
	// Force the A input in this product term to a logical one
	AOI_BFCRT01_PT1_AC_PT1_AC_3 = 0x3
	// Position of PT0_DC field.
	AOI_BFCRT01_PT0_DC_Pos = 0x8
	// Bit mask of PT0_DC field.
	AOI_BFCRT01_PT0_DC_Msk = 0x300
	// Force the D input in this product term to a logical zero
	AOI_BFCRT01_PT0_DC_PT0_DC_0 = 0x0
	// Pass the D input in this product term
	AOI_BFCRT01_PT0_DC_PT0_DC_1 = 0x1
	// Complement the D input in this product term
	AOI_BFCRT01_PT0_DC_PT0_DC_2 = 0x2
	// Force the D input in this product term to a logical one
	AOI_BFCRT01_PT0_DC_PT0_DC_3 = 0x3
	// Position of PT0_CC field.
	AOI_BFCRT01_PT0_CC_Pos = 0xa
	// Bit mask of PT0_CC field.
	AOI_BFCRT01_PT0_CC_Msk = 0xc00
	// Force the C input in this product term to a logical zero
	AOI_BFCRT01_PT0_CC_PT0_CC_0 = 0x0
	// Pass the C input in this product term
	AOI_BFCRT01_PT0_CC_PT0_CC_1 = 0x1
	// Complement the C input in this product term
	AOI_BFCRT01_PT0_CC_PT0_CC_2 = 0x2
	// Force the C input in this product term to a logical one
	AOI_BFCRT01_PT0_CC_PT0_CC_3 = 0x3
	// Position of PT0_BC field.
	AOI_BFCRT01_PT0_BC_Pos = 0xc
	// Bit mask of PT0_BC field.
	AOI_BFCRT01_PT0_BC_Msk = 0x3000
	// Force the B input in this product term to a logical zero
	AOI_BFCRT01_PT0_BC_PT0_BC_0 = 0x0
	// Pass the B input in this product term
	AOI_BFCRT01_PT0_BC_PT0_BC_1 = 0x1
	// Complement the B input in this product term
	AOI_BFCRT01_PT0_BC_PT0_BC_2 = 0x2
	// Force the B input in this product term to a logical one
	AOI_BFCRT01_PT0_BC_PT0_BC_3 = 0x3
	// Position of PT0_AC field.
	AOI_BFCRT01_PT0_AC_Pos = 0xe
	// Bit mask of PT0_AC field.
	AOI_BFCRT01_PT0_AC_Msk = 0xc000
	// Force the A input in this product term to a logical zero
	AOI_BFCRT01_PT0_AC_PT0_AC_0 = 0x0
	// Pass the A input in this product term
	AOI_BFCRT01_PT0_AC_PT0_AC_1 = 0x1
	// Complement the A input in this product term
	AOI_BFCRT01_PT0_AC_PT0_AC_2 = 0x2
	// Force the A input in this product term to a logical one
	AOI_BFCRT01_PT0_AC_PT0_AC_3 = 0x3

	// BFCRT230: Boolean Function Term 2 and 3 Configuration Register for EVENTn
	// Position of PT3_DC field.
	AOI_BFCRT23_PT3_DC_Pos = 0x0
	// Bit mask of PT3_DC field.
	AOI_BFCRT23_PT3_DC_Msk = 0x3
	// Force the D input in this product term to a logical zero
	AOI_BFCRT23_PT3_DC_PT3_DC_0 = 0x0
	// Pass the D input in this product term
	AOI_BFCRT23_PT3_DC_PT3_DC_1 = 0x1
	// Complement the D input in this product term
	AOI_BFCRT23_PT3_DC_PT3_DC_2 = 0x2
	// Force the D input in this product term to a logical one
	AOI_BFCRT23_PT3_DC_PT3_DC_3 = 0x3
	// Position of PT3_CC field.
	AOI_BFCRT23_PT3_CC_Pos = 0x2
	// Bit mask of PT3_CC field.
	AOI_BFCRT23_PT3_CC_Msk = 0xc
	// Force the C input in this product term to a logical zero
	AOI_BFCRT23_PT3_CC_PT3_CC_0 = 0x0
	// Pass the C input in this product term
	AOI_BFCRT23_PT3_CC_PT3_CC_1 = 0x1
	// Complement the C input in this product term
	AOI_BFCRT23_PT3_CC_PT3_CC_2 = 0x2
	// Force the C input in this product term to a logical one
	AOI_BFCRT23_PT3_CC_PT3_CC_3 = 0x3
	// Position of PT3_BC field.
	AOI_BFCRT23_PT3_BC_Pos = 0x4
	// Bit mask of PT3_BC field.
	AOI_BFCRT23_PT3_BC_Msk = 0x30
	// Force the B input in this product term to a logical zero
	AOI_BFCRT23_PT3_BC_PT3_BC_0 = 0x0
	// Pass the B input in this product term
	AOI_BFCRT23_PT3_BC_PT3_BC_1 = 0x1
	// Complement the B input in this product term
	AOI_BFCRT23_PT3_BC_PT3_BC_2 = 0x2
	// Force the B input in this product term to a logical one
	AOI_BFCRT23_PT3_BC_PT3_BC_3 = 0x3
	// Position of PT3_AC field.
	AOI_BFCRT23_PT3_AC_Pos = 0x6
	// Bit mask of PT3_AC field.
	AOI_BFCRT23_PT3_AC_Msk = 0xc0
	// Force the A input in this product term to a logical zero
	AOI_BFCRT23_PT3_AC_PT3_AC_0 = 0x0
	// Pass the A input in this product term
	AOI_BFCRT23_PT3_AC_PT3_AC_1 = 0x1
	// Complement the A input in this product term
	AOI_BFCRT23_PT3_AC_PT3_AC_2 = 0x2
	// Force the A input in this product term to a logical one
	AOI_BFCRT23_PT3_AC_PT3_AC_3 = 0x3
	// Position of PT2_DC field.
	AOI_BFCRT23_PT2_DC_Pos = 0x8
	// Bit mask of PT2_DC field.
	AOI_BFCRT23_PT2_DC_Msk = 0x300
	// Force the D input in this product term to a logical zero
	AOI_BFCRT23_PT2_DC_PT2_DC_0 = 0x0
	// Pass the D input in this product term
	AOI_BFCRT23_PT2_DC_PT2_DC_1 = 0x1
	// Complement the D input in this product term
	AOI_BFCRT23_PT2_DC_PT2_DC_2 = 0x2
	// Force the D input in this product term to a logical one
	AOI_BFCRT23_PT2_DC_PT2_DC_3 = 0x3
	// Position of PT2_CC field.
	AOI_BFCRT23_PT2_CC_Pos = 0xa
	// Bit mask of PT2_CC field.
	AOI_BFCRT23_PT2_CC_Msk = 0xc00
	// Force the C input in this product term to a logical zero
	AOI_BFCRT23_PT2_CC_PT2_CC_0 = 0x0
	// Pass the C input in this product term
	AOI_BFCRT23_PT2_CC_PT2_CC_1 = 0x1
	// Complement the C input in this product term
	AOI_BFCRT23_PT2_CC_PT2_CC_2 = 0x2
	// Force the C input in this product term to a logical one
	AOI_BFCRT23_PT2_CC_PT2_CC_3 = 0x3
	// Position of PT2_BC field.
	AOI_BFCRT23_PT2_BC_Pos = 0xc
	// Bit mask of PT2_BC field.
	AOI_BFCRT23_PT2_BC_Msk = 0x3000
	// Force the B input in this product term to a logical zero
	AOI_BFCRT23_PT2_BC_PT2_BC_0 = 0x0
	// Pass the B input in this product term
	AOI_BFCRT23_PT2_BC_PT2_BC_1 = 0x1
	// Complement the B input in this product term
	AOI_BFCRT23_PT2_BC_PT2_BC_2 = 0x2
	// Force the B input in this product term to a logical one
	AOI_BFCRT23_PT2_BC_PT2_BC_3 = 0x3
	// Position of PT2_AC field.
	AOI_BFCRT23_PT2_AC_Pos = 0xe
	// Bit mask of PT2_AC field.
	AOI_BFCRT23_PT2_AC_Msk = 0xc000
	// Force the A input in this product term to a logical zero
	AOI_BFCRT23_PT2_AC_PT2_AC_0 = 0x0
	// Pass the A input in this product term
	AOI_BFCRT23_PT2_AC_PT2_AC_1 = 0x1
	// Complement the A input in this product term
	AOI_BFCRT23_PT2_AC_PT2_AC_2 = 0x2
	// Force the A input in this product term to a logical one
	AOI_BFCRT23_PT2_AC_PT2_AC_3 = 0x3
)

// Bitfields for XBARA1: Crossbar Switch
const (
	// SEL0: Crossbar A Select Register 0
	// Position of SEL0 field.
	XBARA_SEL0_SEL0_Pos = 0x0
	// Bit mask of SEL0 field.
	XBARA_SEL0_SEL0_Msk = 0x7f
	// Position of SEL1 field.
	XBARA_SEL0_SEL1_Pos = 0x8
	// Bit mask of SEL1 field.
	XBARA_SEL0_SEL1_Msk = 0x7f00

	// SEL1: Crossbar A Select Register 1
	// Position of SEL2 field.
	XBARA_SEL1_SEL2_Pos = 0x0
	// Bit mask of SEL2 field.
	XBARA_SEL1_SEL2_Msk = 0x7f
	// Position of SEL3 field.
	XBARA_SEL1_SEL3_Pos = 0x8
	// Bit mask of SEL3 field.
	XBARA_SEL1_SEL3_Msk = 0x7f00

	// SEL2: Crossbar A Select Register 2
	// Position of SEL4 field.
	XBARA_SEL2_SEL4_Pos = 0x0
	// Bit mask of SEL4 field.
	XBARA_SEL2_SEL4_Msk = 0x7f
	// Position of SEL5 field.
	XBARA_SEL2_SEL5_Pos = 0x8
	// Bit mask of SEL5 field.
	XBARA_SEL2_SEL5_Msk = 0x7f00

	// SEL3: Crossbar A Select Register 3
	// Position of SEL6 field.
	XBARA_SEL3_SEL6_Pos = 0x0
	// Bit mask of SEL6 field.
	XBARA_SEL3_SEL6_Msk = 0x7f
	// Position of SEL7 field.
	XBARA_SEL3_SEL7_Pos = 0x8
	// Bit mask of SEL7 field.
	XBARA_SEL3_SEL7_Msk = 0x7f00

	// SEL4: Crossbar A Select Register 4
	// Position of SEL8 field.
	XBARA_SEL4_SEL8_Pos = 0x0
	// Bit mask of SEL8 field.
	XBARA_SEL4_SEL8_Msk = 0x7f
	// Position of SEL9 field.
	XBARA_SEL4_SEL9_Pos = 0x8
	// Bit mask of SEL9 field.
	XBARA_SEL4_SEL9_Msk = 0x7f00

	// SEL5: Crossbar A Select Register 5
	// Position of SEL10 field.
	XBARA_SEL5_SEL10_Pos = 0x0
	// Bit mask of SEL10 field.
	XBARA_SEL5_SEL10_Msk = 0x7f
	// Position of SEL11 field.
	XBARA_SEL5_SEL11_Pos = 0x8
	// Bit mask of SEL11 field.
	XBARA_SEL5_SEL11_Msk = 0x7f00

	// SEL6: Crossbar A Select Register 6
	// Position of SEL12 field.
	XBARA_SEL6_SEL12_Pos = 0x0
	// Bit mask of SEL12 field.
	XBARA_SEL6_SEL12_Msk = 0x7f
	// Position of SEL13 field.
	XBARA_SEL6_SEL13_Pos = 0x8
	// Bit mask of SEL13 field.
	XBARA_SEL6_SEL13_Msk = 0x7f00

	// SEL7: Crossbar A Select Register 7
	// Position of SEL14 field.
	XBARA_SEL7_SEL14_Pos = 0x0
	// Bit mask of SEL14 field.
	XBARA_SEL7_SEL14_Msk = 0x7f
	// Position of SEL15 field.
	XBARA_SEL7_SEL15_Pos = 0x8
	// Bit mask of SEL15 field.
	XBARA_SEL7_SEL15_Msk = 0x7f00

	// SEL8: Crossbar A Select Register 8
	// Position of SEL16 field.
	XBARA_SEL8_SEL16_Pos = 0x0
	// Bit mask of SEL16 field.
	XBARA_SEL8_SEL16_Msk = 0x7f
	// Position of SEL17 field.
	XBARA_SEL8_SEL17_Pos = 0x8
	// Bit mask of SEL17 field.
	XBARA_SEL8_SEL17_Msk = 0x7f00

	// SEL9: Crossbar A Select Register 9
	// Position of SEL18 field.
	XBARA_SEL9_SEL18_Pos = 0x0
	// Bit mask of SEL18 field.
	XBARA_SEL9_SEL18_Msk = 0x7f
	// Position of SEL19 field.
	XBARA_SEL9_SEL19_Pos = 0x8
	// Bit mask of SEL19 field.
	XBARA_SEL9_SEL19_Msk = 0x7f00

	// SEL10: Crossbar A Select Register 10
	// Position of SEL20 field.
	XBARA_SEL10_SEL20_Pos = 0x0
	// Bit mask of SEL20 field.
	XBARA_SEL10_SEL20_Msk = 0x7f
	// Position of SEL21 field.
	XBARA_SEL10_SEL21_Pos = 0x8
	// Bit mask of SEL21 field.
	XBARA_SEL10_SEL21_Msk = 0x7f00

	// SEL11: Crossbar A Select Register 11
	// Position of SEL22 field.
	XBARA_SEL11_SEL22_Pos = 0x0
	// Bit mask of SEL22 field.
	XBARA_SEL11_SEL22_Msk = 0x7f
	// Position of SEL23 field.
	XBARA_SEL11_SEL23_Pos = 0x8
	// Bit mask of SEL23 field.
	XBARA_SEL11_SEL23_Msk = 0x7f00

	// SEL12: Crossbar A Select Register 12
	// Position of SEL24 field.
	XBARA_SEL12_SEL24_Pos = 0x0
	// Bit mask of SEL24 field.
	XBARA_SEL12_SEL24_Msk = 0x7f
	// Position of SEL25 field.
	XBARA_SEL12_SEL25_Pos = 0x8
	// Bit mask of SEL25 field.
	XBARA_SEL12_SEL25_Msk = 0x7f00

	// SEL13: Crossbar A Select Register 13
	// Position of SEL26 field.
	XBARA_SEL13_SEL26_Pos = 0x0
	// Bit mask of SEL26 field.
	XBARA_SEL13_SEL26_Msk = 0x7f
	// Position of SEL27 field.
	XBARA_SEL13_SEL27_Pos = 0x8
	// Bit mask of SEL27 field.
	XBARA_SEL13_SEL27_Msk = 0x7f00

	// SEL14: Crossbar A Select Register 14
	// Position of SEL28 field.
	XBARA_SEL14_SEL28_Pos = 0x0
	// Bit mask of SEL28 field.
	XBARA_SEL14_SEL28_Msk = 0x7f
	// Position of SEL29 field.
	XBARA_SEL14_SEL29_Pos = 0x8
	// Bit mask of SEL29 field.
	XBARA_SEL14_SEL29_Msk = 0x7f00

	// SEL15: Crossbar A Select Register 15
	// Position of SEL30 field.
	XBARA_SEL15_SEL30_Pos = 0x0
	// Bit mask of SEL30 field.
	XBARA_SEL15_SEL30_Msk = 0x7f
	// Position of SEL31 field.
	XBARA_SEL15_SEL31_Pos = 0x8
	// Bit mask of SEL31 field.
	XBARA_SEL15_SEL31_Msk = 0x7f00

	// SEL16: Crossbar A Select Register 16
	// Position of SEL32 field.
	XBARA_SEL16_SEL32_Pos = 0x0
	// Bit mask of SEL32 field.
	XBARA_SEL16_SEL32_Msk = 0x7f
	// Position of SEL33 field.
	XBARA_SEL16_SEL33_Pos = 0x8
	// Bit mask of SEL33 field.
	XBARA_SEL16_SEL33_Msk = 0x7f00

	// SEL17: Crossbar A Select Register 17
	// Position of SEL34 field.
	XBARA_SEL17_SEL34_Pos = 0x0
	// Bit mask of SEL34 field.
	XBARA_SEL17_SEL34_Msk = 0x7f
	// Position of SEL35 field.
	XBARA_SEL17_SEL35_Pos = 0x8
	// Bit mask of SEL35 field.
	XBARA_SEL17_SEL35_Msk = 0x7f00

	// SEL18: Crossbar A Select Register 18
	// Position of SEL36 field.
	XBARA_SEL18_SEL36_Pos = 0x0
	// Bit mask of SEL36 field.
	XBARA_SEL18_SEL36_Msk = 0x7f
	// Position of SEL37 field.
	XBARA_SEL18_SEL37_Pos = 0x8
	// Bit mask of SEL37 field.
	XBARA_SEL18_SEL37_Msk = 0x7f00

	// SEL19: Crossbar A Select Register 19
	// Position of SEL38 field.
	XBARA_SEL19_SEL38_Pos = 0x0
	// Bit mask of SEL38 field.
	XBARA_SEL19_SEL38_Msk = 0x7f
	// Position of SEL39 field.
	XBARA_SEL19_SEL39_Pos = 0x8
	// Bit mask of SEL39 field.
	XBARA_SEL19_SEL39_Msk = 0x7f00

	// SEL20: Crossbar A Select Register 20
	// Position of SEL40 field.
	XBARA_SEL20_SEL40_Pos = 0x0
	// Bit mask of SEL40 field.
	XBARA_SEL20_SEL40_Msk = 0x7f
	// Position of SEL41 field.
	XBARA_SEL20_SEL41_Pos = 0x8
	// Bit mask of SEL41 field.
	XBARA_SEL20_SEL41_Msk = 0x7f00

	// SEL21: Crossbar A Select Register 21
	// Position of SEL42 field.
	XBARA_SEL21_SEL42_Pos = 0x0
	// Bit mask of SEL42 field.
	XBARA_SEL21_SEL42_Msk = 0x7f
	// Position of SEL43 field.
	XBARA_SEL21_SEL43_Pos = 0x8
	// Bit mask of SEL43 field.
	XBARA_SEL21_SEL43_Msk = 0x7f00

	// SEL22: Crossbar A Select Register 22
	// Position of SEL44 field.
	XBARA_SEL22_SEL44_Pos = 0x0
	// Bit mask of SEL44 field.
	XBARA_SEL22_SEL44_Msk = 0x7f
	// Position of SEL45 field.
	XBARA_SEL22_SEL45_Pos = 0x8
	// Bit mask of SEL45 field.
	XBARA_SEL22_SEL45_Msk = 0x7f00

	// SEL23: Crossbar A Select Register 23
	// Position of SEL46 field.
	XBARA_SEL23_SEL46_Pos = 0x0
	// Bit mask of SEL46 field.
	XBARA_SEL23_SEL46_Msk = 0x7f
	// Position of SEL47 field.
	XBARA_SEL23_SEL47_Pos = 0x8
	// Bit mask of SEL47 field.
	XBARA_SEL23_SEL47_Msk = 0x7f00

	// SEL24: Crossbar A Select Register 24
	// Position of SEL48 field.
	XBARA_SEL24_SEL48_Pos = 0x0
	// Bit mask of SEL48 field.
	XBARA_SEL24_SEL48_Msk = 0x7f
	// Position of SEL49 field.
	XBARA_SEL24_SEL49_Pos = 0x8
	// Bit mask of SEL49 field.
	XBARA_SEL24_SEL49_Msk = 0x7f00

	// SEL25: Crossbar A Select Register 25
	// Position of SEL50 field.
	XBARA_SEL25_SEL50_Pos = 0x0
	// Bit mask of SEL50 field.
	XBARA_SEL25_SEL50_Msk = 0x7f
	// Position of SEL51 field.
	XBARA_SEL25_SEL51_Pos = 0x8
	// Bit mask of SEL51 field.
	XBARA_SEL25_SEL51_Msk = 0x7f00

	// SEL26: Crossbar A Select Register 26
	// Position of SEL52 field.
	XBARA_SEL26_SEL52_Pos = 0x0
	// Bit mask of SEL52 field.
	XBARA_SEL26_SEL52_Msk = 0x7f
	// Position of SEL53 field.
	XBARA_SEL26_SEL53_Pos = 0x8
	// Bit mask of SEL53 field.
	XBARA_SEL26_SEL53_Msk = 0x7f00

	// SEL27: Crossbar A Select Register 27
	// Position of SEL54 field.
	XBARA_SEL27_SEL54_Pos = 0x0
	// Bit mask of SEL54 field.
	XBARA_SEL27_SEL54_Msk = 0x7f
	// Position of SEL55 field.
	XBARA_SEL27_SEL55_Pos = 0x8
	// Bit mask of SEL55 field.
	XBARA_SEL27_SEL55_Msk = 0x7f00

	// SEL28: Crossbar A Select Register 28
	// Position of SEL56 field.
	XBARA_SEL28_SEL56_Pos = 0x0
	// Bit mask of SEL56 field.
	XBARA_SEL28_SEL56_Msk = 0x7f
	// Position of SEL57 field.
	XBARA_SEL28_SEL57_Pos = 0x8
	// Bit mask of SEL57 field.
	XBARA_SEL28_SEL57_Msk = 0x7f00

	// SEL29: Crossbar A Select Register 29
	// Position of SEL58 field.
	XBARA_SEL29_SEL58_Pos = 0x0
	// Bit mask of SEL58 field.
	XBARA_SEL29_SEL58_Msk = 0x7f
	// Position of SEL59 field.
	XBARA_SEL29_SEL59_Pos = 0x8
	// Bit mask of SEL59 field.
	XBARA_SEL29_SEL59_Msk = 0x7f00

	// SEL30: Crossbar A Select Register 30
	// Position of SEL60 field.
	XBARA_SEL30_SEL60_Pos = 0x0
	// Bit mask of SEL60 field.
	XBARA_SEL30_SEL60_Msk = 0x7f
	// Position of SEL61 field.
	XBARA_SEL30_SEL61_Pos = 0x8
	// Bit mask of SEL61 field.
	XBARA_SEL30_SEL61_Msk = 0x7f00

	// SEL31: Crossbar A Select Register 31
	// Position of SEL62 field.
	XBARA_SEL31_SEL62_Pos = 0x0
	// Bit mask of SEL62 field.
	XBARA_SEL31_SEL62_Msk = 0x7f
	// Position of SEL63 field.
	XBARA_SEL31_SEL63_Pos = 0x8
	// Bit mask of SEL63 field.
	XBARA_SEL31_SEL63_Msk = 0x7f00

	// SEL32: Crossbar A Select Register 32
	// Position of SEL64 field.
	XBARA_SEL32_SEL64_Pos = 0x0
	// Bit mask of SEL64 field.
	XBARA_SEL32_SEL64_Msk = 0x7f
	// Position of SEL65 field.
	XBARA_SEL32_SEL65_Pos = 0x8
	// Bit mask of SEL65 field.
	XBARA_SEL32_SEL65_Msk = 0x7f00

	// SEL33: Crossbar A Select Register 33
	// Position of SEL66 field.
	XBARA_SEL33_SEL66_Pos = 0x0
	// Bit mask of SEL66 field.
	XBARA_SEL33_SEL66_Msk = 0x7f
	// Position of SEL67 field.
	XBARA_SEL33_SEL67_Pos = 0x8
	// Bit mask of SEL67 field.
	XBARA_SEL33_SEL67_Msk = 0x7f00

	// SEL34: Crossbar A Select Register 34
	// Position of SEL68 field.
	XBARA_SEL34_SEL68_Pos = 0x0
	// Bit mask of SEL68 field.
	XBARA_SEL34_SEL68_Msk = 0x7f
	// Position of SEL69 field.
	XBARA_SEL34_SEL69_Pos = 0x8
	// Bit mask of SEL69 field.
	XBARA_SEL34_SEL69_Msk = 0x7f00

	// SEL35: Crossbar A Select Register 35
	// Position of SEL70 field.
	XBARA_SEL35_SEL70_Pos = 0x0
	// Bit mask of SEL70 field.
	XBARA_SEL35_SEL70_Msk = 0x7f
	// Position of SEL71 field.
	XBARA_SEL35_SEL71_Pos = 0x8
	// Bit mask of SEL71 field.
	XBARA_SEL35_SEL71_Msk = 0x7f00

	// SEL36: Crossbar A Select Register 36
	// Position of SEL72 field.
	XBARA_SEL36_SEL72_Pos = 0x0
	// Bit mask of SEL72 field.
	XBARA_SEL36_SEL72_Msk = 0x7f
	// Position of SEL73 field.
	XBARA_SEL36_SEL73_Pos = 0x8
	// Bit mask of SEL73 field.
	XBARA_SEL36_SEL73_Msk = 0x7f00

	// SEL37: Crossbar A Select Register 37
	// Position of SEL74 field.
	XBARA_SEL37_SEL74_Pos = 0x0
	// Bit mask of SEL74 field.
	XBARA_SEL37_SEL74_Msk = 0x7f
	// Position of SEL75 field.
	XBARA_SEL37_SEL75_Pos = 0x8
	// Bit mask of SEL75 field.
	XBARA_SEL37_SEL75_Msk = 0x7f00

	// SEL38: Crossbar A Select Register 38
	// Position of SEL76 field.
	XBARA_SEL38_SEL76_Pos = 0x0
	// Bit mask of SEL76 field.
	XBARA_SEL38_SEL76_Msk = 0x7f
	// Position of SEL77 field.
	XBARA_SEL38_SEL77_Pos = 0x8
	// Bit mask of SEL77 field.
	XBARA_SEL38_SEL77_Msk = 0x7f00

	// SEL39: Crossbar A Select Register 39
	// Position of SEL78 field.
	XBARA_SEL39_SEL78_Pos = 0x0
	// Bit mask of SEL78 field.
	XBARA_SEL39_SEL78_Msk = 0x7f
	// Position of SEL79 field.
	XBARA_SEL39_SEL79_Pos = 0x8
	// Bit mask of SEL79 field.
	XBARA_SEL39_SEL79_Msk = 0x7f00

	// SEL40: Crossbar A Select Register 40
	// Position of SEL80 field.
	XBARA_SEL40_SEL80_Pos = 0x0
	// Bit mask of SEL80 field.
	XBARA_SEL40_SEL80_Msk = 0x7f
	// Position of SEL81 field.
	XBARA_SEL40_SEL81_Pos = 0x8
	// Bit mask of SEL81 field.
	XBARA_SEL40_SEL81_Msk = 0x7f00

	// SEL41: Crossbar A Select Register 41
	// Position of SEL82 field.
	XBARA_SEL41_SEL82_Pos = 0x0
	// Bit mask of SEL82 field.
	XBARA_SEL41_SEL82_Msk = 0x7f
	// Position of SEL83 field.
	XBARA_SEL41_SEL83_Pos = 0x8
	// Bit mask of SEL83 field.
	XBARA_SEL41_SEL83_Msk = 0x7f00

	// SEL42: Crossbar A Select Register 42
	// Position of SEL84 field.
	XBARA_SEL42_SEL84_Pos = 0x0
	// Bit mask of SEL84 field.
	XBARA_SEL42_SEL84_Msk = 0x7f
	// Position of SEL85 field.
	XBARA_SEL42_SEL85_Pos = 0x8
	// Bit mask of SEL85 field.
	XBARA_SEL42_SEL85_Msk = 0x7f00

	// SEL43: Crossbar A Select Register 43
	// Position of SEL86 field.
	XBARA_SEL43_SEL86_Pos = 0x0
	// Bit mask of SEL86 field.
	XBARA_SEL43_SEL86_Msk = 0x7f
	// Position of SEL87 field.
	XBARA_SEL43_SEL87_Pos = 0x8
	// Bit mask of SEL87 field.
	XBARA_SEL43_SEL87_Msk = 0x7f00

	// SEL44: Crossbar A Select Register 44
	// Position of SEL88 field.
	XBARA_SEL44_SEL88_Pos = 0x0
	// Bit mask of SEL88 field.
	XBARA_SEL44_SEL88_Msk = 0x7f
	// Position of SEL89 field.
	XBARA_SEL44_SEL89_Pos = 0x8
	// Bit mask of SEL89 field.
	XBARA_SEL44_SEL89_Msk = 0x7f00

	// SEL45: Crossbar A Select Register 45
	// Position of SEL90 field.
	XBARA_SEL45_SEL90_Pos = 0x0
	// Bit mask of SEL90 field.
	XBARA_SEL45_SEL90_Msk = 0x7f
	// Position of SEL91 field.
	XBARA_SEL45_SEL91_Pos = 0x8
	// Bit mask of SEL91 field.
	XBARA_SEL45_SEL91_Msk = 0x7f00

	// SEL46: Crossbar A Select Register 46
	// Position of SEL92 field.
	XBARA_SEL46_SEL92_Pos = 0x0
	// Bit mask of SEL92 field.
	XBARA_SEL46_SEL92_Msk = 0x7f
	// Position of SEL93 field.
	XBARA_SEL46_SEL93_Pos = 0x8
	// Bit mask of SEL93 field.
	XBARA_SEL46_SEL93_Msk = 0x7f00

	// SEL47: Crossbar A Select Register 47
	// Position of SEL94 field.
	XBARA_SEL47_SEL94_Pos = 0x0
	// Bit mask of SEL94 field.
	XBARA_SEL47_SEL94_Msk = 0x7f
	// Position of SEL95 field.
	XBARA_SEL47_SEL95_Pos = 0x8
	// Bit mask of SEL95 field.
	XBARA_SEL47_SEL95_Msk = 0x7f00

	// SEL48: Crossbar A Select Register 48
	// Position of SEL96 field.
	XBARA_SEL48_SEL96_Pos = 0x0
	// Bit mask of SEL96 field.
	XBARA_SEL48_SEL96_Msk = 0x7f
	// Position of SEL97 field.
	XBARA_SEL48_SEL97_Pos = 0x8
	// Bit mask of SEL97 field.
	XBARA_SEL48_SEL97_Msk = 0x7f00

	// SEL49: Crossbar A Select Register 49
	// Position of SEL98 field.
	XBARA_SEL49_SEL98_Pos = 0x0
	// Bit mask of SEL98 field.
	XBARA_SEL49_SEL98_Msk = 0x7f
	// Position of SEL99 field.
	XBARA_SEL49_SEL99_Pos = 0x8
	// Bit mask of SEL99 field.
	XBARA_SEL49_SEL99_Msk = 0x7f00

	// SEL50: Crossbar A Select Register 50
	// Position of SEL100 field.
	XBARA_SEL50_SEL100_Pos = 0x0
	// Bit mask of SEL100 field.
	XBARA_SEL50_SEL100_Msk = 0x7f
	// Position of SEL101 field.
	XBARA_SEL50_SEL101_Pos = 0x8
	// Bit mask of SEL101 field.
	XBARA_SEL50_SEL101_Msk = 0x7f00

	// SEL51: Crossbar A Select Register 51
	// Position of SEL102 field.
	XBARA_SEL51_SEL102_Pos = 0x0
	// Bit mask of SEL102 field.
	XBARA_SEL51_SEL102_Msk = 0x7f
	// Position of SEL103 field.
	XBARA_SEL51_SEL103_Pos = 0x8
	// Bit mask of SEL103 field.
	XBARA_SEL51_SEL103_Msk = 0x7f00

	// SEL52: Crossbar A Select Register 52
	// Position of SEL104 field.
	XBARA_SEL52_SEL104_Pos = 0x0
	// Bit mask of SEL104 field.
	XBARA_SEL52_SEL104_Msk = 0x7f
	// Position of SEL105 field.
	XBARA_SEL52_SEL105_Pos = 0x8
	// Bit mask of SEL105 field.
	XBARA_SEL52_SEL105_Msk = 0x7f00

	// SEL53: Crossbar A Select Register 53
	// Position of SEL106 field.
	XBARA_SEL53_SEL106_Pos = 0x0
	// Bit mask of SEL106 field.
	XBARA_SEL53_SEL106_Msk = 0x7f
	// Position of SEL107 field.
	XBARA_SEL53_SEL107_Pos = 0x8
	// Bit mask of SEL107 field.
	XBARA_SEL53_SEL107_Msk = 0x7f00

	// SEL54: Crossbar A Select Register 54
	// Position of SEL108 field.
	XBARA_SEL54_SEL108_Pos = 0x0
	// Bit mask of SEL108 field.
	XBARA_SEL54_SEL108_Msk = 0x7f
	// Position of SEL109 field.
	XBARA_SEL54_SEL109_Pos = 0x8
	// Bit mask of SEL109 field.
	XBARA_SEL54_SEL109_Msk = 0x7f00

	// SEL55: Crossbar A Select Register 55
	// Position of SEL110 field.
	XBARA_SEL55_SEL110_Pos = 0x0
	// Bit mask of SEL110 field.
	XBARA_SEL55_SEL110_Msk = 0x7f
	// Position of SEL111 field.
	XBARA_SEL55_SEL111_Pos = 0x8
	// Bit mask of SEL111 field.
	XBARA_SEL55_SEL111_Msk = 0x7f00

	// SEL56: Crossbar A Select Register 56
	// Position of SEL112 field.
	XBARA_SEL56_SEL112_Pos = 0x0
	// Bit mask of SEL112 field.
	XBARA_SEL56_SEL112_Msk = 0x7f
	// Position of SEL113 field.
	XBARA_SEL56_SEL113_Pos = 0x8
	// Bit mask of SEL113 field.
	XBARA_SEL56_SEL113_Msk = 0x7f00

	// SEL57: Crossbar A Select Register 57
	// Position of SEL114 field.
	XBARA_SEL57_SEL114_Pos = 0x0
	// Bit mask of SEL114 field.
	XBARA_SEL57_SEL114_Msk = 0x7f
	// Position of SEL115 field.
	XBARA_SEL57_SEL115_Pos = 0x8
	// Bit mask of SEL115 field.
	XBARA_SEL57_SEL115_Msk = 0x7f00

	// SEL58: Crossbar A Select Register 58
	// Position of SEL116 field.
	XBARA_SEL58_SEL116_Pos = 0x0
	// Bit mask of SEL116 field.
	XBARA_SEL58_SEL116_Msk = 0x7f
	// Position of SEL117 field.
	XBARA_SEL58_SEL117_Pos = 0x8
	// Bit mask of SEL117 field.
	XBARA_SEL58_SEL117_Msk = 0x7f00

	// SEL59: Crossbar A Select Register 59
	// Position of SEL118 field.
	XBARA_SEL59_SEL118_Pos = 0x0
	// Bit mask of SEL118 field.
	XBARA_SEL59_SEL118_Msk = 0x7f
	// Position of SEL119 field.
	XBARA_SEL59_SEL119_Pos = 0x8
	// Bit mask of SEL119 field.
	XBARA_SEL59_SEL119_Msk = 0x7f00

	// SEL60: Crossbar A Select Register 60
	// Position of SEL120 field.
	XBARA_SEL60_SEL120_Pos = 0x0
	// Bit mask of SEL120 field.
	XBARA_SEL60_SEL120_Msk = 0x7f
	// Position of SEL121 field.
	XBARA_SEL60_SEL121_Pos = 0x8
	// Bit mask of SEL121 field.
	XBARA_SEL60_SEL121_Msk = 0x7f00

	// SEL61: Crossbar A Select Register 61
	// Position of SEL122 field.
	XBARA_SEL61_SEL122_Pos = 0x0
	// Bit mask of SEL122 field.
	XBARA_SEL61_SEL122_Msk = 0x7f
	// Position of SEL123 field.
	XBARA_SEL61_SEL123_Pos = 0x8
	// Bit mask of SEL123 field.
	XBARA_SEL61_SEL123_Msk = 0x7f00

	// SEL62: Crossbar A Select Register 62
	// Position of SEL124 field.
	XBARA_SEL62_SEL124_Pos = 0x0
	// Bit mask of SEL124 field.
	XBARA_SEL62_SEL124_Msk = 0x7f
	// Position of SEL125 field.
	XBARA_SEL62_SEL125_Pos = 0x8
	// Bit mask of SEL125 field.
	XBARA_SEL62_SEL125_Msk = 0x7f00

	// SEL63: Crossbar A Select Register 63
	// Position of SEL126 field.
	XBARA_SEL63_SEL126_Pos = 0x0
	// Bit mask of SEL126 field.
	XBARA_SEL63_SEL126_Msk = 0x7f
	// Position of SEL127 field.
	XBARA_SEL63_SEL127_Pos = 0x8
	// Bit mask of SEL127 field.
	XBARA_SEL63_SEL127_Msk = 0x7f00

	// SEL64: Crossbar A Select Register 64
	// Position of SEL128 field.
	XBARA_SEL64_SEL128_Pos = 0x0
	// Bit mask of SEL128 field.
	XBARA_SEL64_SEL128_Msk = 0x7f
	// Position of SEL129 field.
	XBARA_SEL64_SEL129_Pos = 0x8
	// Bit mask of SEL129 field.
	XBARA_SEL64_SEL129_Msk = 0x7f00

	// SEL65: Crossbar A Select Register 65
	// Position of SEL130 field.
	XBARA_SEL65_SEL130_Pos = 0x0
	// Bit mask of SEL130 field.
	XBARA_SEL65_SEL130_Msk = 0x7f
	// Position of SEL131 field.
	XBARA_SEL65_SEL131_Pos = 0x8
	// Bit mask of SEL131 field.
	XBARA_SEL65_SEL131_Msk = 0x7f00

	// CTRL0: Crossbar A Control Register 0
	// Position of DEN0 field.
	XBARA_CTRL0_DEN0_Pos = 0x0
	// Bit mask of DEN0 field.
	XBARA_CTRL0_DEN0_Msk = 0x1
	// Bit DEN0.
	XBARA_CTRL0_DEN0 = 0x1
	// DMA disabled
	XBARA_CTRL0_DEN0_DEN0_0 = 0x0
	// DMA enabled
	XBARA_CTRL0_DEN0_DEN0_1 = 0x1
	// Position of IEN0 field.
	XBARA_CTRL0_IEN0_Pos = 0x1
	// Bit mask of IEN0 field.
	XBARA_CTRL0_IEN0_Msk = 0x2
	// Bit IEN0.
	XBARA_CTRL0_IEN0 = 0x2
	// Interrupt disabled
	XBARA_CTRL0_IEN0_IEN0_0 = 0x0
	// Interrupt enabled
	XBARA_CTRL0_IEN0_IEN0_1 = 0x1
	// Position of EDGE0 field.
	XBARA_CTRL0_EDGE0_Pos = 0x2
	// Bit mask of EDGE0 field.
	XBARA_CTRL0_EDGE0_Msk = 0xc
	// STS0 never asserts
	XBARA_CTRL0_EDGE0_EDGE0_0 = 0x0
	// STS0 asserts on rising edges of XBAR_OUT0
	XBARA_CTRL0_EDGE0_EDGE0_1 = 0x1
	// STS0 asserts on falling edges of XBAR_OUT0
	XBARA_CTRL0_EDGE0_EDGE0_2 = 0x2
	// STS0 asserts on rising and falling edges of XBAR_OUT0
	XBARA_CTRL0_EDGE0_EDGE0_3 = 0x3
	// Position of STS0 field.
	XBARA_CTRL0_STS0_Pos = 0x4
	// Bit mask of STS0 field.
	XBARA_CTRL0_STS0_Msk = 0x10
	// Bit STS0.
	XBARA_CTRL0_STS0 = 0x10
	// Active edge not yet detected on XBAR_OUT0
	XBARA_CTRL0_STS0_STS0_0 = 0x0
	// Active edge detected on XBAR_OUT0
	XBARA_CTRL0_STS0_STS0_1 = 0x1
	// Position of DEN1 field.
	XBARA_CTRL0_DEN1_Pos = 0x8
	// Bit mask of DEN1 field.
	XBARA_CTRL0_DEN1_Msk = 0x100
	// Bit DEN1.
	XBARA_CTRL0_DEN1 = 0x100
	// DMA disabled
	XBARA_CTRL0_DEN1_DEN1_0 = 0x0
	// DMA enabled
	XBARA_CTRL0_DEN1_DEN1_1 = 0x1
	// Position of IEN1 field.
	XBARA_CTRL0_IEN1_Pos = 0x9
	// Bit mask of IEN1 field.
	XBARA_CTRL0_IEN1_Msk = 0x200
	// Bit IEN1.
	XBARA_CTRL0_IEN1 = 0x200
	// Interrupt disabled
	XBARA_CTRL0_IEN1_IEN1_0 = 0x0
	// Interrupt enabled
	XBARA_CTRL0_IEN1_IEN1_1 = 0x1
	// Position of EDGE1 field.
	XBARA_CTRL0_EDGE1_Pos = 0xa
	// Bit mask of EDGE1 field.
	XBARA_CTRL0_EDGE1_Msk = 0xc00
	// STS1 never asserts
	XBARA_CTRL0_EDGE1_EDGE1_0 = 0x0
	// STS1 asserts on rising edges of XBAR_OUT1
	XBARA_CTRL0_EDGE1_EDGE1_1 = 0x1
	// STS1 asserts on falling edges of XBAR_OUT1
	XBARA_CTRL0_EDGE1_EDGE1_2 = 0x2
	// STS1 asserts on rising and falling edges of XBAR_OUT1
	XBARA_CTRL0_EDGE1_EDGE1_3 = 0x3
	// Position of STS1 field.
	XBARA_CTRL0_STS1_Pos = 0xc
	// Bit mask of STS1 field.
	XBARA_CTRL0_STS1_Msk = 0x1000
	// Bit STS1.
	XBARA_CTRL0_STS1 = 0x1000
	// Active edge not yet detected on XBAR_OUT1
	XBARA_CTRL0_STS1_STS1_0 = 0x0
	// Active edge detected on XBAR_OUT1
	XBARA_CTRL0_STS1_STS1_1 = 0x1

	// CTRL1: Crossbar A Control Register 1
	// Position of DEN2 field.
	XBARA_CTRL1_DEN2_Pos = 0x0
	// Bit mask of DEN2 field.
	XBARA_CTRL1_DEN2_Msk = 0x1
	// Bit DEN2.
	XBARA_CTRL1_DEN2 = 0x1
	// DMA disabled
	XBARA_CTRL1_DEN2_DEN2_0 = 0x0
	// DMA enabled
	XBARA_CTRL1_DEN2_DEN2_1 = 0x1
	// Position of IEN2 field.
	XBARA_CTRL1_IEN2_Pos = 0x1
	// Bit mask of IEN2 field.
	XBARA_CTRL1_IEN2_Msk = 0x2
	// Bit IEN2.
	XBARA_CTRL1_IEN2 = 0x2
	// Interrupt disabled
	XBARA_CTRL1_IEN2_IEN2_0 = 0x0
	// Interrupt enabled
	XBARA_CTRL1_IEN2_IEN2_1 = 0x1
	// Position of EDGE2 field.
	XBARA_CTRL1_EDGE2_Pos = 0x2
	// Bit mask of EDGE2 field.
	XBARA_CTRL1_EDGE2_Msk = 0xc
	// STS2 never asserts
	XBARA_CTRL1_EDGE2_EDGE2_0 = 0x0
	// STS2 asserts on rising edges of XBAR_OUT2
	XBARA_CTRL1_EDGE2_EDGE2_1 = 0x1
	// STS2 asserts on falling edges of XBAR_OUT2
	XBARA_CTRL1_EDGE2_EDGE2_2 = 0x2
	// STS2 asserts on rising and falling edges of XBAR_OUT2
	XBARA_CTRL1_EDGE2_EDGE2_3 = 0x3
	// Position of STS2 field.
	XBARA_CTRL1_STS2_Pos = 0x4
	// Bit mask of STS2 field.
	XBARA_CTRL1_STS2_Msk = 0x10
	// Bit STS2.
	XBARA_CTRL1_STS2 = 0x10
	// Active edge not yet detected on XBAR_OUT2
	XBARA_CTRL1_STS2_STS2_0 = 0x0
	// Active edge detected on XBAR_OUT2
	XBARA_CTRL1_STS2_STS2_1 = 0x1
	// Position of DEN3 field.
	XBARA_CTRL1_DEN3_Pos = 0x8
	// Bit mask of DEN3 field.
	XBARA_CTRL1_DEN3_Msk = 0x100
	// Bit DEN3.
	XBARA_CTRL1_DEN3 = 0x100
	// DMA disabled
	XBARA_CTRL1_DEN3_DEN3_0 = 0x0
	// DMA enabled
	XBARA_CTRL1_DEN3_DEN3_1 = 0x1
	// Position of IEN3 field.
	XBARA_CTRL1_IEN3_Pos = 0x9
	// Bit mask of IEN3 field.
	XBARA_CTRL1_IEN3_Msk = 0x200
	// Bit IEN3.
	XBARA_CTRL1_IEN3 = 0x200
	// Interrupt disabled
	XBARA_CTRL1_IEN3_IEN3_0 = 0x0
	// Interrupt enabled
	XBARA_CTRL1_IEN3_IEN3_1 = 0x1
	// Position of EDGE3 field.
	XBARA_CTRL1_EDGE3_Pos = 0xa
	// Bit mask of EDGE3 field.
	XBARA_CTRL1_EDGE3_Msk = 0xc00
	// STS3 never asserts
	XBARA_CTRL1_EDGE3_EDGE3_0 = 0x0
	// STS3 asserts on rising edges of XBAR_OUT3
	XBARA_CTRL1_EDGE3_EDGE3_1 = 0x1
	// STS3 asserts on falling edges of XBAR_OUT3
	XBARA_CTRL1_EDGE3_EDGE3_2 = 0x2
	// STS3 asserts on rising and falling edges of XBAR_OUT3
	XBARA_CTRL1_EDGE3_EDGE3_3 = 0x3
	// Position of STS3 field.
	XBARA_CTRL1_STS3_Pos = 0xc
	// Bit mask of STS3 field.
	XBARA_CTRL1_STS3_Msk = 0x1000
	// Bit STS3.
	XBARA_CTRL1_STS3 = 0x1000
	// Active edge not yet detected on XBAR_OUT3
	XBARA_CTRL1_STS3_STS3_0 = 0x0
	// Active edge detected on XBAR_OUT3
	XBARA_CTRL1_STS3_STS3_1 = 0x1
)

// Bitfields for ENC1: Quadrature Decoder
const (
	// CTRL: Control Register
	// Position of CMPIE field.
	ENC_CTRL_CMPIE_Pos = 0x0
	// Bit mask of CMPIE field.
	ENC_CTRL_CMPIE_Msk = 0x1
	// Bit CMPIE.
	ENC_CTRL_CMPIE = 0x1
	// Compare interrupt is disabled
	ENC_CTRL_CMPIE_CMPIE_0 = 0x0
	// Compare interrupt is enabled
	ENC_CTRL_CMPIE_CMPIE_1 = 0x1
	// Position of CMPIRQ field.
	ENC_CTRL_CMPIRQ_Pos = 0x1
	// Bit mask of CMPIRQ field.
	ENC_CTRL_CMPIRQ_Msk = 0x2
	// Bit CMPIRQ.
	ENC_CTRL_CMPIRQ = 0x2
	// No match has occurred
	ENC_CTRL_CMPIRQ_CMPIRQ_0 = 0x0
	// COMP match has occurred
	ENC_CTRL_CMPIRQ_CMPIRQ_1 = 0x1
	// Position of WDE field.
	ENC_CTRL_WDE_Pos = 0x2
	// Bit mask of WDE field.
	ENC_CTRL_WDE_Msk = 0x4
	// Bit WDE.
	ENC_CTRL_WDE = 0x4
	// Watchdog timer is disabled
	ENC_CTRL_WDE_WDE_0 = 0x0
	// Watchdog timer is enabled
	ENC_CTRL_WDE_WDE_1 = 0x1
	// Position of DIE field.
	ENC_CTRL_DIE_Pos = 0x3
	// Bit mask of DIE field.
	ENC_CTRL_DIE_Msk = 0x8
	// Bit DIE.
	ENC_CTRL_DIE = 0x8
	// Watchdog timer interrupt is disabled
	ENC_CTRL_DIE_DIE_0 = 0x0
	// Watchdog timer interrupt is enabled
	ENC_CTRL_DIE_DIE_1 = 0x1
	// Position of DIRQ field.
	ENC_CTRL_DIRQ_Pos = 0x4
	// Bit mask of DIRQ field.
	ENC_CTRL_DIRQ_Msk = 0x10
	// Bit DIRQ.
	ENC_CTRL_DIRQ = 0x10
	// No interrupt has occurred
	ENC_CTRL_DIRQ_DIRQ_0 = 0x0
	// Watchdog timeout interrupt has occurred
	ENC_CTRL_DIRQ_DIRQ_1 = 0x1
	// Position of XNE field.
	ENC_CTRL_XNE_Pos = 0x5
	// Bit mask of XNE field.
	ENC_CTRL_XNE_Msk = 0x20
	// Bit XNE.
	ENC_CTRL_XNE = 0x20
	// Use positive transition edge of INDEX pulse
	ENC_CTRL_XNE_XNE_0 = 0x0
	// Use negative transition edge of INDEX pulse
	ENC_CTRL_XNE_XNE_1 = 0x1
	// Position of XIP field.
	ENC_CTRL_XIP_Pos = 0x6
	// Bit mask of XIP field.
	ENC_CTRL_XIP_Msk = 0x40
	// Bit XIP.
	ENC_CTRL_XIP = 0x40
	// No action
	ENC_CTRL_XIP_XIP_0 = 0x0
	// INDEX pulse initializes the position counter
	ENC_CTRL_XIP_XIP_1 = 0x1
	// Position of XIE field.
	ENC_CTRL_XIE_Pos = 0x7
	// Bit mask of XIE field.
	ENC_CTRL_XIE_Msk = 0x80
	// Bit XIE.
	ENC_CTRL_XIE = 0x80
	// INDEX pulse interrupt is disabled
	ENC_CTRL_XIE_XIE_0 = 0x0
	// INDEX pulse interrupt is enabled
	ENC_CTRL_XIE_XIE_1 = 0x1
	// Position of XIRQ field.
	ENC_CTRL_XIRQ_Pos = 0x8
	// Bit mask of XIRQ field.
	ENC_CTRL_XIRQ_Msk = 0x100
	// Bit XIRQ.
	ENC_CTRL_XIRQ = 0x100
	// No interrupt has occurred
	ENC_CTRL_XIRQ_XIRQ_0 = 0x0
	// INDEX pulse interrupt has occurred
	ENC_CTRL_XIRQ_XIRQ_1 = 0x1
	// Position of PH1 field.
	ENC_CTRL_PH1_Pos = 0x9
	// Bit mask of PH1 field.
	ENC_CTRL_PH1_Msk = 0x200
	// Bit PH1.
	ENC_CTRL_PH1 = 0x200
	// Use standard quadrature decoder where PHASEA and PHASEB represent a two phase quadrature signal.
	ENC_CTRL_PH1_PH1_0 = 0x0
	// Bypass the quadrature decoder. A positive transition of the PHASEA input generates a count signal. The PHASEB input and the REV bit control the counter direction. If CTRL[REV] = 0, PHASEB = 0, then count up If CTRL[REV] = 0, PHASEB = 1, then count down If CTRL[REV] = 1, PHASEB = 0, then count down If CTRL[REV] = 1, PHASEB = 1, then count up
	ENC_CTRL_PH1_PH1_1 = 0x1
	// Position of REV field.
	ENC_CTRL_REV_Pos = 0xa
	// Bit mask of REV field.
	ENC_CTRL_REV_Msk = 0x400
	// Bit REV.
	ENC_CTRL_REV = 0x400
	// Count normally
	ENC_CTRL_REV_REV_0 = 0x0
	// Count in the reverse direction
	ENC_CTRL_REV_REV_1 = 0x1
	// Position of SWIP field.
	ENC_CTRL_SWIP_Pos = 0xb
	// Bit mask of SWIP field.
	ENC_CTRL_SWIP_Msk = 0x800
	// Bit SWIP.
	ENC_CTRL_SWIP = 0x800
	// No action
	ENC_CTRL_SWIP_SWIP_0 = 0x0
	// Initialize position counter
	ENC_CTRL_SWIP_SWIP_1 = 0x1
	// Position of HNE field.
	ENC_CTRL_HNE_Pos = 0xc
	// Bit mask of HNE field.
	ENC_CTRL_HNE_Msk = 0x1000
	// Bit HNE.
	ENC_CTRL_HNE = 0x1000
	// Use positive going edge-to-trigger initialization of position counters UPOS and LPOS
	ENC_CTRL_HNE_HNE_0 = 0x0
	// Use negative going edge-to-trigger initialization of position counters UPOS and LPOS
	ENC_CTRL_HNE_HNE_1 = 0x1
	// Position of HIP field.
	ENC_CTRL_HIP_Pos = 0xd
	// Bit mask of HIP field.
	ENC_CTRL_HIP_Msk = 0x2000
	// Bit HIP.
	ENC_CTRL_HIP = 0x2000
	// No action
	ENC_CTRL_HIP_HIP_0 = 0x0
	// HOME signal initializes the position counter
	ENC_CTRL_HIP_HIP_1 = 0x1
	// Position of HIE field.
	ENC_CTRL_HIE_Pos = 0xe
	// Bit mask of HIE field.
	ENC_CTRL_HIE_Msk = 0x4000
	// Bit HIE.
	ENC_CTRL_HIE = 0x4000
	// Disable HOME interrupts
	ENC_CTRL_HIE_HIE_0 = 0x0
	// Enable HOME interrupts
	ENC_CTRL_HIE_HIE_1 = 0x1
	// Position of HIRQ field.
	ENC_CTRL_HIRQ_Pos = 0xf
	// Bit mask of HIRQ field.
	ENC_CTRL_HIRQ_Msk = 0x8000
	// Bit HIRQ.
	ENC_CTRL_HIRQ = 0x8000
	// No interrupt
	ENC_CTRL_HIRQ_HIRQ_0 = 0x0
	// HOME signal transition interrupt request
	ENC_CTRL_HIRQ_HIRQ_1 = 0x1

	// FILT: Input Filter Register
	// Position of FILT_PER field.
	ENC_FILT_FILT_PER_Pos = 0x0
	// Bit mask of FILT_PER field.
	ENC_FILT_FILT_PER_Msk = 0xff
	// Position of FILT_CNT field.
	ENC_FILT_FILT_CNT_Pos = 0x8
	// Bit mask of FILT_CNT field.
	ENC_FILT_FILT_CNT_Msk = 0x700

	// WTR: Watchdog Timeout Register
	// Position of WDOG field.
	ENC_WTR_WDOG_Pos = 0x0
	// Bit mask of WDOG field.
	ENC_WTR_WDOG_Msk = 0xffff

	// POSD: Position Difference Counter Register
	// Position of POSD field.
	ENC_POSD_POSD_Pos = 0x0
	// Bit mask of POSD field.
	ENC_POSD_POSD_Msk = 0xffff

	// POSDH: Position Difference Hold Register
	// Position of POSDH field.
	ENC_POSDH_POSDH_Pos = 0x0
	// Bit mask of POSDH field.
	ENC_POSDH_POSDH_Msk = 0xffff

	// REV: Revolution Counter Register
	// Position of REV field.
	ENC_REV_REV_Pos = 0x0
	// Bit mask of REV field.
	ENC_REV_REV_Msk = 0xffff

	// REVH: Revolution Hold Register
	// Position of REVH field.
	ENC_REVH_REVH_Pos = 0x0
	// Bit mask of REVH field.
	ENC_REVH_REVH_Msk = 0xffff

	// UPOS: Upper Position Counter Register
	// Position of POS field.
	ENC_UPOS_POS_Pos = 0x0
	// Bit mask of POS field.
	ENC_UPOS_POS_Msk = 0xffff

	// LPOS: Lower Position Counter Register
	// Position of POS field.
	ENC_LPOS_POS_Pos = 0x0
	// Bit mask of POS field.
	ENC_LPOS_POS_Msk = 0xffff

	// UPOSH: Upper Position Hold Register
	// Position of POSH field.
	ENC_UPOSH_POSH_Pos = 0x0
	// Bit mask of POSH field.
	ENC_UPOSH_POSH_Msk = 0xffff

	// LPOSH: Lower Position Hold Register
	// Position of POSH field.
	ENC_LPOSH_POSH_Pos = 0x0
	// Bit mask of POSH field.
	ENC_LPOSH_POSH_Msk = 0xffff

	// UINIT: Upper Initialization Register
	// Position of INIT field.
	ENC_UINIT_INIT_Pos = 0x0
	// Bit mask of INIT field.
	ENC_UINIT_INIT_Msk = 0xffff

	// LINIT: Lower Initialization Register
	// Position of INIT field.
	ENC_LINIT_INIT_Pos = 0x0
	// Bit mask of INIT field.
	ENC_LINIT_INIT_Msk = 0xffff

	// IMR: Input Monitor Register
	// Position of HOME field.
	ENC_IMR_HOME_Pos = 0x0
	// Bit mask of HOME field.
	ENC_IMR_HOME_Msk = 0x1
	// Bit HOME.
	ENC_IMR_HOME = 0x1
	// Position of INDEX field.
	ENC_IMR_INDEX_Pos = 0x1
	// Bit mask of INDEX field.
	ENC_IMR_INDEX_Msk = 0x2
	// Bit INDEX.
	ENC_IMR_INDEX = 0x2
	// Position of PHB field.
	ENC_IMR_PHB_Pos = 0x2
	// Bit mask of PHB field.
	ENC_IMR_PHB_Msk = 0x4
	// Bit PHB.
	ENC_IMR_PHB = 0x4
	// Position of PHA field.
	ENC_IMR_PHA_Pos = 0x3
	// Bit mask of PHA field.
	ENC_IMR_PHA_Msk = 0x8
	// Bit PHA.
	ENC_IMR_PHA = 0x8
	// Position of FHOM field.
	ENC_IMR_FHOM_Pos = 0x4
	// Bit mask of FHOM field.
	ENC_IMR_FHOM_Msk = 0x10
	// Bit FHOM.
	ENC_IMR_FHOM = 0x10
	// Position of FIND field.
	ENC_IMR_FIND_Pos = 0x5
	// Bit mask of FIND field.
	ENC_IMR_FIND_Msk = 0x20
	// Bit FIND.
	ENC_IMR_FIND = 0x20
	// Position of FPHB field.
	ENC_IMR_FPHB_Pos = 0x6
	// Bit mask of FPHB field.
	ENC_IMR_FPHB_Msk = 0x40
	// Bit FPHB.
	ENC_IMR_FPHB = 0x40
	// Position of FPHA field.
	ENC_IMR_FPHA_Pos = 0x7
	// Bit mask of FPHA field.
	ENC_IMR_FPHA_Msk = 0x80
	// Bit FPHA.
	ENC_IMR_FPHA = 0x80

	// TST: Test Register
	// Position of TEST_COUNT field.
	ENC_TST_TEST_COUNT_Pos = 0x0
	// Bit mask of TEST_COUNT field.
	ENC_TST_TEST_COUNT_Msk = 0xff
	// Position of TEST_PERIOD field.
	ENC_TST_TEST_PERIOD_Pos = 0x8
	// Bit mask of TEST_PERIOD field.
	ENC_TST_TEST_PERIOD_Msk = 0x1f00
	// Position of QDN field.
	ENC_TST_QDN_Pos = 0xd
	// Bit mask of QDN field.
	ENC_TST_QDN_Msk = 0x2000
	// Bit QDN.
	ENC_TST_QDN = 0x2000
	// Leaves quadrature decoder signal in a positive direction
	ENC_TST_QDN_QDN_0 = 0x0
	// Generates a negative quadrature decoder signal
	ENC_TST_QDN_QDN_1 = 0x1
	// Position of TCE field.
	ENC_TST_TCE_Pos = 0xe
	// Bit mask of TCE field.
	ENC_TST_TCE_Msk = 0x4000
	// Bit TCE.
	ENC_TST_TCE = 0x4000
	// Test count is not enabled
	ENC_TST_TCE_TCE_0 = 0x0
	// Test count is enabled
	ENC_TST_TCE_TCE_1 = 0x1
	// Position of TEN field.
	ENC_TST_TEN_Pos = 0xf
	// Bit mask of TEN field.
	ENC_TST_TEN_Msk = 0x8000
	// Bit TEN.
	ENC_TST_TEN = 0x8000
	// Test module is not enabled
	ENC_TST_TEN_TEN_0 = 0x0
	// Test module is enabled
	ENC_TST_TEN_TEN_1 = 0x1

	// CTRL2: Control 2 Register
	// Position of UPDHLD field.
	ENC_CTRL2_UPDHLD_Pos = 0x0
	// Bit mask of UPDHLD field.
	ENC_CTRL2_UPDHLD_Msk = 0x1
	// Bit UPDHLD.
	ENC_CTRL2_UPDHLD = 0x1
	// Disable updates of hold registers on rising edge of TRIGGER
	ENC_CTRL2_UPDHLD_UPDHLD_0 = 0x0
	// Enable updates of hold registers on rising edge of TRIGGER
	ENC_CTRL2_UPDHLD_UPDHLD_1 = 0x1
	// Position of UPDPOS field.
	ENC_CTRL2_UPDPOS_Pos = 0x1
	// Bit mask of UPDPOS field.
	ENC_CTRL2_UPDPOS_Msk = 0x2
	// Bit UPDPOS.
	ENC_CTRL2_UPDPOS = 0x2
	// No action for POSD, REV, UPOS and LPOS on rising edge of TRIGGER
	ENC_CTRL2_UPDPOS_UPDPOS_0 = 0x0
	// Clear POSD, REV, UPOS and LPOS on rising edge of TRIGGER
	ENC_CTRL2_UPDPOS_UPDPOS_1 = 0x1
	// Position of MOD field.
	ENC_CTRL2_MOD_Pos = 0x2
	// Bit mask of MOD field.
	ENC_CTRL2_MOD_Msk = 0x4
	// Bit MOD.
	ENC_CTRL2_MOD = 0x4
	// Disable modulo counting
	ENC_CTRL2_MOD_MOD_0 = 0x0
	// Enable modulo counting
	ENC_CTRL2_MOD_MOD_1 = 0x1
	// Position of DIR field.
	ENC_CTRL2_DIR_Pos = 0x3
	// Bit mask of DIR field.
	ENC_CTRL2_DIR_Msk = 0x8
	// Bit DIR.
	ENC_CTRL2_DIR = 0x8
	// Last count was in the down direction
	ENC_CTRL2_DIR_DIR_0 = 0x0
	// Last count was in the up direction
	ENC_CTRL2_DIR_DIR_1 = 0x1
	// Position of RUIE field.
	ENC_CTRL2_RUIE_Pos = 0x4
	// Bit mask of RUIE field.
	ENC_CTRL2_RUIE_Msk = 0x10
	// Bit RUIE.
	ENC_CTRL2_RUIE = 0x10
	// Roll-under interrupt is disabled
	ENC_CTRL2_RUIE_RUIE_0 = 0x0
	// Roll-under interrupt is enabled
	ENC_CTRL2_RUIE_RUIE_1 = 0x1
	// Position of RUIRQ field.
	ENC_CTRL2_RUIRQ_Pos = 0x5
	// Bit mask of RUIRQ field.
	ENC_CTRL2_RUIRQ_Msk = 0x20
	// Bit RUIRQ.
	ENC_CTRL2_RUIRQ = 0x20
	// No roll-under has occurred
	ENC_CTRL2_RUIRQ_RUIRQ_0 = 0x0
	// Roll-under has occurred
	ENC_CTRL2_RUIRQ_RUIRQ_1 = 0x1
	// Position of ROIE field.
	ENC_CTRL2_ROIE_Pos = 0x6
	// Bit mask of ROIE field.
	ENC_CTRL2_ROIE_Msk = 0x40
	// Bit ROIE.
	ENC_CTRL2_ROIE = 0x40
	// Roll-over interrupt is disabled
	ENC_CTRL2_ROIE_ROIE_0 = 0x0
	// Roll-over interrupt is enabled
	ENC_CTRL2_ROIE_ROIE_1 = 0x1
	// Position of ROIRQ field.
	ENC_CTRL2_ROIRQ_Pos = 0x7
	// Bit mask of ROIRQ field.
	ENC_CTRL2_ROIRQ_Msk = 0x80
	// Bit ROIRQ.
	ENC_CTRL2_ROIRQ = 0x80
	// No roll-over has occurred
	ENC_CTRL2_ROIRQ_ROIRQ_0 = 0x0
	// Roll-over has occurred
	ENC_CTRL2_ROIRQ_ROIRQ_1 = 0x1
	// Position of REVMOD field.
	ENC_CTRL2_REVMOD_Pos = 0x8
	// Bit mask of REVMOD field.
	ENC_CTRL2_REVMOD_Msk = 0x100
	// Bit REVMOD.
	ENC_CTRL2_REVMOD = 0x100
	// Use INDEX pulse to increment/decrement revolution counter (REV).
	ENC_CTRL2_REVMOD_REVMOD_0 = 0x0
	// Use modulus counting roll-over/under to increment/decrement revolution counter (REV).
	ENC_CTRL2_REVMOD_REVMOD_1 = 0x1
	// Position of OUTCTL field.
	ENC_CTRL2_OUTCTL_Pos = 0x9
	// Bit mask of OUTCTL field.
	ENC_CTRL2_OUTCTL_Msk = 0x200
	// Bit OUTCTL.
	ENC_CTRL2_OUTCTL = 0x200
	// POSMATCH pulses when a match occurs between the position counters (POS) and the compare value (COMP).
	ENC_CTRL2_OUTCTL_OUTCTL_0 = 0x0
	// POSMATCH pulses when the UPOS, LPOS, REV, or POSD registers are read.
	ENC_CTRL2_OUTCTL_OUTCTL_1 = 0x1
	// Position of SABIE field.
	ENC_CTRL2_SABIE_Pos = 0xa
	// Bit mask of SABIE field.
	ENC_CTRL2_SABIE_Msk = 0x400
	// Bit SABIE.
	ENC_CTRL2_SABIE = 0x400
	// Simultaneous PHASEA and PHASEB change interrupt disabled.
	ENC_CTRL2_SABIE_SABIE_0 = 0x0
	// Simultaneous PHASEA and PHASEB change interrupt enabled.
	ENC_CTRL2_SABIE_SABIE_1 = 0x1
	// Position of SABIRQ field.
	ENC_CTRL2_SABIRQ_Pos = 0xb
	// Bit mask of SABIRQ field.
	ENC_CTRL2_SABIRQ_Msk = 0x800
	// Bit SABIRQ.
	ENC_CTRL2_SABIRQ = 0x800
	// No simultaneous change of PHASEA and PHASEB has occurred.
	ENC_CTRL2_SABIRQ_SABIRQ_0 = 0x0
	// A simultaneous change of PHASEA and PHASEB has occurred.
	ENC_CTRL2_SABIRQ_SABIRQ_1 = 0x1

	// UMOD: Upper Modulus Register
	// Position of MOD field.
	ENC_UMOD_MOD_Pos = 0x0
	// Bit mask of MOD field.
	ENC_UMOD_MOD_Msk = 0xffff

	// LMOD: Lower Modulus Register
	// Position of MOD field.
	ENC_LMOD_MOD_Pos = 0x0
	// Bit mask of MOD field.
	ENC_LMOD_MOD_Msk = 0xffff

	// UCOMP: Upper Position Compare Register
	// Position of COMP field.
	ENC_UCOMP_COMP_Pos = 0x0
	// Bit mask of COMP field.
	ENC_UCOMP_COMP_Msk = 0xffff

	// LCOMP: Lower Position Compare Register
	// Position of COMP field.
	ENC_LCOMP_COMP_Pos = 0x0
	// Bit mask of COMP field.
	ENC_LCOMP_COMP_Msk = 0xffff
)

// Bitfields for PWM1: PWM
const (
	// SM0CNT: Counter Register
	// Position of CNT field.
	PWM_SM0CNT_CNT_Pos = 0x0
	// Bit mask of CNT field.
	PWM_SM0CNT_CNT_Msk = 0xffff

	// SM0INIT: Initial Count Register
	// Position of INIT field.
	PWM_SM0INIT_INIT_Pos = 0x0
	// Bit mask of INIT field.
	PWM_SM0INIT_INIT_Msk = 0xffff

	// SM0CTRL2: Control 2 Register
	// Position of CLK_SEL field.
	PWM_SM0CTRL2_CLK_SEL_Pos = 0x0
	// Bit mask of CLK_SEL field.
	PWM_SM0CTRL2_CLK_SEL_Msk = 0x3
	// The IPBus clock is used as the clock for the local prescaler and counter.
	PWM_SM0CTRL2_CLK_SEL_CLK_SEL_0 = 0x0
	// EXT_CLK is used as the clock for the local prescaler and counter.
	PWM_SM0CTRL2_CLK_SEL_CLK_SEL_1 = 0x1
	// Submodule 0's clock (AUX_CLK) is used as the source clock for the local prescaler and counter. This setting should not be used in submodule 0 as it will force the clock to logic 0.
	PWM_SM0CTRL2_CLK_SEL_CLK_SEL_2 = 0x2
	// Position of RELOAD_SEL field.
	PWM_SM0CTRL2_RELOAD_SEL_Pos = 0x2
	// Bit mask of RELOAD_SEL field.
	PWM_SM0CTRL2_RELOAD_SEL_Msk = 0x4
	// Bit RELOAD_SEL.
	PWM_SM0CTRL2_RELOAD_SEL = 0x4
	// The local RELOAD signal is used to reload registers.
	PWM_SM0CTRL2_RELOAD_SEL_RELOAD_SEL_0 = 0x0
	// The master RELOAD signal (from submodule 0) is used to reload registers. This setting should not be used in submodule 0 as it will force the RELOAD signal to logic 0.
	PWM_SM0CTRL2_RELOAD_SEL_RELOAD_SEL_1 = 0x1
	// Position of FORCE_SEL field.
	PWM_SM0CTRL2_FORCE_SEL_Pos = 0x3
	// Bit mask of FORCE_SEL field.
	PWM_SM0CTRL2_FORCE_SEL_Msk = 0x38
	// The local force signal, CTRL2[FORCE], from this submodule is used to force updates.
	PWM_SM0CTRL2_FORCE_SEL_FORCE_SEL_0 = 0x0
	// The master force signal from submodule 0 is used to force updates. This setting should not be used in submodule 0 as it will hold the FORCE OUTPUT signal to logic 0.
	PWM_SM0CTRL2_FORCE_SEL_FORCE_SEL_1 = 0x1
	// The local reload signal from this submodule is used to force updates without regard to the state of LDOK.
	PWM_SM0CTRL2_FORCE_SEL_FORCE_SEL_2 = 0x2
	// The master reload signal from submodule0 is used to force updates if LDOK is set. This setting should not be used in submodule0 as it will hold the FORCE OUTPUT signal to logic 0.
	PWM_SM0CTRL2_FORCE_SEL_FORCE_SEL_3 = 0x3
	// The local sync signal from this submodule is used to force updates.
	PWM_SM0CTRL2_FORCE_SEL_FORCE_SEL_4 = 0x4
	// The master sync signal from submodule0 is used to force updates. This setting should not be used in submodule0 as it will hold the FORCE OUTPUT signal to logic 0.
	PWM_SM0CTRL2_FORCE_SEL_FORCE_SEL_5 = 0x5
	// The external force signal, EXT_FORCE, from outside the PWM module causes updates.
	PWM_SM0CTRL2_FORCE_SEL_FORCE_SEL_6 = 0x6
	// The external sync signal, EXT_SYNC, from outside the PWM module causes updates.
	PWM_SM0CTRL2_FORCE_SEL_FORCE_SEL_7 = 0x7
	// Position of FORCE field.
	PWM_SM0CTRL2_FORCE_Pos = 0x6
	// Bit mask of FORCE field.
	PWM_SM0CTRL2_FORCE_Msk = 0x40
	// Bit FORCE.
	PWM_SM0CTRL2_FORCE = 0x40
	// Position of FRCEN field.
	PWM_SM0CTRL2_FRCEN_Pos = 0x7
	// Bit mask of FRCEN field.
	PWM_SM0CTRL2_FRCEN_Msk = 0x80
	// Bit FRCEN.
	PWM_SM0CTRL2_FRCEN = 0x80
	// Initialization from a FORCE_OUT is disabled.
	PWM_SM0CTRL2_FRCEN_FRCEN_0 = 0x0
	// Initialization from a FORCE_OUT is enabled.
	PWM_SM0CTRL2_FRCEN_FRCEN_1 = 0x1
	// Position of INIT_SEL field.
	PWM_SM0CTRL2_INIT_SEL_Pos = 0x8
	// Bit mask of INIT_SEL field.
	PWM_SM0CTRL2_INIT_SEL_Msk = 0x300
	// Local sync (PWM_X) causes initialization.
	PWM_SM0CTRL2_INIT_SEL_INIT_SEL_0 = 0x0
	// Master reload from submodule 0 causes initialization. This setting should not be used in submodule 0 as it will force the INIT signal to logic 0. The submodule counter will only reinitialize when a master reload occurs.
	PWM_SM0CTRL2_INIT_SEL_INIT_SEL_1 = 0x1
	// Master sync from submodule 0 causes initialization. This setting should not be used in submodule 0 as it will force the INIT signal to logic 0.
	PWM_SM0CTRL2_INIT_SEL_INIT_SEL_2 = 0x2
	// EXT_SYNC causes initialization.
	PWM_SM0CTRL2_INIT_SEL_INIT_SEL_3 = 0x3
	// Position of PWMX_INIT field.
	PWM_SM0CTRL2_PWMX_INIT_Pos = 0xa
	// Bit mask of PWMX_INIT field.
	PWM_SM0CTRL2_PWMX_INIT_Msk = 0x400
	// Bit PWMX_INIT.
	PWM_SM0CTRL2_PWMX_INIT = 0x400
	// Position of PWM45_INIT field.
	PWM_SM0CTRL2_PWM45_INIT_Pos = 0xb
	// Bit mask of PWM45_INIT field.
	PWM_SM0CTRL2_PWM45_INIT_Msk = 0x800
	// Bit PWM45_INIT.
	PWM_SM0CTRL2_PWM45_INIT = 0x800
	// Position of PWM23_INIT field.
	PWM_SM0CTRL2_PWM23_INIT_Pos = 0xc
	// Bit mask of PWM23_INIT field.
	PWM_SM0CTRL2_PWM23_INIT_Msk = 0x1000
	// Bit PWM23_INIT.
	PWM_SM0CTRL2_PWM23_INIT = 0x1000
	// Position of INDEP field.
	PWM_SM0CTRL2_INDEP_Pos = 0xd
	// Bit mask of INDEP field.
	PWM_SM0CTRL2_INDEP_Msk = 0x2000
	// Bit INDEP.
	PWM_SM0CTRL2_INDEP = 0x2000
	// PWM_A and PWM_B form a complementary PWM pair.
	PWM_SM0CTRL2_INDEP_INDEP_0 = 0x0
	// PWM_A and PWM_B outputs are independent PWMs.
	PWM_SM0CTRL2_INDEP_INDEP_1 = 0x1
	// Position of WAITEN field.
	PWM_SM0CTRL2_WAITEN_Pos = 0xe
	// Bit mask of WAITEN field.
	PWM_SM0CTRL2_WAITEN_Msk = 0x4000
	// Bit WAITEN.
	PWM_SM0CTRL2_WAITEN = 0x4000
	// Position of DBGEN field.
	PWM_SM0CTRL2_DBGEN_Pos = 0xf
	// Bit mask of DBGEN field.
	PWM_SM0CTRL2_DBGEN_Msk = 0x8000
	// Bit DBGEN.
	PWM_SM0CTRL2_DBGEN = 0x8000

	// SM0CTRL: Control Register
	// Position of DBLEN field.
	PWM_SM0CTRL_DBLEN_Pos = 0x0
	// Bit mask of DBLEN field.
	PWM_SM0CTRL_DBLEN_Msk = 0x1
	// Bit DBLEN.
	PWM_SM0CTRL_DBLEN = 0x1
	// Double switching disabled.
	PWM_SM0CTRL_DBLEN_DBLEN_0 = 0x0
	// Double switching enabled.
	PWM_SM0CTRL_DBLEN_DBLEN_1 = 0x1
	// Position of DBLX field.
	PWM_SM0CTRL_DBLX_Pos = 0x1
	// Bit mask of DBLX field.
	PWM_SM0CTRL_DBLX_Msk = 0x2
	// Bit DBLX.
	PWM_SM0CTRL_DBLX = 0x2
	// PWMX double pulse disabled.
	PWM_SM0CTRL_DBLX_DBLX_0 = 0x0
	// PWMX double pulse enabled.
	PWM_SM0CTRL_DBLX_DBLX_1 = 0x1
	// Position of LDMOD field.
	PWM_SM0CTRL_LDMOD_Pos = 0x2
	// Bit mask of LDMOD field.
	PWM_SM0CTRL_LDMOD_Msk = 0x4
	// Bit LDMOD.
	PWM_SM0CTRL_LDMOD = 0x4
	// Buffered registers of this submodule are loaded and take effect at the next PWM reload if MCTRL[LDOK] is set.
	PWM_SM0CTRL_LDMOD_LDMOD_0 = 0x0
	// Buffered registers of this submodule are loaded and take effect immediately upon MCTRL[LDOK] being set. In this case it is not necessary to set CTRL[FULL] or CTRL[HALF].
	PWM_SM0CTRL_LDMOD_LDMOD_1 = 0x1
	// Position of SPLIT field.
	PWM_SM0CTRL_SPLIT_Pos = 0x3
	// Bit mask of SPLIT field.
	PWM_SM0CTRL_SPLIT_Msk = 0x8
	// Bit SPLIT.
	PWM_SM0CTRL_SPLIT = 0x8
	// DBLPWM is not split. PWMA and PWMB each have double pulses.
	PWM_SM0CTRL_SPLIT_SPLIT_0 = 0x0
	// DBLPWM is split to PWMA and PWMB.
	PWM_SM0CTRL_SPLIT_SPLIT_1 = 0x1
	// Position of PRSC field.
	PWM_SM0CTRL_PRSC_Pos = 0x4
	// Bit mask of PRSC field.
	PWM_SM0CTRL_PRSC_Msk = 0x70
	// PWM clock frequency = fclk
	PWM_SM0CTRL_PRSC_PRSC_0 = 0x0
	// PWM clock frequency = fclk/2
	PWM_SM0CTRL_PRSC_PRSC_1 = 0x1
	// PWM clock frequency = fclk/4
	PWM_SM0CTRL_PRSC_PRSC_2 = 0x2
	// PWM clock frequency = fclk/8
	PWM_SM0CTRL_PRSC_PRSC_3 = 0x3
	// PWM clock frequency = fclk/16
	PWM_SM0CTRL_PRSC_PRSC_4 = 0x4
	// PWM clock frequency = fclk/32
	PWM_SM0CTRL_PRSC_PRSC_5 = 0x5
	// PWM clock frequency = fclk/64
	PWM_SM0CTRL_PRSC_PRSC_6 = 0x6
	// PWM clock frequency = fclk/128
	PWM_SM0CTRL_PRSC_PRSC_7 = 0x7
	// Position of COMPMODE field.
	PWM_SM0CTRL_COMPMODE_Pos = 0x7
	// Bit mask of COMPMODE field.
	PWM_SM0CTRL_COMPMODE_Msk = 0x80
	// Bit COMPMODE.
	PWM_SM0CTRL_COMPMODE = 0x80
	// The VAL* registers and the PWM counter are compared using an "equal to" method. This means that PWM edges are only produced when the counter is equal to one of the VAL* register values. This implies that a PWMA output that is high at the end of a period will maintain this state until a match with VAL3 clears the output in the following period.
	PWM_SM0CTRL_COMPMODE_COMPMODE_0 = 0x0
	// The VAL* registers and the PWM counter are compared using an "equal to or greater than" method. This means that PWM edges are produced when the counter is equal to or greater than one of the VAL* register values. This implies that a PWMA output that is high at the end of a period could go low at the start of the next period if the starting counter value is greater than (but not necessarily equal to) the new VAL3 value.
	PWM_SM0CTRL_COMPMODE_COMPMODE_1 = 0x1
	// Position of DT field.
	PWM_SM0CTRL_DT_Pos = 0x8
	// Bit mask of DT field.
	PWM_SM0CTRL_DT_Msk = 0x300
	// Position of FULL field.
	PWM_SM0CTRL_FULL_Pos = 0xa
	// Bit mask of FULL field.
	PWM_SM0CTRL_FULL_Msk = 0x400
	// Bit FULL.
	PWM_SM0CTRL_FULL = 0x400
	// Full-cycle reloads disabled.
	PWM_SM0CTRL_FULL_FULL_0 = 0x0
	// Full-cycle reloads enabled.
	PWM_SM0CTRL_FULL_FULL_1 = 0x1
	// Position of HALF field.
	PWM_SM0CTRL_HALF_Pos = 0xb
	// Bit mask of HALF field.
	PWM_SM0CTRL_HALF_Msk = 0x800
	// Bit HALF.
	PWM_SM0CTRL_HALF = 0x800
	// Half-cycle reloads disabled.
	PWM_SM0CTRL_HALF_HALF_0 = 0x0
	// Half-cycle reloads enabled.
	PWM_SM0CTRL_HALF_HALF_1 = 0x1
	// Position of LDFQ field.
	PWM_SM0CTRL_LDFQ_Pos = 0xc
	// Bit mask of LDFQ field.
	PWM_SM0CTRL_LDFQ_Msk = 0xf000
	// Every PWM opportunity
	PWM_SM0CTRL_LDFQ_LDFQ_0 = 0x0
	// Every 2 PWM opportunities
	PWM_SM0CTRL_LDFQ_LDFQ_1 = 0x1
	// Every 3 PWM opportunities
	PWM_SM0CTRL_LDFQ_LDFQ_2 = 0x2
	// Every 4 PWM opportunities
	PWM_SM0CTRL_LDFQ_LDFQ_3 = 0x3
	// Every 5 PWM opportunities
	PWM_SM0CTRL_LDFQ_LDFQ_4 = 0x4
	// Every 6 PWM opportunities
	PWM_SM0CTRL_LDFQ_LDFQ_5 = 0x5
	// Every 7 PWM opportunities
	PWM_SM0CTRL_LDFQ_LDFQ_6 = 0x6
	// Every 8 PWM opportunities
	PWM_SM0CTRL_LDFQ_LDFQ_7 = 0x7
	// Every 9 PWM opportunities
	PWM_SM0CTRL_LDFQ_LDFQ_8 = 0x8
	// Every 10 PWM opportunities
	PWM_SM0CTRL_LDFQ_LDFQ_9 = 0x9
	// Every 11 PWM opportunities
	PWM_SM0CTRL_LDFQ_LDFQ_10 = 0xa
	// Every 12 PWM opportunities
	PWM_SM0CTRL_LDFQ_LDFQ_11 = 0xb
	// Every 13 PWM opportunities
	PWM_SM0CTRL_LDFQ_LDFQ_12 = 0xc
	// Every 14 PWM opportunities
	PWM_SM0CTRL_LDFQ_LDFQ_13 = 0xd
	// Every 15 PWM opportunities
	PWM_SM0CTRL_LDFQ_LDFQ_14 = 0xe
	// Every 16 PWM opportunities
	PWM_SM0CTRL_LDFQ_LDFQ_15 = 0xf

	// SM0VAL0: Value Register 0
	// Position of VAL0 field.
	PWM_SM0VAL0_VAL0_Pos = 0x0
	// Bit mask of VAL0 field.
	PWM_SM0VAL0_VAL0_Msk = 0xffff

	// SM0FRACVAL1: Fractional Value Register 1
	// Position of FRACVAL1 field.
	PWM_SM0FRACVAL1_FRACVAL1_Pos = 0xb
	// Bit mask of FRACVAL1 field.
	PWM_SM0FRACVAL1_FRACVAL1_Msk = 0xf800

	// SM0VAL1: Value Register 1
	// Position of VAL1 field.
	PWM_SM0VAL1_VAL1_Pos = 0x0
	// Bit mask of VAL1 field.
	PWM_SM0VAL1_VAL1_Msk = 0xffff

	// SM0FRACVAL2: Fractional Value Register 2
	// Position of FRACVAL2 field.
	PWM_SM0FRACVAL2_FRACVAL2_Pos = 0xb
	// Bit mask of FRACVAL2 field.
	PWM_SM0FRACVAL2_FRACVAL2_Msk = 0xf800

	// SM0VAL2: Value Register 2
	// Position of VAL2 field.
	PWM_SM0VAL2_VAL2_Pos = 0x0
	// Bit mask of VAL2 field.
	PWM_SM0VAL2_VAL2_Msk = 0xffff

	// SM0FRACVAL3: Fractional Value Register 3
	// Position of FRACVAL3 field.
	PWM_SM0FRACVAL3_FRACVAL3_Pos = 0xb
	// Bit mask of FRACVAL3 field.
	PWM_SM0FRACVAL3_FRACVAL3_Msk = 0xf800

	// SM0VAL3: Value Register 3
	// Position of VAL3 field.
	PWM_SM0VAL3_VAL3_Pos = 0x0
	// Bit mask of VAL3 field.
	PWM_SM0VAL3_VAL3_Msk = 0xffff

	// SM0FRACVAL4: Fractional Value Register 4
	// Position of FRACVAL4 field.
	PWM_SM0FRACVAL4_FRACVAL4_Pos = 0xb
	// Bit mask of FRACVAL4 field.
	PWM_SM0FRACVAL4_FRACVAL4_Msk = 0xf800

	// SM0VAL4: Value Register 4
	// Position of VAL4 field.
	PWM_SM0VAL4_VAL4_Pos = 0x0
	// Bit mask of VAL4 field.
	PWM_SM0VAL4_VAL4_Msk = 0xffff

	// SM0FRACVAL5: Fractional Value Register 5
	// Position of FRACVAL5 field.
	PWM_SM0FRACVAL5_FRACVAL5_Pos = 0xb
	// Bit mask of FRACVAL5 field.
	PWM_SM0FRACVAL5_FRACVAL5_Msk = 0xf800

	// SM0VAL5: Value Register 5
	// Position of VAL5 field.
	PWM_SM0VAL5_VAL5_Pos = 0x0
	// Bit mask of VAL5 field.
	PWM_SM0VAL5_VAL5_Msk = 0xffff

	// SM0FRCTRL: Fractional Control Register
	// Position of FRAC1_EN field.
	PWM_SM0FRCTRL_FRAC1_EN_Pos = 0x1
	// Bit mask of FRAC1_EN field.
	PWM_SM0FRCTRL_FRAC1_EN_Msk = 0x2
	// Bit FRAC1_EN.
	PWM_SM0FRCTRL_FRAC1_EN = 0x2
	// Disable fractional cycle length for the PWM period.
	PWM_SM0FRCTRL_FRAC1_EN_FRAC1_EN_0 = 0x0
	// Enable fractional cycle length for the PWM period.
	PWM_SM0FRCTRL_FRAC1_EN_FRAC1_EN_1 = 0x1
	// Position of FRAC23_EN field.
	PWM_SM0FRCTRL_FRAC23_EN_Pos = 0x2
	// Bit mask of FRAC23_EN field.
	PWM_SM0FRCTRL_FRAC23_EN_Msk = 0x4
	// Bit FRAC23_EN.
	PWM_SM0FRCTRL_FRAC23_EN = 0x4
	// Disable fractional cycle placement for PWM_A.
	PWM_SM0FRCTRL_FRAC23_EN_FRAC23_EN_0 = 0x0
	// Enable fractional cycle placement for PWM_A.
	PWM_SM0FRCTRL_FRAC23_EN_FRAC23_EN_1 = 0x1
	// Position of FRAC45_EN field.
	PWM_SM0FRCTRL_FRAC45_EN_Pos = 0x4
	// Bit mask of FRAC45_EN field.
	PWM_SM0FRCTRL_FRAC45_EN_Msk = 0x10
	// Bit FRAC45_EN.
	PWM_SM0FRCTRL_FRAC45_EN = 0x10
	// Disable fractional cycle placement for PWM_B.
	PWM_SM0FRCTRL_FRAC45_EN_FRAC45_EN_0 = 0x0
	// Enable fractional cycle placement for PWM_B.
	PWM_SM0FRCTRL_FRAC45_EN_FRAC45_EN_1 = 0x1
	// Position of FRAC_PU field.
	PWM_SM0FRCTRL_FRAC_PU_Pos = 0x8
	// Bit mask of FRAC_PU field.
	PWM_SM0FRCTRL_FRAC_PU_Msk = 0x100
	// Bit FRAC_PU.
	PWM_SM0FRCTRL_FRAC_PU = 0x100
	// Turn off fractional delay logic.
	PWM_SM0FRCTRL_FRAC_PU_FRAC_PU_0 = 0x0
	// Power up fractional delay logic.
	PWM_SM0FRCTRL_FRAC_PU_FRAC_PU_1 = 0x1
	// Position of TEST field.
	PWM_SM0FRCTRL_TEST_Pos = 0xf
	// Bit mask of TEST field.
	PWM_SM0FRCTRL_TEST_Msk = 0x8000
	// Bit TEST.
	PWM_SM0FRCTRL_TEST = 0x8000

	// SM0OCTRL: Output Control Register
	// Position of PWMXFS field.
	PWM_SM0OCTRL_PWMXFS_Pos = 0x0
	// Bit mask of PWMXFS field.
	PWM_SM0OCTRL_PWMXFS_Msk = 0x3
	// Output is forced to logic 0 state prior to consideration of output polarity control.
	PWM_SM0OCTRL_PWMXFS_PWMXFS_0 = 0x0
	// Output is forced to logic 1 state prior to consideration of output polarity control.
	PWM_SM0OCTRL_PWMXFS_PWMXFS_1 = 0x1
	// Output is tristated.
	PWM_SM0OCTRL_PWMXFS_PWMXFS_2 = 0x2
	// Output is tristated.
	PWM_SM0OCTRL_PWMXFS_PWMXFS_3 = 0x3
	// Position of PWMBFS field.
	PWM_SM0OCTRL_PWMBFS_Pos = 0x2
	// Bit mask of PWMBFS field.
	PWM_SM0OCTRL_PWMBFS_Msk = 0xc
	// Output is forced to logic 0 state prior to consideration of output polarity control.
	PWM_SM0OCTRL_PWMBFS_PWMBFS_0 = 0x0
	// Output is forced to logic 1 state prior to consideration of output polarity control.
	PWM_SM0OCTRL_PWMBFS_PWMBFS_1 = 0x1
	// Output is tristated.
	PWM_SM0OCTRL_PWMBFS_PWMBFS_2 = 0x2
	// Output is tristated.
	PWM_SM0OCTRL_PWMBFS_PWMBFS_3 = 0x3
	// Position of PWMAFS field.
	PWM_SM0OCTRL_PWMAFS_Pos = 0x4
	// Bit mask of PWMAFS field.
	PWM_SM0OCTRL_PWMAFS_Msk = 0x30
	// Output is forced to logic 0 state prior to consideration of output polarity control.
	PWM_SM0OCTRL_PWMAFS_PWMAFS_0 = 0x0
	// Output is forced to logic 1 state prior to consideration of output polarity control.
	PWM_SM0OCTRL_PWMAFS_PWMAFS_1 = 0x1
	// Output is tristated.
	PWM_SM0OCTRL_PWMAFS_PWMAFS_2 = 0x2
	// Output is tristated.
	PWM_SM0OCTRL_PWMAFS_PWMAFS_3 = 0x3
	// Position of POLX field.
	PWM_SM0OCTRL_POLX_Pos = 0x8
	// Bit mask of POLX field.
	PWM_SM0OCTRL_POLX_Msk = 0x100
	// Bit POLX.
	PWM_SM0OCTRL_POLX = 0x100
	// PWM_X output not inverted. A high level on the PWM_X pin represents the "on" or "active" state.
	PWM_SM0OCTRL_POLX_POLX_0 = 0x0
	// PWM_X output inverted. A low level on the PWM_X pin represents the "on" or "active" state.
	PWM_SM0OCTRL_POLX_POLX_1 = 0x1
	// Position of POLB field.
	PWM_SM0OCTRL_POLB_Pos = 0x9
	// Bit mask of POLB field.
	PWM_SM0OCTRL_POLB_Msk = 0x200
	// Bit POLB.
	PWM_SM0OCTRL_POLB = 0x200
	// PWM_B output not inverted. A high level on the PWM_B pin represents the "on" or "active" state.
	PWM_SM0OCTRL_POLB_POLB_0 = 0x0
	// PWM_B output inverted. A low level on the PWM_B pin represents the "on" or "active" state.
	PWM_SM0OCTRL_POLB_POLB_1 = 0x1
	// Position of POLA field.
	PWM_SM0OCTRL_POLA_Pos = 0xa
	// Bit mask of POLA field.
	PWM_SM0OCTRL_POLA_Msk = 0x400
	// Bit POLA.
	PWM_SM0OCTRL_POLA = 0x400
	// PWM_A output not inverted. A high level on the PWM_A pin represents the "on" or "active" state.
	PWM_SM0OCTRL_POLA_POLA_0 = 0x0
	// PWM_A output inverted. A low level on the PWM_A pin represents the "on" or "active" state.
	PWM_SM0OCTRL_POLA_POLA_1 = 0x1
	// Position of PWMX_IN field.
	PWM_SM0OCTRL_PWMX_IN_Pos = 0xd
	// Bit mask of PWMX_IN field.
	PWM_SM0OCTRL_PWMX_IN_Msk = 0x2000
	// Bit PWMX_IN.
	PWM_SM0OCTRL_PWMX_IN = 0x2000
	// Position of PWMB_IN field.
	PWM_SM0OCTRL_PWMB_IN_Pos = 0xe
	// Bit mask of PWMB_IN field.
	PWM_SM0OCTRL_PWMB_IN_Msk = 0x4000
	// Bit PWMB_IN.
	PWM_SM0OCTRL_PWMB_IN = 0x4000
	// Position of PWMA_IN field.
	PWM_SM0OCTRL_PWMA_IN_Pos = 0xf
	// Bit mask of PWMA_IN field.
	PWM_SM0OCTRL_PWMA_IN_Msk = 0x8000
	// Bit PWMA_IN.
	PWM_SM0OCTRL_PWMA_IN = 0x8000

	// SM0STS: Status Register
	// Position of CMPF field.
	PWM_SM0STS_CMPF_Pos = 0x0
	// Bit mask of CMPF field.
	PWM_SM0STS_CMPF_Msk = 0x3f
	// No compare event has occurred for a particular VALx value.
	PWM_SM0STS_CMPF_CMPF_0 = 0x0
	// A compare event has occurred for a particular VALx value.
	PWM_SM0STS_CMPF_CMPF_1 = 0x1
	// Position of CFX0 field.
	PWM_SM0STS_CFX0_Pos = 0x6
	// Bit mask of CFX0 field.
	PWM_SM0STS_CFX0_Msk = 0x40
	// Bit CFX0.
	PWM_SM0STS_CFX0 = 0x40
	// Position of CFX1 field.
	PWM_SM0STS_CFX1_Pos = 0x7
	// Bit mask of CFX1 field.
	PWM_SM0STS_CFX1_Msk = 0x80
	// Bit CFX1.
	PWM_SM0STS_CFX1 = 0x80
	// Position of CFB0 field.
	PWM_SM0STS_CFB0_Pos = 0x8
	// Bit mask of CFB0 field.
	PWM_SM0STS_CFB0_Msk = 0x100
	// Bit CFB0.
	PWM_SM0STS_CFB0 = 0x100
	// Position of CFB1 field.
	PWM_SM0STS_CFB1_Pos = 0x9
	// Bit mask of CFB1 field.
	PWM_SM0STS_CFB1_Msk = 0x200
	// Bit CFB1.
	PWM_SM0STS_CFB1 = 0x200
	// Position of CFA0 field.
	PWM_SM0STS_CFA0_Pos = 0xa
	// Bit mask of CFA0 field.
	PWM_SM0STS_CFA0_Msk = 0x400
	// Bit CFA0.
	PWM_SM0STS_CFA0 = 0x400
	// Position of CFA1 field.
	PWM_SM0STS_CFA1_Pos = 0xb
	// Bit mask of CFA1 field.
	PWM_SM0STS_CFA1_Msk = 0x800
	// Bit CFA1.
	PWM_SM0STS_CFA1 = 0x800
	// Position of RF field.
	PWM_SM0STS_RF_Pos = 0xc
	// Bit mask of RF field.
	PWM_SM0STS_RF_Msk = 0x1000
	// Bit RF.
	PWM_SM0STS_RF = 0x1000
	// No new reload cycle since last STS[RF] clearing
	PWM_SM0STS_RF_RF_0 = 0x0
	// New reload cycle since last STS[RF] clearing
	PWM_SM0STS_RF_RF_1 = 0x1
	// Position of REF field.
	PWM_SM0STS_REF_Pos = 0xd
	// Bit mask of REF field.
	PWM_SM0STS_REF_Msk = 0x2000
	// Bit REF.
	PWM_SM0STS_REF = 0x2000
	// No reload error occurred.
	PWM_SM0STS_REF_REF_0 = 0x0
	// Reload signal occurred with non-coherent data and MCTRL[LDOK] = 0.
	PWM_SM0STS_REF_REF_1 = 0x1
	// Position of RUF field.
	PWM_SM0STS_RUF_Pos = 0xe
	// Bit mask of RUF field.
	PWM_SM0STS_RUF_Msk = 0x4000
	// Bit RUF.
	PWM_SM0STS_RUF = 0x4000
	// No register update has occurred since last reload.
	PWM_SM0STS_RUF_RUF_0 = 0x0
	// At least one of the double buffered registers has been updated since the last reload.
	PWM_SM0STS_RUF_RUF_1 = 0x1

	// SM0INTEN: Interrupt Enable Register
	// Position of CMPIE field.
	PWM_SM0INTEN_CMPIE_Pos = 0x0
	// Bit mask of CMPIE field.
	PWM_SM0INTEN_CMPIE_Msk = 0x3f
	// The corresponding STS[CMPF] bit will not cause an interrupt request.
	PWM_SM0INTEN_CMPIE_CMPIE_0 = 0x0
	// The corresponding STS[CMPF] bit will cause an interrupt request.
	PWM_SM0INTEN_CMPIE_CMPIE_1 = 0x1
	// Position of CX0IE field.
	PWM_SM0INTEN_CX0IE_Pos = 0x6
	// Bit mask of CX0IE field.
	PWM_SM0INTEN_CX0IE_Msk = 0x40
	// Bit CX0IE.
	PWM_SM0INTEN_CX0IE = 0x40
	// Interrupt request disabled for STS[CFX0].
	PWM_SM0INTEN_CX0IE_CX0IE_0 = 0x0
	// Interrupt request enabled for STS[CFX0].
	PWM_SM0INTEN_CX0IE_CX0IE_1 = 0x1
	// Position of CX1IE field.
	PWM_SM0INTEN_CX1IE_Pos = 0x7
	// Bit mask of CX1IE field.
	PWM_SM0INTEN_CX1IE_Msk = 0x80
	// Bit CX1IE.
	PWM_SM0INTEN_CX1IE = 0x80
	// Interrupt request disabled for STS[CFX1].
	PWM_SM0INTEN_CX1IE_CX1IE_0 = 0x0
	// Interrupt request enabled for STS[CFX1].
	PWM_SM0INTEN_CX1IE_CX1IE_1 = 0x1
	// Position of CB0IE field.
	PWM_SM0INTEN_CB0IE_Pos = 0x8
	// Bit mask of CB0IE field.
	PWM_SM0INTEN_CB0IE_Msk = 0x100
	// Bit CB0IE.
	PWM_SM0INTEN_CB0IE = 0x100
	// Interrupt request disabled for STS[CFB0].
	PWM_SM0INTEN_CB0IE_CB0IE_0 = 0x0
	// Interrupt request enabled for STS[CFB0].
	PWM_SM0INTEN_CB0IE_CB0IE_1 = 0x1
	// Position of CB1IE field.
	PWM_SM0INTEN_CB1IE_Pos = 0x9
	// Bit mask of CB1IE field.
	PWM_SM0INTEN_CB1IE_Msk = 0x200
	// Bit CB1IE.
	PWM_SM0INTEN_CB1IE = 0x200
	// Interrupt request disabled for STS[CFB1].
	PWM_SM0INTEN_CB1IE_CB1IE_0 = 0x0
	// Interrupt request enabled for STS[CFB1].
	PWM_SM0INTEN_CB1IE_CB1IE_1 = 0x1
	// Position of CA0IE field.
	PWM_SM0INTEN_CA0IE_Pos = 0xa
	// Bit mask of CA0IE field.
	PWM_SM0INTEN_CA0IE_Msk = 0x400
	// Bit CA0IE.
	PWM_SM0INTEN_CA0IE = 0x400
	// Interrupt request disabled for STS[CFA0].
	PWM_SM0INTEN_CA0IE_CA0IE_0 = 0x0
	// Interrupt request enabled for STS[CFA0].
	PWM_SM0INTEN_CA0IE_CA0IE_1 = 0x1
	// Position of CA1IE field.
	PWM_SM0INTEN_CA1IE_Pos = 0xb
	// Bit mask of CA1IE field.
	PWM_SM0INTEN_CA1IE_Msk = 0x800
	// Bit CA1IE.
	PWM_SM0INTEN_CA1IE = 0x800
	// Interrupt request disabled for STS[CFA1].
	PWM_SM0INTEN_CA1IE_CA1IE_0 = 0x0
	// Interrupt request enabled for STS[CFA1].
	PWM_SM0INTEN_CA1IE_CA1IE_1 = 0x1
	// Position of RIE field.
	PWM_SM0INTEN_RIE_Pos = 0xc
	// Bit mask of RIE field.
	PWM_SM0INTEN_RIE_Msk = 0x1000
	// Bit RIE.
	PWM_SM0INTEN_RIE = 0x1000
	// STS[RF] CPU interrupt requests disabled
	PWM_SM0INTEN_RIE_RIE_0 = 0x0
	// STS[RF] CPU interrupt requests enabled
	PWM_SM0INTEN_RIE_RIE_1 = 0x1
	// Position of REIE field.
	PWM_SM0INTEN_REIE_Pos = 0xd
	// Bit mask of REIE field.
	PWM_SM0INTEN_REIE_Msk = 0x2000
	// Bit REIE.
	PWM_SM0INTEN_REIE = 0x2000
	// STS[REF] CPU interrupt requests disabled
	PWM_SM0INTEN_REIE_REIE_0 = 0x0
	// STS[REF] CPU interrupt requests enabled
	PWM_SM0INTEN_REIE_REIE_1 = 0x1

	// SM0DMAEN: DMA Enable Register
	// Position of CX0DE field.
	PWM_SM0DMAEN_CX0DE_Pos = 0x0
	// Bit mask of CX0DE field.
	PWM_SM0DMAEN_CX0DE_Msk = 0x1
	// Bit CX0DE.
	PWM_SM0DMAEN_CX0DE = 0x1
	// Position of CX1DE field.
	PWM_SM0DMAEN_CX1DE_Pos = 0x1
	// Bit mask of CX1DE field.
	PWM_SM0DMAEN_CX1DE_Msk = 0x2
	// Bit CX1DE.
	PWM_SM0DMAEN_CX1DE = 0x2
	// Position of CB0DE field.
	PWM_SM0DMAEN_CB0DE_Pos = 0x2
	// Bit mask of CB0DE field.
	PWM_SM0DMAEN_CB0DE_Msk = 0x4
	// Bit CB0DE.
	PWM_SM0DMAEN_CB0DE = 0x4
	// Position of CB1DE field.
	PWM_SM0DMAEN_CB1DE_Pos = 0x3
	// Bit mask of CB1DE field.
	PWM_SM0DMAEN_CB1DE_Msk = 0x8
	// Bit CB1DE.
	PWM_SM0DMAEN_CB1DE = 0x8
	// Position of CA0DE field.
	PWM_SM0DMAEN_CA0DE_Pos = 0x4
	// Bit mask of CA0DE field.
	PWM_SM0DMAEN_CA0DE_Msk = 0x10
	// Bit CA0DE.
	PWM_SM0DMAEN_CA0DE = 0x10
	// Position of CA1DE field.
	PWM_SM0DMAEN_CA1DE_Pos = 0x5
	// Bit mask of CA1DE field.
	PWM_SM0DMAEN_CA1DE_Msk = 0x20
	// Bit CA1DE.
	PWM_SM0DMAEN_CA1DE = 0x20
	// Position of CAPTDE field.
	PWM_SM0DMAEN_CAPTDE_Pos = 0x6
	// Bit mask of CAPTDE field.
	PWM_SM0DMAEN_CAPTDE_Msk = 0xc0
	// Read DMA requests disabled.
	PWM_SM0DMAEN_CAPTDE_CAPTDE_0 = 0x0
	// Exceeding a FIFO watermark sets the DMA read request. This requires at least one of DMAEN[CA1DE], DMAEN[CA0DE], DMAEN[CB1DE], DMAEN[CB0DE], DMAEN[CX1DE], or DMAEN[CX0DE] to also be set in order to determine to which watermark(s) the DMA request is sensitive.
	PWM_SM0DMAEN_CAPTDE_CAPTDE_1 = 0x1
	// A local sync (VAL1 matches counter) sets the read DMA request.
	PWM_SM0DMAEN_CAPTDE_CAPTDE_2 = 0x2
	// A local reload (STS[RF] being set) sets the read DMA request.
	PWM_SM0DMAEN_CAPTDE_CAPTDE_3 = 0x3
	// Position of FAND field.
	PWM_SM0DMAEN_FAND_Pos = 0x8
	// Bit mask of FAND field.
	PWM_SM0DMAEN_FAND_Msk = 0x100
	// Bit FAND.
	PWM_SM0DMAEN_FAND = 0x100
	// Selected FIFO watermarks are OR'ed together.
	PWM_SM0DMAEN_FAND_FAND_0 = 0x0
	// Selected FIFO watermarks are AND'ed together.
	PWM_SM0DMAEN_FAND_FAND_1 = 0x1
	// Position of VALDE field.
	PWM_SM0DMAEN_VALDE_Pos = 0x9
	// Bit mask of VALDE field.
	PWM_SM0DMAEN_VALDE_Msk = 0x200
	// Bit VALDE.
	PWM_SM0DMAEN_VALDE = 0x200
	// DMA write requests disabled
	PWM_SM0DMAEN_VALDE_VALDE_0 = 0x0
	// DMA write requests for the VALx and FRACVALx registers enabled
	PWM_SM0DMAEN_VALDE_VALDE_1 = 0x1

	// SM0TCTRL: Output Trigger Control Register
	// Position of OUT_TRIG_EN field.
	PWM_SM0TCTRL_OUT_TRIG_EN_Pos = 0x0
	// Bit mask of OUT_TRIG_EN field.
	PWM_SM0TCTRL_OUT_TRIG_EN_Msk = 0x3f
	// PWM_OUT_TRIGx will not set when the counter value matches the VALx value.
	PWM_SM0TCTRL_OUT_TRIG_EN_OUT_TRIG_EN_0 = 0x0
	// PWM_OUT_TRIGx will set when the counter value matches the VALx value.
	PWM_SM0TCTRL_OUT_TRIG_EN_OUT_TRIG_EN_1 = 0x1
	// Position of TRGFRQ field.
	PWM_SM0TCTRL_TRGFRQ_Pos = 0xc
	// Bit mask of TRGFRQ field.
	PWM_SM0TCTRL_TRGFRQ_Msk = 0x1000
	// Bit TRGFRQ.
	PWM_SM0TCTRL_TRGFRQ = 0x1000
	// Trigger outputs are generated during every PWM period even if the PWM is not reloaded every period due to CTRL[LDFQ] being non-zero.
	PWM_SM0TCTRL_TRGFRQ_TRGFRQ_0 = 0x0
	// Trigger outputs are generated only during the final PWM period prior to a reload opportunity when the PWM is not reloaded every period due to CTRL[LDFQ] being non-zero.
	PWM_SM0TCTRL_TRGFRQ_TRGFRQ_1 = 0x1
	// Position of PWBOT1 field.
	PWM_SM0TCTRL_PWBOT1_Pos = 0xe
	// Bit mask of PWBOT1 field.
	PWM_SM0TCTRL_PWBOT1_Msk = 0x4000
	// Bit PWBOT1.
	PWM_SM0TCTRL_PWBOT1 = 0x4000
	// Route the PWM_OUT_TRIG1 signal to PWM_OUT_TRIG1 port.
	PWM_SM0TCTRL_PWBOT1_PWBOT1_0 = 0x0
	// Route the PWMB output to the PWM_OUT_TRIG1 port.
	PWM_SM0TCTRL_PWBOT1_PWBOT1_1 = 0x1
	// Position of PWAOT0 field.
	PWM_SM0TCTRL_PWAOT0_Pos = 0xf
	// Bit mask of PWAOT0 field.
	PWM_SM0TCTRL_PWAOT0_Msk = 0x8000
	// Bit PWAOT0.
	PWM_SM0TCTRL_PWAOT0 = 0x8000
	// Route the PWM_OUT_TRIG0 signal to PWM_OUT_TRIG0 port.
	PWM_SM0TCTRL_PWAOT0_PWAOT0_0 = 0x0
	// Route the PWMA output to the PWM_OUT_TRIG0 port.
	PWM_SM0TCTRL_PWAOT0_PWAOT0_1 = 0x1

	// SM0DISMAP0: Fault Disable Mapping Register 0
	// Position of DIS0A field.
	PWM_SM0DISMAP0_DIS0A_Pos = 0x0
	// Bit mask of DIS0A field.
	PWM_SM0DISMAP0_DIS0A_Msk = 0xf
	// Position of DIS0B field.
	PWM_SM0DISMAP0_DIS0B_Pos = 0x4
	// Bit mask of DIS0B field.
	PWM_SM0DISMAP0_DIS0B_Msk = 0xf0
	// Position of DIS0X field.
	PWM_SM0DISMAP0_DIS0X_Pos = 0x8
	// Bit mask of DIS0X field.
	PWM_SM0DISMAP0_DIS0X_Msk = 0xf00

	// SM0DISMAP1: Fault Disable Mapping Register 1
	// Position of DIS1A field.
	PWM_SM0DISMAP1_DIS1A_Pos = 0x0
	// Bit mask of DIS1A field.
	PWM_SM0DISMAP1_DIS1A_Msk = 0xf
	// Position of DIS1B field.
	PWM_SM0DISMAP1_DIS1B_Pos = 0x4
	// Bit mask of DIS1B field.
	PWM_SM0DISMAP1_DIS1B_Msk = 0xf0
	// Position of DIS1X field.
	PWM_SM0DISMAP1_DIS1X_Pos = 0x8
	// Bit mask of DIS1X field.
	PWM_SM0DISMAP1_DIS1X_Msk = 0xf00

	// SM0DTCNT0: Deadtime Count Register 0
	// Position of DTCNT0 field.
	PWM_SM0DTCNT0_DTCNT0_Pos = 0x0
	// Bit mask of DTCNT0 field.
	PWM_SM0DTCNT0_DTCNT0_Msk = 0xffff

	// SM0DTCNT1: Deadtime Count Register 1
	// Position of DTCNT1 field.
	PWM_SM0DTCNT1_DTCNT1_Pos = 0x0
	// Bit mask of DTCNT1 field.
	PWM_SM0DTCNT1_DTCNT1_Msk = 0xffff

	// SM0CAPTCTRLA: Capture Control A Register
	// Position of ARMA field.
	PWM_SM0CAPTCTRLA_ARMA_Pos = 0x0
	// Bit mask of ARMA field.
	PWM_SM0CAPTCTRLA_ARMA_Msk = 0x1
	// Bit ARMA.
	PWM_SM0CAPTCTRLA_ARMA = 0x1
	// Input capture operation is disabled.
	PWM_SM0CAPTCTRLA_ARMA_ARMA_0 = 0x0
	// Input capture operation as specified by CAPTCTRLA[EDGAx] is enabled.
	PWM_SM0CAPTCTRLA_ARMA_ARMA_1 = 0x1
	// Position of ONESHOTA field.
	PWM_SM0CAPTCTRLA_ONESHOTA_Pos = 0x1
	// Bit mask of ONESHOTA field.
	PWM_SM0CAPTCTRLA_ONESHOTA_Msk = 0x2
	// Bit ONESHOTA.
	PWM_SM0CAPTCTRLA_ONESHOTA = 0x2
	// Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLA[ARMA] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
	PWM_SM0CAPTCTRLA_ONESHOTA_ONESHOTA_0 = 0x0
	// One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLA[ARMA] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and CAPTCTRLA[ARMA] is cleared. No further captures will be performed until CAPTCTRLA[ARMA] is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and CAPTCTRLA[ARMA] is then cleared.
	PWM_SM0CAPTCTRLA_ONESHOTA_ONESHOTA_1 = 0x1
	// Position of EDGA0 field.
	PWM_SM0CAPTCTRLA_EDGA0_Pos = 0x2
	// Bit mask of EDGA0 field.
	PWM_SM0CAPTCTRLA_EDGA0_Msk = 0xc
	// Disabled
	PWM_SM0CAPTCTRLA_EDGA0_EDGA0_0 = 0x0
	// Capture falling edges
	PWM_SM0CAPTCTRLA_EDGA0_EDGA0_1 = 0x1
	// Capture rising edges
	PWM_SM0CAPTCTRLA_EDGA0_EDGA0_2 = 0x2
	// Capture any edge
	PWM_SM0CAPTCTRLA_EDGA0_EDGA0_3 = 0x3
	// Position of EDGA1 field.
	PWM_SM0CAPTCTRLA_EDGA1_Pos = 0x4
	// Bit mask of EDGA1 field.
	PWM_SM0CAPTCTRLA_EDGA1_Msk = 0x30
	// Disabled
	PWM_SM0CAPTCTRLA_EDGA1_EDGA1_0 = 0x0
	// Capture falling edges
	PWM_SM0CAPTCTRLA_EDGA1_EDGA1_1 = 0x1
	// Capture rising edges
	PWM_SM0CAPTCTRLA_EDGA1_EDGA1_2 = 0x2
	// Capture any edge
	PWM_SM0CAPTCTRLA_EDGA1_EDGA1_3 = 0x3
	// Position of INP_SELA field.
	PWM_SM0CAPTCTRLA_INP_SELA_Pos = 0x6
	// Bit mask of INP_SELA field.
	PWM_SM0CAPTCTRLA_INP_SELA_Msk = 0x40
	// Bit INP_SELA.
	PWM_SM0CAPTCTRLA_INP_SELA = 0x40
	// Raw PWM_A input signal selected as source.
	PWM_SM0CAPTCTRLA_INP_SELA_INP_SELA_0 = 0x0
	// Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLA[EDGA0] and CAPTCTRLA[EDGA1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRA[EDGA0] and/or CAPTCTRLA[EDGA1] fields in order to enable one or both of the capture registers.
	PWM_SM0CAPTCTRLA_INP_SELA_INP_SELA_1 = 0x1
	// Position of EDGCNTA_EN field.
	PWM_SM0CAPTCTRLA_EDGCNTA_EN_Pos = 0x7
	// Bit mask of EDGCNTA_EN field.
	PWM_SM0CAPTCTRLA_EDGCNTA_EN_Msk = 0x80
	// Bit EDGCNTA_EN.
	PWM_SM0CAPTCTRLA_EDGCNTA_EN = 0x80
	// Edge counter disabled and held in reset
	PWM_SM0CAPTCTRLA_EDGCNTA_EN_EDGCNTA_EN_0 = 0x0
	// Edge counter enabled
	PWM_SM0CAPTCTRLA_EDGCNTA_EN_EDGCNTA_EN_1 = 0x1
	// Position of CFAWM field.
	PWM_SM0CAPTCTRLA_CFAWM_Pos = 0x8
	// Bit mask of CFAWM field.
	PWM_SM0CAPTCTRLA_CFAWM_Msk = 0x300
	// Position of CA0CNT field.
	PWM_SM0CAPTCTRLA_CA0CNT_Pos = 0xa
	// Bit mask of CA0CNT field.
	PWM_SM0CAPTCTRLA_CA0CNT_Msk = 0x1c00
	// Position of CA1CNT field.
	PWM_SM0CAPTCTRLA_CA1CNT_Pos = 0xd
	// Bit mask of CA1CNT field.
	PWM_SM0CAPTCTRLA_CA1CNT_Msk = 0xe000

	// SM0CAPTCOMPA: Capture Compare A Register
	// Position of EDGCMPA field.
	PWM_SM0CAPTCOMPA_EDGCMPA_Pos = 0x0
	// Bit mask of EDGCMPA field.
	PWM_SM0CAPTCOMPA_EDGCMPA_Msk = 0xff
	// Position of EDGCNTA field.
	PWM_SM0CAPTCOMPA_EDGCNTA_Pos = 0x8
	// Bit mask of EDGCNTA field.
	PWM_SM0CAPTCOMPA_EDGCNTA_Msk = 0xff00

	// SM0CAPTCTRLB: Capture Control B Register
	// Position of ARMB field.
	PWM_SM0CAPTCTRLB_ARMB_Pos = 0x0
	// Bit mask of ARMB field.
	PWM_SM0CAPTCTRLB_ARMB_Msk = 0x1
	// Bit ARMB.
	PWM_SM0CAPTCTRLB_ARMB = 0x1
	// Input capture operation is disabled.
	PWM_SM0CAPTCTRLB_ARMB_ARMB_0 = 0x0
	// Input capture operation as specified by CAPTCTRLB[EDGBx] is enabled.
	PWM_SM0CAPTCTRLB_ARMB_ARMB_1 = 0x1
	// Position of ONESHOTB field.
	PWM_SM0CAPTCTRLB_ONESHOTB_Pos = 0x1
	// Bit mask of ONESHOTB field.
	PWM_SM0CAPTCTRLB_ONESHOTB_Msk = 0x2
	// Bit ONESHOTB.
	PWM_SM0CAPTCTRLB_ONESHOTB = 0x2
	// Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLB[ARMB] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
	PWM_SM0CAPTCTRLB_ONESHOTB_ONESHOTB_0 = 0x0
	// One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLB[ARMB] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and CAPTCTRLB[ARMB] is cleared. No further captures will be performed until CAPTCTRLB[ARMB] is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and CAPTCTRLB[ARMB] is then cleared.
	PWM_SM0CAPTCTRLB_ONESHOTB_ONESHOTB_1 = 0x1
	// Position of EDGB0 field.
	PWM_SM0CAPTCTRLB_EDGB0_Pos = 0x2
	// Bit mask of EDGB0 field.
	PWM_SM0CAPTCTRLB_EDGB0_Msk = 0xc
	// Disabled
	PWM_SM0CAPTCTRLB_EDGB0_EDGB0_0 = 0x0
	// Capture falling edges
	PWM_SM0CAPTCTRLB_EDGB0_EDGB0_1 = 0x1
	// Capture rising edges
	PWM_SM0CAPTCTRLB_EDGB0_EDGB0_2 = 0x2
	// Capture any edge
	PWM_SM0CAPTCTRLB_EDGB0_EDGB0_3 = 0x3
	// Position of EDGB1 field.
	PWM_SM0CAPTCTRLB_EDGB1_Pos = 0x4
	// Bit mask of EDGB1 field.
	PWM_SM0CAPTCTRLB_EDGB1_Msk = 0x30
	// Disabled
	PWM_SM0CAPTCTRLB_EDGB1_EDGB1_0 = 0x0
	// Capture falling edges
	PWM_SM0CAPTCTRLB_EDGB1_EDGB1_1 = 0x1
	// Capture rising edges
	PWM_SM0CAPTCTRLB_EDGB1_EDGB1_2 = 0x2
	// Capture any edge
	PWM_SM0CAPTCTRLB_EDGB1_EDGB1_3 = 0x3
	// Position of INP_SELB field.
	PWM_SM0CAPTCTRLB_INP_SELB_Pos = 0x6
	// Bit mask of INP_SELB field.
	PWM_SM0CAPTCTRLB_INP_SELB_Msk = 0x40
	// Bit INP_SELB.
	PWM_SM0CAPTCTRLB_INP_SELB = 0x40
	// Raw PWM_B input signal selected as source.
	PWM_SM0CAPTCTRLB_INP_SELB_INP_SELB_0 = 0x0
	// Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLB[EDGB0] and CAPTCTRLB[EDGB1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRB[EDGB0] and/or CAPTCTRLB[EDGB1] fields in order to enable one or both of the capture registers.
	PWM_SM0CAPTCTRLB_INP_SELB_INP_SELB_1 = 0x1
	// Position of EDGCNTB_EN field.
	PWM_SM0CAPTCTRLB_EDGCNTB_EN_Pos = 0x7
	// Bit mask of EDGCNTB_EN field.
	PWM_SM0CAPTCTRLB_EDGCNTB_EN_Msk = 0x80
	// Bit EDGCNTB_EN.
	PWM_SM0CAPTCTRLB_EDGCNTB_EN = 0x80
	// Edge counter disabled and held in reset
	PWM_SM0CAPTCTRLB_EDGCNTB_EN_EDGCNTB_EN_0 = 0x0
	// Edge counter enabled
	PWM_SM0CAPTCTRLB_EDGCNTB_EN_EDGCNTB_EN_1 = 0x1
	// Position of CFBWM field.
	PWM_SM0CAPTCTRLB_CFBWM_Pos = 0x8
	// Bit mask of CFBWM field.
	PWM_SM0CAPTCTRLB_CFBWM_Msk = 0x300
	// Position of CB0CNT field.
	PWM_SM0CAPTCTRLB_CB0CNT_Pos = 0xa
	// Bit mask of CB0CNT field.
	PWM_SM0CAPTCTRLB_CB0CNT_Msk = 0x1c00
	// Position of CB1CNT field.
	PWM_SM0CAPTCTRLB_CB1CNT_Pos = 0xd
	// Bit mask of CB1CNT field.
	PWM_SM0CAPTCTRLB_CB1CNT_Msk = 0xe000

	// SM0CAPTCOMPB: Capture Compare B Register
	// Position of EDGCMPB field.
	PWM_SM0CAPTCOMPB_EDGCMPB_Pos = 0x0
	// Bit mask of EDGCMPB field.
	PWM_SM0CAPTCOMPB_EDGCMPB_Msk = 0xff
	// Position of EDGCNTB field.
	PWM_SM0CAPTCOMPB_EDGCNTB_Pos = 0x8
	// Bit mask of EDGCNTB field.
	PWM_SM0CAPTCOMPB_EDGCNTB_Msk = 0xff00

	// SM0CAPTCTRLX: Capture Control X Register
	// Position of ARMX field.
	PWM_SM0CAPTCTRLX_ARMX_Pos = 0x0
	// Bit mask of ARMX field.
	PWM_SM0CAPTCTRLX_ARMX_Msk = 0x1
	// Bit ARMX.
	PWM_SM0CAPTCTRLX_ARMX = 0x1
	// Input capture operation is disabled.
	PWM_SM0CAPTCTRLX_ARMX_ARMX_0 = 0x0
	// Input capture operation as specified by CAPTCTRLX[EDGXx] is enabled.
	PWM_SM0CAPTCTRLX_ARMX_ARMX_1 = 0x1
	// Position of ONESHOTX field.
	PWM_SM0CAPTCTRLX_ONESHOTX_Pos = 0x1
	// Bit mask of ONESHOTX field.
	PWM_SM0CAPTCTRLX_ONESHOTX_Msk = 0x2
	// Bit ONESHOTX.
	PWM_SM0CAPTCTRLX_ONESHOTX = 0x2
	// Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after the ARMX bit is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
	PWM_SM0CAPTCTRLX_ONESHOTX_ONESHOTX_0 = 0x0
	// One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after the ARMX bit is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and the ARMX bit is cleared. No further captures will be performed until the ARMX bit is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and the ARMX bit is then cleared.
	PWM_SM0CAPTCTRLX_ONESHOTX_ONESHOTX_1 = 0x1
	// Position of EDGX0 field.
	PWM_SM0CAPTCTRLX_EDGX0_Pos = 0x2
	// Bit mask of EDGX0 field.
	PWM_SM0CAPTCTRLX_EDGX0_Msk = 0xc
	// Disabled
	PWM_SM0CAPTCTRLX_EDGX0_EDGX0_0 = 0x0
	// Capture falling edges
	PWM_SM0CAPTCTRLX_EDGX0_EDGX0_1 = 0x1
	// Capture rising edges
	PWM_SM0CAPTCTRLX_EDGX0_EDGX0_2 = 0x2
	// Capture any edge
	PWM_SM0CAPTCTRLX_EDGX0_EDGX0_3 = 0x3
	// Position of EDGX1 field.
	PWM_SM0CAPTCTRLX_EDGX1_Pos = 0x4
	// Bit mask of EDGX1 field.
	PWM_SM0CAPTCTRLX_EDGX1_Msk = 0x30
	// Disabled
	PWM_SM0CAPTCTRLX_EDGX1_EDGX1_0 = 0x0
	// Capture falling edges
	PWM_SM0CAPTCTRLX_EDGX1_EDGX1_1 = 0x1
	// Capture rising edges
	PWM_SM0CAPTCTRLX_EDGX1_EDGX1_2 = 0x2
	// Capture any edge
	PWM_SM0CAPTCTRLX_EDGX1_EDGX1_3 = 0x3
	// Position of INP_SELX field.
	PWM_SM0CAPTCTRLX_INP_SELX_Pos = 0x6
	// Bit mask of INP_SELX field.
	PWM_SM0CAPTCTRLX_INP_SELX_Msk = 0x40
	// Bit INP_SELX.
	PWM_SM0CAPTCTRLX_INP_SELX = 0x40
	// Raw PWM_X input signal selected as source.
	PWM_SM0CAPTCTRLX_INP_SELX_INP_SELX_0 = 0x0
	// Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLX[EDGX0] and CAPTCTRLX[EDGX1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRX[EDGX0] and/or CAPTCTRLX[EDGX1] fields in order to enable one or both of the capture registers.
	PWM_SM0CAPTCTRLX_INP_SELX_INP_SELX_1 = 0x1
	// Position of EDGCNTX_EN field.
	PWM_SM0CAPTCTRLX_EDGCNTX_EN_Pos = 0x7
	// Bit mask of EDGCNTX_EN field.
	PWM_SM0CAPTCTRLX_EDGCNTX_EN_Msk = 0x80
	// Bit EDGCNTX_EN.
	PWM_SM0CAPTCTRLX_EDGCNTX_EN = 0x80
	// Edge counter disabled and held in reset
	PWM_SM0CAPTCTRLX_EDGCNTX_EN_EDGCNTX_EN_0 = 0x0
	// Edge counter enabled
	PWM_SM0CAPTCTRLX_EDGCNTX_EN_EDGCNTX_EN_1 = 0x1
	// Position of CFXWM field.
	PWM_SM0CAPTCTRLX_CFXWM_Pos = 0x8
	// Bit mask of CFXWM field.
	PWM_SM0CAPTCTRLX_CFXWM_Msk = 0x300
	// Position of CX0CNT field.
	PWM_SM0CAPTCTRLX_CX0CNT_Pos = 0xa
	// Bit mask of CX0CNT field.
	PWM_SM0CAPTCTRLX_CX0CNT_Msk = 0x1c00
	// Position of CX1CNT field.
	PWM_SM0CAPTCTRLX_CX1CNT_Pos = 0xd
	// Bit mask of CX1CNT field.
	PWM_SM0CAPTCTRLX_CX1CNT_Msk = 0xe000

	// SM0CAPTCOMPX: Capture Compare X Register
	// Position of EDGCMPX field.
	PWM_SM0CAPTCOMPX_EDGCMPX_Pos = 0x0
	// Bit mask of EDGCMPX field.
	PWM_SM0CAPTCOMPX_EDGCMPX_Msk = 0xff
	// Position of EDGCNTX field.
	PWM_SM0CAPTCOMPX_EDGCNTX_Pos = 0x8
	// Bit mask of EDGCNTX field.
	PWM_SM0CAPTCOMPX_EDGCNTX_Msk = 0xff00

	// SM0CVAL0: Capture Value 0 Register
	// Position of CAPTVAL0 field.
	PWM_SM0CVAL0_CAPTVAL0_Pos = 0x0
	// Bit mask of CAPTVAL0 field.
	PWM_SM0CVAL0_CAPTVAL0_Msk = 0xffff

	// SM0CVAL0CYC: Capture Value 0 Cycle Register
	// Position of CVAL0CYC field.
	PWM_SM0CVAL0CYC_CVAL0CYC_Pos = 0x0
	// Bit mask of CVAL0CYC field.
	PWM_SM0CVAL0CYC_CVAL0CYC_Msk = 0xf

	// SM0CVAL1: Capture Value 1 Register
	// Position of CAPTVAL1 field.
	PWM_SM0CVAL1_CAPTVAL1_Pos = 0x0
	// Bit mask of CAPTVAL1 field.
	PWM_SM0CVAL1_CAPTVAL1_Msk = 0xffff

	// SM0CVAL1CYC: Capture Value 1 Cycle Register
	// Position of CVAL1CYC field.
	PWM_SM0CVAL1CYC_CVAL1CYC_Pos = 0x0
	// Bit mask of CVAL1CYC field.
	PWM_SM0CVAL1CYC_CVAL1CYC_Msk = 0xf

	// SM0CVAL2: Capture Value 2 Register
	// Position of CAPTVAL2 field.
	PWM_SM0CVAL2_CAPTVAL2_Pos = 0x0
	// Bit mask of CAPTVAL2 field.
	PWM_SM0CVAL2_CAPTVAL2_Msk = 0xffff

	// SM0CVAL2CYC: Capture Value 2 Cycle Register
	// Position of CVAL2CYC field.
	PWM_SM0CVAL2CYC_CVAL2CYC_Pos = 0x0
	// Bit mask of CVAL2CYC field.
	PWM_SM0CVAL2CYC_CVAL2CYC_Msk = 0xf

	// SM0CVAL3: Capture Value 3 Register
	// Position of CAPTVAL3 field.
	PWM_SM0CVAL3_CAPTVAL3_Pos = 0x0
	// Bit mask of CAPTVAL3 field.
	PWM_SM0CVAL3_CAPTVAL3_Msk = 0xffff

	// SM0CVAL3CYC: Capture Value 3 Cycle Register
	// Position of CVAL3CYC field.
	PWM_SM0CVAL3CYC_CVAL3CYC_Pos = 0x0
	// Bit mask of CVAL3CYC field.
	PWM_SM0CVAL3CYC_CVAL3CYC_Msk = 0xf

	// SM0CVAL4: Capture Value 4 Register
	// Position of CAPTVAL4 field.
	PWM_SM0CVAL4_CAPTVAL4_Pos = 0x0
	// Bit mask of CAPTVAL4 field.
	PWM_SM0CVAL4_CAPTVAL4_Msk = 0xffff

	// SM0CVAL4CYC: Capture Value 4 Cycle Register
	// Position of CVAL4CYC field.
	PWM_SM0CVAL4CYC_CVAL4CYC_Pos = 0x0
	// Bit mask of CVAL4CYC field.
	PWM_SM0CVAL4CYC_CVAL4CYC_Msk = 0xf

	// SM0CVAL5: Capture Value 5 Register
	// Position of CAPTVAL5 field.
	PWM_SM0CVAL5_CAPTVAL5_Pos = 0x0
	// Bit mask of CAPTVAL5 field.
	PWM_SM0CVAL5_CAPTVAL5_Msk = 0xffff

	// SM0CVAL5CYC: Capture Value 5 Cycle Register
	// Position of CVAL5CYC field.
	PWM_SM0CVAL5CYC_CVAL5CYC_Pos = 0x0
	// Bit mask of CVAL5CYC field.
	PWM_SM0CVAL5CYC_CVAL5CYC_Msk = 0xf

	// SM1CNT: Counter Register
	// Position of CNT field.
	PWM_SM1CNT_CNT_Pos = 0x0
	// Bit mask of CNT field.
	PWM_SM1CNT_CNT_Msk = 0xffff

	// SM1INIT: Initial Count Register
	// Position of INIT field.
	PWM_SM1INIT_INIT_Pos = 0x0
	// Bit mask of INIT field.
	PWM_SM1INIT_INIT_Msk = 0xffff

	// SM1CTRL2: Control 2 Register
	// Position of CLK_SEL field.
	PWM_SM1CTRL2_CLK_SEL_Pos = 0x0
	// Bit mask of CLK_SEL field.
	PWM_SM1CTRL2_CLK_SEL_Msk = 0x3
	// The IPBus clock is used as the clock for the local prescaler and counter.
	PWM_SM1CTRL2_CLK_SEL_CLK_SEL_0 = 0x0
	// EXT_CLK is used as the clock for the local prescaler and counter.
	PWM_SM1CTRL2_CLK_SEL_CLK_SEL_1 = 0x1
	// Submodule 0's clock (AUX_CLK) is used as the source clock for the local prescaler and counter. This setting should not be used in submodule 0 as it will force the clock to logic 0.
	PWM_SM1CTRL2_CLK_SEL_CLK_SEL_2 = 0x2
	// Position of RELOAD_SEL field.
	PWM_SM1CTRL2_RELOAD_SEL_Pos = 0x2
	// Bit mask of RELOAD_SEL field.
	PWM_SM1CTRL2_RELOAD_SEL_Msk = 0x4
	// Bit RELOAD_SEL.
	PWM_SM1CTRL2_RELOAD_SEL = 0x4
	// The local RELOAD signal is used to reload registers.
	PWM_SM1CTRL2_RELOAD_SEL_RELOAD_SEL_0 = 0x0
	// The master RELOAD signal (from submodule 0) is used to reload registers. This setting should not be used in submodule 0 as it will force the RELOAD signal to logic 0.
	PWM_SM1CTRL2_RELOAD_SEL_RELOAD_SEL_1 = 0x1
	// Position of FORCE_SEL field.
	PWM_SM1CTRL2_FORCE_SEL_Pos = 0x3
	// Bit mask of FORCE_SEL field.
	PWM_SM1CTRL2_FORCE_SEL_Msk = 0x38
	// The local force signal, CTRL2[FORCE], from this submodule is used to force updates.
	PWM_SM1CTRL2_FORCE_SEL_FORCE_SEL_0 = 0x0
	// The master force signal from submodule 0 is used to force updates. This setting should not be used in submodule 0 as it will hold the FORCE OUTPUT signal to logic 0.
	PWM_SM1CTRL2_FORCE_SEL_FORCE_SEL_1 = 0x1
	// The local reload signal from this submodule is used to force updates without regard to the state of LDOK.
	PWM_SM1CTRL2_FORCE_SEL_FORCE_SEL_2 = 0x2
	// The master reload signal from submodule0 is used to force updates if LDOK is set. This setting should not be used in submodule0 as it will hold the FORCE OUTPUT signal to logic 0.
	PWM_SM1CTRL2_FORCE_SEL_FORCE_SEL_3 = 0x3
	// The local sync signal from this submodule is used to force updates.
	PWM_SM1CTRL2_FORCE_SEL_FORCE_SEL_4 = 0x4
	// The master sync signal from submodule0 is used to force updates. This setting should not be used in submodule0 as it will hold the FORCE OUTPUT signal to logic 0.
	PWM_SM1CTRL2_FORCE_SEL_FORCE_SEL_5 = 0x5
	// The external force signal, EXT_FORCE, from outside the PWM module causes updates.
	PWM_SM1CTRL2_FORCE_SEL_FORCE_SEL_6 = 0x6
	// The external sync signal, EXT_SYNC, from outside the PWM module causes updates.
	PWM_SM1CTRL2_FORCE_SEL_FORCE_SEL_7 = 0x7
	// Position of FORCE field.
	PWM_SM1CTRL2_FORCE_Pos = 0x6
	// Bit mask of FORCE field.
	PWM_SM1CTRL2_FORCE_Msk = 0x40
	// Bit FORCE.
	PWM_SM1CTRL2_FORCE = 0x40
	// Position of FRCEN field.
	PWM_SM1CTRL2_FRCEN_Pos = 0x7
	// Bit mask of FRCEN field.
	PWM_SM1CTRL2_FRCEN_Msk = 0x80
	// Bit FRCEN.
	PWM_SM1CTRL2_FRCEN = 0x80
	// Initialization from a FORCE_OUT is disabled.
	PWM_SM1CTRL2_FRCEN_FRCEN_0 = 0x0
	// Initialization from a FORCE_OUT is enabled.
	PWM_SM1CTRL2_FRCEN_FRCEN_1 = 0x1
	// Position of INIT_SEL field.
	PWM_SM1CTRL2_INIT_SEL_Pos = 0x8
	// Bit mask of INIT_SEL field.
	PWM_SM1CTRL2_INIT_SEL_Msk = 0x300
	// Local sync (PWM_X) causes initialization.
	PWM_SM1CTRL2_INIT_SEL_INIT_SEL_0 = 0x0
	// Master reload from submodule 0 causes initialization. This setting should not be used in submodule 0 as it will force the INIT signal to logic 0. The submodule counter will only reinitialize when a master reload occurs.
	PWM_SM1CTRL2_INIT_SEL_INIT_SEL_1 = 0x1
	// Master sync from submodule 0 causes initialization. This setting should not be used in submodule 0 as it will force the INIT signal to logic 0.
	PWM_SM1CTRL2_INIT_SEL_INIT_SEL_2 = 0x2
	// EXT_SYNC causes initialization.
	PWM_SM1CTRL2_INIT_SEL_INIT_SEL_3 = 0x3
	// Position of PWMX_INIT field.
	PWM_SM1CTRL2_PWMX_INIT_Pos = 0xa
	// Bit mask of PWMX_INIT field.
	PWM_SM1CTRL2_PWMX_INIT_Msk = 0x400
	// Bit PWMX_INIT.
	PWM_SM1CTRL2_PWMX_INIT = 0x400
	// Position of PWM45_INIT field.
	PWM_SM1CTRL2_PWM45_INIT_Pos = 0xb
	// Bit mask of PWM45_INIT field.
	PWM_SM1CTRL2_PWM45_INIT_Msk = 0x800
	// Bit PWM45_INIT.
	PWM_SM1CTRL2_PWM45_INIT = 0x800
	// Position of PWM23_INIT field.
	PWM_SM1CTRL2_PWM23_INIT_Pos = 0xc
	// Bit mask of PWM23_INIT field.
	PWM_SM1CTRL2_PWM23_INIT_Msk = 0x1000
	// Bit PWM23_INIT.
	PWM_SM1CTRL2_PWM23_INIT = 0x1000
	// Position of INDEP field.
	PWM_SM1CTRL2_INDEP_Pos = 0xd
	// Bit mask of INDEP field.
	PWM_SM1CTRL2_INDEP_Msk = 0x2000
	// Bit INDEP.
	PWM_SM1CTRL2_INDEP = 0x2000
	// PWM_A and PWM_B form a complementary PWM pair.
	PWM_SM1CTRL2_INDEP_INDEP_0 = 0x0
	// PWM_A and PWM_B outputs are independent PWMs.
	PWM_SM1CTRL2_INDEP_INDEP_1 = 0x1
	// Position of WAITEN field.
	PWM_SM1CTRL2_WAITEN_Pos = 0xe
	// Bit mask of WAITEN field.
	PWM_SM1CTRL2_WAITEN_Msk = 0x4000
	// Bit WAITEN.
	PWM_SM1CTRL2_WAITEN = 0x4000
	// Position of DBGEN field.
	PWM_SM1CTRL2_DBGEN_Pos = 0xf
	// Bit mask of DBGEN field.
	PWM_SM1CTRL2_DBGEN_Msk = 0x8000
	// Bit DBGEN.
	PWM_SM1CTRL2_DBGEN = 0x8000

	// SM1CTRL: Control Register
	// Position of DBLEN field.
	PWM_SM1CTRL_DBLEN_Pos = 0x0
	// Bit mask of DBLEN field.
	PWM_SM1CTRL_DBLEN_Msk = 0x1
	// Bit DBLEN.
	PWM_SM1CTRL_DBLEN = 0x1
	// Double switching disabled.
	PWM_SM1CTRL_DBLEN_DBLEN_0 = 0x0
	// Double switching enabled.
	PWM_SM1CTRL_DBLEN_DBLEN_1 = 0x1
	// Position of DBLX field.
	PWM_SM1CTRL_DBLX_Pos = 0x1
	// Bit mask of DBLX field.
	PWM_SM1CTRL_DBLX_Msk = 0x2
	// Bit DBLX.
	PWM_SM1CTRL_DBLX = 0x2
	// PWMX double pulse disabled.
	PWM_SM1CTRL_DBLX_DBLX_0 = 0x0
	// PWMX double pulse enabled.
	PWM_SM1CTRL_DBLX_DBLX_1 = 0x1
	// Position of LDMOD field.
	PWM_SM1CTRL_LDMOD_Pos = 0x2
	// Bit mask of LDMOD field.
	PWM_SM1CTRL_LDMOD_Msk = 0x4
	// Bit LDMOD.
	PWM_SM1CTRL_LDMOD = 0x4
	// Buffered registers of this submodule are loaded and take effect at the next PWM reload if MCTRL[LDOK] is set.
	PWM_SM1CTRL_LDMOD_LDMOD_0 = 0x0
	// Buffered registers of this submodule are loaded and take effect immediately upon MCTRL[LDOK] being set. In this case it is not necessary to set CTRL[FULL] or CTRL[HALF].
	PWM_SM1CTRL_LDMOD_LDMOD_1 = 0x1
	// Position of SPLIT field.
	PWM_SM1CTRL_SPLIT_Pos = 0x3
	// Bit mask of SPLIT field.
	PWM_SM1CTRL_SPLIT_Msk = 0x8
	// Bit SPLIT.
	PWM_SM1CTRL_SPLIT = 0x8
	// DBLPWM is not split. PWMA and PWMB each have double pulses.
	PWM_SM1CTRL_SPLIT_SPLIT_0 = 0x0
	// DBLPWM is split to PWMA and PWMB.
	PWM_SM1CTRL_SPLIT_SPLIT_1 = 0x1
	// Position of PRSC field.
	PWM_SM1CTRL_PRSC_Pos = 0x4
	// Bit mask of PRSC field.
	PWM_SM1CTRL_PRSC_Msk = 0x70
	// PWM clock frequency = fclk
	PWM_SM1CTRL_PRSC_PRSC_0 = 0x0
	// PWM clock frequency = fclk/2
	PWM_SM1CTRL_PRSC_PRSC_1 = 0x1
	// PWM clock frequency = fclk/4
	PWM_SM1CTRL_PRSC_PRSC_2 = 0x2
	// PWM clock frequency = fclk/8
	PWM_SM1CTRL_PRSC_PRSC_3 = 0x3
	// PWM clock frequency = fclk/16
	PWM_SM1CTRL_PRSC_PRSC_4 = 0x4
	// PWM clock frequency = fclk/32
	PWM_SM1CTRL_PRSC_PRSC_5 = 0x5
	// PWM clock frequency = fclk/64
	PWM_SM1CTRL_PRSC_PRSC_6 = 0x6
	// PWM clock frequency = fclk/128
	PWM_SM1CTRL_PRSC_PRSC_7 = 0x7
	// Position of COMPMODE field.
	PWM_SM1CTRL_COMPMODE_Pos = 0x7
	// Bit mask of COMPMODE field.
	PWM_SM1CTRL_COMPMODE_Msk = 0x80
	// Bit COMPMODE.
	PWM_SM1CTRL_COMPMODE = 0x80
	// The VAL* registers and the PWM counter are compared using an "equal to" method. This means that PWM edges are only produced when the counter is equal to one of the VAL* register values. This implies that a PWMA output that is high at the end of a period will maintain this state until a match with VAL3 clears the output in the following period.
	PWM_SM1CTRL_COMPMODE_COMPMODE_0 = 0x0
	// The VAL* registers and the PWM counter are compared using an "equal to or greater than" method. This means that PWM edges are produced when the counter is equal to or greater than one of the VAL* register values. This implies that a PWMA output that is high at the end of a period could go low at the start of the next period if the starting counter value is greater than (but not necessarily equal to) the new VAL3 value.
	PWM_SM1CTRL_COMPMODE_COMPMODE_1 = 0x1
	// Position of DT field.
	PWM_SM1CTRL_DT_Pos = 0x8
	// Bit mask of DT field.
	PWM_SM1CTRL_DT_Msk = 0x300
	// Position of FULL field.
	PWM_SM1CTRL_FULL_Pos = 0xa
	// Bit mask of FULL field.
	PWM_SM1CTRL_FULL_Msk = 0x400
	// Bit FULL.
	PWM_SM1CTRL_FULL = 0x400
	// Full-cycle reloads disabled.
	PWM_SM1CTRL_FULL_FULL_0 = 0x0
	// Full-cycle reloads enabled.
	PWM_SM1CTRL_FULL_FULL_1 = 0x1
	// Position of HALF field.
	PWM_SM1CTRL_HALF_Pos = 0xb
	// Bit mask of HALF field.
	PWM_SM1CTRL_HALF_Msk = 0x800
	// Bit HALF.
	PWM_SM1CTRL_HALF = 0x800
	// Half-cycle reloads disabled.
	PWM_SM1CTRL_HALF_HALF_0 = 0x0
	// Half-cycle reloads enabled.
	PWM_SM1CTRL_HALF_HALF_1 = 0x1
	// Position of LDFQ field.
	PWM_SM1CTRL_LDFQ_Pos = 0xc
	// Bit mask of LDFQ field.
	PWM_SM1CTRL_LDFQ_Msk = 0xf000
	// Every PWM opportunity
	PWM_SM1CTRL_LDFQ_LDFQ_0 = 0x0
	// Every 2 PWM opportunities
	PWM_SM1CTRL_LDFQ_LDFQ_1 = 0x1
	// Every 3 PWM opportunities
	PWM_SM1CTRL_LDFQ_LDFQ_2 = 0x2
	// Every 4 PWM opportunities
	PWM_SM1CTRL_LDFQ_LDFQ_3 = 0x3
	// Every 5 PWM opportunities
	PWM_SM1CTRL_LDFQ_LDFQ_4 = 0x4
	// Every 6 PWM opportunities
	PWM_SM1CTRL_LDFQ_LDFQ_5 = 0x5
	// Every 7 PWM opportunities
	PWM_SM1CTRL_LDFQ_LDFQ_6 = 0x6
	// Every 8 PWM opportunities
	PWM_SM1CTRL_LDFQ_LDFQ_7 = 0x7
	// Every 9 PWM opportunities
	PWM_SM1CTRL_LDFQ_LDFQ_8 = 0x8
	// Every 10 PWM opportunities
	PWM_SM1CTRL_LDFQ_LDFQ_9 = 0x9
	// Every 11 PWM opportunities
	PWM_SM1CTRL_LDFQ_LDFQ_10 = 0xa
	// Every 12 PWM opportunities
	PWM_SM1CTRL_LDFQ_LDFQ_11 = 0xb
	// Every 13 PWM opportunities
	PWM_SM1CTRL_LDFQ_LDFQ_12 = 0xc
	// Every 14 PWM opportunities
	PWM_SM1CTRL_LDFQ_LDFQ_13 = 0xd
	// Every 15 PWM opportunities
	PWM_SM1CTRL_LDFQ_LDFQ_14 = 0xe
	// Every 16 PWM opportunities
	PWM_SM1CTRL_LDFQ_LDFQ_15 = 0xf

	// SM1VAL0: Value Register 0
	// Position of VAL0 field.
	PWM_SM1VAL0_VAL0_Pos = 0x0
	// Bit mask of VAL0 field.
	PWM_SM1VAL0_VAL0_Msk = 0xffff

	// SM1FRACVAL1: Fractional Value Register 1
	// Position of FRACVAL1 field.
	PWM_SM1FRACVAL1_FRACVAL1_Pos = 0xb
	// Bit mask of FRACVAL1 field.
	PWM_SM1FRACVAL1_FRACVAL1_Msk = 0xf800

	// SM1VAL1: Value Register 1
	// Position of VAL1 field.
	PWM_SM1VAL1_VAL1_Pos = 0x0
	// Bit mask of VAL1 field.
	PWM_SM1VAL1_VAL1_Msk = 0xffff

	// SM1FRACVAL2: Fractional Value Register 2
	// Position of FRACVAL2 field.
	PWM_SM1FRACVAL2_FRACVAL2_Pos = 0xb
	// Bit mask of FRACVAL2 field.
	PWM_SM1FRACVAL2_FRACVAL2_Msk = 0xf800

	// SM1VAL2: Value Register 2
	// Position of VAL2 field.
	PWM_SM1VAL2_VAL2_Pos = 0x0
	// Bit mask of VAL2 field.
	PWM_SM1VAL2_VAL2_Msk = 0xffff

	// SM1FRACVAL3: Fractional Value Register 3
	// Position of FRACVAL3 field.
	PWM_SM1FRACVAL3_FRACVAL3_Pos = 0xb
	// Bit mask of FRACVAL3 field.
	PWM_SM1FRACVAL3_FRACVAL3_Msk = 0xf800

	// SM1VAL3: Value Register 3
	// Position of VAL3 field.
	PWM_SM1VAL3_VAL3_Pos = 0x0
	// Bit mask of VAL3 field.
	PWM_SM1VAL3_VAL3_Msk = 0xffff

	// SM1FRACVAL4: Fractional Value Register 4
	// Position of FRACVAL4 field.
	PWM_SM1FRACVAL4_FRACVAL4_Pos = 0xb
	// Bit mask of FRACVAL4 field.
	PWM_SM1FRACVAL4_FRACVAL4_Msk = 0xf800

	// SM1VAL4: Value Register 4
	// Position of VAL4 field.
	PWM_SM1VAL4_VAL4_Pos = 0x0
	// Bit mask of VAL4 field.
	PWM_SM1VAL4_VAL4_Msk = 0xffff

	// SM1FRACVAL5: Fractional Value Register 5
	// Position of FRACVAL5 field.
	PWM_SM1FRACVAL5_FRACVAL5_Pos = 0xb
	// Bit mask of FRACVAL5 field.
	PWM_SM1FRACVAL5_FRACVAL5_Msk = 0xf800

	// SM1VAL5: Value Register 5
	// Position of VAL5 field.
	PWM_SM1VAL5_VAL5_Pos = 0x0
	// Bit mask of VAL5 field.
	PWM_SM1VAL5_VAL5_Msk = 0xffff

	// SM1FRCTRL: Fractional Control Register
	// Position of FRAC1_EN field.
	PWM_SM1FRCTRL_FRAC1_EN_Pos = 0x1
	// Bit mask of FRAC1_EN field.
	PWM_SM1FRCTRL_FRAC1_EN_Msk = 0x2
	// Bit FRAC1_EN.
	PWM_SM1FRCTRL_FRAC1_EN = 0x2
	// Disable fractional cycle length for the PWM period.
	PWM_SM1FRCTRL_FRAC1_EN_FRAC1_EN_0 = 0x0
	// Enable fractional cycle length for the PWM period.
	PWM_SM1FRCTRL_FRAC1_EN_FRAC1_EN_1 = 0x1
	// Position of FRAC23_EN field.
	PWM_SM1FRCTRL_FRAC23_EN_Pos = 0x2
	// Bit mask of FRAC23_EN field.
	PWM_SM1FRCTRL_FRAC23_EN_Msk = 0x4
	// Bit FRAC23_EN.
	PWM_SM1FRCTRL_FRAC23_EN = 0x4
	// Disable fractional cycle placement for PWM_A.
	PWM_SM1FRCTRL_FRAC23_EN_FRAC23_EN_0 = 0x0
	// Enable fractional cycle placement for PWM_A.
	PWM_SM1FRCTRL_FRAC23_EN_FRAC23_EN_1 = 0x1
	// Position of FRAC45_EN field.
	PWM_SM1FRCTRL_FRAC45_EN_Pos = 0x4
	// Bit mask of FRAC45_EN field.
	PWM_SM1FRCTRL_FRAC45_EN_Msk = 0x10
	// Bit FRAC45_EN.
	PWM_SM1FRCTRL_FRAC45_EN = 0x10
	// Disable fractional cycle placement for PWM_B.
	PWM_SM1FRCTRL_FRAC45_EN_FRAC45_EN_0 = 0x0
	// Enable fractional cycle placement for PWM_B.
	PWM_SM1FRCTRL_FRAC45_EN_FRAC45_EN_1 = 0x1
	// Position of FRAC_PU field.
	PWM_SM1FRCTRL_FRAC_PU_Pos = 0x8
	// Bit mask of FRAC_PU field.
	PWM_SM1FRCTRL_FRAC_PU_Msk = 0x100
	// Bit FRAC_PU.
	PWM_SM1FRCTRL_FRAC_PU = 0x100
	// Turn off fractional delay logic.
	PWM_SM1FRCTRL_FRAC_PU_FRAC_PU_0 = 0x0
	// Power up fractional delay logic.
	PWM_SM1FRCTRL_FRAC_PU_FRAC_PU_1 = 0x1
	// Position of TEST field.
	PWM_SM1FRCTRL_TEST_Pos = 0xf
	// Bit mask of TEST field.
	PWM_SM1FRCTRL_TEST_Msk = 0x8000
	// Bit TEST.
	PWM_SM1FRCTRL_TEST = 0x8000

	// SM1OCTRL: Output Control Register
	// Position of PWMXFS field.
	PWM_SM1OCTRL_PWMXFS_Pos = 0x0
	// Bit mask of PWMXFS field.
	PWM_SM1OCTRL_PWMXFS_Msk = 0x3
	// Output is forced to logic 0 state prior to consideration of output polarity control.
	PWM_SM1OCTRL_PWMXFS_PWMXFS_0 = 0x0
	// Output is forced to logic 1 state prior to consideration of output polarity control.
	PWM_SM1OCTRL_PWMXFS_PWMXFS_1 = 0x1
	// Output is tristated.
	PWM_SM1OCTRL_PWMXFS_PWMXFS_2 = 0x2
	// Output is tristated.
	PWM_SM1OCTRL_PWMXFS_PWMXFS_3 = 0x3
	// Position of PWMBFS field.
	PWM_SM1OCTRL_PWMBFS_Pos = 0x2
	// Bit mask of PWMBFS field.
	PWM_SM1OCTRL_PWMBFS_Msk = 0xc
	// Output is forced to logic 0 state prior to consideration of output polarity control.
	PWM_SM1OCTRL_PWMBFS_PWMBFS_0 = 0x0
	// Output is forced to logic 1 state prior to consideration of output polarity control.
	PWM_SM1OCTRL_PWMBFS_PWMBFS_1 = 0x1
	// Output is tristated.
	PWM_SM1OCTRL_PWMBFS_PWMBFS_2 = 0x2
	// Output is tristated.
	PWM_SM1OCTRL_PWMBFS_PWMBFS_3 = 0x3
	// Position of PWMAFS field.
	PWM_SM1OCTRL_PWMAFS_Pos = 0x4
	// Bit mask of PWMAFS field.
	PWM_SM1OCTRL_PWMAFS_Msk = 0x30
	// Output is forced to logic 0 state prior to consideration of output polarity control.
	PWM_SM1OCTRL_PWMAFS_PWMAFS_0 = 0x0
	// Output is forced to logic 1 state prior to consideration of output polarity control.
	PWM_SM1OCTRL_PWMAFS_PWMAFS_1 = 0x1
	// Output is tristated.
	PWM_SM1OCTRL_PWMAFS_PWMAFS_2 = 0x2
	// Output is tristated.
	PWM_SM1OCTRL_PWMAFS_PWMAFS_3 = 0x3
	// Position of POLX field.
	PWM_SM1OCTRL_POLX_Pos = 0x8
	// Bit mask of POLX field.
	PWM_SM1OCTRL_POLX_Msk = 0x100
	// Bit POLX.
	PWM_SM1OCTRL_POLX = 0x100
	// PWM_X output not inverted. A high level on the PWM_X pin represents the "on" or "active" state.
	PWM_SM1OCTRL_POLX_POLX_0 = 0x0
	// PWM_X output inverted. A low level on the PWM_X pin represents the "on" or "active" state.
	PWM_SM1OCTRL_POLX_POLX_1 = 0x1
	// Position of POLB field.
	PWM_SM1OCTRL_POLB_Pos = 0x9
	// Bit mask of POLB field.
	PWM_SM1OCTRL_POLB_Msk = 0x200
	// Bit POLB.
	PWM_SM1OCTRL_POLB = 0x200
	// PWM_B output not inverted. A high level on the PWM_B pin represents the "on" or "active" state.
	PWM_SM1OCTRL_POLB_POLB_0 = 0x0
	// PWM_B output inverted. A low level on the PWM_B pin represents the "on" or "active" state.
	PWM_SM1OCTRL_POLB_POLB_1 = 0x1
	// Position of POLA field.
	PWM_SM1OCTRL_POLA_Pos = 0xa
	// Bit mask of POLA field.
	PWM_SM1OCTRL_POLA_Msk = 0x400
	// Bit POLA.
	PWM_SM1OCTRL_POLA = 0x400
	// PWM_A output not inverted. A high level on the PWM_A pin represents the "on" or "active" state.
	PWM_SM1OCTRL_POLA_POLA_0 = 0x0
	// PWM_A output inverted. A low level on the PWM_A pin represents the "on" or "active" state.
	PWM_SM1OCTRL_POLA_POLA_1 = 0x1
	// Position of PWMX_IN field.
	PWM_SM1OCTRL_PWMX_IN_Pos = 0xd
	// Bit mask of PWMX_IN field.
	PWM_SM1OCTRL_PWMX_IN_Msk = 0x2000
	// Bit PWMX_IN.
	PWM_SM1OCTRL_PWMX_IN = 0x2000
	// Position of PWMB_IN field.
	PWM_SM1OCTRL_PWMB_IN_Pos = 0xe
	// Bit mask of PWMB_IN field.
	PWM_SM1OCTRL_PWMB_IN_Msk = 0x4000
	// Bit PWMB_IN.
	PWM_SM1OCTRL_PWMB_IN = 0x4000
	// Position of PWMA_IN field.
	PWM_SM1OCTRL_PWMA_IN_Pos = 0xf
	// Bit mask of PWMA_IN field.
	PWM_SM1OCTRL_PWMA_IN_Msk = 0x8000
	// Bit PWMA_IN.
	PWM_SM1OCTRL_PWMA_IN = 0x8000

	// SM1STS: Status Register
	// Position of CMPF field.
	PWM_SM1STS_CMPF_Pos = 0x0
	// Bit mask of CMPF field.
	PWM_SM1STS_CMPF_Msk = 0x3f
	// No compare event has occurred for a particular VALx value.
	PWM_SM1STS_CMPF_CMPF_0 = 0x0
	// A compare event has occurred for a particular VALx value.
	PWM_SM1STS_CMPF_CMPF_1 = 0x1
	// Position of CFX0 field.
	PWM_SM1STS_CFX0_Pos = 0x6
	// Bit mask of CFX0 field.
	PWM_SM1STS_CFX0_Msk = 0x40
	// Bit CFX0.
	PWM_SM1STS_CFX0 = 0x40
	// Position of CFX1 field.
	PWM_SM1STS_CFX1_Pos = 0x7
	// Bit mask of CFX1 field.
	PWM_SM1STS_CFX1_Msk = 0x80
	// Bit CFX1.
	PWM_SM1STS_CFX1 = 0x80
	// Position of CFB0 field.
	PWM_SM1STS_CFB0_Pos = 0x8
	// Bit mask of CFB0 field.
	PWM_SM1STS_CFB0_Msk = 0x100
	// Bit CFB0.
	PWM_SM1STS_CFB0 = 0x100
	// Position of CFB1 field.
	PWM_SM1STS_CFB1_Pos = 0x9
	// Bit mask of CFB1 field.
	PWM_SM1STS_CFB1_Msk = 0x200
	// Bit CFB1.
	PWM_SM1STS_CFB1 = 0x200
	// Position of CFA0 field.
	PWM_SM1STS_CFA0_Pos = 0xa
	// Bit mask of CFA0 field.
	PWM_SM1STS_CFA0_Msk = 0x400
	// Bit CFA0.
	PWM_SM1STS_CFA0 = 0x400
	// Position of CFA1 field.
	PWM_SM1STS_CFA1_Pos = 0xb
	// Bit mask of CFA1 field.
	PWM_SM1STS_CFA1_Msk = 0x800
	// Bit CFA1.
	PWM_SM1STS_CFA1 = 0x800
	// Position of RF field.
	PWM_SM1STS_RF_Pos = 0xc
	// Bit mask of RF field.
	PWM_SM1STS_RF_Msk = 0x1000
	// Bit RF.
	PWM_SM1STS_RF = 0x1000
	// No new reload cycle since last STS[RF] clearing
	PWM_SM1STS_RF_RF_0 = 0x0
	// New reload cycle since last STS[RF] clearing
	PWM_SM1STS_RF_RF_1 = 0x1
	// Position of REF field.
	PWM_SM1STS_REF_Pos = 0xd
	// Bit mask of REF field.
	PWM_SM1STS_REF_Msk = 0x2000
	// Bit REF.
	PWM_SM1STS_REF = 0x2000
	// No reload error occurred.
	PWM_SM1STS_REF_REF_0 = 0x0
	// Reload signal occurred with non-coherent data and MCTRL[LDOK] = 0.
	PWM_SM1STS_REF_REF_1 = 0x1
	// Position of RUF field.
	PWM_SM1STS_RUF_Pos = 0xe
	// Bit mask of RUF field.
	PWM_SM1STS_RUF_Msk = 0x4000
	// Bit RUF.
	PWM_SM1STS_RUF = 0x4000
	// No register update has occurred since last reload.
	PWM_SM1STS_RUF_RUF_0 = 0x0
	// At least one of the double buffered registers has been updated since the last reload.
	PWM_SM1STS_RUF_RUF_1 = 0x1

	// SM1INTEN: Interrupt Enable Register
	// Position of CMPIE field.
	PWM_SM1INTEN_CMPIE_Pos = 0x0
	// Bit mask of CMPIE field.
	PWM_SM1INTEN_CMPIE_Msk = 0x3f
	// The corresponding STS[CMPF] bit will not cause an interrupt request.
	PWM_SM1INTEN_CMPIE_CMPIE_0 = 0x0
	// The corresponding STS[CMPF] bit will cause an interrupt request.
	PWM_SM1INTEN_CMPIE_CMPIE_1 = 0x1
	// Position of CX0IE field.
	PWM_SM1INTEN_CX0IE_Pos = 0x6
	// Bit mask of CX0IE field.
	PWM_SM1INTEN_CX0IE_Msk = 0x40
	// Bit CX0IE.
	PWM_SM1INTEN_CX0IE = 0x40
	// Interrupt request disabled for STS[CFX0].
	PWM_SM1INTEN_CX0IE_CX0IE_0 = 0x0
	// Interrupt request enabled for STS[CFX0].
	PWM_SM1INTEN_CX0IE_CX0IE_1 = 0x1
	// Position of CX1IE field.
	PWM_SM1INTEN_CX1IE_Pos = 0x7
	// Bit mask of CX1IE field.
	PWM_SM1INTEN_CX1IE_Msk = 0x80
	// Bit CX1IE.
	PWM_SM1INTEN_CX1IE = 0x80
	// Interrupt request disabled for STS[CFX1].
	PWM_SM1INTEN_CX1IE_CX1IE_0 = 0x0
	// Interrupt request enabled for STS[CFX1].
	PWM_SM1INTEN_CX1IE_CX1IE_1 = 0x1
	// Position of CB0IE field.
	PWM_SM1INTEN_CB0IE_Pos = 0x8
	// Bit mask of CB0IE field.
	PWM_SM1INTEN_CB0IE_Msk = 0x100
	// Bit CB0IE.
	PWM_SM1INTEN_CB0IE = 0x100
	// Interrupt request disabled for STS[CFB0].
	PWM_SM1INTEN_CB0IE_CB0IE_0 = 0x0
	// Interrupt request enabled for STS[CFB0].
	PWM_SM1INTEN_CB0IE_CB0IE_1 = 0x1
	// Position of CB1IE field.
	PWM_SM1INTEN_CB1IE_Pos = 0x9
	// Bit mask of CB1IE field.
	PWM_SM1INTEN_CB1IE_Msk = 0x200
	// Bit CB1IE.
	PWM_SM1INTEN_CB1IE = 0x200
	// Interrupt request disabled for STS[CFB1].
	PWM_SM1INTEN_CB1IE_CB1IE_0 = 0x0
	// Interrupt request enabled for STS[CFB1].
	PWM_SM1INTEN_CB1IE_CB1IE_1 = 0x1
	// Position of CA0IE field.
	PWM_SM1INTEN_CA0IE_Pos = 0xa
	// Bit mask of CA0IE field.
	PWM_SM1INTEN_CA0IE_Msk = 0x400
	// Bit CA0IE.
	PWM_SM1INTEN_CA0IE = 0x400
	// Interrupt request disabled for STS[CFA0].
	PWM_SM1INTEN_CA0IE_CA0IE_0 = 0x0
	// Interrupt request enabled for STS[CFA0].
	PWM_SM1INTEN_CA0IE_CA0IE_1 = 0x1
	// Position of CA1IE field.
	PWM_SM1INTEN_CA1IE_Pos = 0xb
	// Bit mask of CA1IE field.
	PWM_SM1INTEN_CA1IE_Msk = 0x800
	// Bit CA1IE.
	PWM_SM1INTEN_CA1IE = 0x800
	// Interrupt request disabled for STS[CFA1].
	PWM_SM1INTEN_CA1IE_CA1IE_0 = 0x0
	// Interrupt request enabled for STS[CFA1].
	PWM_SM1INTEN_CA1IE_CA1IE_1 = 0x1
	// Position of RIE field.
	PWM_SM1INTEN_RIE_Pos = 0xc
	// Bit mask of RIE field.
	PWM_SM1INTEN_RIE_Msk = 0x1000
	// Bit RIE.
	PWM_SM1INTEN_RIE = 0x1000
	// STS[RF] CPU interrupt requests disabled
	PWM_SM1INTEN_RIE_RIE_0 = 0x0
	// STS[RF] CPU interrupt requests enabled
	PWM_SM1INTEN_RIE_RIE_1 = 0x1
	// Position of REIE field.
	PWM_SM1INTEN_REIE_Pos = 0xd
	// Bit mask of REIE field.
	PWM_SM1INTEN_REIE_Msk = 0x2000
	// Bit REIE.
	PWM_SM1INTEN_REIE = 0x2000
	// STS[REF] CPU interrupt requests disabled
	PWM_SM1INTEN_REIE_REIE_0 = 0x0
	// STS[REF] CPU interrupt requests enabled
	PWM_SM1INTEN_REIE_REIE_1 = 0x1

	// SM1DMAEN: DMA Enable Register
	// Position of CX0DE field.
	PWM_SM1DMAEN_CX0DE_Pos = 0x0
	// Bit mask of CX0DE field.
	PWM_SM1DMAEN_CX0DE_Msk = 0x1
	// Bit CX0DE.
	PWM_SM1DMAEN_CX0DE = 0x1
	// Position of CX1DE field.
	PWM_SM1DMAEN_CX1DE_Pos = 0x1
	// Bit mask of CX1DE field.
	PWM_SM1DMAEN_CX1DE_Msk = 0x2
	// Bit CX1DE.
	PWM_SM1DMAEN_CX1DE = 0x2
	// Position of CB0DE field.
	PWM_SM1DMAEN_CB0DE_Pos = 0x2
	// Bit mask of CB0DE field.
	PWM_SM1DMAEN_CB0DE_Msk = 0x4
	// Bit CB0DE.
	PWM_SM1DMAEN_CB0DE = 0x4
	// Position of CB1DE field.
	PWM_SM1DMAEN_CB1DE_Pos = 0x3
	// Bit mask of CB1DE field.
	PWM_SM1DMAEN_CB1DE_Msk = 0x8
	// Bit CB1DE.
	PWM_SM1DMAEN_CB1DE = 0x8
	// Position of CA0DE field.
	PWM_SM1DMAEN_CA0DE_Pos = 0x4
	// Bit mask of CA0DE field.
	PWM_SM1DMAEN_CA0DE_Msk = 0x10
	// Bit CA0DE.
	PWM_SM1DMAEN_CA0DE = 0x10
	// Position of CA1DE field.
	PWM_SM1DMAEN_CA1DE_Pos = 0x5
	// Bit mask of CA1DE field.
	PWM_SM1DMAEN_CA1DE_Msk = 0x20
	// Bit CA1DE.
	PWM_SM1DMAEN_CA1DE = 0x20
	// Position of CAPTDE field.
	PWM_SM1DMAEN_CAPTDE_Pos = 0x6
	// Bit mask of CAPTDE field.
	PWM_SM1DMAEN_CAPTDE_Msk = 0xc0
	// Read DMA requests disabled.
	PWM_SM1DMAEN_CAPTDE_CAPTDE_0 = 0x0
	// Exceeding a FIFO watermark sets the DMA read request. This requires at least one of DMAEN[CA1DE], DMAEN[CA0DE], DMAEN[CB1DE], DMAEN[CB0DE], DMAEN[CX1DE], or DMAEN[CX0DE] to also be set in order to determine to which watermark(s) the DMA request is sensitive.
	PWM_SM1DMAEN_CAPTDE_CAPTDE_1 = 0x1
	// A local sync (VAL1 matches counter) sets the read DMA request.
	PWM_SM1DMAEN_CAPTDE_CAPTDE_2 = 0x2
	// A local reload (STS[RF] being set) sets the read DMA request.
	PWM_SM1DMAEN_CAPTDE_CAPTDE_3 = 0x3
	// Position of FAND field.
	PWM_SM1DMAEN_FAND_Pos = 0x8
	// Bit mask of FAND field.
	PWM_SM1DMAEN_FAND_Msk = 0x100
	// Bit FAND.
	PWM_SM1DMAEN_FAND = 0x100
	// Selected FIFO watermarks are OR'ed together.
	PWM_SM1DMAEN_FAND_FAND_0 = 0x0
	// Selected FIFO watermarks are AND'ed together.
	PWM_SM1DMAEN_FAND_FAND_1 = 0x1
	// Position of VALDE field.
	PWM_SM1DMAEN_VALDE_Pos = 0x9
	// Bit mask of VALDE field.
	PWM_SM1DMAEN_VALDE_Msk = 0x200
	// Bit VALDE.
	PWM_SM1DMAEN_VALDE = 0x200
	// DMA write requests disabled
	PWM_SM1DMAEN_VALDE_VALDE_0 = 0x0
	// DMA write requests for the VALx and FRACVALx registers enabled
	PWM_SM1DMAEN_VALDE_VALDE_1 = 0x1

	// SM1TCTRL: Output Trigger Control Register
	// Position of OUT_TRIG_EN field.
	PWM_SM1TCTRL_OUT_TRIG_EN_Pos = 0x0
	// Bit mask of OUT_TRIG_EN field.
	PWM_SM1TCTRL_OUT_TRIG_EN_Msk = 0x3f
	// PWM_OUT_TRIGx will not set when the counter value matches the VALx value.
	PWM_SM1TCTRL_OUT_TRIG_EN_OUT_TRIG_EN_0 = 0x0
	// PWM_OUT_TRIGx will set when the counter value matches the VALx value.
	PWM_SM1TCTRL_OUT_TRIG_EN_OUT_TRIG_EN_1 = 0x1
	// Position of TRGFRQ field.
	PWM_SM1TCTRL_TRGFRQ_Pos = 0xc
	// Bit mask of TRGFRQ field.
	PWM_SM1TCTRL_TRGFRQ_Msk = 0x1000
	// Bit TRGFRQ.
	PWM_SM1TCTRL_TRGFRQ = 0x1000
	// Trigger outputs are generated during every PWM period even if the PWM is not reloaded every period due to CTRL[LDFQ] being non-zero.
	PWM_SM1TCTRL_TRGFRQ_TRGFRQ_0 = 0x0
	// Trigger outputs are generated only during the final PWM period prior to a reload opportunity when the PWM is not reloaded every period due to CTRL[LDFQ] being non-zero.
	PWM_SM1TCTRL_TRGFRQ_TRGFRQ_1 = 0x1
	// Position of PWBOT1 field.
	PWM_SM1TCTRL_PWBOT1_Pos = 0xe
	// Bit mask of PWBOT1 field.
	PWM_SM1TCTRL_PWBOT1_Msk = 0x4000
	// Bit PWBOT1.
	PWM_SM1TCTRL_PWBOT1 = 0x4000
	// Route the PWM_OUT_TRIG1 signal to PWM_OUT_TRIG1 port.
	PWM_SM1TCTRL_PWBOT1_PWBOT1_0 = 0x0
	// Route the PWMB output to the PWM_OUT_TRIG1 port.
	PWM_SM1TCTRL_PWBOT1_PWBOT1_1 = 0x1
	// Position of PWAOT0 field.
	PWM_SM1TCTRL_PWAOT0_Pos = 0xf
	// Bit mask of PWAOT0 field.
	PWM_SM1TCTRL_PWAOT0_Msk = 0x8000
	// Bit PWAOT0.
	PWM_SM1TCTRL_PWAOT0 = 0x8000
	// Route the PWM_OUT_TRIG0 signal to PWM_OUT_TRIG0 port.
	PWM_SM1TCTRL_PWAOT0_PWAOT0_0 = 0x0
	// Route the PWMA output to the PWM_OUT_TRIG0 port.
	PWM_SM1TCTRL_PWAOT0_PWAOT0_1 = 0x1

	// SM1DISMAP0: Fault Disable Mapping Register 0
	// Position of DIS0A field.
	PWM_SM1DISMAP0_DIS0A_Pos = 0x0
	// Bit mask of DIS0A field.
	PWM_SM1DISMAP0_DIS0A_Msk = 0xf
	// Position of DIS0B field.
	PWM_SM1DISMAP0_DIS0B_Pos = 0x4
	// Bit mask of DIS0B field.
	PWM_SM1DISMAP0_DIS0B_Msk = 0xf0
	// Position of DIS0X field.
	PWM_SM1DISMAP0_DIS0X_Pos = 0x8
	// Bit mask of DIS0X field.
	PWM_SM1DISMAP0_DIS0X_Msk = 0xf00

	// SM1DISMAP1: Fault Disable Mapping Register 1
	// Position of DIS1A field.
	PWM_SM1DISMAP1_DIS1A_Pos = 0x0
	// Bit mask of DIS1A field.
	PWM_SM1DISMAP1_DIS1A_Msk = 0xf
	// Position of DIS1B field.
	PWM_SM1DISMAP1_DIS1B_Pos = 0x4
	// Bit mask of DIS1B field.
	PWM_SM1DISMAP1_DIS1B_Msk = 0xf0
	// Position of DIS1X field.
	PWM_SM1DISMAP1_DIS1X_Pos = 0x8
	// Bit mask of DIS1X field.
	PWM_SM1DISMAP1_DIS1X_Msk = 0xf00

	// SM1DTCNT0: Deadtime Count Register 0
	// Position of DTCNT0 field.
	PWM_SM1DTCNT0_DTCNT0_Pos = 0x0
	// Bit mask of DTCNT0 field.
	PWM_SM1DTCNT0_DTCNT0_Msk = 0xffff

	// SM1DTCNT1: Deadtime Count Register 1
	// Position of DTCNT1 field.
	PWM_SM1DTCNT1_DTCNT1_Pos = 0x0
	// Bit mask of DTCNT1 field.
	PWM_SM1DTCNT1_DTCNT1_Msk = 0xffff

	// SM1CAPTCTRLA: Capture Control A Register
	// Position of ARMA field.
	PWM_SM1CAPTCTRLA_ARMA_Pos = 0x0
	// Bit mask of ARMA field.
	PWM_SM1CAPTCTRLA_ARMA_Msk = 0x1
	// Bit ARMA.
	PWM_SM1CAPTCTRLA_ARMA = 0x1
	// Input capture operation is disabled.
	PWM_SM1CAPTCTRLA_ARMA_ARMA_0 = 0x0
	// Input capture operation as specified by CAPTCTRLA[EDGAx] is enabled.
	PWM_SM1CAPTCTRLA_ARMA_ARMA_1 = 0x1
	// Position of ONESHOTA field.
	PWM_SM1CAPTCTRLA_ONESHOTA_Pos = 0x1
	// Bit mask of ONESHOTA field.
	PWM_SM1CAPTCTRLA_ONESHOTA_Msk = 0x2
	// Bit ONESHOTA.
	PWM_SM1CAPTCTRLA_ONESHOTA = 0x2
	// Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLA[ARMA] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
	PWM_SM1CAPTCTRLA_ONESHOTA_ONESHOTA_0 = 0x0
	// One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLA[ARMA] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and CAPTCTRLA[ARMA] is cleared. No further captures will be performed until CAPTCTRLA[ARMA] is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and CAPTCTRLA[ARMA] is then cleared.
	PWM_SM1CAPTCTRLA_ONESHOTA_ONESHOTA_1 = 0x1
	// Position of EDGA0 field.
	PWM_SM1CAPTCTRLA_EDGA0_Pos = 0x2
	// Bit mask of EDGA0 field.
	PWM_SM1CAPTCTRLA_EDGA0_Msk = 0xc
	// Disabled
	PWM_SM1CAPTCTRLA_EDGA0_EDGA0_0 = 0x0
	// Capture falling edges
	PWM_SM1CAPTCTRLA_EDGA0_EDGA0_1 = 0x1
	// Capture rising edges
	PWM_SM1CAPTCTRLA_EDGA0_EDGA0_2 = 0x2
	// Capture any edge
	PWM_SM1CAPTCTRLA_EDGA0_EDGA0_3 = 0x3
	// Position of EDGA1 field.
	PWM_SM1CAPTCTRLA_EDGA1_Pos = 0x4
	// Bit mask of EDGA1 field.
	PWM_SM1CAPTCTRLA_EDGA1_Msk = 0x30
	// Disabled
	PWM_SM1CAPTCTRLA_EDGA1_EDGA1_0 = 0x0
	// Capture falling edges
	PWM_SM1CAPTCTRLA_EDGA1_EDGA1_1 = 0x1
	// Capture rising edges
	PWM_SM1CAPTCTRLA_EDGA1_EDGA1_2 = 0x2
	// Capture any edge
	PWM_SM1CAPTCTRLA_EDGA1_EDGA1_3 = 0x3
	// Position of INP_SELA field.
	PWM_SM1CAPTCTRLA_INP_SELA_Pos = 0x6
	// Bit mask of INP_SELA field.
	PWM_SM1CAPTCTRLA_INP_SELA_Msk = 0x40
	// Bit INP_SELA.
	PWM_SM1CAPTCTRLA_INP_SELA = 0x40
	// Raw PWM_A input signal selected as source.
	PWM_SM1CAPTCTRLA_INP_SELA_INP_SELA_0 = 0x0
	// Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLA[EDGA0] and CAPTCTRLA[EDGA1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRA[EDGA0] and/or CAPTCTRLA[EDGA1] fields in order to enable one or both of the capture registers.
	PWM_SM1CAPTCTRLA_INP_SELA_INP_SELA_1 = 0x1
	// Position of EDGCNTA_EN field.
	PWM_SM1CAPTCTRLA_EDGCNTA_EN_Pos = 0x7
	// Bit mask of EDGCNTA_EN field.
	PWM_SM1CAPTCTRLA_EDGCNTA_EN_Msk = 0x80
	// Bit EDGCNTA_EN.
	PWM_SM1CAPTCTRLA_EDGCNTA_EN = 0x80
	// Edge counter disabled and held in reset
	PWM_SM1CAPTCTRLA_EDGCNTA_EN_EDGCNTA_EN_0 = 0x0
	// Edge counter enabled
	PWM_SM1CAPTCTRLA_EDGCNTA_EN_EDGCNTA_EN_1 = 0x1
	// Position of CFAWM field.
	PWM_SM1CAPTCTRLA_CFAWM_Pos = 0x8
	// Bit mask of CFAWM field.
	PWM_SM1CAPTCTRLA_CFAWM_Msk = 0x300
	// Position of CA0CNT field.
	PWM_SM1CAPTCTRLA_CA0CNT_Pos = 0xa
	// Bit mask of CA0CNT field.
	PWM_SM1CAPTCTRLA_CA0CNT_Msk = 0x1c00
	// Position of CA1CNT field.
	PWM_SM1CAPTCTRLA_CA1CNT_Pos = 0xd
	// Bit mask of CA1CNT field.
	PWM_SM1CAPTCTRLA_CA1CNT_Msk = 0xe000

	// SM1CAPTCOMPA: Capture Compare A Register
	// Position of EDGCMPA field.
	PWM_SM1CAPTCOMPA_EDGCMPA_Pos = 0x0
	// Bit mask of EDGCMPA field.
	PWM_SM1CAPTCOMPA_EDGCMPA_Msk = 0xff
	// Position of EDGCNTA field.
	PWM_SM1CAPTCOMPA_EDGCNTA_Pos = 0x8
	// Bit mask of EDGCNTA field.
	PWM_SM1CAPTCOMPA_EDGCNTA_Msk = 0xff00

	// SM1CAPTCTRLB: Capture Control B Register
	// Position of ARMB field.
	PWM_SM1CAPTCTRLB_ARMB_Pos = 0x0
	// Bit mask of ARMB field.
	PWM_SM1CAPTCTRLB_ARMB_Msk = 0x1
	// Bit ARMB.
	PWM_SM1CAPTCTRLB_ARMB = 0x1
	// Input capture operation is disabled.
	PWM_SM1CAPTCTRLB_ARMB_ARMB_0 = 0x0
	// Input capture operation as specified by CAPTCTRLB[EDGBx] is enabled.
	PWM_SM1CAPTCTRLB_ARMB_ARMB_1 = 0x1
	// Position of ONESHOTB field.
	PWM_SM1CAPTCTRLB_ONESHOTB_Pos = 0x1
	// Bit mask of ONESHOTB field.
	PWM_SM1CAPTCTRLB_ONESHOTB_Msk = 0x2
	// Bit ONESHOTB.
	PWM_SM1CAPTCTRLB_ONESHOTB = 0x2
	// Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLB[ARMB] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
	PWM_SM1CAPTCTRLB_ONESHOTB_ONESHOTB_0 = 0x0
	// One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLB[ARMB] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and CAPTCTRLB[ARMB] is cleared. No further captures will be performed until CAPTCTRLB[ARMB] is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and CAPTCTRLB[ARMB] is then cleared.
	PWM_SM1CAPTCTRLB_ONESHOTB_ONESHOTB_1 = 0x1
	// Position of EDGB0 field.
	PWM_SM1CAPTCTRLB_EDGB0_Pos = 0x2
	// Bit mask of EDGB0 field.
	PWM_SM1CAPTCTRLB_EDGB0_Msk = 0xc
	// Disabled
	PWM_SM1CAPTCTRLB_EDGB0_EDGB0_0 = 0x0
	// Capture falling edges
	PWM_SM1CAPTCTRLB_EDGB0_EDGB0_1 = 0x1
	// Capture rising edges
	PWM_SM1CAPTCTRLB_EDGB0_EDGB0_2 = 0x2
	// Capture any edge
	PWM_SM1CAPTCTRLB_EDGB0_EDGB0_3 = 0x3
	// Position of EDGB1 field.
	PWM_SM1CAPTCTRLB_EDGB1_Pos = 0x4
	// Bit mask of EDGB1 field.
	PWM_SM1CAPTCTRLB_EDGB1_Msk = 0x30
	// Disabled
	PWM_SM1CAPTCTRLB_EDGB1_EDGB1_0 = 0x0
	// Capture falling edges
	PWM_SM1CAPTCTRLB_EDGB1_EDGB1_1 = 0x1
	// Capture rising edges
	PWM_SM1CAPTCTRLB_EDGB1_EDGB1_2 = 0x2
	// Capture any edge
	PWM_SM1CAPTCTRLB_EDGB1_EDGB1_3 = 0x3
	// Position of INP_SELB field.
	PWM_SM1CAPTCTRLB_INP_SELB_Pos = 0x6
	// Bit mask of INP_SELB field.
	PWM_SM1CAPTCTRLB_INP_SELB_Msk = 0x40
	// Bit INP_SELB.
	PWM_SM1CAPTCTRLB_INP_SELB = 0x40
	// Raw PWM_B input signal selected as source.
	PWM_SM1CAPTCTRLB_INP_SELB_INP_SELB_0 = 0x0
	// Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLB[EDGB0] and CAPTCTRLB[EDGB1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRB[EDGB0] and/or CAPTCTRLB[EDGB1] fields in order to enable one or both of the capture registers.
	PWM_SM1CAPTCTRLB_INP_SELB_INP_SELB_1 = 0x1
	// Position of EDGCNTB_EN field.
	PWM_SM1CAPTCTRLB_EDGCNTB_EN_Pos = 0x7
	// Bit mask of EDGCNTB_EN field.
	PWM_SM1CAPTCTRLB_EDGCNTB_EN_Msk = 0x80
	// Bit EDGCNTB_EN.
	PWM_SM1CAPTCTRLB_EDGCNTB_EN = 0x80
	// Edge counter disabled and held in reset
	PWM_SM1CAPTCTRLB_EDGCNTB_EN_EDGCNTB_EN_0 = 0x0
	// Edge counter enabled
	PWM_SM1CAPTCTRLB_EDGCNTB_EN_EDGCNTB_EN_1 = 0x1
	// Position of CFBWM field.
	PWM_SM1CAPTCTRLB_CFBWM_Pos = 0x8
	// Bit mask of CFBWM field.
	PWM_SM1CAPTCTRLB_CFBWM_Msk = 0x300
	// Position of CB0CNT field.
	PWM_SM1CAPTCTRLB_CB0CNT_Pos = 0xa
	// Bit mask of CB0CNT field.
	PWM_SM1CAPTCTRLB_CB0CNT_Msk = 0x1c00
	// Position of CB1CNT field.
	PWM_SM1CAPTCTRLB_CB1CNT_Pos = 0xd
	// Bit mask of CB1CNT field.
	PWM_SM1CAPTCTRLB_CB1CNT_Msk = 0xe000

	// SM1CAPTCOMPB: Capture Compare B Register
	// Position of EDGCMPB field.
	PWM_SM1CAPTCOMPB_EDGCMPB_Pos = 0x0
	// Bit mask of EDGCMPB field.
	PWM_SM1CAPTCOMPB_EDGCMPB_Msk = 0xff
	// Position of EDGCNTB field.
	PWM_SM1CAPTCOMPB_EDGCNTB_Pos = 0x8
	// Bit mask of EDGCNTB field.
	PWM_SM1CAPTCOMPB_EDGCNTB_Msk = 0xff00

	// SM1CAPTCTRLX: Capture Control X Register
	// Position of ARMX field.
	PWM_SM1CAPTCTRLX_ARMX_Pos = 0x0
	// Bit mask of ARMX field.
	PWM_SM1CAPTCTRLX_ARMX_Msk = 0x1
	// Bit ARMX.
	PWM_SM1CAPTCTRLX_ARMX = 0x1
	// Input capture operation is disabled.
	PWM_SM1CAPTCTRLX_ARMX_ARMX_0 = 0x0
	// Input capture operation as specified by CAPTCTRLX[EDGXx] is enabled.
	PWM_SM1CAPTCTRLX_ARMX_ARMX_1 = 0x1
	// Position of ONESHOTX field.
	PWM_SM1CAPTCTRLX_ONESHOTX_Pos = 0x1
	// Bit mask of ONESHOTX field.
	PWM_SM1CAPTCTRLX_ONESHOTX_Msk = 0x2
	// Bit ONESHOTX.
	PWM_SM1CAPTCTRLX_ONESHOTX = 0x2
	// Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after the ARMX bit is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
	PWM_SM1CAPTCTRLX_ONESHOTX_ONESHOTX_0 = 0x0
	// One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after the ARMX bit is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and the ARMX bit is cleared. No further captures will be performed until the ARMX bit is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and the ARMX bit is then cleared.
	PWM_SM1CAPTCTRLX_ONESHOTX_ONESHOTX_1 = 0x1
	// Position of EDGX0 field.
	PWM_SM1CAPTCTRLX_EDGX0_Pos = 0x2
	// Bit mask of EDGX0 field.
	PWM_SM1CAPTCTRLX_EDGX0_Msk = 0xc
	// Disabled
	PWM_SM1CAPTCTRLX_EDGX0_EDGX0_0 = 0x0
	// Capture falling edges
	PWM_SM1CAPTCTRLX_EDGX0_EDGX0_1 = 0x1
	// Capture rising edges
	PWM_SM1CAPTCTRLX_EDGX0_EDGX0_2 = 0x2
	// Capture any edge
	PWM_SM1CAPTCTRLX_EDGX0_EDGX0_3 = 0x3
	// Position of EDGX1 field.
	PWM_SM1CAPTCTRLX_EDGX1_Pos = 0x4
	// Bit mask of EDGX1 field.
	PWM_SM1CAPTCTRLX_EDGX1_Msk = 0x30
	// Disabled
	PWM_SM1CAPTCTRLX_EDGX1_EDGX1_0 = 0x0
	// Capture falling edges
	PWM_SM1CAPTCTRLX_EDGX1_EDGX1_1 = 0x1
	// Capture rising edges
	PWM_SM1CAPTCTRLX_EDGX1_EDGX1_2 = 0x2
	// Capture any edge
	PWM_SM1CAPTCTRLX_EDGX1_EDGX1_3 = 0x3
	// Position of INP_SELX field.
	PWM_SM1CAPTCTRLX_INP_SELX_Pos = 0x6
	// Bit mask of INP_SELX field.
	PWM_SM1CAPTCTRLX_INP_SELX_Msk = 0x40
	// Bit INP_SELX.
	PWM_SM1CAPTCTRLX_INP_SELX = 0x40
	// Raw PWM_X input signal selected as source.
	PWM_SM1CAPTCTRLX_INP_SELX_INP_SELX_0 = 0x0
	// Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLX[EDGX0] and CAPTCTRLX[EDGX1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRX[EDGX0] and/or CAPTCTRLX[EDGX1] fields in order to enable one or both of the capture registers.
	PWM_SM1CAPTCTRLX_INP_SELX_INP_SELX_1 = 0x1
	// Position of EDGCNTX_EN field.
	PWM_SM1CAPTCTRLX_EDGCNTX_EN_Pos = 0x7
	// Bit mask of EDGCNTX_EN field.
	PWM_SM1CAPTCTRLX_EDGCNTX_EN_Msk = 0x80
	// Bit EDGCNTX_EN.
	PWM_SM1CAPTCTRLX_EDGCNTX_EN = 0x80
	// Edge counter disabled and held in reset
	PWM_SM1CAPTCTRLX_EDGCNTX_EN_EDGCNTX_EN_0 = 0x0
	// Edge counter enabled
	PWM_SM1CAPTCTRLX_EDGCNTX_EN_EDGCNTX_EN_1 = 0x1
	// Position of CFXWM field.
	PWM_SM1CAPTCTRLX_CFXWM_Pos = 0x8
	// Bit mask of CFXWM field.
	PWM_SM1CAPTCTRLX_CFXWM_Msk = 0x300
	// Position of CX0CNT field.
	PWM_SM1CAPTCTRLX_CX0CNT_Pos = 0xa
	// Bit mask of CX0CNT field.
	PWM_SM1CAPTCTRLX_CX0CNT_Msk = 0x1c00
	// Position of CX1CNT field.
	PWM_SM1CAPTCTRLX_CX1CNT_Pos = 0xd
	// Bit mask of CX1CNT field.
	PWM_SM1CAPTCTRLX_CX1CNT_Msk = 0xe000

	// SM1CAPTCOMPX: Capture Compare X Register
	// Position of EDGCMPX field.
	PWM_SM1CAPTCOMPX_EDGCMPX_Pos = 0x0
	// Bit mask of EDGCMPX field.
	PWM_SM1CAPTCOMPX_EDGCMPX_Msk = 0xff
	// Position of EDGCNTX field.
	PWM_SM1CAPTCOMPX_EDGCNTX_Pos = 0x8
	// Bit mask of EDGCNTX field.
	PWM_SM1CAPTCOMPX_EDGCNTX_Msk = 0xff00

	// SM1CVAL0: Capture Value 0 Register
	// Position of CAPTVAL0 field.
	PWM_SM1CVAL0_CAPTVAL0_Pos = 0x0
	// Bit mask of CAPTVAL0 field.
	PWM_SM1CVAL0_CAPTVAL0_Msk = 0xffff

	// SM1CVAL0CYC: Capture Value 0 Cycle Register
	// Position of CVAL0CYC field.
	PWM_SM1CVAL0CYC_CVAL0CYC_Pos = 0x0
	// Bit mask of CVAL0CYC field.
	PWM_SM1CVAL0CYC_CVAL0CYC_Msk = 0xf

	// SM1CVAL1: Capture Value 1 Register
	// Position of CAPTVAL1 field.
	PWM_SM1CVAL1_CAPTVAL1_Pos = 0x0
	// Bit mask of CAPTVAL1 field.
	PWM_SM1CVAL1_CAPTVAL1_Msk = 0xffff

	// SM1CVAL1CYC: Capture Value 1 Cycle Register
	// Position of CVAL1CYC field.
	PWM_SM1CVAL1CYC_CVAL1CYC_Pos = 0x0
	// Bit mask of CVAL1CYC field.
	PWM_SM1CVAL1CYC_CVAL1CYC_Msk = 0xf

	// SM1CVAL2: Capture Value 2 Register
	// Position of CAPTVAL2 field.
	PWM_SM1CVAL2_CAPTVAL2_Pos = 0x0
	// Bit mask of CAPTVAL2 field.
	PWM_SM1CVAL2_CAPTVAL2_Msk = 0xffff

	// SM1CVAL2CYC: Capture Value 2 Cycle Register
	// Position of CVAL2CYC field.
	PWM_SM1CVAL2CYC_CVAL2CYC_Pos = 0x0
	// Bit mask of CVAL2CYC field.
	PWM_SM1CVAL2CYC_CVAL2CYC_Msk = 0xf

	// SM1CVAL3: Capture Value 3 Register
	// Position of CAPTVAL3 field.
	PWM_SM1CVAL3_CAPTVAL3_Pos = 0x0
	// Bit mask of CAPTVAL3 field.
	PWM_SM1CVAL3_CAPTVAL3_Msk = 0xffff

	// SM1CVAL3CYC: Capture Value 3 Cycle Register
	// Position of CVAL3CYC field.
	PWM_SM1CVAL3CYC_CVAL3CYC_Pos = 0x0
	// Bit mask of CVAL3CYC field.
	PWM_SM1CVAL3CYC_CVAL3CYC_Msk = 0xf

	// SM1CVAL4: Capture Value 4 Register
	// Position of CAPTVAL4 field.
	PWM_SM1CVAL4_CAPTVAL4_Pos = 0x0
	// Bit mask of CAPTVAL4 field.
	PWM_SM1CVAL4_CAPTVAL4_Msk = 0xffff

	// SM1CVAL4CYC: Capture Value 4 Cycle Register
	// Position of CVAL4CYC field.
	PWM_SM1CVAL4CYC_CVAL4CYC_Pos = 0x0
	// Bit mask of CVAL4CYC field.
	PWM_SM1CVAL4CYC_CVAL4CYC_Msk = 0xf

	// SM1CVAL5: Capture Value 5 Register
	// Position of CAPTVAL5 field.
	PWM_SM1CVAL5_CAPTVAL5_Pos = 0x0
	// Bit mask of CAPTVAL5 field.
	PWM_SM1CVAL5_CAPTVAL5_Msk = 0xffff

	// SM1CVAL5CYC: Capture Value 5 Cycle Register
	// Position of CVAL5CYC field.
	PWM_SM1CVAL5CYC_CVAL5CYC_Pos = 0x0
	// Bit mask of CVAL5CYC field.
	PWM_SM1CVAL5CYC_CVAL5CYC_Msk = 0xf

	// SM2CNT: Counter Register
	// Position of CNT field.
	PWM_SM2CNT_CNT_Pos = 0x0
	// Bit mask of CNT field.
	PWM_SM2CNT_CNT_Msk = 0xffff

	// SM2INIT: Initial Count Register
	// Position of INIT field.
	PWM_SM2INIT_INIT_Pos = 0x0
	// Bit mask of INIT field.
	PWM_SM2INIT_INIT_Msk = 0xffff

	// SM2CTRL2: Control 2 Register
	// Position of CLK_SEL field.
	PWM_SM2CTRL2_CLK_SEL_Pos = 0x0
	// Bit mask of CLK_SEL field.
	PWM_SM2CTRL2_CLK_SEL_Msk = 0x3
	// The IPBus clock is used as the clock for the local prescaler and counter.
	PWM_SM2CTRL2_CLK_SEL_CLK_SEL_0 = 0x0
	// EXT_CLK is used as the clock for the local prescaler and counter.
	PWM_SM2CTRL2_CLK_SEL_CLK_SEL_1 = 0x1
	// Submodule 0's clock (AUX_CLK) is used as the source clock for the local prescaler and counter. This setting should not be used in submodule 0 as it will force the clock to logic 0.
	PWM_SM2CTRL2_CLK_SEL_CLK_SEL_2 = 0x2
	// Position of RELOAD_SEL field.
	PWM_SM2CTRL2_RELOAD_SEL_Pos = 0x2
	// Bit mask of RELOAD_SEL field.
	PWM_SM2CTRL2_RELOAD_SEL_Msk = 0x4
	// Bit RELOAD_SEL.
	PWM_SM2CTRL2_RELOAD_SEL = 0x4
	// The local RELOAD signal is used to reload registers.
	PWM_SM2CTRL2_RELOAD_SEL_RELOAD_SEL_0 = 0x0
	// The master RELOAD signal (from submodule 0) is used to reload registers. This setting should not be used in submodule 0 as it will force the RELOAD signal to logic 0.
	PWM_SM2CTRL2_RELOAD_SEL_RELOAD_SEL_1 = 0x1
	// Position of FORCE_SEL field.
	PWM_SM2CTRL2_FORCE_SEL_Pos = 0x3
	// Bit mask of FORCE_SEL field.
	PWM_SM2CTRL2_FORCE_SEL_Msk = 0x38
	// The local force signal, CTRL2[FORCE], from this submodule is used to force updates.
	PWM_SM2CTRL2_FORCE_SEL_FORCE_SEL_0 = 0x0
	// The master force signal from submodule 0 is used to force updates. This setting should not be used in submodule 0 as it will hold the FORCE OUTPUT signal to logic 0.
	PWM_SM2CTRL2_FORCE_SEL_FORCE_SEL_1 = 0x1
	// The local reload signal from this submodule is used to force updates without regard to the state of LDOK.
	PWM_SM2CTRL2_FORCE_SEL_FORCE_SEL_2 = 0x2
	// The master reload signal from submodule0 is used to force updates if LDOK is set. This setting should not be used in submodule0 as it will hold the FORCE OUTPUT signal to logic 0.
	PWM_SM2CTRL2_FORCE_SEL_FORCE_SEL_3 = 0x3
	// The local sync signal from this submodule is used to force updates.
	PWM_SM2CTRL2_FORCE_SEL_FORCE_SEL_4 = 0x4
	// The master sync signal from submodule0 is used to force updates. This setting should not be used in submodule0 as it will hold the FORCE OUTPUT signal to logic 0.
	PWM_SM2CTRL2_FORCE_SEL_FORCE_SEL_5 = 0x5
	// The external force signal, EXT_FORCE, from outside the PWM module causes updates.
	PWM_SM2CTRL2_FORCE_SEL_FORCE_SEL_6 = 0x6
	// The external sync signal, EXT_SYNC, from outside the PWM module causes updates.
	PWM_SM2CTRL2_FORCE_SEL_FORCE_SEL_7 = 0x7
	// Position of FORCE field.
	PWM_SM2CTRL2_FORCE_Pos = 0x6
	// Bit mask of FORCE field.
	PWM_SM2CTRL2_FORCE_Msk = 0x40
	// Bit FORCE.
	PWM_SM2CTRL2_FORCE = 0x40
	// Position of FRCEN field.
	PWM_SM2CTRL2_FRCEN_Pos = 0x7
	// Bit mask of FRCEN field.
	PWM_SM2CTRL2_FRCEN_Msk = 0x80
	// Bit FRCEN.
	PWM_SM2CTRL2_FRCEN = 0x80
	// Initialization from a FORCE_OUT is disabled.
	PWM_SM2CTRL2_FRCEN_FRCEN_0 = 0x0
	// Initialization from a FORCE_OUT is enabled.
	PWM_SM2CTRL2_FRCEN_FRCEN_1 = 0x1
	// Position of INIT_SEL field.
	PWM_SM2CTRL2_INIT_SEL_Pos = 0x8
	// Bit mask of INIT_SEL field.
	PWM_SM2CTRL2_INIT_SEL_Msk = 0x300
	// Local sync (PWM_X) causes initialization.
	PWM_SM2CTRL2_INIT_SEL_INIT_SEL_0 = 0x0
	// Master reload from submodule 0 causes initialization. This setting should not be used in submodule 0 as it will force the INIT signal to logic 0. The submodule counter will only reinitialize when a master reload occurs.
	PWM_SM2CTRL2_INIT_SEL_INIT_SEL_1 = 0x1
	// Master sync from submodule 0 causes initialization. This setting should not be used in submodule 0 as it will force the INIT signal to logic 0.
	PWM_SM2CTRL2_INIT_SEL_INIT_SEL_2 = 0x2
	// EXT_SYNC causes initialization.
	PWM_SM2CTRL2_INIT_SEL_INIT_SEL_3 = 0x3
	// Position of PWMX_INIT field.
	PWM_SM2CTRL2_PWMX_INIT_Pos = 0xa
	// Bit mask of PWMX_INIT field.
	PWM_SM2CTRL2_PWMX_INIT_Msk = 0x400
	// Bit PWMX_INIT.
	PWM_SM2CTRL2_PWMX_INIT = 0x400
	// Position of PWM45_INIT field.
	PWM_SM2CTRL2_PWM45_INIT_Pos = 0xb
	// Bit mask of PWM45_INIT field.
	PWM_SM2CTRL2_PWM45_INIT_Msk = 0x800
	// Bit PWM45_INIT.
	PWM_SM2CTRL2_PWM45_INIT = 0x800
	// Position of PWM23_INIT field.
	PWM_SM2CTRL2_PWM23_INIT_Pos = 0xc
	// Bit mask of PWM23_INIT field.
	PWM_SM2CTRL2_PWM23_INIT_Msk = 0x1000
	// Bit PWM23_INIT.
	PWM_SM2CTRL2_PWM23_INIT = 0x1000
	// Position of INDEP field.
	PWM_SM2CTRL2_INDEP_Pos = 0xd
	// Bit mask of INDEP field.
	PWM_SM2CTRL2_INDEP_Msk = 0x2000
	// Bit INDEP.
	PWM_SM2CTRL2_INDEP = 0x2000
	// PWM_A and PWM_B form a complementary PWM pair.
	PWM_SM2CTRL2_INDEP_INDEP_0 = 0x0
	// PWM_A and PWM_B outputs are independent PWMs.
	PWM_SM2CTRL2_INDEP_INDEP_1 = 0x1
	// Position of WAITEN field.
	PWM_SM2CTRL2_WAITEN_Pos = 0xe
	// Bit mask of WAITEN field.
	PWM_SM2CTRL2_WAITEN_Msk = 0x4000
	// Bit WAITEN.
	PWM_SM2CTRL2_WAITEN = 0x4000
	// Position of DBGEN field.
	PWM_SM2CTRL2_DBGEN_Pos = 0xf
	// Bit mask of DBGEN field.
	PWM_SM2CTRL2_DBGEN_Msk = 0x8000
	// Bit DBGEN.
	PWM_SM2CTRL2_DBGEN = 0x8000

	// SM2CTRL: Control Register
	// Position of DBLEN field.
	PWM_SM2CTRL_DBLEN_Pos = 0x0
	// Bit mask of DBLEN field.
	PWM_SM2CTRL_DBLEN_Msk = 0x1
	// Bit DBLEN.
	PWM_SM2CTRL_DBLEN = 0x1
	// Double switching disabled.
	PWM_SM2CTRL_DBLEN_DBLEN_0 = 0x0
	// Double switching enabled.
	PWM_SM2CTRL_DBLEN_DBLEN_1 = 0x1
	// Position of DBLX field.
	PWM_SM2CTRL_DBLX_Pos = 0x1
	// Bit mask of DBLX field.
	PWM_SM2CTRL_DBLX_Msk = 0x2
	// Bit DBLX.
	PWM_SM2CTRL_DBLX = 0x2
	// PWMX double pulse disabled.
	PWM_SM2CTRL_DBLX_DBLX_0 = 0x0
	// PWMX double pulse enabled.
	PWM_SM2CTRL_DBLX_DBLX_1 = 0x1
	// Position of LDMOD field.
	PWM_SM2CTRL_LDMOD_Pos = 0x2
	// Bit mask of LDMOD field.
	PWM_SM2CTRL_LDMOD_Msk = 0x4
	// Bit LDMOD.
	PWM_SM2CTRL_LDMOD = 0x4
	// Buffered registers of this submodule are loaded and take effect at the next PWM reload if MCTRL[LDOK] is set.
	PWM_SM2CTRL_LDMOD_LDMOD_0 = 0x0
	// Buffered registers of this submodule are loaded and take effect immediately upon MCTRL[LDOK] being set. In this case it is not necessary to set CTRL[FULL] or CTRL[HALF].
	PWM_SM2CTRL_LDMOD_LDMOD_1 = 0x1
	// Position of SPLIT field.
	PWM_SM2CTRL_SPLIT_Pos = 0x3
	// Bit mask of SPLIT field.
	PWM_SM2CTRL_SPLIT_Msk = 0x8
	// Bit SPLIT.
	PWM_SM2CTRL_SPLIT = 0x8
	// DBLPWM is not split. PWMA and PWMB each have double pulses.
	PWM_SM2CTRL_SPLIT_SPLIT_0 = 0x0
	// DBLPWM is split to PWMA and PWMB.
	PWM_SM2CTRL_SPLIT_SPLIT_1 = 0x1
	// Position of PRSC field.
	PWM_SM2CTRL_PRSC_Pos = 0x4
	// Bit mask of PRSC field.
	PWM_SM2CTRL_PRSC_Msk = 0x70
	// PWM clock frequency = fclk
	PWM_SM2CTRL_PRSC_PRSC_0 = 0x0
	// PWM clock frequency = fclk/2
	PWM_SM2CTRL_PRSC_PRSC_1 = 0x1
	// PWM clock frequency = fclk/4
	PWM_SM2CTRL_PRSC_PRSC_2 = 0x2
	// PWM clock frequency = fclk/8
	PWM_SM2CTRL_PRSC_PRSC_3 = 0x3
	// PWM clock frequency = fclk/16
	PWM_SM2CTRL_PRSC_PRSC_4 = 0x4
	// PWM clock frequency = fclk/32
	PWM_SM2CTRL_PRSC_PRSC_5 = 0x5
	// PWM clock frequency = fclk/64
	PWM_SM2CTRL_PRSC_PRSC_6 = 0x6
	// PWM clock frequency = fclk/128
	PWM_SM2CTRL_PRSC_PRSC_7 = 0x7
	// Position of COMPMODE field.
	PWM_SM2CTRL_COMPMODE_Pos = 0x7
	// Bit mask of COMPMODE field.
	PWM_SM2CTRL_COMPMODE_Msk = 0x80
	// Bit COMPMODE.
	PWM_SM2CTRL_COMPMODE = 0x80
	// The VAL* registers and the PWM counter are compared using an "equal to" method. This means that PWM edges are only produced when the counter is equal to one of the VAL* register values. This implies that a PWMA output that is high at the end of a period will maintain this state until a match with VAL3 clears the output in the following period.
	PWM_SM2CTRL_COMPMODE_COMPMODE_0 = 0x0
	// The VAL* registers and the PWM counter are compared using an "equal to or greater than" method. This means that PWM edges are produced when the counter is equal to or greater than one of the VAL* register values. This implies that a PWMA output that is high at the end of a period could go low at the start of the next period if the starting counter value is greater than (but not necessarily equal to) the new VAL3 value.
	PWM_SM2CTRL_COMPMODE_COMPMODE_1 = 0x1
	// Position of DT field.
	PWM_SM2CTRL_DT_Pos = 0x8
	// Bit mask of DT field.
	PWM_SM2CTRL_DT_Msk = 0x300
	// Position of FULL field.
	PWM_SM2CTRL_FULL_Pos = 0xa
	// Bit mask of FULL field.
	PWM_SM2CTRL_FULL_Msk = 0x400
	// Bit FULL.
	PWM_SM2CTRL_FULL = 0x400
	// Full-cycle reloads disabled.
	PWM_SM2CTRL_FULL_FULL_0 = 0x0
	// Full-cycle reloads enabled.
	PWM_SM2CTRL_FULL_FULL_1 = 0x1
	// Position of HALF field.
	PWM_SM2CTRL_HALF_Pos = 0xb
	// Bit mask of HALF field.
	PWM_SM2CTRL_HALF_Msk = 0x800
	// Bit HALF.
	PWM_SM2CTRL_HALF = 0x800
	// Half-cycle reloads disabled.
	PWM_SM2CTRL_HALF_HALF_0 = 0x0
	// Half-cycle reloads enabled.
	PWM_SM2CTRL_HALF_HALF_1 = 0x1
	// Position of LDFQ field.
	PWM_SM2CTRL_LDFQ_Pos = 0xc
	// Bit mask of LDFQ field.
	PWM_SM2CTRL_LDFQ_Msk = 0xf000
	// Every PWM opportunity
	PWM_SM2CTRL_LDFQ_LDFQ_0 = 0x0
	// Every 2 PWM opportunities
	PWM_SM2CTRL_LDFQ_LDFQ_1 = 0x1
	// Every 3 PWM opportunities
	PWM_SM2CTRL_LDFQ_LDFQ_2 = 0x2
	// Every 4 PWM opportunities
	PWM_SM2CTRL_LDFQ_LDFQ_3 = 0x3
	// Every 5 PWM opportunities
	PWM_SM2CTRL_LDFQ_LDFQ_4 = 0x4
	// Every 6 PWM opportunities
	PWM_SM2CTRL_LDFQ_LDFQ_5 = 0x5
	// Every 7 PWM opportunities
	PWM_SM2CTRL_LDFQ_LDFQ_6 = 0x6
	// Every 8 PWM opportunities
	PWM_SM2CTRL_LDFQ_LDFQ_7 = 0x7
	// Every 9 PWM opportunities
	PWM_SM2CTRL_LDFQ_LDFQ_8 = 0x8
	// Every 10 PWM opportunities
	PWM_SM2CTRL_LDFQ_LDFQ_9 = 0x9
	// Every 11 PWM opportunities
	PWM_SM2CTRL_LDFQ_LDFQ_10 = 0xa
	// Every 12 PWM opportunities
	PWM_SM2CTRL_LDFQ_LDFQ_11 = 0xb
	// Every 13 PWM opportunities
	PWM_SM2CTRL_LDFQ_LDFQ_12 = 0xc
	// Every 14 PWM opportunities
	PWM_SM2CTRL_LDFQ_LDFQ_13 = 0xd
	// Every 15 PWM opportunities
	PWM_SM2CTRL_LDFQ_LDFQ_14 = 0xe
	// Every 16 PWM opportunities
	PWM_SM2CTRL_LDFQ_LDFQ_15 = 0xf

	// SM2VAL0: Value Register 0
	// Position of VAL0 field.
	PWM_SM2VAL0_VAL0_Pos = 0x0
	// Bit mask of VAL0 field.
	PWM_SM2VAL0_VAL0_Msk = 0xffff

	// SM2FRACVAL1: Fractional Value Register 1
	// Position of FRACVAL1 field.
	PWM_SM2FRACVAL1_FRACVAL1_Pos = 0xb
	// Bit mask of FRACVAL1 field.
	PWM_SM2FRACVAL1_FRACVAL1_Msk = 0xf800

	// SM2VAL1: Value Register 1
	// Position of VAL1 field.
	PWM_SM2VAL1_VAL1_Pos = 0x0
	// Bit mask of VAL1 field.
	PWM_SM2VAL1_VAL1_Msk = 0xffff

	// SM2FRACVAL2: Fractional Value Register 2
	// Position of FRACVAL2 field.
	PWM_SM2FRACVAL2_FRACVAL2_Pos = 0xb
	// Bit mask of FRACVAL2 field.
	PWM_SM2FRACVAL2_FRACVAL2_Msk = 0xf800

	// SM2VAL2: Value Register 2
	// Position of VAL2 field.
	PWM_SM2VAL2_VAL2_Pos = 0x0
	// Bit mask of VAL2 field.
	PWM_SM2VAL2_VAL2_Msk = 0xffff

	// SM2FRACVAL3: Fractional Value Register 3
	// Position of FRACVAL3 field.
	PWM_SM2FRACVAL3_FRACVAL3_Pos = 0xb
	// Bit mask of FRACVAL3 field.
	PWM_SM2FRACVAL3_FRACVAL3_Msk = 0xf800

	// SM2VAL3: Value Register 3
	// Position of VAL3 field.
	PWM_SM2VAL3_VAL3_Pos = 0x0
	// Bit mask of VAL3 field.
	PWM_SM2VAL3_VAL3_Msk = 0xffff

	// SM2FRACVAL4: Fractional Value Register 4
	// Position of FRACVAL4 field.
	PWM_SM2FRACVAL4_FRACVAL4_Pos = 0xb
	// Bit mask of FRACVAL4 field.
	PWM_SM2FRACVAL4_FRACVAL4_Msk = 0xf800

	// SM2VAL4: Value Register 4
	// Position of VAL4 field.
	PWM_SM2VAL4_VAL4_Pos = 0x0
	// Bit mask of VAL4 field.
	PWM_SM2VAL4_VAL4_Msk = 0xffff

	// SM2FRACVAL5: Fractional Value Register 5
	// Position of FRACVAL5 field.
	PWM_SM2FRACVAL5_FRACVAL5_Pos = 0xb
	// Bit mask of FRACVAL5 field.
	PWM_SM2FRACVAL5_FRACVAL5_Msk = 0xf800

	// SM2VAL5: Value Register 5
	// Position of VAL5 field.
	PWM_SM2VAL5_VAL5_Pos = 0x0
	// Bit mask of VAL5 field.
	PWM_SM2VAL5_VAL5_Msk = 0xffff

	// SM2FRCTRL: Fractional Control Register
	// Position of FRAC1_EN field.
	PWM_SM2FRCTRL_FRAC1_EN_Pos = 0x1
	// Bit mask of FRAC1_EN field.
	PWM_SM2FRCTRL_FRAC1_EN_Msk = 0x2
	// Bit FRAC1_EN.
	PWM_SM2FRCTRL_FRAC1_EN = 0x2
	// Disable fractional cycle length for the PWM period.
	PWM_SM2FRCTRL_FRAC1_EN_FRAC1_EN_0 = 0x0
	// Enable fractional cycle length for the PWM period.
	PWM_SM2FRCTRL_FRAC1_EN_FRAC1_EN_1 = 0x1
	// Position of FRAC23_EN field.
	PWM_SM2FRCTRL_FRAC23_EN_Pos = 0x2
	// Bit mask of FRAC23_EN field.
	PWM_SM2FRCTRL_FRAC23_EN_Msk = 0x4
	// Bit FRAC23_EN.
	PWM_SM2FRCTRL_FRAC23_EN = 0x4
	// Disable fractional cycle placement for PWM_A.
	PWM_SM2FRCTRL_FRAC23_EN_FRAC23_EN_0 = 0x0
	// Enable fractional cycle placement for PWM_A.
	PWM_SM2FRCTRL_FRAC23_EN_FRAC23_EN_1 = 0x1
	// Position of FRAC45_EN field.
	PWM_SM2FRCTRL_FRAC45_EN_Pos = 0x4
	// Bit mask of FRAC45_EN field.
	PWM_SM2FRCTRL_FRAC45_EN_Msk = 0x10
	// Bit FRAC45_EN.
	PWM_SM2FRCTRL_FRAC45_EN = 0x10
	// Disable fractional cycle placement for PWM_B.
	PWM_SM2FRCTRL_FRAC45_EN_FRAC45_EN_0 = 0x0
	// Enable fractional cycle placement for PWM_B.
	PWM_SM2FRCTRL_FRAC45_EN_FRAC45_EN_1 = 0x1
	// Position of FRAC_PU field.
	PWM_SM2FRCTRL_FRAC_PU_Pos = 0x8
	// Bit mask of FRAC_PU field.
	PWM_SM2FRCTRL_FRAC_PU_Msk = 0x100
	// Bit FRAC_PU.
	PWM_SM2FRCTRL_FRAC_PU = 0x100
	// Turn off fractional delay logic.
	PWM_SM2FRCTRL_FRAC_PU_FRAC_PU_0 = 0x0
	// Power up fractional delay logic.
	PWM_SM2FRCTRL_FRAC_PU_FRAC_PU_1 = 0x1
	// Position of TEST field.
	PWM_SM2FRCTRL_TEST_Pos = 0xf
	// Bit mask of TEST field.
	PWM_SM2FRCTRL_TEST_Msk = 0x8000
	// Bit TEST.
	PWM_SM2FRCTRL_TEST = 0x8000

	// SM2OCTRL: Output Control Register
	// Position of PWMXFS field.
	PWM_SM2OCTRL_PWMXFS_Pos = 0x0
	// Bit mask of PWMXFS field.
	PWM_SM2OCTRL_PWMXFS_Msk = 0x3
	// Output is forced to logic 0 state prior to consideration of output polarity control.
	PWM_SM2OCTRL_PWMXFS_PWMXFS_0 = 0x0
	// Output is forced to logic 1 state prior to consideration of output polarity control.
	PWM_SM2OCTRL_PWMXFS_PWMXFS_1 = 0x1
	// Output is tristated.
	PWM_SM2OCTRL_PWMXFS_PWMXFS_2 = 0x2
	// Output is tristated.
	PWM_SM2OCTRL_PWMXFS_PWMXFS_3 = 0x3
	// Position of PWMBFS field.
	PWM_SM2OCTRL_PWMBFS_Pos = 0x2
	// Bit mask of PWMBFS field.
	PWM_SM2OCTRL_PWMBFS_Msk = 0xc
	// Output is forced to logic 0 state prior to consideration of output polarity control.
	PWM_SM2OCTRL_PWMBFS_PWMBFS_0 = 0x0
	// Output is forced to logic 1 state prior to consideration of output polarity control.
	PWM_SM2OCTRL_PWMBFS_PWMBFS_1 = 0x1
	// Output is tristated.
	PWM_SM2OCTRL_PWMBFS_PWMBFS_2 = 0x2
	// Output is tristated.
	PWM_SM2OCTRL_PWMBFS_PWMBFS_3 = 0x3
	// Position of PWMAFS field.
	PWM_SM2OCTRL_PWMAFS_Pos = 0x4
	// Bit mask of PWMAFS field.
	PWM_SM2OCTRL_PWMAFS_Msk = 0x30
	// Output is forced to logic 0 state prior to consideration of output polarity control.
	PWM_SM2OCTRL_PWMAFS_PWMAFS_0 = 0x0
	// Output is forced to logic 1 state prior to consideration of output polarity control.
	PWM_SM2OCTRL_PWMAFS_PWMAFS_1 = 0x1
	// Output is tristated.
	PWM_SM2OCTRL_PWMAFS_PWMAFS_2 = 0x2
	// Output is tristated.
	PWM_SM2OCTRL_PWMAFS_PWMAFS_3 = 0x3
	// Position of POLX field.
	PWM_SM2OCTRL_POLX_Pos = 0x8
	// Bit mask of POLX field.
	PWM_SM2OCTRL_POLX_Msk = 0x100
	// Bit POLX.
	PWM_SM2OCTRL_POLX = 0x100
	// PWM_X output not inverted. A high level on the PWM_X pin represents the "on" or "active" state.
	PWM_SM2OCTRL_POLX_POLX_0 = 0x0
	// PWM_X output inverted. A low level on the PWM_X pin represents the "on" or "active" state.
	PWM_SM2OCTRL_POLX_POLX_1 = 0x1
	// Position of POLB field.
	PWM_SM2OCTRL_POLB_Pos = 0x9
	// Bit mask of POLB field.
	PWM_SM2OCTRL_POLB_Msk = 0x200
	// Bit POLB.
	PWM_SM2OCTRL_POLB = 0x200
	// PWM_B output not inverted. A high level on the PWM_B pin represents the "on" or "active" state.
	PWM_SM2OCTRL_POLB_POLB_0 = 0x0
	// PWM_B output inverted. A low level on the PWM_B pin represents the "on" or "active" state.
	PWM_SM2OCTRL_POLB_POLB_1 = 0x1
	// Position of POLA field.
	PWM_SM2OCTRL_POLA_Pos = 0xa
	// Bit mask of POLA field.
	PWM_SM2OCTRL_POLA_Msk = 0x400
	// Bit POLA.
	PWM_SM2OCTRL_POLA = 0x400
	// PWM_A output not inverted. A high level on the PWM_A pin represents the "on" or "active" state.
	PWM_SM2OCTRL_POLA_POLA_0 = 0x0
	// PWM_A output inverted. A low level on the PWM_A pin represents the "on" or "active" state.
	PWM_SM2OCTRL_POLA_POLA_1 = 0x1
	// Position of PWMX_IN field.
	PWM_SM2OCTRL_PWMX_IN_Pos = 0xd
	// Bit mask of PWMX_IN field.
	PWM_SM2OCTRL_PWMX_IN_Msk = 0x2000
	// Bit PWMX_IN.
	PWM_SM2OCTRL_PWMX_IN = 0x2000
	// Position of PWMB_IN field.
	PWM_SM2OCTRL_PWMB_IN_Pos = 0xe
	// Bit mask of PWMB_IN field.
	PWM_SM2OCTRL_PWMB_IN_Msk = 0x4000
	// Bit PWMB_IN.
	PWM_SM2OCTRL_PWMB_IN = 0x4000
	// Position of PWMA_IN field.
	PWM_SM2OCTRL_PWMA_IN_Pos = 0xf
	// Bit mask of PWMA_IN field.
	PWM_SM2OCTRL_PWMA_IN_Msk = 0x8000
	// Bit PWMA_IN.
	PWM_SM2OCTRL_PWMA_IN = 0x8000

	// SM2STS: Status Register
	// Position of CMPF field.
	PWM_SM2STS_CMPF_Pos = 0x0
	// Bit mask of CMPF field.
	PWM_SM2STS_CMPF_Msk = 0x3f
	// No compare event has occurred for a particular VALx value.
	PWM_SM2STS_CMPF_CMPF_0 = 0x0
	// A compare event has occurred for a particular VALx value.
	PWM_SM2STS_CMPF_CMPF_1 = 0x1
	// Position of CFX0 field.
	PWM_SM2STS_CFX0_Pos = 0x6
	// Bit mask of CFX0 field.
	PWM_SM2STS_CFX0_Msk = 0x40
	// Bit CFX0.
	PWM_SM2STS_CFX0 = 0x40
	// Position of CFX1 field.
	PWM_SM2STS_CFX1_Pos = 0x7
	// Bit mask of CFX1 field.
	PWM_SM2STS_CFX1_Msk = 0x80
	// Bit CFX1.
	PWM_SM2STS_CFX1 = 0x80
	// Position of CFB0 field.
	PWM_SM2STS_CFB0_Pos = 0x8
	// Bit mask of CFB0 field.
	PWM_SM2STS_CFB0_Msk = 0x100
	// Bit CFB0.
	PWM_SM2STS_CFB0 = 0x100
	// Position of CFB1 field.
	PWM_SM2STS_CFB1_Pos = 0x9
	// Bit mask of CFB1 field.
	PWM_SM2STS_CFB1_Msk = 0x200
	// Bit CFB1.
	PWM_SM2STS_CFB1 = 0x200
	// Position of CFA0 field.
	PWM_SM2STS_CFA0_Pos = 0xa
	// Bit mask of CFA0 field.
	PWM_SM2STS_CFA0_Msk = 0x400
	// Bit CFA0.
	PWM_SM2STS_CFA0 = 0x400
	// Position of CFA1 field.
	PWM_SM2STS_CFA1_Pos = 0xb
	// Bit mask of CFA1 field.
	PWM_SM2STS_CFA1_Msk = 0x800
	// Bit CFA1.
	PWM_SM2STS_CFA1 = 0x800
	// Position of RF field.
	PWM_SM2STS_RF_Pos = 0xc
	// Bit mask of RF field.
	PWM_SM2STS_RF_Msk = 0x1000
	// Bit RF.
	PWM_SM2STS_RF = 0x1000
	// No new reload cycle since last STS[RF] clearing
	PWM_SM2STS_RF_RF_0 = 0x0
	// New reload cycle since last STS[RF] clearing
	PWM_SM2STS_RF_RF_1 = 0x1
	// Position of REF field.
	PWM_SM2STS_REF_Pos = 0xd
	// Bit mask of REF field.
	PWM_SM2STS_REF_Msk = 0x2000
	// Bit REF.
	PWM_SM2STS_REF = 0x2000
	// No reload error occurred.
	PWM_SM2STS_REF_REF_0 = 0x0
	// Reload signal occurred with non-coherent data and MCTRL[LDOK] = 0.
	PWM_SM2STS_REF_REF_1 = 0x1
	// Position of RUF field.
	PWM_SM2STS_RUF_Pos = 0xe
	// Bit mask of RUF field.
	PWM_SM2STS_RUF_Msk = 0x4000
	// Bit RUF.
	PWM_SM2STS_RUF = 0x4000
	// No register update has occurred since last reload.
	PWM_SM2STS_RUF_RUF_0 = 0x0
	// At least one of the double buffered registers has been updated since the last reload.
	PWM_SM2STS_RUF_RUF_1 = 0x1

	// SM2INTEN: Interrupt Enable Register
	// Position of CMPIE field.
	PWM_SM2INTEN_CMPIE_Pos = 0x0
	// Bit mask of CMPIE field.
	PWM_SM2INTEN_CMPIE_Msk = 0x3f
	// The corresponding STS[CMPF] bit will not cause an interrupt request.
	PWM_SM2INTEN_CMPIE_CMPIE_0 = 0x0
	// The corresponding STS[CMPF] bit will cause an interrupt request.
	PWM_SM2INTEN_CMPIE_CMPIE_1 = 0x1
	// Position of CX0IE field.
	PWM_SM2INTEN_CX0IE_Pos = 0x6
	// Bit mask of CX0IE field.
	PWM_SM2INTEN_CX0IE_Msk = 0x40
	// Bit CX0IE.
	PWM_SM2INTEN_CX0IE = 0x40
	// Interrupt request disabled for STS[CFX0].
	PWM_SM2INTEN_CX0IE_CX0IE_0 = 0x0
	// Interrupt request enabled for STS[CFX0].
	PWM_SM2INTEN_CX0IE_CX0IE_1 = 0x1
	// Position of CX1IE field.
	PWM_SM2INTEN_CX1IE_Pos = 0x7
	// Bit mask of CX1IE field.
	PWM_SM2INTEN_CX1IE_Msk = 0x80
	// Bit CX1IE.
	PWM_SM2INTEN_CX1IE = 0x80
	// Interrupt request disabled for STS[CFX1].
	PWM_SM2INTEN_CX1IE_CX1IE_0 = 0x0
	// Interrupt request enabled for STS[CFX1].
	PWM_SM2INTEN_CX1IE_CX1IE_1 = 0x1
	// Position of CB0IE field.
	PWM_SM2INTEN_CB0IE_Pos = 0x8
	// Bit mask of CB0IE field.
	PWM_SM2INTEN_CB0IE_Msk = 0x100
	// Bit CB0IE.
	PWM_SM2INTEN_CB0IE = 0x100
	// Interrupt request disabled for STS[CFB0].
	PWM_SM2INTEN_CB0IE_CB0IE_0 = 0x0
	// Interrupt request enabled for STS[CFB0].
	PWM_SM2INTEN_CB0IE_CB0IE_1 = 0x1
	// Position of CB1IE field.
	PWM_SM2INTEN_CB1IE_Pos = 0x9
	// Bit mask of CB1IE field.
	PWM_SM2INTEN_CB1IE_Msk = 0x200
	// Bit CB1IE.
	PWM_SM2INTEN_CB1IE = 0x200
	// Interrupt request disabled for STS[CFB1].
	PWM_SM2INTEN_CB1IE_CB1IE_0 = 0x0
	// Interrupt request enabled for STS[CFB1].
	PWM_SM2INTEN_CB1IE_CB1IE_1 = 0x1
	// Position of CA0IE field.
	PWM_SM2INTEN_CA0IE_Pos = 0xa
	// Bit mask of CA0IE field.
	PWM_SM2INTEN_CA0IE_Msk = 0x400
	// Bit CA0IE.
	PWM_SM2INTEN_CA0IE = 0x400
	// Interrupt request disabled for STS[CFA0].
	PWM_SM2INTEN_CA0IE_CA0IE_0 = 0x0
	// Interrupt request enabled for STS[CFA0].
	PWM_SM2INTEN_CA0IE_CA0IE_1 = 0x1
	// Position of CA1IE field.
	PWM_SM2INTEN_CA1IE_Pos = 0xb
	// Bit mask of CA1IE field.
	PWM_SM2INTEN_CA1IE_Msk = 0x800
	// Bit CA1IE.
	PWM_SM2INTEN_CA1IE = 0x800
	// Interrupt request disabled for STS[CFA1].
	PWM_SM2INTEN_CA1IE_CA1IE_0 = 0x0
	// Interrupt request enabled for STS[CFA1].
	PWM_SM2INTEN_CA1IE_CA1IE_1 = 0x1
	// Position of RIE field.
	PWM_SM2INTEN_RIE_Pos = 0xc
	// Bit mask of RIE field.
	PWM_SM2INTEN_RIE_Msk = 0x1000
	// Bit RIE.
	PWM_SM2INTEN_RIE = 0x1000
	// STS[RF] CPU interrupt requests disabled
	PWM_SM2INTEN_RIE_RIE_0 = 0x0
	// STS[RF] CPU interrupt requests enabled
	PWM_SM2INTEN_RIE_RIE_1 = 0x1
	// Position of REIE field.
	PWM_SM2INTEN_REIE_Pos = 0xd
	// Bit mask of REIE field.
	PWM_SM2INTEN_REIE_Msk = 0x2000
	// Bit REIE.
	PWM_SM2INTEN_REIE = 0x2000
	// STS[REF] CPU interrupt requests disabled
	PWM_SM2INTEN_REIE_REIE_0 = 0x0
	// STS[REF] CPU interrupt requests enabled
	PWM_SM2INTEN_REIE_REIE_1 = 0x1

	// SM2DMAEN: DMA Enable Register
	// Position of CX0DE field.
	PWM_SM2DMAEN_CX0DE_Pos = 0x0
	// Bit mask of CX0DE field.
	PWM_SM2DMAEN_CX0DE_Msk = 0x1
	// Bit CX0DE.
	PWM_SM2DMAEN_CX0DE = 0x1
	// Position of CX1DE field.
	PWM_SM2DMAEN_CX1DE_Pos = 0x1
	// Bit mask of CX1DE field.
	PWM_SM2DMAEN_CX1DE_Msk = 0x2
	// Bit CX1DE.
	PWM_SM2DMAEN_CX1DE = 0x2
	// Position of CB0DE field.
	PWM_SM2DMAEN_CB0DE_Pos = 0x2
	// Bit mask of CB0DE field.
	PWM_SM2DMAEN_CB0DE_Msk = 0x4
	// Bit CB0DE.
	PWM_SM2DMAEN_CB0DE = 0x4
	// Position of CB1DE field.
	PWM_SM2DMAEN_CB1DE_Pos = 0x3
	// Bit mask of CB1DE field.
	PWM_SM2DMAEN_CB1DE_Msk = 0x8
	// Bit CB1DE.
	PWM_SM2DMAEN_CB1DE = 0x8
	// Position of CA0DE field.
	PWM_SM2DMAEN_CA0DE_Pos = 0x4
	// Bit mask of CA0DE field.
	PWM_SM2DMAEN_CA0DE_Msk = 0x10
	// Bit CA0DE.
	PWM_SM2DMAEN_CA0DE = 0x10
	// Position of CA1DE field.
	PWM_SM2DMAEN_CA1DE_Pos = 0x5
	// Bit mask of CA1DE field.
	PWM_SM2DMAEN_CA1DE_Msk = 0x20
	// Bit CA1DE.
	PWM_SM2DMAEN_CA1DE = 0x20
	// Position of CAPTDE field.
	PWM_SM2DMAEN_CAPTDE_Pos = 0x6
	// Bit mask of CAPTDE field.
	PWM_SM2DMAEN_CAPTDE_Msk = 0xc0
	// Read DMA requests disabled.
	PWM_SM2DMAEN_CAPTDE_CAPTDE_0 = 0x0
	// Exceeding a FIFO watermark sets the DMA read request. This requires at least one of DMAEN[CA1DE], DMAEN[CA0DE], DMAEN[CB1DE], DMAEN[CB0DE], DMAEN[CX1DE], or DMAEN[CX0DE] to also be set in order to determine to which watermark(s) the DMA request is sensitive.
	PWM_SM2DMAEN_CAPTDE_CAPTDE_1 = 0x1
	// A local sync (VAL1 matches counter) sets the read DMA request.
	PWM_SM2DMAEN_CAPTDE_CAPTDE_2 = 0x2
	// A local reload (STS[RF] being set) sets the read DMA request.
	PWM_SM2DMAEN_CAPTDE_CAPTDE_3 = 0x3
	// Position of FAND field.
	PWM_SM2DMAEN_FAND_Pos = 0x8
	// Bit mask of FAND field.
	PWM_SM2DMAEN_FAND_Msk = 0x100
	// Bit FAND.
	PWM_SM2DMAEN_FAND = 0x100
	// Selected FIFO watermarks are OR'ed together.
	PWM_SM2DMAEN_FAND_FAND_0 = 0x0
	// Selected FIFO watermarks are AND'ed together.
	PWM_SM2DMAEN_FAND_FAND_1 = 0x1
	// Position of VALDE field.
	PWM_SM2DMAEN_VALDE_Pos = 0x9
	// Bit mask of VALDE field.
	PWM_SM2DMAEN_VALDE_Msk = 0x200
	// Bit VALDE.
	PWM_SM2DMAEN_VALDE = 0x200
	// DMA write requests disabled
	PWM_SM2DMAEN_VALDE_VALDE_0 = 0x0
	// DMA write requests for the VALx and FRACVALx registers enabled
	PWM_SM2DMAEN_VALDE_VALDE_1 = 0x1

	// SM2TCTRL: Output Trigger Control Register
	// Position of OUT_TRIG_EN field.
	PWM_SM2TCTRL_OUT_TRIG_EN_Pos = 0x0
	// Bit mask of OUT_TRIG_EN field.
	PWM_SM2TCTRL_OUT_TRIG_EN_Msk = 0x3f
	// PWM_OUT_TRIGx will not set when the counter value matches the VALx value.
	PWM_SM2TCTRL_OUT_TRIG_EN_OUT_TRIG_EN_0 = 0x0
	// PWM_OUT_TRIGx will set when the counter value matches the VALx value.
	PWM_SM2TCTRL_OUT_TRIG_EN_OUT_TRIG_EN_1 = 0x1
	// Position of TRGFRQ field.
	PWM_SM2TCTRL_TRGFRQ_Pos = 0xc
	// Bit mask of TRGFRQ field.
	PWM_SM2TCTRL_TRGFRQ_Msk = 0x1000
	// Bit TRGFRQ.
	PWM_SM2TCTRL_TRGFRQ = 0x1000
	// Trigger outputs are generated during every PWM period even if the PWM is not reloaded every period due to CTRL[LDFQ] being non-zero.
	PWM_SM2TCTRL_TRGFRQ_TRGFRQ_0 = 0x0
	// Trigger outputs are generated only during the final PWM period prior to a reload opportunity when the PWM is not reloaded every period due to CTRL[LDFQ] being non-zero.
	PWM_SM2TCTRL_TRGFRQ_TRGFRQ_1 = 0x1
	// Position of PWBOT1 field.
	PWM_SM2TCTRL_PWBOT1_Pos = 0xe
	// Bit mask of PWBOT1 field.
	PWM_SM2TCTRL_PWBOT1_Msk = 0x4000
	// Bit PWBOT1.
	PWM_SM2TCTRL_PWBOT1 = 0x4000
	// Route the PWM_OUT_TRIG1 signal to PWM_OUT_TRIG1 port.
	PWM_SM2TCTRL_PWBOT1_PWBOT1_0 = 0x0
	// Route the PWMB output to the PWM_OUT_TRIG1 port.
	PWM_SM2TCTRL_PWBOT1_PWBOT1_1 = 0x1
	// Position of PWAOT0 field.
	PWM_SM2TCTRL_PWAOT0_Pos = 0xf
	// Bit mask of PWAOT0 field.
	PWM_SM2TCTRL_PWAOT0_Msk = 0x8000
	// Bit PWAOT0.
	PWM_SM2TCTRL_PWAOT0 = 0x8000
	// Route the PWM_OUT_TRIG0 signal to PWM_OUT_TRIG0 port.
	PWM_SM2TCTRL_PWAOT0_PWAOT0_0 = 0x0
	// Route the PWMA output to the PWM_OUT_TRIG0 port.
	PWM_SM2TCTRL_PWAOT0_PWAOT0_1 = 0x1

	// SM2DISMAP0: Fault Disable Mapping Register 0
	// Position of DIS0A field.
	PWM_SM2DISMAP0_DIS0A_Pos = 0x0
	// Bit mask of DIS0A field.
	PWM_SM2DISMAP0_DIS0A_Msk = 0xf
	// Position of DIS0B field.
	PWM_SM2DISMAP0_DIS0B_Pos = 0x4
	// Bit mask of DIS0B field.
	PWM_SM2DISMAP0_DIS0B_Msk = 0xf0
	// Position of DIS0X field.
	PWM_SM2DISMAP0_DIS0X_Pos = 0x8
	// Bit mask of DIS0X field.
	PWM_SM2DISMAP0_DIS0X_Msk = 0xf00

	// SM2DISMAP1: Fault Disable Mapping Register 1
	// Position of DIS1A field.
	PWM_SM2DISMAP1_DIS1A_Pos = 0x0
	// Bit mask of DIS1A field.
	PWM_SM2DISMAP1_DIS1A_Msk = 0xf
	// Position of DIS1B field.
	PWM_SM2DISMAP1_DIS1B_Pos = 0x4
	// Bit mask of DIS1B field.
	PWM_SM2DISMAP1_DIS1B_Msk = 0xf0
	// Position of DIS1X field.
	PWM_SM2DISMAP1_DIS1X_Pos = 0x8
	// Bit mask of DIS1X field.
	PWM_SM2DISMAP1_DIS1X_Msk = 0xf00

	// SM2DTCNT0: Deadtime Count Register 0
	// Position of DTCNT0 field.
	PWM_SM2DTCNT0_DTCNT0_Pos = 0x0
	// Bit mask of DTCNT0 field.
	PWM_SM2DTCNT0_DTCNT0_Msk = 0xffff

	// SM2DTCNT1: Deadtime Count Register 1
	// Position of DTCNT1 field.
	PWM_SM2DTCNT1_DTCNT1_Pos = 0x0
	// Bit mask of DTCNT1 field.
	PWM_SM2DTCNT1_DTCNT1_Msk = 0xffff

	// SM2CAPTCTRLA: Capture Control A Register
	// Position of ARMA field.
	PWM_SM2CAPTCTRLA_ARMA_Pos = 0x0
	// Bit mask of ARMA field.
	PWM_SM2CAPTCTRLA_ARMA_Msk = 0x1
	// Bit ARMA.
	PWM_SM2CAPTCTRLA_ARMA = 0x1
	// Input capture operation is disabled.
	PWM_SM2CAPTCTRLA_ARMA_ARMA_0 = 0x0
	// Input capture operation as specified by CAPTCTRLA[EDGAx] is enabled.
	PWM_SM2CAPTCTRLA_ARMA_ARMA_1 = 0x1
	// Position of ONESHOTA field.
	PWM_SM2CAPTCTRLA_ONESHOTA_Pos = 0x1
	// Bit mask of ONESHOTA field.
	PWM_SM2CAPTCTRLA_ONESHOTA_Msk = 0x2
	// Bit ONESHOTA.
	PWM_SM2CAPTCTRLA_ONESHOTA = 0x2
	// Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLA[ARMA] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
	PWM_SM2CAPTCTRLA_ONESHOTA_ONESHOTA_0 = 0x0
	// One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLA[ARMA] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and CAPTCTRLA[ARMA] is cleared. No further captures will be performed until CAPTCTRLA[ARMA] is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and CAPTCTRLA[ARMA] is then cleared.
	PWM_SM2CAPTCTRLA_ONESHOTA_ONESHOTA_1 = 0x1
	// Position of EDGA0 field.
	PWM_SM2CAPTCTRLA_EDGA0_Pos = 0x2
	// Bit mask of EDGA0 field.
	PWM_SM2CAPTCTRLA_EDGA0_Msk = 0xc
	// Disabled
	PWM_SM2CAPTCTRLA_EDGA0_EDGA0_0 = 0x0
	// Capture falling edges
	PWM_SM2CAPTCTRLA_EDGA0_EDGA0_1 = 0x1
	// Capture rising edges
	PWM_SM2CAPTCTRLA_EDGA0_EDGA0_2 = 0x2
	// Capture any edge
	PWM_SM2CAPTCTRLA_EDGA0_EDGA0_3 = 0x3
	// Position of EDGA1 field.
	PWM_SM2CAPTCTRLA_EDGA1_Pos = 0x4
	// Bit mask of EDGA1 field.
	PWM_SM2CAPTCTRLA_EDGA1_Msk = 0x30
	// Disabled
	PWM_SM2CAPTCTRLA_EDGA1_EDGA1_0 = 0x0
	// Capture falling edges
	PWM_SM2CAPTCTRLA_EDGA1_EDGA1_1 = 0x1
	// Capture rising edges
	PWM_SM2CAPTCTRLA_EDGA1_EDGA1_2 = 0x2
	// Capture any edge
	PWM_SM2CAPTCTRLA_EDGA1_EDGA1_3 = 0x3
	// Position of INP_SELA field.
	PWM_SM2CAPTCTRLA_INP_SELA_Pos = 0x6
	// Bit mask of INP_SELA field.
	PWM_SM2CAPTCTRLA_INP_SELA_Msk = 0x40
	// Bit INP_SELA.
	PWM_SM2CAPTCTRLA_INP_SELA = 0x40
	// Raw PWM_A input signal selected as source.
	PWM_SM2CAPTCTRLA_INP_SELA_INP_SELA_0 = 0x0
	// Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLA[EDGA0] and CAPTCTRLA[EDGA1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRA[EDGA0] and/or CAPTCTRLA[EDGA1] fields in order to enable one or both of the capture registers.
	PWM_SM2CAPTCTRLA_INP_SELA_INP_SELA_1 = 0x1
	// Position of EDGCNTA_EN field.
	PWM_SM2CAPTCTRLA_EDGCNTA_EN_Pos = 0x7
	// Bit mask of EDGCNTA_EN field.
	PWM_SM2CAPTCTRLA_EDGCNTA_EN_Msk = 0x80
	// Bit EDGCNTA_EN.
	PWM_SM2CAPTCTRLA_EDGCNTA_EN = 0x80
	// Edge counter disabled and held in reset
	PWM_SM2CAPTCTRLA_EDGCNTA_EN_EDGCNTA_EN_0 = 0x0
	// Edge counter enabled
	PWM_SM2CAPTCTRLA_EDGCNTA_EN_EDGCNTA_EN_1 = 0x1
	// Position of CFAWM field.
	PWM_SM2CAPTCTRLA_CFAWM_Pos = 0x8
	// Bit mask of CFAWM field.
	PWM_SM2CAPTCTRLA_CFAWM_Msk = 0x300
	// Position of CA0CNT field.
	PWM_SM2CAPTCTRLA_CA0CNT_Pos = 0xa
	// Bit mask of CA0CNT field.
	PWM_SM2CAPTCTRLA_CA0CNT_Msk = 0x1c00
	// Position of CA1CNT field.
	PWM_SM2CAPTCTRLA_CA1CNT_Pos = 0xd
	// Bit mask of CA1CNT field.
	PWM_SM2CAPTCTRLA_CA1CNT_Msk = 0xe000

	// SM2CAPTCOMPA: Capture Compare A Register
	// Position of EDGCMPA field.
	PWM_SM2CAPTCOMPA_EDGCMPA_Pos = 0x0
	// Bit mask of EDGCMPA field.
	PWM_SM2CAPTCOMPA_EDGCMPA_Msk = 0xff
	// Position of EDGCNTA field.
	PWM_SM2CAPTCOMPA_EDGCNTA_Pos = 0x8
	// Bit mask of EDGCNTA field.
	PWM_SM2CAPTCOMPA_EDGCNTA_Msk = 0xff00

	// SM2CAPTCTRLB: Capture Control B Register
	// Position of ARMB field.
	PWM_SM2CAPTCTRLB_ARMB_Pos = 0x0
	// Bit mask of ARMB field.
	PWM_SM2CAPTCTRLB_ARMB_Msk = 0x1
	// Bit ARMB.
	PWM_SM2CAPTCTRLB_ARMB = 0x1
	// Input capture operation is disabled.
	PWM_SM2CAPTCTRLB_ARMB_ARMB_0 = 0x0
	// Input capture operation as specified by CAPTCTRLB[EDGBx] is enabled.
	PWM_SM2CAPTCTRLB_ARMB_ARMB_1 = 0x1
	// Position of ONESHOTB field.
	PWM_SM2CAPTCTRLB_ONESHOTB_Pos = 0x1
	// Bit mask of ONESHOTB field.
	PWM_SM2CAPTCTRLB_ONESHOTB_Msk = 0x2
	// Bit ONESHOTB.
	PWM_SM2CAPTCTRLB_ONESHOTB = 0x2
	// Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLB[ARMB] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
	PWM_SM2CAPTCTRLB_ONESHOTB_ONESHOTB_0 = 0x0
	// One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLB[ARMB] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and CAPTCTRLB[ARMB] is cleared. No further captures will be performed until CAPTCTRLB[ARMB] is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and CAPTCTRLB[ARMB] is then cleared.
	PWM_SM2CAPTCTRLB_ONESHOTB_ONESHOTB_1 = 0x1
	// Position of EDGB0 field.
	PWM_SM2CAPTCTRLB_EDGB0_Pos = 0x2
	// Bit mask of EDGB0 field.
	PWM_SM2CAPTCTRLB_EDGB0_Msk = 0xc
	// Disabled
	PWM_SM2CAPTCTRLB_EDGB0_EDGB0_0 = 0x0
	// Capture falling edges
	PWM_SM2CAPTCTRLB_EDGB0_EDGB0_1 = 0x1
	// Capture rising edges
	PWM_SM2CAPTCTRLB_EDGB0_EDGB0_2 = 0x2
	// Capture any edge
	PWM_SM2CAPTCTRLB_EDGB0_EDGB0_3 = 0x3
	// Position of EDGB1 field.
	PWM_SM2CAPTCTRLB_EDGB1_Pos = 0x4
	// Bit mask of EDGB1 field.
	PWM_SM2CAPTCTRLB_EDGB1_Msk = 0x30
	// Disabled
	PWM_SM2CAPTCTRLB_EDGB1_EDGB1_0 = 0x0
	// Capture falling edges
	PWM_SM2CAPTCTRLB_EDGB1_EDGB1_1 = 0x1
	// Capture rising edges
	PWM_SM2CAPTCTRLB_EDGB1_EDGB1_2 = 0x2
	// Capture any edge
	PWM_SM2CAPTCTRLB_EDGB1_EDGB1_3 = 0x3
	// Position of INP_SELB field.
	PWM_SM2CAPTCTRLB_INP_SELB_Pos = 0x6
	// Bit mask of INP_SELB field.
	PWM_SM2CAPTCTRLB_INP_SELB_Msk = 0x40
	// Bit INP_SELB.
	PWM_SM2CAPTCTRLB_INP_SELB = 0x40
	// Raw PWM_B input signal selected as source.
	PWM_SM2CAPTCTRLB_INP_SELB_INP_SELB_0 = 0x0
	// Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLB[EDGB0] and CAPTCTRLB[EDGB1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRB[EDGB0] and/or CAPTCTRLB[EDGB1] fields in order to enable one or both of the capture registers.
	PWM_SM2CAPTCTRLB_INP_SELB_INP_SELB_1 = 0x1
	// Position of EDGCNTB_EN field.
	PWM_SM2CAPTCTRLB_EDGCNTB_EN_Pos = 0x7
	// Bit mask of EDGCNTB_EN field.
	PWM_SM2CAPTCTRLB_EDGCNTB_EN_Msk = 0x80
	// Bit EDGCNTB_EN.
	PWM_SM2CAPTCTRLB_EDGCNTB_EN = 0x80
	// Edge counter disabled and held in reset
	PWM_SM2CAPTCTRLB_EDGCNTB_EN_EDGCNTB_EN_0 = 0x0
	// Edge counter enabled
	PWM_SM2CAPTCTRLB_EDGCNTB_EN_EDGCNTB_EN_1 = 0x1
	// Position of CFBWM field.
	PWM_SM2CAPTCTRLB_CFBWM_Pos = 0x8
	// Bit mask of CFBWM field.
	PWM_SM2CAPTCTRLB_CFBWM_Msk = 0x300
	// Position of CB0CNT field.
	PWM_SM2CAPTCTRLB_CB0CNT_Pos = 0xa
	// Bit mask of CB0CNT field.
	PWM_SM2CAPTCTRLB_CB0CNT_Msk = 0x1c00
	// Position of CB1CNT field.
	PWM_SM2CAPTCTRLB_CB1CNT_Pos = 0xd
	// Bit mask of CB1CNT field.
	PWM_SM2CAPTCTRLB_CB1CNT_Msk = 0xe000

	// SM2CAPTCOMPB: Capture Compare B Register
	// Position of EDGCMPB field.
	PWM_SM2CAPTCOMPB_EDGCMPB_Pos = 0x0
	// Bit mask of EDGCMPB field.
	PWM_SM2CAPTCOMPB_EDGCMPB_Msk = 0xff
	// Position of EDGCNTB field.
	PWM_SM2CAPTCOMPB_EDGCNTB_Pos = 0x8
	// Bit mask of EDGCNTB field.
	PWM_SM2CAPTCOMPB_EDGCNTB_Msk = 0xff00

	// SM2CAPTCTRLX: Capture Control X Register
	// Position of ARMX field.
	PWM_SM2CAPTCTRLX_ARMX_Pos = 0x0
	// Bit mask of ARMX field.
	PWM_SM2CAPTCTRLX_ARMX_Msk = 0x1
	// Bit ARMX.
	PWM_SM2CAPTCTRLX_ARMX = 0x1
	// Input capture operation is disabled.
	PWM_SM2CAPTCTRLX_ARMX_ARMX_0 = 0x0
	// Input capture operation as specified by CAPTCTRLX[EDGXx] is enabled.
	PWM_SM2CAPTCTRLX_ARMX_ARMX_1 = 0x1
	// Position of ONESHOTX field.
	PWM_SM2CAPTCTRLX_ONESHOTX_Pos = 0x1
	// Bit mask of ONESHOTX field.
	PWM_SM2CAPTCTRLX_ONESHOTX_Msk = 0x2
	// Bit ONESHOTX.
	PWM_SM2CAPTCTRLX_ONESHOTX = 0x2
	// Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after the ARMX bit is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
	PWM_SM2CAPTCTRLX_ONESHOTX_ONESHOTX_0 = 0x0
	// One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after the ARMX bit is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and the ARMX bit is cleared. No further captures will be performed until the ARMX bit is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and the ARMX bit is then cleared.
	PWM_SM2CAPTCTRLX_ONESHOTX_ONESHOTX_1 = 0x1
	// Position of EDGX0 field.
	PWM_SM2CAPTCTRLX_EDGX0_Pos = 0x2
	// Bit mask of EDGX0 field.
	PWM_SM2CAPTCTRLX_EDGX0_Msk = 0xc
	// Disabled
	PWM_SM2CAPTCTRLX_EDGX0_EDGX0_0 = 0x0
	// Capture falling edges
	PWM_SM2CAPTCTRLX_EDGX0_EDGX0_1 = 0x1
	// Capture rising edges
	PWM_SM2CAPTCTRLX_EDGX0_EDGX0_2 = 0x2
	// Capture any edge
	PWM_SM2CAPTCTRLX_EDGX0_EDGX0_3 = 0x3
	// Position of EDGX1 field.
	PWM_SM2CAPTCTRLX_EDGX1_Pos = 0x4
	// Bit mask of EDGX1 field.
	PWM_SM2CAPTCTRLX_EDGX1_Msk = 0x30
	// Disabled
	PWM_SM2CAPTCTRLX_EDGX1_EDGX1_0 = 0x0
	// Capture falling edges
	PWM_SM2CAPTCTRLX_EDGX1_EDGX1_1 = 0x1
	// Capture rising edges
	PWM_SM2CAPTCTRLX_EDGX1_EDGX1_2 = 0x2
	// Capture any edge
	PWM_SM2CAPTCTRLX_EDGX1_EDGX1_3 = 0x3
	// Position of INP_SELX field.
	PWM_SM2CAPTCTRLX_INP_SELX_Pos = 0x6
	// Bit mask of INP_SELX field.
	PWM_SM2CAPTCTRLX_INP_SELX_Msk = 0x40
	// Bit INP_SELX.
	PWM_SM2CAPTCTRLX_INP_SELX = 0x40
	// Raw PWM_X input signal selected as source.
	PWM_SM2CAPTCTRLX_INP_SELX_INP_SELX_0 = 0x0
	// Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLX[EDGX0] and CAPTCTRLX[EDGX1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRX[EDGX0] and/or CAPTCTRLX[EDGX1] fields in order to enable one or both of the capture registers.
	PWM_SM2CAPTCTRLX_INP_SELX_INP_SELX_1 = 0x1
	// Position of EDGCNTX_EN field.
	PWM_SM2CAPTCTRLX_EDGCNTX_EN_Pos = 0x7
	// Bit mask of EDGCNTX_EN field.
	PWM_SM2CAPTCTRLX_EDGCNTX_EN_Msk = 0x80
	// Bit EDGCNTX_EN.
	PWM_SM2CAPTCTRLX_EDGCNTX_EN = 0x80
	// Edge counter disabled and held in reset
	PWM_SM2CAPTCTRLX_EDGCNTX_EN_EDGCNTX_EN_0 = 0x0
	// Edge counter enabled
	PWM_SM2CAPTCTRLX_EDGCNTX_EN_EDGCNTX_EN_1 = 0x1
	// Position of CFXWM field.
	PWM_SM2CAPTCTRLX_CFXWM_Pos = 0x8
	// Bit mask of CFXWM field.
	PWM_SM2CAPTCTRLX_CFXWM_Msk = 0x300
	// Position of CX0CNT field.
	PWM_SM2CAPTCTRLX_CX0CNT_Pos = 0xa
	// Bit mask of CX0CNT field.
	PWM_SM2CAPTCTRLX_CX0CNT_Msk = 0x1c00
	// Position of CX1CNT field.
	PWM_SM2CAPTCTRLX_CX1CNT_Pos = 0xd
	// Bit mask of CX1CNT field.
	PWM_SM2CAPTCTRLX_CX1CNT_Msk = 0xe000

	// SM2CAPTCOMPX: Capture Compare X Register
	// Position of EDGCMPX field.
	PWM_SM2CAPTCOMPX_EDGCMPX_Pos = 0x0
	// Bit mask of EDGCMPX field.
	PWM_SM2CAPTCOMPX_EDGCMPX_Msk = 0xff
	// Position of EDGCNTX field.
	PWM_SM2CAPTCOMPX_EDGCNTX_Pos = 0x8
	// Bit mask of EDGCNTX field.
	PWM_SM2CAPTCOMPX_EDGCNTX_Msk = 0xff00

	// SM2CVAL0: Capture Value 0 Register
	// Position of CAPTVAL0 field.
	PWM_SM2CVAL0_CAPTVAL0_Pos = 0x0
	// Bit mask of CAPTVAL0 field.
	PWM_SM2CVAL0_CAPTVAL0_Msk = 0xffff

	// SM2CVAL0CYC: Capture Value 0 Cycle Register
	// Position of CVAL0CYC field.
	PWM_SM2CVAL0CYC_CVAL0CYC_Pos = 0x0
	// Bit mask of CVAL0CYC field.
	PWM_SM2CVAL0CYC_CVAL0CYC_Msk = 0xf

	// SM2CVAL1: Capture Value 1 Register
	// Position of CAPTVAL1 field.
	PWM_SM2CVAL1_CAPTVAL1_Pos = 0x0
	// Bit mask of CAPTVAL1 field.
	PWM_SM2CVAL1_CAPTVAL1_Msk = 0xffff

	// SM2CVAL1CYC: Capture Value 1 Cycle Register
	// Position of CVAL1CYC field.
	PWM_SM2CVAL1CYC_CVAL1CYC_Pos = 0x0
	// Bit mask of CVAL1CYC field.
	PWM_SM2CVAL1CYC_CVAL1CYC_Msk = 0xf

	// SM2CVAL2: Capture Value 2 Register
	// Position of CAPTVAL2 field.
	PWM_SM2CVAL2_CAPTVAL2_Pos = 0x0
	// Bit mask of CAPTVAL2 field.
	PWM_SM2CVAL2_CAPTVAL2_Msk = 0xffff

	// SM2CVAL2CYC: Capture Value 2 Cycle Register
	// Position of CVAL2CYC field.
	PWM_SM2CVAL2CYC_CVAL2CYC_Pos = 0x0
	// Bit mask of CVAL2CYC field.
	PWM_SM2CVAL2CYC_CVAL2CYC_Msk = 0xf

	// SM2CVAL3: Capture Value 3 Register
	// Position of CAPTVAL3 field.
	PWM_SM2CVAL3_CAPTVAL3_Pos = 0x0
	// Bit mask of CAPTVAL3 field.
	PWM_SM2CVAL3_CAPTVAL3_Msk = 0xffff

	// SM2CVAL3CYC: Capture Value 3 Cycle Register
	// Position of CVAL3CYC field.
	PWM_SM2CVAL3CYC_CVAL3CYC_Pos = 0x0
	// Bit mask of CVAL3CYC field.
	PWM_SM2CVAL3CYC_CVAL3CYC_Msk = 0xf

	// SM2CVAL4: Capture Value 4 Register
	// Position of CAPTVAL4 field.
	PWM_SM2CVAL4_CAPTVAL4_Pos = 0x0
	// Bit mask of CAPTVAL4 field.
	PWM_SM2CVAL4_CAPTVAL4_Msk = 0xffff

	// SM2CVAL4CYC: Capture Value 4 Cycle Register
	// Position of CVAL4CYC field.
	PWM_SM2CVAL4CYC_CVAL4CYC_Pos = 0x0
	// Bit mask of CVAL4CYC field.
	PWM_SM2CVAL4CYC_CVAL4CYC_Msk = 0xf

	// SM2CVAL5: Capture Value 5 Register
	// Position of CAPTVAL5 field.
	PWM_SM2CVAL5_CAPTVAL5_Pos = 0x0
	// Bit mask of CAPTVAL5 field.
	PWM_SM2CVAL5_CAPTVAL5_Msk = 0xffff

	// SM2CVAL5CYC: Capture Value 5 Cycle Register
	// Position of CVAL5CYC field.
	PWM_SM2CVAL5CYC_CVAL5CYC_Pos = 0x0
	// Bit mask of CVAL5CYC field.
	PWM_SM2CVAL5CYC_CVAL5CYC_Msk = 0xf

	// SM3CNT: Counter Register
	// Position of CNT field.
	PWM_SM3CNT_CNT_Pos = 0x0
	// Bit mask of CNT field.
	PWM_SM3CNT_CNT_Msk = 0xffff

	// SM3INIT: Initial Count Register
	// Position of INIT field.
	PWM_SM3INIT_INIT_Pos = 0x0
	// Bit mask of INIT field.
	PWM_SM3INIT_INIT_Msk = 0xffff

	// SM3CTRL2: Control 2 Register
	// Position of CLK_SEL field.
	PWM_SM3CTRL2_CLK_SEL_Pos = 0x0
	// Bit mask of CLK_SEL field.
	PWM_SM3CTRL2_CLK_SEL_Msk = 0x3
	// The IPBus clock is used as the clock for the local prescaler and counter.
	PWM_SM3CTRL2_CLK_SEL_CLK_SEL_0 = 0x0
	// EXT_CLK is used as the clock for the local prescaler and counter.
	PWM_SM3CTRL2_CLK_SEL_CLK_SEL_1 = 0x1
	// Submodule 0's clock (AUX_CLK) is used as the source clock for the local prescaler and counter. This setting should not be used in submodule 0 as it will force the clock to logic 0.
	PWM_SM3CTRL2_CLK_SEL_CLK_SEL_2 = 0x2
	// Position of RELOAD_SEL field.
	PWM_SM3CTRL2_RELOAD_SEL_Pos = 0x2
	// Bit mask of RELOAD_SEL field.
	PWM_SM3CTRL2_RELOAD_SEL_Msk = 0x4
	// Bit RELOAD_SEL.
	PWM_SM3CTRL2_RELOAD_SEL = 0x4
	// The local RELOAD signal is used to reload registers.
	PWM_SM3CTRL2_RELOAD_SEL_RELOAD_SEL_0 = 0x0
	// The master RELOAD signal (from submodule 0) is used to reload registers. This setting should not be used in submodule 0 as it will force the RELOAD signal to logic 0.
	PWM_SM3CTRL2_RELOAD_SEL_RELOAD_SEL_1 = 0x1
	// Position of FORCE_SEL field.
	PWM_SM3CTRL2_FORCE_SEL_Pos = 0x3
	// Bit mask of FORCE_SEL field.
	PWM_SM3CTRL2_FORCE_SEL_Msk = 0x38
	// The local force signal, CTRL2[FORCE], from this submodule is used to force updates.
	PWM_SM3CTRL2_FORCE_SEL_FORCE_SEL_0 = 0x0
	// The master force signal from submodule 0 is used to force updates. This setting should not be used in submodule 0 as it will hold the FORCE OUTPUT signal to logic 0.
	PWM_SM3CTRL2_FORCE_SEL_FORCE_SEL_1 = 0x1
	// The local reload signal from this submodule is used to force updates without regard to the state of LDOK.
	PWM_SM3CTRL2_FORCE_SEL_FORCE_SEL_2 = 0x2
	// The master reload signal from submodule0 is used to force updates if LDOK is set. This setting should not be used in submodule0 as it will hold the FORCE OUTPUT signal to logic 0.
	PWM_SM3CTRL2_FORCE_SEL_FORCE_SEL_3 = 0x3
	// The local sync signal from this submodule is used to force updates.
	PWM_SM3CTRL2_FORCE_SEL_FORCE_SEL_4 = 0x4
	// The master sync signal from submodule0 is used to force updates. This setting should not be used in submodule0 as it will hold the FORCE OUTPUT signal to logic 0.
	PWM_SM3CTRL2_FORCE_SEL_FORCE_SEL_5 = 0x5
	// The external force signal, EXT_FORCE, from outside the PWM module causes updates.
	PWM_SM3CTRL2_FORCE_SEL_FORCE_SEL_6 = 0x6
	// The external sync signal, EXT_SYNC, from outside the PWM module causes updates.
	PWM_SM3CTRL2_FORCE_SEL_FORCE_SEL_7 = 0x7
	// Position of FORCE field.
	PWM_SM3CTRL2_FORCE_Pos = 0x6
	// Bit mask of FORCE field.
	PWM_SM3CTRL2_FORCE_Msk = 0x40
	// Bit FORCE.
	PWM_SM3CTRL2_FORCE = 0x40
	// Position of FRCEN field.
	PWM_SM3CTRL2_FRCEN_Pos = 0x7
	// Bit mask of FRCEN field.
	PWM_SM3CTRL2_FRCEN_Msk = 0x80
	// Bit FRCEN.
	PWM_SM3CTRL2_FRCEN = 0x80
	// Initialization from a FORCE_OUT is disabled.
	PWM_SM3CTRL2_FRCEN_FRCEN_0 = 0x0
	// Initialization from a FORCE_OUT is enabled.
	PWM_SM3CTRL2_FRCEN_FRCEN_1 = 0x1
	// Position of INIT_SEL field.
	PWM_SM3CTRL2_INIT_SEL_Pos = 0x8
	// Bit mask of INIT_SEL field.
	PWM_SM3CTRL2_INIT_SEL_Msk = 0x300
	// Local sync (PWM_X) causes initialization.
	PWM_SM3CTRL2_INIT_SEL_INIT_SEL_0 = 0x0
	// Master reload from submodule 0 causes initialization. This setting should not be used in submodule 0 as it will force the INIT signal to logic 0. The submodule counter will only reinitialize when a master reload occurs.
	PWM_SM3CTRL2_INIT_SEL_INIT_SEL_1 = 0x1
	// Master sync from submodule 0 causes initialization. This setting should not be used in submodule 0 as it will force the INIT signal to logic 0.
	PWM_SM3CTRL2_INIT_SEL_INIT_SEL_2 = 0x2
	// EXT_SYNC causes initialization.
	PWM_SM3CTRL2_INIT_SEL_INIT_SEL_3 = 0x3
	// Position of PWMX_INIT field.
	PWM_SM3CTRL2_PWMX_INIT_Pos = 0xa
	// Bit mask of PWMX_INIT field.
	PWM_SM3CTRL2_PWMX_INIT_Msk = 0x400
	// Bit PWMX_INIT.
	PWM_SM3CTRL2_PWMX_INIT = 0x400
	// Position of PWM45_INIT field.
	PWM_SM3CTRL2_PWM45_INIT_Pos = 0xb
	// Bit mask of PWM45_INIT field.
	PWM_SM3CTRL2_PWM45_INIT_Msk = 0x800
	// Bit PWM45_INIT.
	PWM_SM3CTRL2_PWM45_INIT = 0x800
	// Position of PWM23_INIT field.
	PWM_SM3CTRL2_PWM23_INIT_Pos = 0xc
	// Bit mask of PWM23_INIT field.
	PWM_SM3CTRL2_PWM23_INIT_Msk = 0x1000
	// Bit PWM23_INIT.
	PWM_SM3CTRL2_PWM23_INIT = 0x1000
	// Position of INDEP field.
	PWM_SM3CTRL2_INDEP_Pos = 0xd
	// Bit mask of INDEP field.
	PWM_SM3CTRL2_INDEP_Msk = 0x2000
	// Bit INDEP.
	PWM_SM3CTRL2_INDEP = 0x2000
	// PWM_A and PWM_B form a complementary PWM pair.
	PWM_SM3CTRL2_INDEP_INDEP_0 = 0x0
	// PWM_A and PWM_B outputs are independent PWMs.
	PWM_SM3CTRL2_INDEP_INDEP_1 = 0x1
	// Position of WAITEN field.
	PWM_SM3CTRL2_WAITEN_Pos = 0xe
	// Bit mask of WAITEN field.
	PWM_SM3CTRL2_WAITEN_Msk = 0x4000
	// Bit WAITEN.
	PWM_SM3CTRL2_WAITEN = 0x4000
	// Position of DBGEN field.
	PWM_SM3CTRL2_DBGEN_Pos = 0xf
	// Bit mask of DBGEN field.
	PWM_SM3CTRL2_DBGEN_Msk = 0x8000
	// Bit DBGEN.
	PWM_SM3CTRL2_DBGEN = 0x8000

	// SM3CTRL: Control Register
	// Position of DBLEN field.
	PWM_SM3CTRL_DBLEN_Pos = 0x0
	// Bit mask of DBLEN field.
	PWM_SM3CTRL_DBLEN_Msk = 0x1
	// Bit DBLEN.
	PWM_SM3CTRL_DBLEN = 0x1
	// Double switching disabled.
	PWM_SM3CTRL_DBLEN_DBLEN_0 = 0x0
	// Double switching enabled.
	PWM_SM3CTRL_DBLEN_DBLEN_1 = 0x1
	// Position of DBLX field.
	PWM_SM3CTRL_DBLX_Pos = 0x1
	// Bit mask of DBLX field.
	PWM_SM3CTRL_DBLX_Msk = 0x2
	// Bit DBLX.
	PWM_SM3CTRL_DBLX = 0x2
	// PWMX double pulse disabled.
	PWM_SM3CTRL_DBLX_DBLX_0 = 0x0
	// PWMX double pulse enabled.
	PWM_SM3CTRL_DBLX_DBLX_1 = 0x1
	// Position of LDMOD field.
	PWM_SM3CTRL_LDMOD_Pos = 0x2
	// Bit mask of LDMOD field.
	PWM_SM3CTRL_LDMOD_Msk = 0x4
	// Bit LDMOD.
	PWM_SM3CTRL_LDMOD = 0x4
	// Buffered registers of this submodule are loaded and take effect at the next PWM reload if MCTRL[LDOK] is set.
	PWM_SM3CTRL_LDMOD_LDMOD_0 = 0x0
	// Buffered registers of this submodule are loaded and take effect immediately upon MCTRL[LDOK] being set. In this case it is not necessary to set CTRL[FULL] or CTRL[HALF].
	PWM_SM3CTRL_LDMOD_LDMOD_1 = 0x1
	// Position of SPLIT field.
	PWM_SM3CTRL_SPLIT_Pos = 0x3
	// Bit mask of SPLIT field.
	PWM_SM3CTRL_SPLIT_Msk = 0x8
	// Bit SPLIT.
	PWM_SM3CTRL_SPLIT = 0x8
	// DBLPWM is not split. PWMA and PWMB each have double pulses.
	PWM_SM3CTRL_SPLIT_SPLIT_0 = 0x0
	// DBLPWM is split to PWMA and PWMB.
	PWM_SM3CTRL_SPLIT_SPLIT_1 = 0x1
	// Position of PRSC field.
	PWM_SM3CTRL_PRSC_Pos = 0x4
	// Bit mask of PRSC field.
	PWM_SM3CTRL_PRSC_Msk = 0x70
	// PWM clock frequency = fclk
	PWM_SM3CTRL_PRSC_PRSC_0 = 0x0
	// PWM clock frequency = fclk/2
	PWM_SM3CTRL_PRSC_PRSC_1 = 0x1
	// PWM clock frequency = fclk/4
	PWM_SM3CTRL_PRSC_PRSC_2 = 0x2
	// PWM clock frequency = fclk/8
	PWM_SM3CTRL_PRSC_PRSC_3 = 0x3
	// PWM clock frequency = fclk/16
	PWM_SM3CTRL_PRSC_PRSC_4 = 0x4
	// PWM clock frequency = fclk/32
	PWM_SM3CTRL_PRSC_PRSC_5 = 0x5
	// PWM clock frequency = fclk/64
	PWM_SM3CTRL_PRSC_PRSC_6 = 0x6
	// PWM clock frequency = fclk/128
	PWM_SM3CTRL_PRSC_PRSC_7 = 0x7
	// Position of COMPMODE field.
	PWM_SM3CTRL_COMPMODE_Pos = 0x7
	// Bit mask of COMPMODE field.
	PWM_SM3CTRL_COMPMODE_Msk = 0x80
	// Bit COMPMODE.
	PWM_SM3CTRL_COMPMODE = 0x80
	// The VAL* registers and the PWM counter are compared using an "equal to" method. This means that PWM edges are only produced when the counter is equal to one of the VAL* register values. This implies that a PWMA output that is high at the end of a period will maintain this state until a match with VAL3 clears the output in the following period.
	PWM_SM3CTRL_COMPMODE_COMPMODE_0 = 0x0
	// The VAL* registers and the PWM counter are compared using an "equal to or greater than" method. This means that PWM edges are produced when the counter is equal to or greater than one of the VAL* register values. This implies that a PWMA output that is high at the end of a period could go low at the start of the next period if the starting counter value is greater than (but not necessarily equal to) the new VAL3 value.
	PWM_SM3CTRL_COMPMODE_COMPMODE_1 = 0x1
	// Position of DT field.
	PWM_SM3CTRL_DT_Pos = 0x8
	// Bit mask of DT field.
	PWM_SM3CTRL_DT_Msk = 0x300
	// Position of FULL field.
	PWM_SM3CTRL_FULL_Pos = 0xa
	// Bit mask of FULL field.
	PWM_SM3CTRL_FULL_Msk = 0x400
	// Bit FULL.
	PWM_SM3CTRL_FULL = 0x400
	// Full-cycle reloads disabled.
	PWM_SM3CTRL_FULL_FULL_0 = 0x0
	// Full-cycle reloads enabled.
	PWM_SM3CTRL_FULL_FULL_1 = 0x1
	// Position of HALF field.
	PWM_SM3CTRL_HALF_Pos = 0xb
	// Bit mask of HALF field.
	PWM_SM3CTRL_HALF_Msk = 0x800
	// Bit HALF.
	PWM_SM3CTRL_HALF = 0x800
	// Half-cycle reloads disabled.
	PWM_SM3CTRL_HALF_HALF_0 = 0x0
	// Half-cycle reloads enabled.
	PWM_SM3CTRL_HALF_HALF_1 = 0x1
	// Position of LDFQ field.
	PWM_SM3CTRL_LDFQ_Pos = 0xc
	// Bit mask of LDFQ field.
	PWM_SM3CTRL_LDFQ_Msk = 0xf000
	// Every PWM opportunity
	PWM_SM3CTRL_LDFQ_LDFQ_0 = 0x0
	// Every 2 PWM opportunities
	PWM_SM3CTRL_LDFQ_LDFQ_1 = 0x1
	// Every 3 PWM opportunities
	PWM_SM3CTRL_LDFQ_LDFQ_2 = 0x2
	// Every 4 PWM opportunities
	PWM_SM3CTRL_LDFQ_LDFQ_3 = 0x3
	// Every 5 PWM opportunities
	PWM_SM3CTRL_LDFQ_LDFQ_4 = 0x4
	// Every 6 PWM opportunities
	PWM_SM3CTRL_LDFQ_LDFQ_5 = 0x5
	// Every 7 PWM opportunities
	PWM_SM3CTRL_LDFQ_LDFQ_6 = 0x6
	// Every 8 PWM opportunities
	PWM_SM3CTRL_LDFQ_LDFQ_7 = 0x7
	// Every 9 PWM opportunities
	PWM_SM3CTRL_LDFQ_LDFQ_8 = 0x8
	// Every 10 PWM opportunities
	PWM_SM3CTRL_LDFQ_LDFQ_9 = 0x9
	// Every 11 PWM opportunities
	PWM_SM3CTRL_LDFQ_LDFQ_10 = 0xa
	// Every 12 PWM opportunities
	PWM_SM3CTRL_LDFQ_LDFQ_11 = 0xb
	// Every 13 PWM opportunities
	PWM_SM3CTRL_LDFQ_LDFQ_12 = 0xc
	// Every 14 PWM opportunities
	PWM_SM3CTRL_LDFQ_LDFQ_13 = 0xd
	// Every 15 PWM opportunities
	PWM_SM3CTRL_LDFQ_LDFQ_14 = 0xe
	// Every 16 PWM opportunities
	PWM_SM3CTRL_LDFQ_LDFQ_15 = 0xf

	// SM3VAL0: Value Register 0
	// Position of VAL0 field.
	PWM_SM3VAL0_VAL0_Pos = 0x0
	// Bit mask of VAL0 field.
	PWM_SM3VAL0_VAL0_Msk = 0xffff

	// SM3FRACVAL1: Fractional Value Register 1
	// Position of FRACVAL1 field.
	PWM_SM3FRACVAL1_FRACVAL1_Pos = 0xb
	// Bit mask of FRACVAL1 field.
	PWM_SM3FRACVAL1_FRACVAL1_Msk = 0xf800

	// SM3VAL1: Value Register 1
	// Position of VAL1 field.
	PWM_SM3VAL1_VAL1_Pos = 0x0
	// Bit mask of VAL1 field.
	PWM_SM3VAL1_VAL1_Msk = 0xffff

	// SM3FRACVAL2: Fractional Value Register 2
	// Position of FRACVAL2 field.
	PWM_SM3FRACVAL2_FRACVAL2_Pos = 0xb
	// Bit mask of FRACVAL2 field.
	PWM_SM3FRACVAL2_FRACVAL2_Msk = 0xf800

	// SM3VAL2: Value Register 2
	// Position of VAL2 field.
	PWM_SM3VAL2_VAL2_Pos = 0x0
	// Bit mask of VAL2 field.
	PWM_SM3VAL2_VAL2_Msk = 0xffff

	// SM3FRACVAL3: Fractional Value Register 3
	// Position of FRACVAL3 field.
	PWM_SM3FRACVAL3_FRACVAL3_Pos = 0xb
	// Bit mask of FRACVAL3 field.
	PWM_SM3FRACVAL3_FRACVAL3_Msk = 0xf800

	// SM3VAL3: Value Register 3
	// Position of VAL3 field.
	PWM_SM3VAL3_VAL3_Pos = 0x0
	// Bit mask of VAL3 field.
	PWM_SM3VAL3_VAL3_Msk = 0xffff

	// SM3FRACVAL4: Fractional Value Register 4
	// Position of FRACVAL4 field.
	PWM_SM3FRACVAL4_FRACVAL4_Pos = 0xb
	// Bit mask of FRACVAL4 field.
	PWM_SM3FRACVAL4_FRACVAL4_Msk = 0xf800

	// SM3VAL4: Value Register 4
	// Position of VAL4 field.
	PWM_SM3VAL4_VAL4_Pos = 0x0
	// Bit mask of VAL4 field.
	PWM_SM3VAL4_VAL4_Msk = 0xffff

	// SM3FRACVAL5: Fractional Value Register 5
	// Position of FRACVAL5 field.
	PWM_SM3FRACVAL5_FRACVAL5_Pos = 0xb
	// Bit mask of FRACVAL5 field.
	PWM_SM3FRACVAL5_FRACVAL5_Msk = 0xf800

	// SM3VAL5: Value Register 5
	// Position of VAL5 field.
	PWM_SM3VAL5_VAL5_Pos = 0x0
	// Bit mask of VAL5 field.
	PWM_SM3VAL5_VAL5_Msk = 0xffff

	// SM3FRCTRL: Fractional Control Register
	// Position of FRAC1_EN field.
	PWM_SM3FRCTRL_FRAC1_EN_Pos = 0x1
	// Bit mask of FRAC1_EN field.
	PWM_SM3FRCTRL_FRAC1_EN_Msk = 0x2
	// Bit FRAC1_EN.
	PWM_SM3FRCTRL_FRAC1_EN = 0x2
	// Disable fractional cycle length for the PWM period.
	PWM_SM3FRCTRL_FRAC1_EN_FRAC1_EN_0 = 0x0
	// Enable fractional cycle length for the PWM period.
	PWM_SM3FRCTRL_FRAC1_EN_FRAC1_EN_1 = 0x1
	// Position of FRAC23_EN field.
	PWM_SM3FRCTRL_FRAC23_EN_Pos = 0x2
	// Bit mask of FRAC23_EN field.
	PWM_SM3FRCTRL_FRAC23_EN_Msk = 0x4
	// Bit FRAC23_EN.
	PWM_SM3FRCTRL_FRAC23_EN = 0x4
	// Disable fractional cycle placement for PWM_A.
	PWM_SM3FRCTRL_FRAC23_EN_FRAC23_EN_0 = 0x0
	// Enable fractional cycle placement for PWM_A.
	PWM_SM3FRCTRL_FRAC23_EN_FRAC23_EN_1 = 0x1
	// Position of FRAC45_EN field.
	PWM_SM3FRCTRL_FRAC45_EN_Pos = 0x4
	// Bit mask of FRAC45_EN field.
	PWM_SM3FRCTRL_FRAC45_EN_Msk = 0x10
	// Bit FRAC45_EN.
	PWM_SM3FRCTRL_FRAC45_EN = 0x10
	// Disable fractional cycle placement for PWM_B.
	PWM_SM3FRCTRL_FRAC45_EN_FRAC45_EN_0 = 0x0
	// Enable fractional cycle placement for PWM_B.
	PWM_SM3FRCTRL_FRAC45_EN_FRAC45_EN_1 = 0x1
	// Position of FRAC_PU field.
	PWM_SM3FRCTRL_FRAC_PU_Pos = 0x8
	// Bit mask of FRAC_PU field.
	PWM_SM3FRCTRL_FRAC_PU_Msk = 0x100
	// Bit FRAC_PU.
	PWM_SM3FRCTRL_FRAC_PU = 0x100
	// Turn off fractional delay logic.
	PWM_SM3FRCTRL_FRAC_PU_FRAC_PU_0 = 0x0
	// Power up fractional delay logic.
	PWM_SM3FRCTRL_FRAC_PU_FRAC_PU_1 = 0x1
	// Position of TEST field.
	PWM_SM3FRCTRL_TEST_Pos = 0xf
	// Bit mask of TEST field.
	PWM_SM3FRCTRL_TEST_Msk = 0x8000
	// Bit TEST.
	PWM_SM3FRCTRL_TEST = 0x8000

	// SM3OCTRL: Output Control Register
	// Position of PWMXFS field.
	PWM_SM3OCTRL_PWMXFS_Pos = 0x0
	// Bit mask of PWMXFS field.
	PWM_SM3OCTRL_PWMXFS_Msk = 0x3
	// Output is forced to logic 0 state prior to consideration of output polarity control.
	PWM_SM3OCTRL_PWMXFS_PWMXFS_0 = 0x0
	// Output is forced to logic 1 state prior to consideration of output polarity control.
	PWM_SM3OCTRL_PWMXFS_PWMXFS_1 = 0x1
	// Output is tristated.
	PWM_SM3OCTRL_PWMXFS_PWMXFS_2 = 0x2
	// Output is tristated.
	PWM_SM3OCTRL_PWMXFS_PWMXFS_3 = 0x3
	// Position of PWMBFS field.
	PWM_SM3OCTRL_PWMBFS_Pos = 0x2
	// Bit mask of PWMBFS field.
	PWM_SM3OCTRL_PWMBFS_Msk = 0xc
	// Output is forced to logic 0 state prior to consideration of output polarity control.
	PWM_SM3OCTRL_PWMBFS_PWMBFS_0 = 0x0
	// Output is forced to logic 1 state prior to consideration of output polarity control.
	PWM_SM3OCTRL_PWMBFS_PWMBFS_1 = 0x1
	// Output is tristated.
	PWM_SM3OCTRL_PWMBFS_PWMBFS_2 = 0x2
	// Output is tristated.
	PWM_SM3OCTRL_PWMBFS_PWMBFS_3 = 0x3
	// Position of PWMAFS field.
	PWM_SM3OCTRL_PWMAFS_Pos = 0x4
	// Bit mask of PWMAFS field.
	PWM_SM3OCTRL_PWMAFS_Msk = 0x30
	// Output is forced to logic 0 state prior to consideration of output polarity control.
	PWM_SM3OCTRL_PWMAFS_PWMAFS_0 = 0x0
	// Output is forced to logic 1 state prior to consideration of output polarity control.
	PWM_SM3OCTRL_PWMAFS_PWMAFS_1 = 0x1
	// Output is tristated.
	PWM_SM3OCTRL_PWMAFS_PWMAFS_2 = 0x2
	// Output is tristated.
	PWM_SM3OCTRL_PWMAFS_PWMAFS_3 = 0x3
	// Position of POLX field.
	PWM_SM3OCTRL_POLX_Pos = 0x8
	// Bit mask of POLX field.
	PWM_SM3OCTRL_POLX_Msk = 0x100
	// Bit POLX.
	PWM_SM3OCTRL_POLX = 0x100
	// PWM_X output not inverted. A high level on the PWM_X pin represents the "on" or "active" state.
	PWM_SM3OCTRL_POLX_POLX_0 = 0x0
	// PWM_X output inverted. A low level on the PWM_X pin represents the "on" or "active" state.
	PWM_SM3OCTRL_POLX_POLX_1 = 0x1
	// Position of POLB field.
	PWM_SM3OCTRL_POLB_Pos = 0x9
	// Bit mask of POLB field.
	PWM_SM3OCTRL_POLB_Msk = 0x200
	// Bit POLB.
	PWM_SM3OCTRL_POLB = 0x200
	// PWM_B output not inverted. A high level on the PWM_B pin represents the "on" or "active" state.
	PWM_SM3OCTRL_POLB_POLB_0 = 0x0
	// PWM_B output inverted. A low level on the PWM_B pin represents the "on" or "active" state.
	PWM_SM3OCTRL_POLB_POLB_1 = 0x1
	// Position of POLA field.
	PWM_SM3OCTRL_POLA_Pos = 0xa
	// Bit mask of POLA field.
	PWM_SM3OCTRL_POLA_Msk = 0x400
	// Bit POLA.
	PWM_SM3OCTRL_POLA = 0x400
	// PWM_A output not inverted. A high level on the PWM_A pin represents the "on" or "active" state.
	PWM_SM3OCTRL_POLA_POLA_0 = 0x0
	// PWM_A output inverted. A low level on the PWM_A pin represents the "on" or "active" state.
	PWM_SM3OCTRL_POLA_POLA_1 = 0x1
	// Position of PWMX_IN field.
	PWM_SM3OCTRL_PWMX_IN_Pos = 0xd
	// Bit mask of PWMX_IN field.
	PWM_SM3OCTRL_PWMX_IN_Msk = 0x2000
	// Bit PWMX_IN.
	PWM_SM3OCTRL_PWMX_IN = 0x2000
	// Position of PWMB_IN field.
	PWM_SM3OCTRL_PWMB_IN_Pos = 0xe
	// Bit mask of PWMB_IN field.
	PWM_SM3OCTRL_PWMB_IN_Msk = 0x4000
	// Bit PWMB_IN.
	PWM_SM3OCTRL_PWMB_IN = 0x4000
	// Position of PWMA_IN field.
	PWM_SM3OCTRL_PWMA_IN_Pos = 0xf
	// Bit mask of PWMA_IN field.
	PWM_SM3OCTRL_PWMA_IN_Msk = 0x8000
	// Bit PWMA_IN.
	PWM_SM3OCTRL_PWMA_IN = 0x8000

	// SM3STS: Status Register
	// Position of CMPF field.
	PWM_SM3STS_CMPF_Pos = 0x0
	// Bit mask of CMPF field.
	PWM_SM3STS_CMPF_Msk = 0x3f
	// No compare event has occurred for a particular VALx value.
	PWM_SM3STS_CMPF_CMPF_0 = 0x0
	// A compare event has occurred for a particular VALx value.
	PWM_SM3STS_CMPF_CMPF_1 = 0x1
	// Position of CFX0 field.
	PWM_SM3STS_CFX0_Pos = 0x6
	// Bit mask of CFX0 field.
	PWM_SM3STS_CFX0_Msk = 0x40
	// Bit CFX0.
	PWM_SM3STS_CFX0 = 0x40
	// Position of CFX1 field.
	PWM_SM3STS_CFX1_Pos = 0x7
	// Bit mask of CFX1 field.
	PWM_SM3STS_CFX1_Msk = 0x80
	// Bit CFX1.
	PWM_SM3STS_CFX1 = 0x80
	// Position of CFB0 field.
	PWM_SM3STS_CFB0_Pos = 0x8
	// Bit mask of CFB0 field.
	PWM_SM3STS_CFB0_Msk = 0x100
	// Bit CFB0.
	PWM_SM3STS_CFB0 = 0x100
	// Position of CFB1 field.
	PWM_SM3STS_CFB1_Pos = 0x9
	// Bit mask of CFB1 field.
	PWM_SM3STS_CFB1_Msk = 0x200
	// Bit CFB1.
	PWM_SM3STS_CFB1 = 0x200
	// Position of CFA0 field.
	PWM_SM3STS_CFA0_Pos = 0xa
	// Bit mask of CFA0 field.
	PWM_SM3STS_CFA0_Msk = 0x400
	// Bit CFA0.
	PWM_SM3STS_CFA0 = 0x400
	// Position of CFA1 field.
	PWM_SM3STS_CFA1_Pos = 0xb
	// Bit mask of CFA1 field.
	PWM_SM3STS_CFA1_Msk = 0x800
	// Bit CFA1.
	PWM_SM3STS_CFA1 = 0x800
	// Position of RF field.
	PWM_SM3STS_RF_Pos = 0xc
	// Bit mask of RF field.
	PWM_SM3STS_RF_Msk = 0x1000
	// Bit RF.
	PWM_SM3STS_RF = 0x1000
	// No new reload cycle since last STS[RF] clearing
	PWM_SM3STS_RF_RF_0 = 0x0
	// New reload cycle since last STS[RF] clearing
	PWM_SM3STS_RF_RF_1 = 0x1
	// Position of REF field.
	PWM_SM3STS_REF_Pos = 0xd
	// Bit mask of REF field.
	PWM_SM3STS_REF_Msk = 0x2000
	// Bit REF.
	PWM_SM3STS_REF = 0x2000
	// No reload error occurred.
	PWM_SM3STS_REF_REF_0 = 0x0
	// Reload signal occurred with non-coherent data and MCTRL[LDOK] = 0.
	PWM_SM3STS_REF_REF_1 = 0x1
	// Position of RUF field.
	PWM_SM3STS_RUF_Pos = 0xe
	// Bit mask of RUF field.
	PWM_SM3STS_RUF_Msk = 0x4000
	// Bit RUF.
	PWM_SM3STS_RUF = 0x4000
	// No register update has occurred since last reload.
	PWM_SM3STS_RUF_RUF_0 = 0x0
	// At least one of the double buffered registers has been updated since the last reload.
	PWM_SM3STS_RUF_RUF_1 = 0x1

	// SM3INTEN: Interrupt Enable Register
	// Position of CMPIE field.
	PWM_SM3INTEN_CMPIE_Pos = 0x0
	// Bit mask of CMPIE field.
	PWM_SM3INTEN_CMPIE_Msk = 0x3f
	// The corresponding STS[CMPF] bit will not cause an interrupt request.
	PWM_SM3INTEN_CMPIE_CMPIE_0 = 0x0
	// The corresponding STS[CMPF] bit will cause an interrupt request.
	PWM_SM3INTEN_CMPIE_CMPIE_1 = 0x1
	// Position of CX0IE field.
	PWM_SM3INTEN_CX0IE_Pos = 0x6
	// Bit mask of CX0IE field.
	PWM_SM3INTEN_CX0IE_Msk = 0x40
	// Bit CX0IE.
	PWM_SM3INTEN_CX0IE = 0x40
	// Interrupt request disabled for STS[CFX0].
	PWM_SM3INTEN_CX0IE_CX0IE_0 = 0x0
	// Interrupt request enabled for STS[CFX0].
	PWM_SM3INTEN_CX0IE_CX0IE_1 = 0x1
	// Position of CX1IE field.
	PWM_SM3INTEN_CX1IE_Pos = 0x7
	// Bit mask of CX1IE field.
	PWM_SM3INTEN_CX1IE_Msk = 0x80
	// Bit CX1IE.
	PWM_SM3INTEN_CX1IE = 0x80
	// Interrupt request disabled for STS[CFX1].
	PWM_SM3INTEN_CX1IE_CX1IE_0 = 0x0
	// Interrupt request enabled for STS[CFX1].
	PWM_SM3INTEN_CX1IE_CX1IE_1 = 0x1
	// Position of CB0IE field.
	PWM_SM3INTEN_CB0IE_Pos = 0x8
	// Bit mask of CB0IE field.
	PWM_SM3INTEN_CB0IE_Msk = 0x100
	// Bit CB0IE.
	PWM_SM3INTEN_CB0IE = 0x100
	// Interrupt request disabled for STS[CFB0].
	PWM_SM3INTEN_CB0IE_CB0IE_0 = 0x0
	// Interrupt request enabled for STS[CFB0].
	PWM_SM3INTEN_CB0IE_CB0IE_1 = 0x1
	// Position of CB1IE field.
	PWM_SM3INTEN_CB1IE_Pos = 0x9
	// Bit mask of CB1IE field.
	PWM_SM3INTEN_CB1IE_Msk = 0x200
	// Bit CB1IE.
	PWM_SM3INTEN_CB1IE = 0x200
	// Interrupt request disabled for STS[CFB1].
	PWM_SM3INTEN_CB1IE_CB1IE_0 = 0x0
	// Interrupt request enabled for STS[CFB1].
	PWM_SM3INTEN_CB1IE_CB1IE_1 = 0x1
	// Position of CA0IE field.
	PWM_SM3INTEN_CA0IE_Pos = 0xa
	// Bit mask of CA0IE field.
	PWM_SM3INTEN_CA0IE_Msk = 0x400
	// Bit CA0IE.
	PWM_SM3INTEN_CA0IE = 0x400
	// Interrupt request disabled for STS[CFA0].
	PWM_SM3INTEN_CA0IE_CA0IE_0 = 0x0
	// Interrupt request enabled for STS[CFA0].
	PWM_SM3INTEN_CA0IE_CA0IE_1 = 0x1
	// Position of CA1IE field.
	PWM_SM3INTEN_CA1IE_Pos = 0xb
	// Bit mask of CA1IE field.
	PWM_SM3INTEN_CA1IE_Msk = 0x800
	// Bit CA1IE.
	PWM_SM3INTEN_CA1IE = 0x800
	// Interrupt request disabled for STS[CFA1].
	PWM_SM3INTEN_CA1IE_CA1IE_0 = 0x0
	// Interrupt request enabled for STS[CFA1].
	PWM_SM3INTEN_CA1IE_CA1IE_1 = 0x1
	// Position of RIE field.
	PWM_SM3INTEN_RIE_Pos = 0xc
	// Bit mask of RIE field.
	PWM_SM3INTEN_RIE_Msk = 0x1000
	// Bit RIE.
	PWM_SM3INTEN_RIE = 0x1000
	// STS[RF] CPU interrupt requests disabled
	PWM_SM3INTEN_RIE_RIE_0 = 0x0
	// STS[RF] CPU interrupt requests enabled
	PWM_SM3INTEN_RIE_RIE_1 = 0x1
	// Position of REIE field.
	PWM_SM3INTEN_REIE_Pos = 0xd
	// Bit mask of REIE field.
	PWM_SM3INTEN_REIE_Msk = 0x2000
	// Bit REIE.
	PWM_SM3INTEN_REIE = 0x2000
	// STS[REF] CPU interrupt requests disabled
	PWM_SM3INTEN_REIE_REIE_0 = 0x0
	// STS[REF] CPU interrupt requests enabled
	PWM_SM3INTEN_REIE_REIE_1 = 0x1

	// SM3DMAEN: DMA Enable Register
	// Position of CX0DE field.
	PWM_SM3DMAEN_CX0DE_Pos = 0x0
	// Bit mask of CX0DE field.
	PWM_SM3DMAEN_CX0DE_Msk = 0x1
	// Bit CX0DE.
	PWM_SM3DMAEN_CX0DE = 0x1
	// Position of CX1DE field.
	PWM_SM3DMAEN_CX1DE_Pos = 0x1
	// Bit mask of CX1DE field.
	PWM_SM3DMAEN_CX1DE_Msk = 0x2
	// Bit CX1DE.
	PWM_SM3DMAEN_CX1DE = 0x2
	// Position of CB0DE field.
	PWM_SM3DMAEN_CB0DE_Pos = 0x2
	// Bit mask of CB0DE field.
	PWM_SM3DMAEN_CB0DE_Msk = 0x4
	// Bit CB0DE.
	PWM_SM3DMAEN_CB0DE = 0x4
	// Position of CB1DE field.
	PWM_SM3DMAEN_CB1DE_Pos = 0x3
	// Bit mask of CB1DE field.
	PWM_SM3DMAEN_CB1DE_Msk = 0x8
	// Bit CB1DE.
	PWM_SM3DMAEN_CB1DE = 0x8
	// Position of CA0DE field.
	PWM_SM3DMAEN_CA0DE_Pos = 0x4
	// Bit mask of CA0DE field.
	PWM_SM3DMAEN_CA0DE_Msk = 0x10
	// Bit CA0DE.
	PWM_SM3DMAEN_CA0DE = 0x10
	// Position of CA1DE field.
	PWM_SM3DMAEN_CA1DE_Pos = 0x5
	// Bit mask of CA1DE field.
	PWM_SM3DMAEN_CA1DE_Msk = 0x20
	// Bit CA1DE.
	PWM_SM3DMAEN_CA1DE = 0x20
	// Position of CAPTDE field.
	PWM_SM3DMAEN_CAPTDE_Pos = 0x6
	// Bit mask of CAPTDE field.
	PWM_SM3DMAEN_CAPTDE_Msk = 0xc0
	// Read DMA requests disabled.
	PWM_SM3DMAEN_CAPTDE_CAPTDE_0 = 0x0
	// Exceeding a FIFO watermark sets the DMA read request. This requires at least one of DMAEN[CA1DE], DMAEN[CA0DE], DMAEN[CB1DE], DMAEN[CB0DE], DMAEN[CX1DE], or DMAEN[CX0DE] to also be set in order to determine to which watermark(s) the DMA request is sensitive.
	PWM_SM3DMAEN_CAPTDE_CAPTDE_1 = 0x1
	// A local sync (VAL1 matches counter) sets the read DMA request.
	PWM_SM3DMAEN_CAPTDE_CAPTDE_2 = 0x2
	// A local reload (STS[RF] being set) sets the read DMA request.
	PWM_SM3DMAEN_CAPTDE_CAPTDE_3 = 0x3
	// Position of FAND field.
	PWM_SM3DMAEN_FAND_Pos = 0x8
	// Bit mask of FAND field.
	PWM_SM3DMAEN_FAND_Msk = 0x100
	// Bit FAND.
	PWM_SM3DMAEN_FAND = 0x100
	// Selected FIFO watermarks are OR'ed together.
	PWM_SM3DMAEN_FAND_FAND_0 = 0x0
	// Selected FIFO watermarks are AND'ed together.
	PWM_SM3DMAEN_FAND_FAND_1 = 0x1
	// Position of VALDE field.
	PWM_SM3DMAEN_VALDE_Pos = 0x9
	// Bit mask of VALDE field.
	PWM_SM3DMAEN_VALDE_Msk = 0x200
	// Bit VALDE.
	PWM_SM3DMAEN_VALDE = 0x200
	// DMA write requests disabled
	PWM_SM3DMAEN_VALDE_VALDE_0 = 0x0
	// DMA write requests for the VALx and FRACVALx registers enabled
	PWM_SM3DMAEN_VALDE_VALDE_1 = 0x1

	// SM3TCTRL: Output Trigger Control Register
	// Position of OUT_TRIG_EN field.
	PWM_SM3TCTRL_OUT_TRIG_EN_Pos = 0x0
	// Bit mask of OUT_TRIG_EN field.
	PWM_SM3TCTRL_OUT_TRIG_EN_Msk = 0x3f
	// PWM_OUT_TRIGx will not set when the counter value matches the VALx value.
	PWM_SM3TCTRL_OUT_TRIG_EN_OUT_TRIG_EN_0 = 0x0
	// PWM_OUT_TRIGx will set when the counter value matches the VALx value.
	PWM_SM3TCTRL_OUT_TRIG_EN_OUT_TRIG_EN_1 = 0x1
	// Position of TRGFRQ field.
	PWM_SM3TCTRL_TRGFRQ_Pos = 0xc
	// Bit mask of TRGFRQ field.
	PWM_SM3TCTRL_TRGFRQ_Msk = 0x1000
	// Bit TRGFRQ.
	PWM_SM3TCTRL_TRGFRQ = 0x1000
	// Trigger outputs are generated during every PWM period even if the PWM is not reloaded every period due to CTRL[LDFQ] being non-zero.
	PWM_SM3TCTRL_TRGFRQ_TRGFRQ_0 = 0x0
	// Trigger outputs are generated only during the final PWM period prior to a reload opportunity when the PWM is not reloaded every period due to CTRL[LDFQ] being non-zero.
	PWM_SM3TCTRL_TRGFRQ_TRGFRQ_1 = 0x1
	// Position of PWBOT1 field.
	PWM_SM3TCTRL_PWBOT1_Pos = 0xe
	// Bit mask of PWBOT1 field.
	PWM_SM3TCTRL_PWBOT1_Msk = 0x4000
	// Bit PWBOT1.
	PWM_SM3TCTRL_PWBOT1 = 0x4000
	// Route the PWM_OUT_TRIG1 signal to PWM_OUT_TRIG1 port.
	PWM_SM3TCTRL_PWBOT1_PWBOT1_0 = 0x0
	// Route the PWMB output to the PWM_OUT_TRIG1 port.
	PWM_SM3TCTRL_PWBOT1_PWBOT1_1 = 0x1
	// Position of PWAOT0 field.
	PWM_SM3TCTRL_PWAOT0_Pos = 0xf
	// Bit mask of PWAOT0 field.
	PWM_SM3TCTRL_PWAOT0_Msk = 0x8000
	// Bit PWAOT0.
	PWM_SM3TCTRL_PWAOT0 = 0x8000
	// Route the PWM_OUT_TRIG0 signal to PWM_OUT_TRIG0 port.
	PWM_SM3TCTRL_PWAOT0_PWAOT0_0 = 0x0
	// Route the PWMA output to the PWM_OUT_TRIG0 port.
	PWM_SM3TCTRL_PWAOT0_PWAOT0_1 = 0x1

	// SM3DISMAP0: Fault Disable Mapping Register 0
	// Position of DIS0A field.
	PWM_SM3DISMAP0_DIS0A_Pos = 0x0
	// Bit mask of DIS0A field.
	PWM_SM3DISMAP0_DIS0A_Msk = 0xf
	// Position of DIS0B field.
	PWM_SM3DISMAP0_DIS0B_Pos = 0x4
	// Bit mask of DIS0B field.
	PWM_SM3DISMAP0_DIS0B_Msk = 0xf0
	// Position of DIS0X field.
	PWM_SM3DISMAP0_DIS0X_Pos = 0x8
	// Bit mask of DIS0X field.
	PWM_SM3DISMAP0_DIS0X_Msk = 0xf00

	// SM3DISMAP1: Fault Disable Mapping Register 1
	// Position of DIS1A field.
	PWM_SM3DISMAP1_DIS1A_Pos = 0x0
	// Bit mask of DIS1A field.
	PWM_SM3DISMAP1_DIS1A_Msk = 0xf
	// Position of DIS1B field.
	PWM_SM3DISMAP1_DIS1B_Pos = 0x4
	// Bit mask of DIS1B field.
	PWM_SM3DISMAP1_DIS1B_Msk = 0xf0
	// Position of DIS1X field.
	PWM_SM3DISMAP1_DIS1X_Pos = 0x8
	// Bit mask of DIS1X field.
	PWM_SM3DISMAP1_DIS1X_Msk = 0xf00

	// SM3DTCNT0: Deadtime Count Register 0
	// Position of DTCNT0 field.
	PWM_SM3DTCNT0_DTCNT0_Pos = 0x0
	// Bit mask of DTCNT0 field.
	PWM_SM3DTCNT0_DTCNT0_Msk = 0xffff

	// SM3DTCNT1: Deadtime Count Register 1
	// Position of DTCNT1 field.
	PWM_SM3DTCNT1_DTCNT1_Pos = 0x0
	// Bit mask of DTCNT1 field.
	PWM_SM3DTCNT1_DTCNT1_Msk = 0xffff

	// SM3CAPTCTRLA: Capture Control A Register
	// Position of ARMA field.
	PWM_SM3CAPTCTRLA_ARMA_Pos = 0x0
	// Bit mask of ARMA field.
	PWM_SM3CAPTCTRLA_ARMA_Msk = 0x1
	// Bit ARMA.
	PWM_SM3CAPTCTRLA_ARMA = 0x1
	// Input capture operation is disabled.
	PWM_SM3CAPTCTRLA_ARMA_ARMA_0 = 0x0
	// Input capture operation as specified by CAPTCTRLA[EDGAx] is enabled.
	PWM_SM3CAPTCTRLA_ARMA_ARMA_1 = 0x1
	// Position of ONESHOTA field.
	PWM_SM3CAPTCTRLA_ONESHOTA_Pos = 0x1
	// Bit mask of ONESHOTA field.
	PWM_SM3CAPTCTRLA_ONESHOTA_Msk = 0x2
	// Bit ONESHOTA.
	PWM_SM3CAPTCTRLA_ONESHOTA = 0x2
	// Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLA[ARMA] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
	PWM_SM3CAPTCTRLA_ONESHOTA_ONESHOTA_0 = 0x0
	// One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLA[ARMA] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and CAPTCTRLA[ARMA] is cleared. No further captures will be performed until CAPTCTRLA[ARMA] is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and CAPTCTRLA[ARMA] is then cleared.
	PWM_SM3CAPTCTRLA_ONESHOTA_ONESHOTA_1 = 0x1
	// Position of EDGA0 field.
	PWM_SM3CAPTCTRLA_EDGA0_Pos = 0x2
	// Bit mask of EDGA0 field.
	PWM_SM3CAPTCTRLA_EDGA0_Msk = 0xc
	// Disabled
	PWM_SM3CAPTCTRLA_EDGA0_EDGA0_0 = 0x0
	// Capture falling edges
	PWM_SM3CAPTCTRLA_EDGA0_EDGA0_1 = 0x1
	// Capture rising edges
	PWM_SM3CAPTCTRLA_EDGA0_EDGA0_2 = 0x2
	// Capture any edge
	PWM_SM3CAPTCTRLA_EDGA0_EDGA0_3 = 0x3
	// Position of EDGA1 field.
	PWM_SM3CAPTCTRLA_EDGA1_Pos = 0x4
	// Bit mask of EDGA1 field.
	PWM_SM3CAPTCTRLA_EDGA1_Msk = 0x30
	// Disabled
	PWM_SM3CAPTCTRLA_EDGA1_EDGA1_0 = 0x0
	// Capture falling edges
	PWM_SM3CAPTCTRLA_EDGA1_EDGA1_1 = 0x1
	// Capture rising edges
	PWM_SM3CAPTCTRLA_EDGA1_EDGA1_2 = 0x2
	// Capture any edge
	PWM_SM3CAPTCTRLA_EDGA1_EDGA1_3 = 0x3
	// Position of INP_SELA field.
	PWM_SM3CAPTCTRLA_INP_SELA_Pos = 0x6
	// Bit mask of INP_SELA field.
	PWM_SM3CAPTCTRLA_INP_SELA_Msk = 0x40
	// Bit INP_SELA.
	PWM_SM3CAPTCTRLA_INP_SELA = 0x40
	// Raw PWM_A input signal selected as source.
	PWM_SM3CAPTCTRLA_INP_SELA_INP_SELA_0 = 0x0
	// Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLA[EDGA0] and CAPTCTRLA[EDGA1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRA[EDGA0] and/or CAPTCTRLA[EDGA1] fields in order to enable one or both of the capture registers.
	PWM_SM3CAPTCTRLA_INP_SELA_INP_SELA_1 = 0x1
	// Position of EDGCNTA_EN field.
	PWM_SM3CAPTCTRLA_EDGCNTA_EN_Pos = 0x7
	// Bit mask of EDGCNTA_EN field.
	PWM_SM3CAPTCTRLA_EDGCNTA_EN_Msk = 0x80
	// Bit EDGCNTA_EN.
	PWM_SM3CAPTCTRLA_EDGCNTA_EN = 0x80
	// Edge counter disabled and held in reset
	PWM_SM3CAPTCTRLA_EDGCNTA_EN_EDGCNTA_EN_0 = 0x0
	// Edge counter enabled
	PWM_SM3CAPTCTRLA_EDGCNTA_EN_EDGCNTA_EN_1 = 0x1
	// Position of CFAWM field.
	PWM_SM3CAPTCTRLA_CFAWM_Pos = 0x8
	// Bit mask of CFAWM field.
	PWM_SM3CAPTCTRLA_CFAWM_Msk = 0x300
	// Position of CA0CNT field.
	PWM_SM3CAPTCTRLA_CA0CNT_Pos = 0xa
	// Bit mask of CA0CNT field.
	PWM_SM3CAPTCTRLA_CA0CNT_Msk = 0x1c00
	// Position of CA1CNT field.
	PWM_SM3CAPTCTRLA_CA1CNT_Pos = 0xd
	// Bit mask of CA1CNT field.
	PWM_SM3CAPTCTRLA_CA1CNT_Msk = 0xe000

	// SM3CAPTCOMPA: Capture Compare A Register
	// Position of EDGCMPA field.
	PWM_SM3CAPTCOMPA_EDGCMPA_Pos = 0x0
	// Bit mask of EDGCMPA field.
	PWM_SM3CAPTCOMPA_EDGCMPA_Msk = 0xff
	// Position of EDGCNTA field.
	PWM_SM3CAPTCOMPA_EDGCNTA_Pos = 0x8
	// Bit mask of EDGCNTA field.
	PWM_SM3CAPTCOMPA_EDGCNTA_Msk = 0xff00

	// SM3CAPTCTRLB: Capture Control B Register
	// Position of ARMB field.
	PWM_SM3CAPTCTRLB_ARMB_Pos = 0x0
	// Bit mask of ARMB field.
	PWM_SM3CAPTCTRLB_ARMB_Msk = 0x1
	// Bit ARMB.
	PWM_SM3CAPTCTRLB_ARMB = 0x1
	// Input capture operation is disabled.
	PWM_SM3CAPTCTRLB_ARMB_ARMB_0 = 0x0
	// Input capture operation as specified by CAPTCTRLB[EDGBx] is enabled.
	PWM_SM3CAPTCTRLB_ARMB_ARMB_1 = 0x1
	// Position of ONESHOTB field.
	PWM_SM3CAPTCTRLB_ONESHOTB_Pos = 0x1
	// Bit mask of ONESHOTB field.
	PWM_SM3CAPTCTRLB_ONESHOTB_Msk = 0x2
	// Bit ONESHOTB.
	PWM_SM3CAPTCTRLB_ONESHOTB = 0x2
	// Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLB[ARMB] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
	PWM_SM3CAPTCTRLB_ONESHOTB_ONESHOTB_0 = 0x0
	// One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLB[ARMB] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and CAPTCTRLB[ARMB] is cleared. No further captures will be performed until CAPTCTRLB[ARMB] is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and CAPTCTRLB[ARMB] is then cleared.
	PWM_SM3CAPTCTRLB_ONESHOTB_ONESHOTB_1 = 0x1
	// Position of EDGB0 field.
	PWM_SM3CAPTCTRLB_EDGB0_Pos = 0x2
	// Bit mask of EDGB0 field.
	PWM_SM3CAPTCTRLB_EDGB0_Msk = 0xc
	// Disabled
	PWM_SM3CAPTCTRLB_EDGB0_EDGB0_0 = 0x0
	// Capture falling edges
	PWM_SM3CAPTCTRLB_EDGB0_EDGB0_1 = 0x1
	// Capture rising edges
	PWM_SM3CAPTCTRLB_EDGB0_EDGB0_2 = 0x2
	// Capture any edge
	PWM_SM3CAPTCTRLB_EDGB0_EDGB0_3 = 0x3
	// Position of EDGB1 field.
	PWM_SM3CAPTCTRLB_EDGB1_Pos = 0x4
	// Bit mask of EDGB1 field.
	PWM_SM3CAPTCTRLB_EDGB1_Msk = 0x30
	// Disabled
	PWM_SM3CAPTCTRLB_EDGB1_EDGB1_0 = 0x0
	// Capture falling edges
	PWM_SM3CAPTCTRLB_EDGB1_EDGB1_1 = 0x1
	// Capture rising edges
	PWM_SM3CAPTCTRLB_EDGB1_EDGB1_2 = 0x2
	// Capture any edge
	PWM_SM3CAPTCTRLB_EDGB1_EDGB1_3 = 0x3
	// Position of INP_SELB field.
	PWM_SM3CAPTCTRLB_INP_SELB_Pos = 0x6
	// Bit mask of INP_SELB field.
	PWM_SM3CAPTCTRLB_INP_SELB_Msk = 0x40
	// Bit INP_SELB.
	PWM_SM3CAPTCTRLB_INP_SELB = 0x40
	// Raw PWM_B input signal selected as source.
	PWM_SM3CAPTCTRLB_INP_SELB_INP_SELB_0 = 0x0
	// Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLB[EDGB0] and CAPTCTRLB[EDGB1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRB[EDGB0] and/or CAPTCTRLB[EDGB1] fields in order to enable one or both of the capture registers.
	PWM_SM3CAPTCTRLB_INP_SELB_INP_SELB_1 = 0x1
	// Position of EDGCNTB_EN field.
	PWM_SM3CAPTCTRLB_EDGCNTB_EN_Pos = 0x7
	// Bit mask of EDGCNTB_EN field.
	PWM_SM3CAPTCTRLB_EDGCNTB_EN_Msk = 0x80
	// Bit EDGCNTB_EN.
	PWM_SM3CAPTCTRLB_EDGCNTB_EN = 0x80
	// Edge counter disabled and held in reset
	PWM_SM3CAPTCTRLB_EDGCNTB_EN_EDGCNTB_EN_0 = 0x0
	// Edge counter enabled
	PWM_SM3CAPTCTRLB_EDGCNTB_EN_EDGCNTB_EN_1 = 0x1
	// Position of CFBWM field.
	PWM_SM3CAPTCTRLB_CFBWM_Pos = 0x8
	// Bit mask of CFBWM field.
	PWM_SM3CAPTCTRLB_CFBWM_Msk = 0x300
	// Position of CB0CNT field.
	PWM_SM3CAPTCTRLB_CB0CNT_Pos = 0xa
	// Bit mask of CB0CNT field.
	PWM_SM3CAPTCTRLB_CB0CNT_Msk = 0x1c00
	// Position of CB1CNT field.
	PWM_SM3CAPTCTRLB_CB1CNT_Pos = 0xd
	// Bit mask of CB1CNT field.
	PWM_SM3CAPTCTRLB_CB1CNT_Msk = 0xe000

	// SM3CAPTCOMPB: Capture Compare B Register
	// Position of EDGCMPB field.
	PWM_SM3CAPTCOMPB_EDGCMPB_Pos = 0x0
	// Bit mask of EDGCMPB field.
	PWM_SM3CAPTCOMPB_EDGCMPB_Msk = 0xff
	// Position of EDGCNTB field.
	PWM_SM3CAPTCOMPB_EDGCNTB_Pos = 0x8
	// Bit mask of EDGCNTB field.
	PWM_SM3CAPTCOMPB_EDGCNTB_Msk = 0xff00

	// SM3CAPTCTRLX: Capture Control X Register
	// Position of ARMX field.
	PWM_SM3CAPTCTRLX_ARMX_Pos = 0x0
	// Bit mask of ARMX field.
	PWM_SM3CAPTCTRLX_ARMX_Msk = 0x1
	// Bit ARMX.
	PWM_SM3CAPTCTRLX_ARMX = 0x1
	// Input capture operation is disabled.
	PWM_SM3CAPTCTRLX_ARMX_ARMX_0 = 0x0
	// Input capture operation as specified by CAPTCTRLX[EDGXx] is enabled.
	PWM_SM3CAPTCTRLX_ARMX_ARMX_1 = 0x1
	// Position of ONESHOTX field.
	PWM_SM3CAPTCTRLX_ONESHOTX_Pos = 0x1
	// Bit mask of ONESHOTX field.
	PWM_SM3CAPTCTRLX_ONESHOTX_Msk = 0x2
	// Bit ONESHOTX.
	PWM_SM3CAPTCTRLX_ONESHOTX = 0x2
	// Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after the ARMX bit is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
	PWM_SM3CAPTCTRLX_ONESHOTX_ONESHOTX_0 = 0x0
	// One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after the ARMX bit is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and the ARMX bit is cleared. No further captures will be performed until the ARMX bit is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and the ARMX bit is then cleared.
	PWM_SM3CAPTCTRLX_ONESHOTX_ONESHOTX_1 = 0x1
	// Position of EDGX0 field.
	PWM_SM3CAPTCTRLX_EDGX0_Pos = 0x2
	// Bit mask of EDGX0 field.
	PWM_SM3CAPTCTRLX_EDGX0_Msk = 0xc
	// Disabled
	PWM_SM3CAPTCTRLX_EDGX0_EDGX0_0 = 0x0
	// Capture falling edges
	PWM_SM3CAPTCTRLX_EDGX0_EDGX0_1 = 0x1
	// Capture rising edges
	PWM_SM3CAPTCTRLX_EDGX0_EDGX0_2 = 0x2
	// Capture any edge
	PWM_SM3CAPTCTRLX_EDGX0_EDGX0_3 = 0x3
	// Position of EDGX1 field.
	PWM_SM3CAPTCTRLX_EDGX1_Pos = 0x4
	// Bit mask of EDGX1 field.
	PWM_SM3CAPTCTRLX_EDGX1_Msk = 0x30
	// Disabled
	PWM_SM3CAPTCTRLX_EDGX1_EDGX1_0 = 0x0
	// Capture falling edges
	PWM_SM3CAPTCTRLX_EDGX1_EDGX1_1 = 0x1
	// Capture rising edges
	PWM_SM3CAPTCTRLX_EDGX1_EDGX1_2 = 0x2
	// Capture any edge
	PWM_SM3CAPTCTRLX_EDGX1_EDGX1_3 = 0x3
	// Position of INP_SELX field.
	PWM_SM3CAPTCTRLX_INP_SELX_Pos = 0x6
	// Bit mask of INP_SELX field.
	PWM_SM3CAPTCTRLX_INP_SELX_Msk = 0x40
	// Bit INP_SELX.
	PWM_SM3CAPTCTRLX_INP_SELX = 0x40
	// Raw PWM_X input signal selected as source.
	PWM_SM3CAPTCTRLX_INP_SELX_INP_SELX_0 = 0x0
	// Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLX[EDGX0] and CAPTCTRLX[EDGX1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRX[EDGX0] and/or CAPTCTRLX[EDGX1] fields in order to enable one or both of the capture registers.
	PWM_SM3CAPTCTRLX_INP_SELX_INP_SELX_1 = 0x1
	// Position of EDGCNTX_EN field.
	PWM_SM3CAPTCTRLX_EDGCNTX_EN_Pos = 0x7
	// Bit mask of EDGCNTX_EN field.
	PWM_SM3CAPTCTRLX_EDGCNTX_EN_Msk = 0x80
	// Bit EDGCNTX_EN.
	PWM_SM3CAPTCTRLX_EDGCNTX_EN = 0x80
	// Edge counter disabled and held in reset
	PWM_SM3CAPTCTRLX_EDGCNTX_EN_EDGCNTX_EN_0 = 0x0
	// Edge counter enabled
	PWM_SM3CAPTCTRLX_EDGCNTX_EN_EDGCNTX_EN_1 = 0x1
	// Position of CFXWM field.
	PWM_SM3CAPTCTRLX_CFXWM_Pos = 0x8
	// Bit mask of CFXWM field.
	PWM_SM3CAPTCTRLX_CFXWM_Msk = 0x300
	// Position of CX0CNT field.
	PWM_SM3CAPTCTRLX_CX0CNT_Pos = 0xa
	// Bit mask of CX0CNT field.
	PWM_SM3CAPTCTRLX_CX0CNT_Msk = 0x1c00
	// Position of CX1CNT field.
	PWM_SM3CAPTCTRLX_CX1CNT_Pos = 0xd
	// Bit mask of CX1CNT field.
	PWM_SM3CAPTCTRLX_CX1CNT_Msk = 0xe000

	// SM3CAPTCOMPX: Capture Compare X Register
	// Position of EDGCMPX field.
	PWM_SM3CAPTCOMPX_EDGCMPX_Pos = 0x0
	// Bit mask of EDGCMPX field.
	PWM_SM3CAPTCOMPX_EDGCMPX_Msk = 0xff
	// Position of EDGCNTX field.
	PWM_SM3CAPTCOMPX_EDGCNTX_Pos = 0x8
	// Bit mask of EDGCNTX field.
	PWM_SM3CAPTCOMPX_EDGCNTX_Msk = 0xff00

	// SM3CVAL0: Capture Value 0 Register
	// Position of CAPTVAL0 field.
	PWM_SM3CVAL0_CAPTVAL0_Pos = 0x0
	// Bit mask of CAPTVAL0 field.
	PWM_SM3CVAL0_CAPTVAL0_Msk = 0xffff

	// SM3CVAL0CYC: Capture Value 0 Cycle Register
	// Position of CVAL0CYC field.
	PWM_SM3CVAL0CYC_CVAL0CYC_Pos = 0x0
	// Bit mask of CVAL0CYC field.
	PWM_SM3CVAL0CYC_CVAL0CYC_Msk = 0xf

	// SM3CVAL1: Capture Value 1 Register
	// Position of CAPTVAL1 field.
	PWM_SM3CVAL1_CAPTVAL1_Pos = 0x0
	// Bit mask of CAPTVAL1 field.
	PWM_SM3CVAL1_CAPTVAL1_Msk = 0xffff

	// SM3CVAL1CYC: Capture Value 1 Cycle Register
	// Position of CVAL1CYC field.
	PWM_SM3CVAL1CYC_CVAL1CYC_Pos = 0x0
	// Bit mask of CVAL1CYC field.
	PWM_SM3CVAL1CYC_CVAL1CYC_Msk = 0xf

	// SM3CVAL2: Capture Value 2 Register
	// Position of CAPTVAL2 field.
	PWM_SM3CVAL2_CAPTVAL2_Pos = 0x0
	// Bit mask of CAPTVAL2 field.
	PWM_SM3CVAL2_CAPTVAL2_Msk = 0xffff

	// SM3CVAL2CYC: Capture Value 2 Cycle Register
	// Position of CVAL2CYC field.
	PWM_SM3CVAL2CYC_CVAL2CYC_Pos = 0x0
	// Bit mask of CVAL2CYC field.
	PWM_SM3CVAL2CYC_CVAL2CYC_Msk = 0xf

	// SM3CVAL3: Capture Value 3 Register
	// Position of CAPTVAL3 field.
	PWM_SM3CVAL3_CAPTVAL3_Pos = 0x0
	// Bit mask of CAPTVAL3 field.
	PWM_SM3CVAL3_CAPTVAL3_Msk = 0xffff

	// SM3CVAL3CYC: Capture Value 3 Cycle Register
	// Position of CVAL3CYC field.
	PWM_SM3CVAL3CYC_CVAL3CYC_Pos = 0x0
	// Bit mask of CVAL3CYC field.
	PWM_SM3CVAL3CYC_CVAL3CYC_Msk = 0xf

	// SM3CVAL4: Capture Value 4 Register
	// Position of CAPTVAL4 field.
	PWM_SM3CVAL4_CAPTVAL4_Pos = 0x0
	// Bit mask of CAPTVAL4 field.
	PWM_SM3CVAL4_CAPTVAL4_Msk = 0xffff

	// SM3CVAL4CYC: Capture Value 4 Cycle Register
	// Position of CVAL4CYC field.
	PWM_SM3CVAL4CYC_CVAL4CYC_Pos = 0x0
	// Bit mask of CVAL4CYC field.
	PWM_SM3CVAL4CYC_CVAL4CYC_Msk = 0xf

	// SM3CVAL5: Capture Value 5 Register
	// Position of CAPTVAL5 field.
	PWM_SM3CVAL5_CAPTVAL5_Pos = 0x0
	// Bit mask of CAPTVAL5 field.
	PWM_SM3CVAL5_CAPTVAL5_Msk = 0xffff

	// SM3CVAL5CYC: Capture Value 5 Cycle Register
	// Position of CVAL5CYC field.
	PWM_SM3CVAL5CYC_CVAL5CYC_Pos = 0x0
	// Bit mask of CVAL5CYC field.
	PWM_SM3CVAL5CYC_CVAL5CYC_Msk = 0xf

	// OUTEN: Output Enable Register
	// Position of PWMX_EN field.
	PWM_OUTEN_PWMX_EN_Pos = 0x0
	// Bit mask of PWMX_EN field.
	PWM_OUTEN_PWMX_EN_Msk = 0xf
	// PWM_X output disabled.
	PWM_OUTEN_PWMX_EN_PWMX_EN_0 = 0x0
	// PWM_X output enabled.
	PWM_OUTEN_PWMX_EN_PWMX_EN_1 = 0x1
	// Position of PWMB_EN field.
	PWM_OUTEN_PWMB_EN_Pos = 0x4
	// Bit mask of PWMB_EN field.
	PWM_OUTEN_PWMB_EN_Msk = 0xf0
	// PWM_B output disabled.
	PWM_OUTEN_PWMB_EN_PWMB_EN_0 = 0x0
	// PWM_B output enabled.
	PWM_OUTEN_PWMB_EN_PWMB_EN_1 = 0x1
	// Position of PWMA_EN field.
	PWM_OUTEN_PWMA_EN_Pos = 0x8
	// Bit mask of PWMA_EN field.
	PWM_OUTEN_PWMA_EN_Msk = 0xf00
	// PWM_A output disabled.
	PWM_OUTEN_PWMA_EN_PWMA_EN_0 = 0x0
	// PWM_A output enabled.
	PWM_OUTEN_PWMA_EN_PWMA_EN_1 = 0x1

	// MASK: Mask Register
	// Position of MASKX field.
	PWM_MASK_MASKX_Pos = 0x0
	// Bit mask of MASKX field.
	PWM_MASK_MASKX_Msk = 0xf
	// PWM_X output normal.
	PWM_MASK_MASKX_MASKX_0 = 0x0
	// PWM_X output masked.
	PWM_MASK_MASKX_MASKX_1 = 0x1
	// Position of MASKB field.
	PWM_MASK_MASKB_Pos = 0x4
	// Bit mask of MASKB field.
	PWM_MASK_MASKB_Msk = 0xf0
	// PWM_B output normal.
	PWM_MASK_MASKB_MASKB_0 = 0x0
	// PWM_B output masked.
	PWM_MASK_MASKB_MASKB_1 = 0x1
	// Position of MASKA field.
	PWM_MASK_MASKA_Pos = 0x8
	// Bit mask of MASKA field.
	PWM_MASK_MASKA_Msk = 0xf00
	// PWM_A output normal.
	PWM_MASK_MASKA_MASKA_0 = 0x0
	// PWM_A output masked.
	PWM_MASK_MASKA_MASKA_1 = 0x1
	// Position of UPDATE_MASK field.
	PWM_MASK_UPDATE_MASK_Pos = 0xc
	// Bit mask of UPDATE_MASK field.
	PWM_MASK_UPDATE_MASK_Msk = 0xf000
	// Normal operation. MASK* bits within the corresponding submodule are not updated until a FORCE_OUT event occurs within the submodule.
	PWM_MASK_UPDATE_MASK_UPDATE_MASK_0 = 0x0
	// Immediate operation. MASK* bits within the corresponding submodule are updated on the following clock edge after setting this bit.
	PWM_MASK_UPDATE_MASK_UPDATE_MASK_1 = 0x1

	// SWCOUT: Software Controlled Output Register
	// Position of SM0OUT45 field.
	PWM_SWCOUT_SM0OUT45_Pos = 0x0
	// Bit mask of SM0OUT45 field.
	PWM_SWCOUT_SM0OUT45_Msk = 0x1
	// Bit SM0OUT45.
	PWM_SWCOUT_SM0OUT45 = 0x1
	// A logic 0 is supplied to the deadtime generator of submodule 0 instead of PWM45.
	PWM_SWCOUT_SM0OUT45_SM0OUT45_0 = 0x0
	// A logic 1 is supplied to the deadtime generator of submodule 0 instead of PWM45.
	PWM_SWCOUT_SM0OUT45_SM0OUT45_1 = 0x1
	// Position of SM0OUT23 field.
	PWM_SWCOUT_SM0OUT23_Pos = 0x1
	// Bit mask of SM0OUT23 field.
	PWM_SWCOUT_SM0OUT23_Msk = 0x2
	// Bit SM0OUT23.
	PWM_SWCOUT_SM0OUT23 = 0x2
	// A logic 0 is supplied to the deadtime generator of submodule 0 instead of PWM23.
	PWM_SWCOUT_SM0OUT23_SM0OUT23_0 = 0x0
	// A logic 1 is supplied to the deadtime generator of submodule 0 instead of PWM23.
	PWM_SWCOUT_SM0OUT23_SM0OUT23_1 = 0x1
	// Position of SM1OUT45 field.
	PWM_SWCOUT_SM1OUT45_Pos = 0x2
	// Bit mask of SM1OUT45 field.
	PWM_SWCOUT_SM1OUT45_Msk = 0x4
	// Bit SM1OUT45.
	PWM_SWCOUT_SM1OUT45 = 0x4
	// A logic 0 is supplied to the deadtime generator of submodule 1 instead of PWM45.
	PWM_SWCOUT_SM1OUT45_SM1OUT45_0 = 0x0
	// A logic 1 is supplied to the deadtime generator of submodule 1 instead of PWM45.
	PWM_SWCOUT_SM1OUT45_SM1OUT45_1 = 0x1
	// Position of SM1OUT23 field.
	PWM_SWCOUT_SM1OUT23_Pos = 0x3
	// Bit mask of SM1OUT23 field.
	PWM_SWCOUT_SM1OUT23_Msk = 0x8
	// Bit SM1OUT23.
	PWM_SWCOUT_SM1OUT23 = 0x8
	// A logic 0 is supplied to the deadtime generator of submodule 1 instead of PWM23.
	PWM_SWCOUT_SM1OUT23_SM1OUT23_0 = 0x0
	// A logic 1 is supplied to the deadtime generator of submodule 1 instead of PWM23.
	PWM_SWCOUT_SM1OUT23_SM1OUT23_1 = 0x1
	// Position of SM2OUT45 field.
	PWM_SWCOUT_SM2OUT45_Pos = 0x4
	// Bit mask of SM2OUT45 field.
	PWM_SWCOUT_SM2OUT45_Msk = 0x10
	// Bit SM2OUT45.
	PWM_SWCOUT_SM2OUT45 = 0x10
	// A logic 0 is supplied to the deadtime generator of submodule 2 instead of PWM45.
	PWM_SWCOUT_SM2OUT45_SM2OUT45_0 = 0x0
	// A logic 1 is supplied to the deadtime generator of submodule 2 instead of PWM45.
	PWM_SWCOUT_SM2OUT45_SM2OUT45_1 = 0x1
	// Position of SM2OUT23 field.
	PWM_SWCOUT_SM2OUT23_Pos = 0x5
	// Bit mask of SM2OUT23 field.
	PWM_SWCOUT_SM2OUT23_Msk = 0x20
	// Bit SM2OUT23.
	PWM_SWCOUT_SM2OUT23 = 0x20
	// A logic 0 is supplied to the deadtime generator of submodule 2 instead of PWM23.
	PWM_SWCOUT_SM2OUT23_SM2OUT23_0 = 0x0
	// A logic 1 is supplied to the deadtime generator of submodule 2 instead of PWM23.
	PWM_SWCOUT_SM2OUT23_SM2OUT23_1 = 0x1
	// Position of SM3OUT45 field.
	PWM_SWCOUT_SM3OUT45_Pos = 0x6
	// Bit mask of SM3OUT45 field.
	PWM_SWCOUT_SM3OUT45_Msk = 0x40
	// Bit SM3OUT45.
	PWM_SWCOUT_SM3OUT45 = 0x40
	// A logic 0 is supplied to the deadtime generator of submodule 3 instead of PWM45.
	PWM_SWCOUT_SM3OUT45_SM3OUT45_0 = 0x0
	// A logic 1 is supplied to the deadtime generator of submodule 3 instead of PWM45.
	PWM_SWCOUT_SM3OUT45_SM3OUT45_1 = 0x1
	// Position of SM3OUT23 field.
	PWM_SWCOUT_SM3OUT23_Pos = 0x7
	// Bit mask of SM3OUT23 field.
	PWM_SWCOUT_SM3OUT23_Msk = 0x80
	// Bit SM3OUT23.
	PWM_SWCOUT_SM3OUT23 = 0x80
	// A logic 0 is supplied to the deadtime generator of submodule 3 instead of PWM23.
	PWM_SWCOUT_SM3OUT23_SM3OUT23_0 = 0x0
	// A logic 1 is supplied to the deadtime generator of submodule 3 instead of PWM23.
	PWM_SWCOUT_SM3OUT23_SM3OUT23_1 = 0x1

	// DTSRCSEL: PWM Source Select Register
	// Position of SM0SEL45 field.
	PWM_DTSRCSEL_SM0SEL45_Pos = 0x0
	// Bit mask of SM0SEL45 field.
	PWM_DTSRCSEL_SM0SEL45_Msk = 0x3
	// Generated SM0PWM45 signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM0SEL45_SM0SEL45_0 = 0x0
	// Inverted generated SM0PWM45 signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM0SEL45_SM0SEL45_1 = 0x1
	// SWCOUT[SM0OUT45] is used by the deadtime logic.
	PWM_DTSRCSEL_SM0SEL45_SM0SEL45_2 = 0x2
	// PWM0_EXTB signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM0SEL45_SM0SEL45_3 = 0x3
	// Position of SM0SEL23 field.
	PWM_DTSRCSEL_SM0SEL23_Pos = 0x2
	// Bit mask of SM0SEL23 field.
	PWM_DTSRCSEL_SM0SEL23_Msk = 0xc
	// Generated SM0PWM23 signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM0SEL23_SM0SEL23_0 = 0x0
	// Inverted generated SM0PWM23 signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM0SEL23_SM0SEL23_1 = 0x1
	// SWCOUT[SM0OUT23] is used by the deadtime logic.
	PWM_DTSRCSEL_SM0SEL23_SM0SEL23_2 = 0x2
	// PWM0_EXTA signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM0SEL23_SM0SEL23_3 = 0x3
	// Position of SM1SEL45 field.
	PWM_DTSRCSEL_SM1SEL45_Pos = 0x4
	// Bit mask of SM1SEL45 field.
	PWM_DTSRCSEL_SM1SEL45_Msk = 0x30
	// Generated SM1PWM45 signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM1SEL45_SM1SEL45_0 = 0x0
	// Inverted generated SM1PWM45 signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM1SEL45_SM1SEL45_1 = 0x1
	// SWCOUT[SM1OUT45] is used by the deadtime logic.
	PWM_DTSRCSEL_SM1SEL45_SM1SEL45_2 = 0x2
	// PWM1_EXTB signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM1SEL45_SM1SEL45_3 = 0x3
	// Position of SM1SEL23 field.
	PWM_DTSRCSEL_SM1SEL23_Pos = 0x6
	// Bit mask of SM1SEL23 field.
	PWM_DTSRCSEL_SM1SEL23_Msk = 0xc0
	// Generated SM1PWM23 signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM1SEL23_SM1SEL23_0 = 0x0
	// Inverted generated SM1PWM23 signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM1SEL23_SM1SEL23_1 = 0x1
	// SWCOUT[SM1OUT23] is used by the deadtime logic.
	PWM_DTSRCSEL_SM1SEL23_SM1SEL23_2 = 0x2
	// PWM1_EXTA signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM1SEL23_SM1SEL23_3 = 0x3
	// Position of SM2SEL45 field.
	PWM_DTSRCSEL_SM2SEL45_Pos = 0x8
	// Bit mask of SM2SEL45 field.
	PWM_DTSRCSEL_SM2SEL45_Msk = 0x300
	// Generated SM2PWM45 signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM2SEL45_SM2SEL45_0 = 0x0
	// Inverted generated SM2PWM45 signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM2SEL45_SM2SEL45_1 = 0x1
	// SWCOUT[SM2OUT45] is used by the deadtime logic.
	PWM_DTSRCSEL_SM2SEL45_SM2SEL45_2 = 0x2
	// PWM2_EXTB signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM2SEL45_SM2SEL45_3 = 0x3
	// Position of SM2SEL23 field.
	PWM_DTSRCSEL_SM2SEL23_Pos = 0xa
	// Bit mask of SM2SEL23 field.
	PWM_DTSRCSEL_SM2SEL23_Msk = 0xc00
	// Generated SM2PWM23 signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM2SEL23_SM2SEL23_0 = 0x0
	// Inverted generated SM2PWM23 signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM2SEL23_SM2SEL23_1 = 0x1
	// SWCOUT[SM2OUT23] is used by the deadtime logic.
	PWM_DTSRCSEL_SM2SEL23_SM2SEL23_2 = 0x2
	// PWM2_EXTA signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM2SEL23_SM2SEL23_3 = 0x3
	// Position of SM3SEL45 field.
	PWM_DTSRCSEL_SM3SEL45_Pos = 0xc
	// Bit mask of SM3SEL45 field.
	PWM_DTSRCSEL_SM3SEL45_Msk = 0x3000
	// Generated SM3PWM45 signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM3SEL45_SM3SEL45_0 = 0x0
	// Inverted generated SM3PWM45 signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM3SEL45_SM3SEL45_1 = 0x1
	// SWCOUT[SM3OUT45] is used by the deadtime logic.
	PWM_DTSRCSEL_SM3SEL45_SM3SEL45_2 = 0x2
	// PWM3_EXTB signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM3SEL45_SM3SEL45_3 = 0x3
	// Position of SM3SEL23 field.
	PWM_DTSRCSEL_SM3SEL23_Pos = 0xe
	// Bit mask of SM3SEL23 field.
	PWM_DTSRCSEL_SM3SEL23_Msk = 0xc000
	// Generated SM3PWM23 signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM3SEL23_SM3SEL23_0 = 0x0
	// Inverted generated SM3PWM23 signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM3SEL23_SM3SEL23_1 = 0x1
	// SWCOUT[SM3OUT23] is used by the deadtime logic.
	PWM_DTSRCSEL_SM3SEL23_SM3SEL23_2 = 0x2
	// PWM3_EXTA signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM3SEL23_SM3SEL23_3 = 0x3

	// MCTRL: Master Control Register
	// Position of LDOK field.
	PWM_MCTRL_LDOK_Pos = 0x0
	// Bit mask of LDOK field.
	PWM_MCTRL_LDOK_Msk = 0xf
	// Do not load new values.
	PWM_MCTRL_LDOK_LDOK_0 = 0x0
	// Load prescaler, modulus, and PWM values of the corresponding submodule.
	PWM_MCTRL_LDOK_LDOK_1 = 0x1
	// Position of CLDOK field.
	PWM_MCTRL_CLDOK_Pos = 0x4
	// Bit mask of CLDOK field.
	PWM_MCTRL_CLDOK_Msk = 0xf0
	// Position of RUN field.
	PWM_MCTRL_RUN_Pos = 0x8
	// Bit mask of RUN field.
	PWM_MCTRL_RUN_Msk = 0xf00
	// PWM generator is disabled in the corresponding submodule.
	PWM_MCTRL_RUN_RUN_0 = 0x0
	// PWM generator is enabled in the corresponding submodule.
	PWM_MCTRL_RUN_RUN_1 = 0x1
	// Position of IPOL field.
	PWM_MCTRL_IPOL_Pos = 0xc
	// Bit mask of IPOL field.
	PWM_MCTRL_IPOL_Msk = 0xf000
	// PWM23 is used to generate complementary PWM pair in the corresponding submodule.
	PWM_MCTRL_IPOL_IPOL_0 = 0x0
	// PWM45 is used to generate complementary PWM pair in the corresponding submodule.
	PWM_MCTRL_IPOL_IPOL_1 = 0x1

	// MCTRL2: Master Control 2 Register
	// Position of MONPLL field.
	PWM_MCTRL2_MONPLL_Pos = 0x0
	// Bit mask of MONPLL field.
	PWM_MCTRL2_MONPLL_Msk = 0x3
	// Not locked. Do not monitor PLL operation. Resetting of the fractional delay block in case of PLL losing lock will be controlled by software.
	PWM_MCTRL2_MONPLL_MONPLL_0 = 0x0
	// Not locked. Monitor PLL operation to automatically disable the fractional delay block when the PLL encounters problems.
	PWM_MCTRL2_MONPLL_MONPLL_1 = 0x1
	// Locked. Do not monitor PLL operation. Resetting of the fractional delay block in case of PLL losing lock will be controlled by software. These bits are write protected until the next reset.
	PWM_MCTRL2_MONPLL_MONPLL_2 = 0x2
	// Locked. Monitor PLL operation to automatically disable the fractional delay block when the PLL encounters problems. These bits are write protected until the next reset.
	PWM_MCTRL2_MONPLL_MONPLL_3 = 0x3

	// FCTRL0: Fault Control Register
	// Position of FIE field.
	PWM_FCTRL0_FIE_Pos = 0x0
	// Bit mask of FIE field.
	PWM_FCTRL0_FIE_Msk = 0xf
	// FAULTx CPU interrupt requests disabled.
	PWM_FCTRL0_FIE_FIE_0 = 0x0
	// FAULTx CPU interrupt requests enabled.
	PWM_FCTRL0_FIE_FIE_1 = 0x1
	// Position of FSAFE field.
	PWM_FCTRL0_FSAFE_Pos = 0x4
	// Bit mask of FSAFE field.
	PWM_FCTRL0_FSAFE_Msk = 0xf0
	// Normal mode. PWM outputs disabled by this fault are not enabled until FSTS[FFLAGx] is clear at the start of a half cycle or full cycle depending on the state of FSTS[FFULL] without regard to the state of FSTS[FFPINx]. The PWM outputs disabled by this fault input will not be re-enabled until the actual FAULTx input signal de-asserts since the fault input will combinationally disable the PWM outputs (as programmed in DISMAPn).
	PWM_FCTRL0_FSAFE_FSAFE_0 = 0x0
	// Safe mode. PWM outputs disabled by this fault are not enabled until FSTS[FFLAGx] is clear and FSTS[FFPINx] is clear at the start of a half cycle or full cycle depending on the state of FSTS[FFULL].
	PWM_FCTRL0_FSAFE_FSAFE_1 = 0x1
	// Position of FAUTO field.
	PWM_FCTRL0_FAUTO_Pos = 0x8
	// Bit mask of FAUTO field.
	PWM_FCTRL0_FAUTO_Msk = 0xf00
	// Manual fault clearing. PWM outputs disabled by this fault are not enabled until FSTS[FFLAGx] is clear at the start of a half cycle or full cycle depending the state of FSTS[FFULL]. This is further controlled by FCTRL[FSAFE].
	PWM_FCTRL0_FAUTO_FAUTO_0 = 0x0
	// Automatic fault clearing. PWM outputs disabled by this fault are enabled when FSTS[FFPINx] is clear at the start of a half cycle or full cycle depending on the state of FSTS[FFULL] without regard to the state of FSTS[FFLAGx].
	PWM_FCTRL0_FAUTO_FAUTO_1 = 0x1
	// Position of FLVL field.
	PWM_FCTRL0_FLVL_Pos = 0xc
	// Bit mask of FLVL field.
	PWM_FCTRL0_FLVL_Msk = 0xf000
	// A logic 0 on the fault input indicates a fault condition.
	PWM_FCTRL0_FLVL_FLVL_0 = 0x0
	// A logic 1 on the fault input indicates a fault condition.
	PWM_FCTRL0_FLVL_FLVL_1 = 0x1

	// FSTS0: Fault Status Register
	// Position of FFLAG field.
	PWM_FSTS0_FFLAG_Pos = 0x0
	// Bit mask of FFLAG field.
	PWM_FSTS0_FFLAG_Msk = 0xf
	// No fault on the FAULTx pin.
	PWM_FSTS0_FFLAG_FFLAG_0 = 0x0
	// Fault on the FAULTx pin.
	PWM_FSTS0_FFLAG_FFLAG_1 = 0x1
	// Position of FFULL field.
	PWM_FSTS0_FFULL_Pos = 0x4
	// Bit mask of FFULL field.
	PWM_FSTS0_FFULL_Msk = 0xf0
	// PWM outputs are not re-enabled at the start of a full cycle
	PWM_FSTS0_FFULL_FFULL_0 = 0x0
	// PWM outputs are re-enabled at the start of a full cycle
	PWM_FSTS0_FFULL_FFULL_1 = 0x1
	// Position of FFPIN field.
	PWM_FSTS0_FFPIN_Pos = 0x8
	// Bit mask of FFPIN field.
	PWM_FSTS0_FFPIN_Msk = 0xf00
	// Position of FHALF field.
	PWM_FSTS0_FHALF_Pos = 0xc
	// Bit mask of FHALF field.
	PWM_FSTS0_FHALF_Msk = 0xf000
	// PWM outputs are not re-enabled at the start of a half cycle.
	PWM_FSTS0_FHALF_FHALF_0 = 0x0
	// PWM outputs are re-enabled at the start of a half cycle (as defined by VAL0).
	PWM_FSTS0_FHALF_FHALF_1 = 0x1

	// FFILT0: Fault Filter Register
	// Position of FILT_PER field.
	PWM_FFILT0_FILT_PER_Pos = 0x0
	// Bit mask of FILT_PER field.
	PWM_FFILT0_FILT_PER_Msk = 0xff
	// Position of FILT_CNT field.
	PWM_FFILT0_FILT_CNT_Pos = 0x8
	// Bit mask of FILT_CNT field.
	PWM_FFILT0_FILT_CNT_Msk = 0x700
	// Position of GSTR field.
	PWM_FFILT0_GSTR_Pos = 0xf
	// Bit mask of GSTR field.
	PWM_FFILT0_GSTR_Msk = 0x8000
	// Bit GSTR.
	PWM_FFILT0_GSTR = 0x8000
	// Fault input glitch stretching is disabled.
	PWM_FFILT0_GSTR_GSTR_0 = 0x0
	// Input fault signals will be stretched to at least 2 IPBus clock cycles.
	PWM_FFILT0_GSTR_GSTR_1 = 0x1

	// FTST0: Fault Test Register
	// Position of FTEST field.
	PWM_FTST0_FTEST_Pos = 0x0
	// Bit mask of FTEST field.
	PWM_FTST0_FTEST_Msk = 0x1
	// Bit FTEST.
	PWM_FTST0_FTEST = 0x1
	// No fault
	PWM_FTST0_FTEST_FTEST_0 = 0x0
	// Cause a simulated fault
	PWM_FTST0_FTEST_FTEST_1 = 0x1

	// FCTRL20: Fault Control 2 Register
	// Position of NOCOMB field.
	PWM_FCTRL20_NOCOMB_Pos = 0x0
	// Bit mask of NOCOMB field.
	PWM_FCTRL20_NOCOMB_Msk = 0xf
	// There is a combinational link from the fault inputs to the PWM outputs. The fault inputs are combined with the filtered and latched fault signals to disable the PWM outputs.
	PWM_FCTRL20_NOCOMB_NOCOMB_0 = 0x0
	// The direct combinational path from the fault inputs to the PWM outputs is disabled and the filtered and latched fault signals are used to disable the PWM outputs.
	PWM_FCTRL20_NOCOMB_NOCOMB_1 = 0x1
)

// Bitfields for BEE: Bus Encryption Engine
const (
	// CTRL: BEE Control Register
	// Position of BEE_ENABLE field.
	BEE_CTRL_BEE_ENABLE_Pos = 0x0
	// Bit mask of BEE_ENABLE field.
	BEE_CTRL_BEE_ENABLE_Msk = 0x1
	// Bit BEE_ENABLE.
	BEE_CTRL_BEE_ENABLE = 0x1
	// Disable BEE
	BEE_CTRL_BEE_ENABLE_BEE_ENABLE_0 = 0x0
	// Enable BEE
	BEE_CTRL_BEE_ENABLE_BEE_ENABLE_1 = 0x1
	// Position of CTRL_CLK_EN field.
	BEE_CTRL_CTRL_CLK_EN_Pos = 0x1
	// Bit mask of CTRL_CLK_EN field.
	BEE_CTRL_CTRL_CLK_EN_Msk = 0x2
	// Bit CTRL_CLK_EN.
	BEE_CTRL_CTRL_CLK_EN = 0x2
	// Position of CTRL_SFTRST_N field.
	BEE_CTRL_CTRL_SFTRST_N_Pos = 0x2
	// Bit mask of CTRL_SFTRST_N field.
	BEE_CTRL_CTRL_SFTRST_N_Msk = 0x4
	// Bit CTRL_SFTRST_N.
	BEE_CTRL_CTRL_SFTRST_N = 0x4
	// Position of KEY_VALID field.
	BEE_CTRL_KEY_VALID_Pos = 0x4
	// Bit mask of KEY_VALID field.
	BEE_CTRL_KEY_VALID_Msk = 0x10
	// Bit KEY_VALID.
	BEE_CTRL_KEY_VALID = 0x10
	// Position of KEY_REGION_SEL field.
	BEE_CTRL_KEY_REGION_SEL_Pos = 0x5
	// Bit mask of KEY_REGION_SEL field.
	BEE_CTRL_KEY_REGION_SEL_Msk = 0x20
	// Bit KEY_REGION_SEL.
	BEE_CTRL_KEY_REGION_SEL = 0x20
	// Load AES key for region0
	BEE_CTRL_KEY_REGION_SEL_KEY_REGION_SEL_0 = 0x0
	// Load AES key for region1
	BEE_CTRL_KEY_REGION_SEL_KEY_REGION_SEL_1 = 0x1
	// Position of AC_PROT_EN field.
	BEE_CTRL_AC_PROT_EN_Pos = 0x6
	// Bit mask of AC_PROT_EN field.
	BEE_CTRL_AC_PROT_EN_Msk = 0x40
	// Bit AC_PROT_EN.
	BEE_CTRL_AC_PROT_EN = 0x40
	// Position of LITTLE_ENDIAN field.
	BEE_CTRL_LITTLE_ENDIAN_Pos = 0x7
	// Bit mask of LITTLE_ENDIAN field.
	BEE_CTRL_LITTLE_ENDIAN_Msk = 0x80
	// Bit LITTLE_ENDIAN.
	BEE_CTRL_LITTLE_ENDIAN = 0x80
	// The input and output data of the AES core is swapped as below: {B15,B14,B13,B12,B11,B10,B9,B8, B7,B6,B5,B4,B3,B2,B1,B0} swap to {B0,B1,B2,B3,B4,B5,B6,B7, B8,B9,B10,B11,B12,B13,B14,B15}, where B0~B15 refers to Byte0 to Byte15.
	BEE_CTRL_LITTLE_ENDIAN_LITTLE_ENDIAN_0 = 0x0
	// The input and output data of AES core is not swapped.
	BEE_CTRL_LITTLE_ENDIAN_LITTLE_ENDIAN_1 = 0x1
	// Position of SECURITY_LEVEL_R0 field.
	BEE_CTRL_SECURITY_LEVEL_R0_Pos = 0x8
	// Bit mask of SECURITY_LEVEL_R0 field.
	BEE_CTRL_SECURITY_LEVEL_R0_Msk = 0x300
	// Position of CTRL_AES_MODE_R0 field.
	BEE_CTRL_CTRL_AES_MODE_R0_Pos = 0xa
	// Bit mask of CTRL_AES_MODE_R0 field.
	BEE_CTRL_CTRL_AES_MODE_R0_Msk = 0x400
	// Bit CTRL_AES_MODE_R0.
	BEE_CTRL_CTRL_AES_MODE_R0 = 0x400
	// ECB
	BEE_CTRL_CTRL_AES_MODE_R0_CTRL_AES_MODE_R0_0 = 0x0
	// CTR
	BEE_CTRL_CTRL_AES_MODE_R0_CTRL_AES_MODE_R0_1 = 0x1
	// Position of SECURITY_LEVEL_R1 field.
	BEE_CTRL_SECURITY_LEVEL_R1_Pos = 0xc
	// Bit mask of SECURITY_LEVEL_R1 field.
	BEE_CTRL_SECURITY_LEVEL_R1_Msk = 0x3000
	// Position of CTRL_AES_MODE_R1 field.
	BEE_CTRL_CTRL_AES_MODE_R1_Pos = 0xe
	// Bit mask of CTRL_AES_MODE_R1 field.
	BEE_CTRL_CTRL_AES_MODE_R1_Msk = 0x4000
	// Bit CTRL_AES_MODE_R1.
	BEE_CTRL_CTRL_AES_MODE_R1 = 0x4000
	// ECB
	BEE_CTRL_CTRL_AES_MODE_R1_CTRL_AES_MODE_R1_0 = 0x0
	// CTR
	BEE_CTRL_CTRL_AES_MODE_R1_CTRL_AES_MODE_R1_1 = 0x1
	// Position of BEE_ENABLE_LOCK field.
	BEE_CTRL_BEE_ENABLE_LOCK_Pos = 0x10
	// Bit mask of BEE_ENABLE_LOCK field.
	BEE_CTRL_BEE_ENABLE_LOCK_Msk = 0x10000
	// Bit BEE_ENABLE_LOCK.
	BEE_CTRL_BEE_ENABLE_LOCK = 0x10000
	// Position of CTRL_CLK_EN_LOCK field.
	BEE_CTRL_CTRL_CLK_EN_LOCK_Pos = 0x11
	// Bit mask of CTRL_CLK_EN_LOCK field.
	BEE_CTRL_CTRL_CLK_EN_LOCK_Msk = 0x20000
	// Bit CTRL_CLK_EN_LOCK.
	BEE_CTRL_CTRL_CLK_EN_LOCK = 0x20000
	// Position of CTRL_SFTRST_N_LOCK field.
	BEE_CTRL_CTRL_SFTRST_N_LOCK_Pos = 0x12
	// Bit mask of CTRL_SFTRST_N_LOCK field.
	BEE_CTRL_CTRL_SFTRST_N_LOCK_Msk = 0x40000
	// Bit CTRL_SFTRST_N_LOCK.
	BEE_CTRL_CTRL_SFTRST_N_LOCK = 0x40000
	// Position of REGION1_ADDR_LOCK field.
	BEE_CTRL_REGION1_ADDR_LOCK_Pos = 0x13
	// Bit mask of REGION1_ADDR_LOCK field.
	BEE_CTRL_REGION1_ADDR_LOCK_Msk = 0x80000
	// Bit REGION1_ADDR_LOCK.
	BEE_CTRL_REGION1_ADDR_LOCK = 0x80000
	// Position of KEY_VALID_LOCK field.
	BEE_CTRL_KEY_VALID_LOCK_Pos = 0x14
	// Bit mask of KEY_VALID_LOCK field.
	BEE_CTRL_KEY_VALID_LOCK_Msk = 0x100000
	// Bit KEY_VALID_LOCK.
	BEE_CTRL_KEY_VALID_LOCK = 0x100000
	// Position of KEY_REGION_SEL_LOCK field.
	BEE_CTRL_KEY_REGION_SEL_LOCK_Pos = 0x15
	// Bit mask of KEY_REGION_SEL_LOCK field.
	BEE_CTRL_KEY_REGION_SEL_LOCK_Msk = 0x200000
	// Bit KEY_REGION_SEL_LOCK.
	BEE_CTRL_KEY_REGION_SEL_LOCK = 0x200000
	// Position of AC_PROT_EN_LOCK field.
	BEE_CTRL_AC_PROT_EN_LOCK_Pos = 0x16
	// Bit mask of AC_PROT_EN_LOCK field.
	BEE_CTRL_AC_PROT_EN_LOCK_Msk = 0x400000
	// Bit AC_PROT_EN_LOCK.
	BEE_CTRL_AC_PROT_EN_LOCK = 0x400000
	// Position of LITTLE_ENDIAN_LOCK field.
	BEE_CTRL_LITTLE_ENDIAN_LOCK_Pos = 0x17
	// Bit mask of LITTLE_ENDIAN_LOCK field.
	BEE_CTRL_LITTLE_ENDIAN_LOCK_Msk = 0x800000
	// Bit LITTLE_ENDIAN_LOCK.
	BEE_CTRL_LITTLE_ENDIAN_LOCK = 0x800000
	// Position of SECURITY_LEVEL_R0_LOCK field.
	BEE_CTRL_SECURITY_LEVEL_R0_LOCK_Pos = 0x18
	// Bit mask of SECURITY_LEVEL_R0_LOCK field.
	BEE_CTRL_SECURITY_LEVEL_R0_LOCK_Msk = 0x3000000
	// Position of CTRL_AES_MODE_R0_LOCK field.
	BEE_CTRL_CTRL_AES_MODE_R0_LOCK_Pos = 0x1a
	// Bit mask of CTRL_AES_MODE_R0_LOCK field.
	BEE_CTRL_CTRL_AES_MODE_R0_LOCK_Msk = 0x4000000
	// Bit CTRL_AES_MODE_R0_LOCK.
	BEE_CTRL_CTRL_AES_MODE_R0_LOCK = 0x4000000
	// Position of REGION0_KEY_LOCK field.
	BEE_CTRL_REGION0_KEY_LOCK_Pos = 0x1b
	// Bit mask of REGION0_KEY_LOCK field.
	BEE_CTRL_REGION0_KEY_LOCK_Msk = 0x8000000
	// Bit REGION0_KEY_LOCK.
	BEE_CTRL_REGION0_KEY_LOCK = 0x8000000
	// Position of SECURITY_LEVEL_R1_LOCK field.
	BEE_CTRL_SECURITY_LEVEL_R1_LOCK_Pos = 0x1c
	// Bit mask of SECURITY_LEVEL_R1_LOCK field.
	BEE_CTRL_SECURITY_LEVEL_R1_LOCK_Msk = 0x30000000
	// Position of CTRL_AES_MODE_R1_LOCK field.
	BEE_CTRL_CTRL_AES_MODE_R1_LOCK_Pos = 0x1e
	// Bit mask of CTRL_AES_MODE_R1_LOCK field.
	BEE_CTRL_CTRL_AES_MODE_R1_LOCK_Msk = 0x40000000
	// Bit CTRL_AES_MODE_R1_LOCK.
	BEE_CTRL_CTRL_AES_MODE_R1_LOCK = 0x40000000
	// Position of REGION1_KEY_LOCK field.
	BEE_CTRL_REGION1_KEY_LOCK_Pos = 0x1f
	// Bit mask of REGION1_KEY_LOCK field.
	BEE_CTRL_REGION1_KEY_LOCK_Msk = 0x80000000
	// Bit REGION1_KEY_LOCK.
	BEE_CTRL_REGION1_KEY_LOCK = 0x80000000

	// ADDR_OFFSET0: no description available
	// Position of ADDR_OFFSET0 field.
	BEE_ADDR_OFFSET0_ADDR_OFFSET0_Pos = 0x0
	// Bit mask of ADDR_OFFSET0 field.
	BEE_ADDR_OFFSET0_ADDR_OFFSET0_Msk = 0xffff
	// Position of ADDR_OFFSET0_LOCK field.
	BEE_ADDR_OFFSET0_ADDR_OFFSET0_LOCK_Pos = 0x10
	// Bit mask of ADDR_OFFSET0_LOCK field.
	BEE_ADDR_OFFSET0_ADDR_OFFSET0_LOCK_Msk = 0xffff0000

	// ADDR_OFFSET1: no description available
	// Position of ADDR_OFFSET1 field.
	BEE_ADDR_OFFSET1_ADDR_OFFSET1_Pos = 0x0
	// Bit mask of ADDR_OFFSET1 field.
	BEE_ADDR_OFFSET1_ADDR_OFFSET1_Msk = 0xffff
	// Position of ADDR_OFFSET1_LOCK field.
	BEE_ADDR_OFFSET1_ADDR_OFFSET1_LOCK_Pos = 0x10
	// Bit mask of ADDR_OFFSET1_LOCK field.
	BEE_ADDR_OFFSET1_ADDR_OFFSET1_LOCK_Msk = 0xffff0000

	// AES_KEY0_W0: no description available
	// Position of KEY0 field.
	BEE_AES_KEY0_W0_KEY0_Pos = 0x0
	// Bit mask of KEY0 field.
	BEE_AES_KEY0_W0_KEY0_Msk = 0xffffffff

	// AES_KEY0_W1: no description available
	// Position of KEY1 field.
	BEE_AES_KEY0_W1_KEY1_Pos = 0x0
	// Bit mask of KEY1 field.
	BEE_AES_KEY0_W1_KEY1_Msk = 0xffffffff

	// AES_KEY0_W2: no description available
	// Position of KEY2 field.
	BEE_AES_KEY0_W2_KEY2_Pos = 0x0
	// Bit mask of KEY2 field.
	BEE_AES_KEY0_W2_KEY2_Msk = 0xffffffff

	// AES_KEY0_W3: no description available
	// Position of KEY3 field.
	BEE_AES_KEY0_W3_KEY3_Pos = 0x0
	// Bit mask of KEY3 field.
	BEE_AES_KEY0_W3_KEY3_Msk = 0xffffffff

	// STATUS: no description available
	// Position of IRQ_VEC field.
	BEE_STATUS_IRQ_VEC_Pos = 0x0
	// Bit mask of IRQ_VEC field.
	BEE_STATUS_IRQ_VEC_Msk = 0xff
	// Position of BEE_IDLE field.
	BEE_STATUS_BEE_IDLE_Pos = 0x8
	// Bit mask of BEE_IDLE field.
	BEE_STATUS_BEE_IDLE_Msk = 0x100
	// Bit BEE_IDLE.
	BEE_STATUS_BEE_IDLE = 0x100

	// CTR_NONCE0_W0: no description available
	// Position of NONCE00 field.
	BEE_CTR_NONCE0_W0_NONCE00_Pos = 0x0
	// Bit mask of NONCE00 field.
	BEE_CTR_NONCE0_W0_NONCE00_Msk = 0xffffffff

	// CTR_NONCE0_W1: no description available
	// Position of NONCE01 field.
	BEE_CTR_NONCE0_W1_NONCE01_Pos = 0x0
	// Bit mask of NONCE01 field.
	BEE_CTR_NONCE0_W1_NONCE01_Msk = 0xffffffff

	// CTR_NONCE0_W2: no description available
	// Position of NONCE02 field.
	BEE_CTR_NONCE0_W2_NONCE02_Pos = 0x0
	// Bit mask of NONCE02 field.
	BEE_CTR_NONCE0_W2_NONCE02_Msk = 0xffffffff

	// CTR_NONCE0_W3: no description available
	// Position of NONCE03 field.
	BEE_CTR_NONCE0_W3_NONCE03_Pos = 0x0
	// Bit mask of NONCE03 field.
	BEE_CTR_NONCE0_W3_NONCE03_Msk = 0xffffffff

	// CTR_NONCE1_W0: no description available
	// Position of NONCE10 field.
	BEE_CTR_NONCE1_W0_NONCE10_Pos = 0x0
	// Bit mask of NONCE10 field.
	BEE_CTR_NONCE1_W0_NONCE10_Msk = 0xffffffff

	// CTR_NONCE1_W1: no description available
	// Position of NONCE11 field.
	BEE_CTR_NONCE1_W1_NONCE11_Pos = 0x0
	// Bit mask of NONCE11 field.
	BEE_CTR_NONCE1_W1_NONCE11_Msk = 0xffffffff

	// CTR_NONCE1_W2: no description available
	// Position of NONCE12 field.
	BEE_CTR_NONCE1_W2_NONCE12_Pos = 0x0
	// Bit mask of NONCE12 field.
	BEE_CTR_NONCE1_W2_NONCE12_Msk = 0xffffffff

	// CTR_NONCE1_W3: no description available
	// Position of NONCE13 field.
	BEE_CTR_NONCE1_W3_NONCE13_Pos = 0x0
	// Bit mask of NONCE13 field.
	BEE_CTR_NONCE1_W3_NONCE13_Msk = 0xffffffff

	// REGION1_TOP: no description available
	// Position of REGION1_TOP field.
	BEE_REGION1_TOP_REGION1_TOP_Pos = 0x0
	// Bit mask of REGION1_TOP field.
	BEE_REGION1_TOP_REGION1_TOP_Msk = 0xffffffff

	// REGION1_BOT: no description available
	// Position of REGION1_BOT field.
	BEE_REGION1_BOT_REGION1_BOT_Pos = 0x0
	// Bit mask of REGION1_BOT field.
	BEE_REGION1_BOT_REGION1_BOT_Msk = 0xffffffff
)

// Bitfields for LPI2C1: LPI2C
const (
	// VERID: Version ID Register
	// Position of FEATURE field.
	LPI2C_VERID_FEATURE_Pos = 0x0
	// Bit mask of FEATURE field.
	LPI2C_VERID_FEATURE_Msk = 0xffff
	// Master only, with standard feature set
	LPI2C_VERID_FEATURE_FEATURE_2 = 0x2
	// Master and slave, with standard feature set
	LPI2C_VERID_FEATURE_FEATURE_3 = 0x3
	// Position of MINOR field.
	LPI2C_VERID_MINOR_Pos = 0x10
	// Bit mask of MINOR field.
	LPI2C_VERID_MINOR_Msk = 0xff0000
	// Position of MAJOR field.
	LPI2C_VERID_MAJOR_Pos = 0x18
	// Bit mask of MAJOR field.
	LPI2C_VERID_MAJOR_Msk = 0xff000000

	// PARAM: Parameter Register
	// Position of MTXFIFO field.
	LPI2C_PARAM_MTXFIFO_Pos = 0x0
	// Bit mask of MTXFIFO field.
	LPI2C_PARAM_MTXFIFO_Msk = 0xf
	// Position of MRXFIFO field.
	LPI2C_PARAM_MRXFIFO_Pos = 0x8
	// Bit mask of MRXFIFO field.
	LPI2C_PARAM_MRXFIFO_Msk = 0xf00

	// MCR: Master Control Register
	// Position of MEN field.
	LPI2C_MCR_MEN_Pos = 0x0
	// Bit mask of MEN field.
	LPI2C_MCR_MEN_Msk = 0x1
	// Bit MEN.
	LPI2C_MCR_MEN = 0x1
	// Master logic is disabled
	LPI2C_MCR_MEN_MEN_0 = 0x0
	// Master logic is enabled
	LPI2C_MCR_MEN_MEN_1 = 0x1
	// Position of RST field.
	LPI2C_MCR_RST_Pos = 0x1
	// Bit mask of RST field.
	LPI2C_MCR_RST_Msk = 0x2
	// Bit RST.
	LPI2C_MCR_RST = 0x2
	// Master logic is not reset
	LPI2C_MCR_RST_RST_0 = 0x0
	// Master logic is reset
	LPI2C_MCR_RST_RST_1 = 0x1
	// Position of DOZEN field.
	LPI2C_MCR_DOZEN_Pos = 0x2
	// Bit mask of DOZEN field.
	LPI2C_MCR_DOZEN_Msk = 0x4
	// Bit DOZEN.
	LPI2C_MCR_DOZEN = 0x4
	// Master is enabled in Doze mode
	LPI2C_MCR_DOZEN_DOZEN_0 = 0x0
	// Master is disabled in Doze mode
	LPI2C_MCR_DOZEN_DOZEN_1 = 0x1
	// Position of DBGEN field.
	LPI2C_MCR_DBGEN_Pos = 0x3
	// Bit mask of DBGEN field.
	LPI2C_MCR_DBGEN_Msk = 0x8
	// Bit DBGEN.
	LPI2C_MCR_DBGEN = 0x8
	// Master is disabled in debug mode
	LPI2C_MCR_DBGEN_DBGEN_0 = 0x0
	// Master is enabled in debug mode
	LPI2C_MCR_DBGEN_DBGEN_1 = 0x1
	// Position of RTF field.
	LPI2C_MCR_RTF_Pos = 0x8
	// Bit mask of RTF field.
	LPI2C_MCR_RTF_Msk = 0x100
	// Bit RTF.
	LPI2C_MCR_RTF = 0x100
	// No effect
	LPI2C_MCR_RTF_RTF_0 = 0x0
	// Transmit FIFO is reset
	LPI2C_MCR_RTF_RTF_1 = 0x1
	// Position of RRF field.
	LPI2C_MCR_RRF_Pos = 0x9
	// Bit mask of RRF field.
	LPI2C_MCR_RRF_Msk = 0x200
	// Bit RRF.
	LPI2C_MCR_RRF = 0x200
	// No effect
	LPI2C_MCR_RRF_RRF_0 = 0x0
	// Receive FIFO is reset
	LPI2C_MCR_RRF_RRF_1 = 0x1

	// MSR: Master Status Register
	// Position of TDF field.
	LPI2C_MSR_TDF_Pos = 0x0
	// Bit mask of TDF field.
	LPI2C_MSR_TDF_Msk = 0x1
	// Bit TDF.
	LPI2C_MSR_TDF = 0x1
	// Transmit data is not requested
	LPI2C_MSR_TDF_TDF_0 = 0x0
	// Transmit data is requested
	LPI2C_MSR_TDF_TDF_1 = 0x1
	// Position of RDF field.
	LPI2C_MSR_RDF_Pos = 0x1
	// Bit mask of RDF field.
	LPI2C_MSR_RDF_Msk = 0x2
	// Bit RDF.
	LPI2C_MSR_RDF = 0x2
	// Receive Data is not ready
	LPI2C_MSR_RDF_RDF_0 = 0x0
	// Receive data is ready
	LPI2C_MSR_RDF_RDF_1 = 0x1
	// Position of EPF field.
	LPI2C_MSR_EPF_Pos = 0x8
	// Bit mask of EPF field.
	LPI2C_MSR_EPF_Msk = 0x100
	// Bit EPF.
	LPI2C_MSR_EPF = 0x100
	// Master has not generated a STOP or Repeated START condition
	LPI2C_MSR_EPF_EPF_0 = 0x0
	// Master has generated a STOP or Repeated START condition
	LPI2C_MSR_EPF_EPF_1 = 0x1
	// Position of SDF field.
	LPI2C_MSR_SDF_Pos = 0x9
	// Bit mask of SDF field.
	LPI2C_MSR_SDF_Msk = 0x200
	// Bit SDF.
	LPI2C_MSR_SDF = 0x200
	// Master has not generated a STOP condition
	LPI2C_MSR_SDF_SDF_0 = 0x0
	// Master has generated a STOP condition
	LPI2C_MSR_SDF_SDF_1 = 0x1
	// Position of NDF field.
	LPI2C_MSR_NDF_Pos = 0xa
	// Bit mask of NDF field.
	LPI2C_MSR_NDF_Msk = 0x400
	// Bit NDF.
	LPI2C_MSR_NDF = 0x400
	// Unexpected NACK was not detected
	LPI2C_MSR_NDF_NDF_0 = 0x0
	// Unexpected NACK was detected
	LPI2C_MSR_NDF_NDF_1 = 0x1
	// Position of ALF field.
	LPI2C_MSR_ALF_Pos = 0xb
	// Bit mask of ALF field.
	LPI2C_MSR_ALF_Msk = 0x800
	// Bit ALF.
	LPI2C_MSR_ALF = 0x800
	// Master has not lost arbitration
	LPI2C_MSR_ALF_ALF_0 = 0x0
	// Master has lost arbitration
	LPI2C_MSR_ALF_ALF_1 = 0x1
	// Position of FEF field.
	LPI2C_MSR_FEF_Pos = 0xc
	// Bit mask of FEF field.
	LPI2C_MSR_FEF_Msk = 0x1000
	// Bit FEF.
	LPI2C_MSR_FEF = 0x1000
	// No error
	LPI2C_MSR_FEF_FEF_0 = 0x0
	// Master sending or receiving data without a START condition
	LPI2C_MSR_FEF_FEF_1 = 0x1
	// Position of PLTF field.
	LPI2C_MSR_PLTF_Pos = 0xd
	// Bit mask of PLTF field.
	LPI2C_MSR_PLTF_Msk = 0x2000
	// Bit PLTF.
	LPI2C_MSR_PLTF = 0x2000
	// Pin low timeout has not occurred or is disabled
	LPI2C_MSR_PLTF_PLTF_0 = 0x0
	// Pin low timeout has occurred
	LPI2C_MSR_PLTF_PLTF_1 = 0x1
	// Position of DMF field.
	LPI2C_MSR_DMF_Pos = 0xe
	// Bit mask of DMF field.
	LPI2C_MSR_DMF_Msk = 0x4000
	// Bit DMF.
	LPI2C_MSR_DMF = 0x4000
	// Have not received matching data
	LPI2C_MSR_DMF_DMF_0 = 0x0
	// Have received matching data
	LPI2C_MSR_DMF_DMF_1 = 0x1
	// Position of MBF field.
	LPI2C_MSR_MBF_Pos = 0x18
	// Bit mask of MBF field.
	LPI2C_MSR_MBF_Msk = 0x1000000
	// Bit MBF.
	LPI2C_MSR_MBF = 0x1000000
	// I2C Master is idle
	LPI2C_MSR_MBF_MBF_0 = 0x0
	// I2C Master is busy
	LPI2C_MSR_MBF_MBF_1 = 0x1
	// Position of BBF field.
	LPI2C_MSR_BBF_Pos = 0x19
	// Bit mask of BBF field.
	LPI2C_MSR_BBF_Msk = 0x2000000
	// Bit BBF.
	LPI2C_MSR_BBF = 0x2000000
	// I2C Bus is idle
	LPI2C_MSR_BBF_BBF_0 = 0x0
	// I2C Bus is busy
	LPI2C_MSR_BBF_BBF_1 = 0x1

	// MIER: Master Interrupt Enable Register
	// Position of TDIE field.
	LPI2C_MIER_TDIE_Pos = 0x0
	// Bit mask of TDIE field.
	LPI2C_MIER_TDIE_Msk = 0x1
	// Bit TDIE.
	LPI2C_MIER_TDIE = 0x1
	// Disabled
	LPI2C_MIER_TDIE_TDIE_0 = 0x0
	// Enabled
	LPI2C_MIER_TDIE_TDIE_1 = 0x1
	// Position of RDIE field.
	LPI2C_MIER_RDIE_Pos = 0x1
	// Bit mask of RDIE field.
	LPI2C_MIER_RDIE_Msk = 0x2
	// Bit RDIE.
	LPI2C_MIER_RDIE = 0x2
	// Disabled
	LPI2C_MIER_RDIE_RDIE_0 = 0x0
	// Enabled
	LPI2C_MIER_RDIE_RDIE_1 = 0x1
	// Position of EPIE field.
	LPI2C_MIER_EPIE_Pos = 0x8
	// Bit mask of EPIE field.
	LPI2C_MIER_EPIE_Msk = 0x100
	// Bit EPIE.
	LPI2C_MIER_EPIE = 0x100
	// Disabled
	LPI2C_MIER_EPIE_EPIE_0 = 0x0
	// Enabled
	LPI2C_MIER_EPIE_EPIE_1 = 0x1
	// Position of SDIE field.
	LPI2C_MIER_SDIE_Pos = 0x9
	// Bit mask of SDIE field.
	LPI2C_MIER_SDIE_Msk = 0x200
	// Bit SDIE.
	LPI2C_MIER_SDIE = 0x200
	// Disabled
	LPI2C_MIER_SDIE_SDIE_0 = 0x0
	// Enabled
	LPI2C_MIER_SDIE_SDIE_1 = 0x1
	// Position of NDIE field.
	LPI2C_MIER_NDIE_Pos = 0xa
	// Bit mask of NDIE field.
	LPI2C_MIER_NDIE_Msk = 0x400
	// Bit NDIE.
	LPI2C_MIER_NDIE = 0x400
	// Disabled
	LPI2C_MIER_NDIE_NDIE_0 = 0x0
	// Enabled
	LPI2C_MIER_NDIE_NDIE_1 = 0x1
	// Position of ALIE field.
	LPI2C_MIER_ALIE_Pos = 0xb
	// Bit mask of ALIE field.
	LPI2C_MIER_ALIE_Msk = 0x800
	// Bit ALIE.
	LPI2C_MIER_ALIE = 0x800
	// Disabled
	LPI2C_MIER_ALIE_ALIE_0 = 0x0
	// Enabled
	LPI2C_MIER_ALIE_ALIE_1 = 0x1
	// Position of FEIE field.
	LPI2C_MIER_FEIE_Pos = 0xc
	// Bit mask of FEIE field.
	LPI2C_MIER_FEIE_Msk = 0x1000
	// Bit FEIE.
	LPI2C_MIER_FEIE = 0x1000
	// Enabled
	LPI2C_MIER_FEIE_FEIE_0 = 0x0
	// Disabled
	LPI2C_MIER_FEIE_FEIE_1 = 0x1
	// Position of PLTIE field.
	LPI2C_MIER_PLTIE_Pos = 0xd
	// Bit mask of PLTIE field.
	LPI2C_MIER_PLTIE_Msk = 0x2000
	// Bit PLTIE.
	LPI2C_MIER_PLTIE = 0x2000
	// Disabled
	LPI2C_MIER_PLTIE_PLTIE_0 = 0x0
	// Enabled
	LPI2C_MIER_PLTIE_PLTIE_1 = 0x1
	// Position of DMIE field.
	LPI2C_MIER_DMIE_Pos = 0xe
	// Bit mask of DMIE field.
	LPI2C_MIER_DMIE_Msk = 0x4000
	// Bit DMIE.
	LPI2C_MIER_DMIE = 0x4000
	// Disabled
	LPI2C_MIER_DMIE_DMIE_0 = 0x0
	// Enabled
	LPI2C_MIER_DMIE_DMIE_1 = 0x1

	// MDER: Master DMA Enable Register
	// Position of TDDE field.
	LPI2C_MDER_TDDE_Pos = 0x0
	// Bit mask of TDDE field.
	LPI2C_MDER_TDDE_Msk = 0x1
	// Bit TDDE.
	LPI2C_MDER_TDDE = 0x1
	// DMA request is disabled
	LPI2C_MDER_TDDE_TDDE_0 = 0x0
	// DMA request is enabled
	LPI2C_MDER_TDDE_TDDE_1 = 0x1
	// Position of RDDE field.
	LPI2C_MDER_RDDE_Pos = 0x1
	// Bit mask of RDDE field.
	LPI2C_MDER_RDDE_Msk = 0x2
	// Bit RDDE.
	LPI2C_MDER_RDDE = 0x2
	// DMA request is disabled
	LPI2C_MDER_RDDE_RDDE_0 = 0x0
	// DMA request is enabled
	LPI2C_MDER_RDDE_RDDE_1 = 0x1

	// MCFGR0: Master Configuration Register 0
	// Position of HREN field.
	LPI2C_MCFGR0_HREN_Pos = 0x0
	// Bit mask of HREN field.
	LPI2C_MCFGR0_HREN_Msk = 0x1
	// Bit HREN.
	LPI2C_MCFGR0_HREN = 0x1
	// Host request input is disabled
	LPI2C_MCFGR0_HREN_HREN_0 = 0x0
	// Host request input is enabled
	LPI2C_MCFGR0_HREN_HREN_1 = 0x1
	// Position of HRPOL field.
	LPI2C_MCFGR0_HRPOL_Pos = 0x1
	// Bit mask of HRPOL field.
	LPI2C_MCFGR0_HRPOL_Msk = 0x2
	// Bit HRPOL.
	LPI2C_MCFGR0_HRPOL = 0x2
	// Active low
	LPI2C_MCFGR0_HRPOL_HRPOL_0 = 0x0
	// Active high
	LPI2C_MCFGR0_HRPOL_HRPOL_1 = 0x1
	// Position of HRSEL field.
	LPI2C_MCFGR0_HRSEL_Pos = 0x2
	// Bit mask of HRSEL field.
	LPI2C_MCFGR0_HRSEL_Msk = 0x4
	// Bit HRSEL.
	LPI2C_MCFGR0_HRSEL = 0x4
	// Host request input is pin HREQ
	LPI2C_MCFGR0_HRSEL_HRSEL_0 = 0x0
	// Host request input is input trigger
	LPI2C_MCFGR0_HRSEL_HRSEL_1 = 0x1
	// Position of CIRFIFO field.
	LPI2C_MCFGR0_CIRFIFO_Pos = 0x8
	// Bit mask of CIRFIFO field.
	LPI2C_MCFGR0_CIRFIFO_Msk = 0x100
	// Bit CIRFIFO.
	LPI2C_MCFGR0_CIRFIFO = 0x100
	// Circular FIFO is disabled
	LPI2C_MCFGR0_CIRFIFO_CIRFIFO_0 = 0x0
	// Circular FIFO is enabled
	LPI2C_MCFGR0_CIRFIFO_CIRFIFO_1 = 0x1
	// Position of RDMO field.
	LPI2C_MCFGR0_RDMO_Pos = 0x9
	// Bit mask of RDMO field.
	LPI2C_MCFGR0_RDMO_Msk = 0x200
	// Bit RDMO.
	LPI2C_MCFGR0_RDMO = 0x200
	// Received data is stored in the receive FIFO
	LPI2C_MCFGR0_RDMO_RDMO_0 = 0x0
	// Received data is discarded unless the the Data Match Flag (MSR[DMF]) is set
	LPI2C_MCFGR0_RDMO_RDMO_1 = 0x1

	// MCFGR1: Master Configuration Register 1
	// Position of PRESCALE field.
	LPI2C_MCFGR1_PRESCALE_Pos = 0x0
	// Bit mask of PRESCALE field.
	LPI2C_MCFGR1_PRESCALE_Msk = 0x7
	// Divide by 1
	LPI2C_MCFGR1_PRESCALE_PRESCALE_0 = 0x0
	// Divide by 2
	LPI2C_MCFGR1_PRESCALE_PRESCALE_1 = 0x1
	// Divide by 4
	LPI2C_MCFGR1_PRESCALE_PRESCALE_2 = 0x2
	// Divide by 8
	LPI2C_MCFGR1_PRESCALE_PRESCALE_3 = 0x3
	// Divide by 16
	LPI2C_MCFGR1_PRESCALE_PRESCALE_4 = 0x4
	// Divide by 32
	LPI2C_MCFGR1_PRESCALE_PRESCALE_5 = 0x5
	// Divide by 64
	LPI2C_MCFGR1_PRESCALE_PRESCALE_6 = 0x6
	// Divide by 128
	LPI2C_MCFGR1_PRESCALE_PRESCALE_7 = 0x7
	// Position of AUTOSTOP field.
	LPI2C_MCFGR1_AUTOSTOP_Pos = 0x8
	// Bit mask of AUTOSTOP field.
	LPI2C_MCFGR1_AUTOSTOP_Msk = 0x100
	// Bit AUTOSTOP.
	LPI2C_MCFGR1_AUTOSTOP = 0x100
	// No effect
	LPI2C_MCFGR1_AUTOSTOP_AUTOSTOP_0 = 0x0
	// STOP condition is automatically generated whenever the transmit FIFO is empty and the LPI2C master is busy
	LPI2C_MCFGR1_AUTOSTOP_AUTOSTOP_1 = 0x1
	// Position of IGNACK field.
	LPI2C_MCFGR1_IGNACK_Pos = 0x9
	// Bit mask of IGNACK field.
	LPI2C_MCFGR1_IGNACK_Msk = 0x200
	// Bit IGNACK.
	LPI2C_MCFGR1_IGNACK = 0x200
	// LPI2C Master will receive ACK and NACK normally
	LPI2C_MCFGR1_IGNACK_IGNACK_0 = 0x0
	// LPI2C Master will treat a received NACK as if it (NACK) was an ACK
	LPI2C_MCFGR1_IGNACK_IGNACK_1 = 0x1
	// Position of TIMECFG field.
	LPI2C_MCFGR1_TIMECFG_Pos = 0xa
	// Bit mask of TIMECFG field.
	LPI2C_MCFGR1_TIMECFG_Msk = 0x400
	// Bit TIMECFG.
	LPI2C_MCFGR1_TIMECFG = 0x400
	// Pin Low Timeout Flag will set if SCL is low for longer than the configured timeout
	LPI2C_MCFGR1_TIMECFG_TIMECFG_0 = 0x0
	// Pin Low Timeout Flag will set if either SCL or SDA is low for longer than the configured timeout
	LPI2C_MCFGR1_TIMECFG_TIMECFG_1 = 0x1
	// Position of MATCFG field.
	LPI2C_MCFGR1_MATCFG_Pos = 0x10
	// Bit mask of MATCFG field.
	LPI2C_MCFGR1_MATCFG_Msk = 0x70000
	// Match is disabled
	LPI2C_MCFGR1_MATCFG_MATCFG_0 = 0x0
	// Match is enabled (1st data word equals MATCH0 OR MATCH1)
	LPI2C_MCFGR1_MATCFG_MATCFG_2 = 0x2
	// Match is enabled (any data word equals MATCH0 OR MATCH1)
	LPI2C_MCFGR1_MATCFG_MATCFG_3 = 0x3
	// Match is enabled (1st data word equals MATCH0 AND 2nd data word equals MATCH1)
	LPI2C_MCFGR1_MATCFG_MATCFG_4 = 0x4
	// Match is enabled (any data word equals MATCH0 AND next data word equals MATCH1)
	LPI2C_MCFGR1_MATCFG_MATCFG_5 = 0x5
	// Match is enabled (1st data word AND MATCH1 equals MATCH0 AND MATCH1)
	LPI2C_MCFGR1_MATCFG_MATCFG_6 = 0x6
	// Match is enabled (any data word AND MATCH1 equals MATCH0 AND MATCH1)
	LPI2C_MCFGR1_MATCFG_MATCFG_7 = 0x7
	// Position of PINCFG field.
	LPI2C_MCFGR1_PINCFG_Pos = 0x18
	// Bit mask of PINCFG field.
	LPI2C_MCFGR1_PINCFG_Msk = 0x7000000
	// 2-pin open drain mode
	LPI2C_MCFGR1_PINCFG_PINCFG_0 = 0x0
	// 2-pin output only mode (ultra-fast mode)
	LPI2C_MCFGR1_PINCFG_PINCFG_1 = 0x1
	// 2-pin push-pull mode
	LPI2C_MCFGR1_PINCFG_PINCFG_2 = 0x2
	// 4-pin push-pull mode
	LPI2C_MCFGR1_PINCFG_PINCFG_3 = 0x3
	// 2-pin open drain mode with separate LPI2C slave
	LPI2C_MCFGR1_PINCFG_PINCFG_4 = 0x4
	// 2-pin output only mode (ultra-fast mode) with separate LPI2C slave
	LPI2C_MCFGR1_PINCFG_PINCFG_5 = 0x5
	// 2-pin push-pull mode with separate LPI2C slave
	LPI2C_MCFGR1_PINCFG_PINCFG_6 = 0x6
	// 4-pin push-pull mode (inverted outputs)
	LPI2C_MCFGR1_PINCFG_PINCFG_7 = 0x7

	// MCFGR2: Master Configuration Register 2
	// Position of BUSIDLE field.
	LPI2C_MCFGR2_BUSIDLE_Pos = 0x0
	// Bit mask of BUSIDLE field.
	LPI2C_MCFGR2_BUSIDLE_Msk = 0xfff
	// Position of FILTSCL field.
	LPI2C_MCFGR2_FILTSCL_Pos = 0x10
	// Bit mask of FILTSCL field.
	LPI2C_MCFGR2_FILTSCL_Msk = 0xf0000
	// Position of FILTSDA field.
	LPI2C_MCFGR2_FILTSDA_Pos = 0x18
	// Bit mask of FILTSDA field.
	LPI2C_MCFGR2_FILTSDA_Msk = 0xf000000

	// MCFGR3: Master Configuration Register 3
	// Position of PINLOW field.
	LPI2C_MCFGR3_PINLOW_Pos = 0x8
	// Bit mask of PINLOW field.
	LPI2C_MCFGR3_PINLOW_Msk = 0xfff00

	// MDMR: Master Data Match Register
	// Position of MATCH0 field.
	LPI2C_MDMR_MATCH0_Pos = 0x0
	// Bit mask of MATCH0 field.
	LPI2C_MDMR_MATCH0_Msk = 0xff
	// Position of MATCH1 field.
	LPI2C_MDMR_MATCH1_Pos = 0x10
	// Bit mask of MATCH1 field.
	LPI2C_MDMR_MATCH1_Msk = 0xff0000

	// MCCR0: Master Clock Configuration Register 0
	// Position of CLKLO field.
	LPI2C_MCCR0_CLKLO_Pos = 0x0
	// Bit mask of CLKLO field.
	LPI2C_MCCR0_CLKLO_Msk = 0x3f
	// Position of CLKHI field.
	LPI2C_MCCR0_CLKHI_Pos = 0x8
	// Bit mask of CLKHI field.
	LPI2C_MCCR0_CLKHI_Msk = 0x3f00
	// Position of SETHOLD field.
	LPI2C_MCCR0_SETHOLD_Pos = 0x10
	// Bit mask of SETHOLD field.
	LPI2C_MCCR0_SETHOLD_Msk = 0x3f0000
	// Position of DATAVD field.
	LPI2C_MCCR0_DATAVD_Pos = 0x18
	// Bit mask of DATAVD field.
	LPI2C_MCCR0_DATAVD_Msk = 0x3f000000

	// MCCR1: Master Clock Configuration Register 1
	// Position of CLKLO field.
	LPI2C_MCCR1_CLKLO_Pos = 0x0
	// Bit mask of CLKLO field.
	LPI2C_MCCR1_CLKLO_Msk = 0x3f
	// Position of CLKHI field.
	LPI2C_MCCR1_CLKHI_Pos = 0x8
	// Bit mask of CLKHI field.
	LPI2C_MCCR1_CLKHI_Msk = 0x3f00
	// Position of SETHOLD field.
	LPI2C_MCCR1_SETHOLD_Pos = 0x10
	// Bit mask of SETHOLD field.
	LPI2C_MCCR1_SETHOLD_Msk = 0x3f0000
	// Position of DATAVD field.
	LPI2C_MCCR1_DATAVD_Pos = 0x18
	// Bit mask of DATAVD field.
	LPI2C_MCCR1_DATAVD_Msk = 0x3f000000

	// MFCR: Master FIFO Control Register
	// Position of TXWATER field.
	LPI2C_MFCR_TXWATER_Pos = 0x0
	// Bit mask of TXWATER field.
	LPI2C_MFCR_TXWATER_Msk = 0x3
	// Position of RXWATER field.
	LPI2C_MFCR_RXWATER_Pos = 0x10
	// Bit mask of RXWATER field.
	LPI2C_MFCR_RXWATER_Msk = 0x30000

	// MFSR: Master FIFO Status Register
	// Position of TXCOUNT field.
	LPI2C_MFSR_TXCOUNT_Pos = 0x0
	// Bit mask of TXCOUNT field.
	LPI2C_MFSR_TXCOUNT_Msk = 0x7
	// Position of RXCOUNT field.
	LPI2C_MFSR_RXCOUNT_Pos = 0x10
	// Bit mask of RXCOUNT field.
	LPI2C_MFSR_RXCOUNT_Msk = 0x70000

	// MTDR: Master Transmit Data Register
	// Position of DATA field.
	LPI2C_MTDR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	LPI2C_MTDR_DATA_Msk = 0xff
	// Position of CMD field.
	LPI2C_MTDR_CMD_Pos = 0x8
	// Bit mask of CMD field.
	LPI2C_MTDR_CMD_Msk = 0x700
	// Transmit DATA[7:0]
	LPI2C_MTDR_CMD_CMD_0 = 0x0
	// Receive (DATA[7:0] + 1) bytes
	LPI2C_MTDR_CMD_CMD_1 = 0x1
	// Generate STOP condition
	LPI2C_MTDR_CMD_CMD_2 = 0x2
	// Receive and discard (DATA[7:0] + 1) bytes
	LPI2C_MTDR_CMD_CMD_3 = 0x3
	// Generate (repeated) START and transmit address in DATA[7:0]
	LPI2C_MTDR_CMD_CMD_4 = 0x4
	// Generate (repeated) START and transmit address in DATA[7:0]. This transfer expects a NACK to be returned.
	LPI2C_MTDR_CMD_CMD_5 = 0x5
	// Generate (repeated) START and transmit address in DATA[7:0] using high speed mode
	LPI2C_MTDR_CMD_CMD_6 = 0x6
	// Generate (repeated) START and transmit address in DATA[7:0] using high speed mode. This transfer expects a NACK to be returned.
	LPI2C_MTDR_CMD_CMD_7 = 0x7

	// MRDR: Master Receive Data Register
	// Position of DATA field.
	LPI2C_MRDR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	LPI2C_MRDR_DATA_Msk = 0xff
	// Position of RXEMPTY field.
	LPI2C_MRDR_RXEMPTY_Pos = 0xe
	// Bit mask of RXEMPTY field.
	LPI2C_MRDR_RXEMPTY_Msk = 0x4000
	// Bit RXEMPTY.
	LPI2C_MRDR_RXEMPTY = 0x4000
	// Receive FIFO is not empty
	LPI2C_MRDR_RXEMPTY_RXEMPTY_0 = 0x0
	// Receive FIFO is empty
	LPI2C_MRDR_RXEMPTY_RXEMPTY_1 = 0x1

	// SCR: Slave Control Register
	// Position of SEN field.
	LPI2C_SCR_SEN_Pos = 0x0
	// Bit mask of SEN field.
	LPI2C_SCR_SEN_Msk = 0x1
	// Bit SEN.
	LPI2C_SCR_SEN = 0x1
	// I2C Slave mode is disabled
	LPI2C_SCR_SEN_SEN_0 = 0x0
	// I2C Slave mode is enabled
	LPI2C_SCR_SEN_SEN_1 = 0x1
	// Position of RST field.
	LPI2C_SCR_RST_Pos = 0x1
	// Bit mask of RST field.
	LPI2C_SCR_RST_Msk = 0x2
	// Bit RST.
	LPI2C_SCR_RST = 0x2
	// Slave mode logic is not reset
	LPI2C_SCR_RST_RST_0 = 0x0
	// Slave mode logic is reset
	LPI2C_SCR_RST_RST_1 = 0x1
	// Position of FILTEN field.
	LPI2C_SCR_FILTEN_Pos = 0x4
	// Bit mask of FILTEN field.
	LPI2C_SCR_FILTEN_Msk = 0x10
	// Bit FILTEN.
	LPI2C_SCR_FILTEN = 0x10
	// Disable digital filter and output delay counter for slave mode
	LPI2C_SCR_FILTEN_FILTEN_0 = 0x0
	// Enable digital filter and output delay counter for slave mode
	LPI2C_SCR_FILTEN_FILTEN_1 = 0x1
	// Position of FILTDZ field.
	LPI2C_SCR_FILTDZ_Pos = 0x5
	// Bit mask of FILTDZ field.
	LPI2C_SCR_FILTDZ_Msk = 0x20
	// Bit FILTDZ.
	LPI2C_SCR_FILTDZ = 0x20
	// Filter remains enabled in Doze mode
	LPI2C_SCR_FILTDZ_FILTDZ_0 = 0x0
	// Filter is disabled in Doze mode
	LPI2C_SCR_FILTDZ_FILTDZ_1 = 0x1
	// Position of RTF field.
	LPI2C_SCR_RTF_Pos = 0x8
	// Bit mask of RTF field.
	LPI2C_SCR_RTF_Msk = 0x100
	// Bit RTF.
	LPI2C_SCR_RTF = 0x100
	// No effect
	LPI2C_SCR_RTF_RTF_0 = 0x0
	// Transmit Data Register is now empty
	LPI2C_SCR_RTF_RTF_1 = 0x1
	// Position of RRF field.
	LPI2C_SCR_RRF_Pos = 0x9
	// Bit mask of RRF field.
	LPI2C_SCR_RRF_Msk = 0x200
	// Bit RRF.
	LPI2C_SCR_RRF = 0x200
	// No effect
	LPI2C_SCR_RRF_RRF_0 = 0x0
	// Receive Data Register is now empty
	LPI2C_SCR_RRF_RRF_1 = 0x1

	// SSR: Slave Status Register
	// Position of TDF field.
	LPI2C_SSR_TDF_Pos = 0x0
	// Bit mask of TDF field.
	LPI2C_SSR_TDF_Msk = 0x1
	// Bit TDF.
	LPI2C_SSR_TDF = 0x1
	// Transmit data not requested
	LPI2C_SSR_TDF_TDF_0 = 0x0
	// Transmit data is requested
	LPI2C_SSR_TDF_TDF_1 = 0x1
	// Position of RDF field.
	LPI2C_SSR_RDF_Pos = 0x1
	// Bit mask of RDF field.
	LPI2C_SSR_RDF_Msk = 0x2
	// Bit RDF.
	LPI2C_SSR_RDF = 0x2
	// Receive data is not ready
	LPI2C_SSR_RDF_RDF_0 = 0x0
	// Receive data is ready
	LPI2C_SSR_RDF_RDF_1 = 0x1
	// Position of AVF field.
	LPI2C_SSR_AVF_Pos = 0x2
	// Bit mask of AVF field.
	LPI2C_SSR_AVF_Msk = 0x4
	// Bit AVF.
	LPI2C_SSR_AVF = 0x4
	// Address Status Register is not valid
	LPI2C_SSR_AVF_AVF_0 = 0x0
	// Address Status Register is valid
	LPI2C_SSR_AVF_AVF_1 = 0x1
	// Position of TAF field.
	LPI2C_SSR_TAF_Pos = 0x3
	// Bit mask of TAF field.
	LPI2C_SSR_TAF_Msk = 0x8
	// Bit TAF.
	LPI2C_SSR_TAF = 0x8
	// Transmit ACK/NACK is not required
	LPI2C_SSR_TAF_TAF_0 = 0x0
	// Transmit ACK/NACK is required
	LPI2C_SSR_TAF_TAF_1 = 0x1
	// Position of RSF field.
	LPI2C_SSR_RSF_Pos = 0x8
	// Bit mask of RSF field.
	LPI2C_SSR_RSF_Msk = 0x100
	// Bit RSF.
	LPI2C_SSR_RSF = 0x100
	// Slave has not detected a Repeated START condition
	LPI2C_SSR_RSF_RSF_0 = 0x0
	// Slave has detected a Repeated START condition
	LPI2C_SSR_RSF_RSF_1 = 0x1
	// Position of SDF field.
	LPI2C_SSR_SDF_Pos = 0x9
	// Bit mask of SDF field.
	LPI2C_SSR_SDF_Msk = 0x200
	// Bit SDF.
	LPI2C_SSR_SDF = 0x200
	// Slave has not detected a STOP condition
	LPI2C_SSR_SDF_SDF_0 = 0x0
	// Slave has detected a STOP condition
	LPI2C_SSR_SDF_SDF_1 = 0x1
	// Position of BEF field.
	LPI2C_SSR_BEF_Pos = 0xa
	// Bit mask of BEF field.
	LPI2C_SSR_BEF_Msk = 0x400
	// Bit BEF.
	LPI2C_SSR_BEF = 0x400
	// Slave has not detected a bit error
	LPI2C_SSR_BEF_BEF_0 = 0x0
	// Slave has detected a bit error
	LPI2C_SSR_BEF_BEF_1 = 0x1
	// Position of FEF field.
	LPI2C_SSR_FEF_Pos = 0xb
	// Bit mask of FEF field.
	LPI2C_SSR_FEF_Msk = 0x800
	// Bit FEF.
	LPI2C_SSR_FEF = 0x800
	// FIFO underflow or overflow was not detected
	LPI2C_SSR_FEF_FEF_0 = 0x0
	// FIFO underflow or overflow was detected
	LPI2C_SSR_FEF_FEF_1 = 0x1
	// Position of AM0F field.
	LPI2C_SSR_AM0F_Pos = 0xc
	// Bit mask of AM0F field.
	LPI2C_SSR_AM0F_Msk = 0x1000
	// Bit AM0F.
	LPI2C_SSR_AM0F = 0x1000
	// Have not received an ADDR0 matching address
	LPI2C_SSR_AM0F_AM0F_0 = 0x0
	// Have received an ADDR0 matching address
	LPI2C_SSR_AM0F_AM0F_1 = 0x1
	// Position of AM1F field.
	LPI2C_SSR_AM1F_Pos = 0xd
	// Bit mask of AM1F field.
	LPI2C_SSR_AM1F_Msk = 0x2000
	// Bit AM1F.
	LPI2C_SSR_AM1F = 0x2000
	// Have not received an ADDR1 or ADDR0/ADDR1 range matching address
	LPI2C_SSR_AM1F_AM1F_0 = 0x0
	// Have received an ADDR1 or ADDR0/ADDR1 range matching address
	LPI2C_SSR_AM1F_AM1F_1 = 0x1
	// Position of GCF field.
	LPI2C_SSR_GCF_Pos = 0xe
	// Bit mask of GCF field.
	LPI2C_SSR_GCF_Msk = 0x4000
	// Bit GCF.
	LPI2C_SSR_GCF = 0x4000
	// Slave has not detected the General Call Address or the General Call Address is disabled
	LPI2C_SSR_GCF_GCF_0 = 0x0
	// Slave has detected the General Call Address
	LPI2C_SSR_GCF_GCF_1 = 0x1
	// Position of SARF field.
	LPI2C_SSR_SARF_Pos = 0xf
	// Bit mask of SARF field.
	LPI2C_SSR_SARF_Msk = 0x8000
	// Bit SARF.
	LPI2C_SSR_SARF = 0x8000
	// SMBus Alert Response is disabled or not detected
	LPI2C_SSR_SARF_SARF_0 = 0x0
	// SMBus Alert Response is enabled and detected
	LPI2C_SSR_SARF_SARF_1 = 0x1
	// Position of SBF field.
	LPI2C_SSR_SBF_Pos = 0x18
	// Bit mask of SBF field.
	LPI2C_SSR_SBF_Msk = 0x1000000
	// Bit SBF.
	LPI2C_SSR_SBF = 0x1000000
	// I2C Slave is idle
	LPI2C_SSR_SBF_SBF_0 = 0x0
	// I2C Slave is busy
	LPI2C_SSR_SBF_SBF_1 = 0x1
	// Position of BBF field.
	LPI2C_SSR_BBF_Pos = 0x19
	// Bit mask of BBF field.
	LPI2C_SSR_BBF_Msk = 0x2000000
	// Bit BBF.
	LPI2C_SSR_BBF = 0x2000000
	// I2C Bus is idle
	LPI2C_SSR_BBF_BBF_0 = 0x0
	// I2C Bus is busy
	LPI2C_SSR_BBF_BBF_1 = 0x1

	// SIER: Slave Interrupt Enable Register
	// Position of TDIE field.
	LPI2C_SIER_TDIE_Pos = 0x0
	// Bit mask of TDIE field.
	LPI2C_SIER_TDIE_Msk = 0x1
	// Bit TDIE.
	LPI2C_SIER_TDIE = 0x1
	// Disabled
	LPI2C_SIER_TDIE_TDIE_0 = 0x0
	// Enabled
	LPI2C_SIER_TDIE_TDIE_1 = 0x1
	// Position of RDIE field.
	LPI2C_SIER_RDIE_Pos = 0x1
	// Bit mask of RDIE field.
	LPI2C_SIER_RDIE_Msk = 0x2
	// Bit RDIE.
	LPI2C_SIER_RDIE = 0x2
	// Disabled
	LPI2C_SIER_RDIE_RDIE_0 = 0x0
	// Enabled
	LPI2C_SIER_RDIE_RDIE_1 = 0x1
	// Position of AVIE field.
	LPI2C_SIER_AVIE_Pos = 0x2
	// Bit mask of AVIE field.
	LPI2C_SIER_AVIE_Msk = 0x4
	// Bit AVIE.
	LPI2C_SIER_AVIE = 0x4
	// Disabled
	LPI2C_SIER_AVIE_AVIE_0 = 0x0
	// Enabled
	LPI2C_SIER_AVIE_AVIE_1 = 0x1
	// Position of TAIE field.
	LPI2C_SIER_TAIE_Pos = 0x3
	// Bit mask of TAIE field.
	LPI2C_SIER_TAIE_Msk = 0x8
	// Bit TAIE.
	LPI2C_SIER_TAIE = 0x8
	// Disabled
	LPI2C_SIER_TAIE_TAIE_0 = 0x0
	// Enabled
	LPI2C_SIER_TAIE_TAIE_1 = 0x1
	// Position of RSIE field.
	LPI2C_SIER_RSIE_Pos = 0x8
	// Bit mask of RSIE field.
	LPI2C_SIER_RSIE_Msk = 0x100
	// Bit RSIE.
	LPI2C_SIER_RSIE = 0x100
	// Disabled
	LPI2C_SIER_RSIE_RSIE_0 = 0x0
	// Enabled
	LPI2C_SIER_RSIE_RSIE_1 = 0x1
	// Position of SDIE field.
	LPI2C_SIER_SDIE_Pos = 0x9
	// Bit mask of SDIE field.
	LPI2C_SIER_SDIE_Msk = 0x200
	// Bit SDIE.
	LPI2C_SIER_SDIE = 0x200
	// Disabled
	LPI2C_SIER_SDIE_SDIE_0 = 0x0
	// Enabled
	LPI2C_SIER_SDIE_SDIE_1 = 0x1
	// Position of BEIE field.
	LPI2C_SIER_BEIE_Pos = 0xa
	// Bit mask of BEIE field.
	LPI2C_SIER_BEIE_Msk = 0x400
	// Bit BEIE.
	LPI2C_SIER_BEIE = 0x400
	// Disabled
	LPI2C_SIER_BEIE_BEIE_0 = 0x0
	// Enabled
	LPI2C_SIER_BEIE_BEIE_1 = 0x1
	// Position of FEIE field.
	LPI2C_SIER_FEIE_Pos = 0xb
	// Bit mask of FEIE field.
	LPI2C_SIER_FEIE_Msk = 0x800
	// Bit FEIE.
	LPI2C_SIER_FEIE = 0x800
	// Disabled
	LPI2C_SIER_FEIE_FEIE_0 = 0x0
	// Enabled
	LPI2C_SIER_FEIE_FEIE_1 = 0x1
	// Position of AM0IE field.
	LPI2C_SIER_AM0IE_Pos = 0xc
	// Bit mask of AM0IE field.
	LPI2C_SIER_AM0IE_Msk = 0x1000
	// Bit AM0IE.
	LPI2C_SIER_AM0IE = 0x1000
	// Enabled
	LPI2C_SIER_AM0IE_AM0IE_0 = 0x0
	// Disabled
	LPI2C_SIER_AM0IE_AM0IE_1 = 0x1
	// Position of AM1F field.
	LPI2C_SIER_AM1F_Pos = 0xd
	// Bit mask of AM1F field.
	LPI2C_SIER_AM1F_Msk = 0x2000
	// Bit AM1F.
	LPI2C_SIER_AM1F = 0x2000
	// Disabled
	LPI2C_SIER_AM1F_AM1F_0 = 0x0
	// Enabled
	LPI2C_SIER_AM1F_AM1F_1 = 0x1
	// Position of GCIE field.
	LPI2C_SIER_GCIE_Pos = 0xe
	// Bit mask of GCIE field.
	LPI2C_SIER_GCIE_Msk = 0x4000
	// Bit GCIE.
	LPI2C_SIER_GCIE = 0x4000
	// Disabled
	LPI2C_SIER_GCIE_GCIE_0 = 0x0
	// Enabled
	LPI2C_SIER_GCIE_GCIE_1 = 0x1
	// Position of SARIE field.
	LPI2C_SIER_SARIE_Pos = 0xf
	// Bit mask of SARIE field.
	LPI2C_SIER_SARIE_Msk = 0x8000
	// Bit SARIE.
	LPI2C_SIER_SARIE = 0x8000
	// Disabled
	LPI2C_SIER_SARIE_SARIE_0 = 0x0
	// Enabled
	LPI2C_SIER_SARIE_SARIE_1 = 0x1

	// SDER: Slave DMA Enable Register
	// Position of TDDE field.
	LPI2C_SDER_TDDE_Pos = 0x0
	// Bit mask of TDDE field.
	LPI2C_SDER_TDDE_Msk = 0x1
	// Bit TDDE.
	LPI2C_SDER_TDDE = 0x1
	// DMA request is disabled
	LPI2C_SDER_TDDE_TDDE_0 = 0x0
	// DMA request is enabled
	LPI2C_SDER_TDDE_TDDE_1 = 0x1
	// Position of RDDE field.
	LPI2C_SDER_RDDE_Pos = 0x1
	// Bit mask of RDDE field.
	LPI2C_SDER_RDDE_Msk = 0x2
	// Bit RDDE.
	LPI2C_SDER_RDDE = 0x2
	// DMA request is disabled
	LPI2C_SDER_RDDE_RDDE_0 = 0x0
	// DMA request is enabled
	LPI2C_SDER_RDDE_RDDE_1 = 0x1
	// Position of AVDE field.
	LPI2C_SDER_AVDE_Pos = 0x2
	// Bit mask of AVDE field.
	LPI2C_SDER_AVDE_Msk = 0x4
	// Bit AVDE.
	LPI2C_SDER_AVDE = 0x4
	// DMA request is disabled
	LPI2C_SDER_AVDE_AVDE_0 = 0x0
	// DMA request is enabled
	LPI2C_SDER_AVDE_AVDE_1 = 0x1

	// SCFGR1: Slave Configuration Register 1
	// Position of ADRSTALL field.
	LPI2C_SCFGR1_ADRSTALL_Pos = 0x0
	// Bit mask of ADRSTALL field.
	LPI2C_SCFGR1_ADRSTALL_Msk = 0x1
	// Bit ADRSTALL.
	LPI2C_SCFGR1_ADRSTALL = 0x1
	// Clock stretching is disabled
	LPI2C_SCFGR1_ADRSTALL_ADRSTALL_0 = 0x0
	// Clock stretching is enabled
	LPI2C_SCFGR1_ADRSTALL_ADRSTALL_1 = 0x1
	// Position of RXSTALL field.
	LPI2C_SCFGR1_RXSTALL_Pos = 0x1
	// Bit mask of RXSTALL field.
	LPI2C_SCFGR1_RXSTALL_Msk = 0x2
	// Bit RXSTALL.
	LPI2C_SCFGR1_RXSTALL = 0x2
	// Clock stretching is disabled
	LPI2C_SCFGR1_RXSTALL_RXSTALL_0 = 0x0
	// Clock stretching is enabled
	LPI2C_SCFGR1_RXSTALL_RXSTALL_1 = 0x1
	// Position of TXDSTALL field.
	LPI2C_SCFGR1_TXDSTALL_Pos = 0x2
	// Bit mask of TXDSTALL field.
	LPI2C_SCFGR1_TXDSTALL_Msk = 0x4
	// Bit TXDSTALL.
	LPI2C_SCFGR1_TXDSTALL = 0x4
	// Clock stretching is disabled
	LPI2C_SCFGR1_TXDSTALL_TXDSTALL_0 = 0x0
	// Clock stretching is enabled
	LPI2C_SCFGR1_TXDSTALL_TXDSTALL_1 = 0x1
	// Position of ACKSTALL field.
	LPI2C_SCFGR1_ACKSTALL_Pos = 0x3
	// Bit mask of ACKSTALL field.
	LPI2C_SCFGR1_ACKSTALL_Msk = 0x8
	// Bit ACKSTALL.
	LPI2C_SCFGR1_ACKSTALL = 0x8
	// Clock stretching is disabled
	LPI2C_SCFGR1_ACKSTALL_ACKSTALL_0 = 0x0
	// Clock stretching is enabled
	LPI2C_SCFGR1_ACKSTALL_ACKSTALL_1 = 0x1
	// Position of GCEN field.
	LPI2C_SCFGR1_GCEN_Pos = 0x8
	// Bit mask of GCEN field.
	LPI2C_SCFGR1_GCEN_Msk = 0x100
	// Bit GCEN.
	LPI2C_SCFGR1_GCEN = 0x100
	// General Call address is disabled
	LPI2C_SCFGR1_GCEN_GCEN_0 = 0x0
	// General Call address is enabled
	LPI2C_SCFGR1_GCEN_GCEN_1 = 0x1
	// Position of SAEN field.
	LPI2C_SCFGR1_SAEN_Pos = 0x9
	// Bit mask of SAEN field.
	LPI2C_SCFGR1_SAEN_Msk = 0x200
	// Bit SAEN.
	LPI2C_SCFGR1_SAEN = 0x200
	// Disables match on SMBus Alert
	LPI2C_SCFGR1_SAEN_SAEN_0 = 0x0
	// Enables match on SMBus Alert
	LPI2C_SCFGR1_SAEN_SAEN_1 = 0x1
	// Position of TXCFG field.
	LPI2C_SCFGR1_TXCFG_Pos = 0xa
	// Bit mask of TXCFG field.
	LPI2C_SCFGR1_TXCFG_Msk = 0x400
	// Bit TXCFG.
	LPI2C_SCFGR1_TXCFG = 0x400
	// Transmit Data Flag will only assert during a slave-transmit transfer when the Transmit Data register is empty
	LPI2C_SCFGR1_TXCFG_TXCFG_0 = 0x0
	// Transmit Data Flag will assert whenever the Transmit Data register is empty
	LPI2C_SCFGR1_TXCFG_TXCFG_1 = 0x1
	// Position of RXCFG field.
	LPI2C_SCFGR1_RXCFG_Pos = 0xb
	// Bit mask of RXCFG field.
	LPI2C_SCFGR1_RXCFG_Msk = 0x800
	// Bit RXCFG.
	LPI2C_SCFGR1_RXCFG = 0x800
	// Reading the Receive Data register will return received data and clear the Receive Data flag (MSR[RDF]).
	LPI2C_SCFGR1_RXCFG_RXCFG_0 = 0x0
	// Reading the Receive Data register when the Address Valid flag (SSR[AVF])is set, will return the Address Status register and clear the Address Valid flag. Reading the Receive Data register when the Address Valid flag is clear, will return received data and clear the Receive Data flag (MSR[RDF]).
	LPI2C_SCFGR1_RXCFG_RXCFG_1 = 0x1
	// Position of IGNACK field.
	LPI2C_SCFGR1_IGNACK_Pos = 0xc
	// Bit mask of IGNACK field.
	LPI2C_SCFGR1_IGNACK_Msk = 0x1000
	// Bit IGNACK.
	LPI2C_SCFGR1_IGNACK = 0x1000
	// Slave will end transfer when NACK is detected
	LPI2C_SCFGR1_IGNACK_IGNACK_0 = 0x0
	// Slave will not end transfer when NACK detected
	LPI2C_SCFGR1_IGNACK_IGNACK_1 = 0x1
	// Position of HSMEN field.
	LPI2C_SCFGR1_HSMEN_Pos = 0xd
	// Bit mask of HSMEN field.
	LPI2C_SCFGR1_HSMEN_Msk = 0x2000
	// Bit HSMEN.
	LPI2C_SCFGR1_HSMEN = 0x2000
	// Disables detection of HS-mode master code
	LPI2C_SCFGR1_HSMEN_HSMEN_0 = 0x0
	// Enables detection of HS-mode master code
	LPI2C_SCFGR1_HSMEN_HSMEN_1 = 0x1
	// Position of ADDRCFG field.
	LPI2C_SCFGR1_ADDRCFG_Pos = 0x10
	// Bit mask of ADDRCFG field.
	LPI2C_SCFGR1_ADDRCFG_Msk = 0x70000
	// Address match 0 (7-bit)
	LPI2C_SCFGR1_ADDRCFG_ADDRCFG_0 = 0x0
	// Address match 0 (10-bit)
	LPI2C_SCFGR1_ADDRCFG_ADDRCFG_1 = 0x1
	// Address match 0 (7-bit) or Address match 1 (7-bit)
	LPI2C_SCFGR1_ADDRCFG_ADDRCFG_2 = 0x2
	// Address match 0 (10-bit) or Address match 1 (10-bit)
	LPI2C_SCFGR1_ADDRCFG_ADDRCFG_3 = 0x3
	// Address match 0 (7-bit) or Address match 1 (10-bit)
	LPI2C_SCFGR1_ADDRCFG_ADDRCFG_4 = 0x4
	// Address match 0 (10-bit) or Address match 1 (7-bit)
	LPI2C_SCFGR1_ADDRCFG_ADDRCFG_5 = 0x5
	// From Address match 0 (7-bit) to Address match 1 (7-bit)
	LPI2C_SCFGR1_ADDRCFG_ADDRCFG_6 = 0x6
	// From Address match 0 (10-bit) to Address match 1 (10-bit)
	LPI2C_SCFGR1_ADDRCFG_ADDRCFG_7 = 0x7

	// SCFGR2: Slave Configuration Register 2
	// Position of CLKHOLD field.
	LPI2C_SCFGR2_CLKHOLD_Pos = 0x0
	// Bit mask of CLKHOLD field.
	LPI2C_SCFGR2_CLKHOLD_Msk = 0xf
	// Position of DATAVD field.
	LPI2C_SCFGR2_DATAVD_Pos = 0x8
	// Bit mask of DATAVD field.
	LPI2C_SCFGR2_DATAVD_Msk = 0x3f00
	// Position of FILTSCL field.
	LPI2C_SCFGR2_FILTSCL_Pos = 0x10
	// Bit mask of FILTSCL field.
	LPI2C_SCFGR2_FILTSCL_Msk = 0xf0000
	// Position of FILTSDA field.
	LPI2C_SCFGR2_FILTSDA_Pos = 0x18
	// Bit mask of FILTSDA field.
	LPI2C_SCFGR2_FILTSDA_Msk = 0xf000000

	// SAMR: Slave Address Match Register
	// Position of ADDR0 field.
	LPI2C_SAMR_ADDR0_Pos = 0x1
	// Bit mask of ADDR0 field.
	LPI2C_SAMR_ADDR0_Msk = 0x7fe
	// Position of ADDR1 field.
	LPI2C_SAMR_ADDR1_Pos = 0x11
	// Bit mask of ADDR1 field.
	LPI2C_SAMR_ADDR1_Msk = 0x7fe0000

	// SASR: Slave Address Status Register
	// Position of RADDR field.
	LPI2C_SASR_RADDR_Pos = 0x0
	// Bit mask of RADDR field.
	LPI2C_SASR_RADDR_Msk = 0x7ff
	// Position of ANV field.
	LPI2C_SASR_ANV_Pos = 0xe
	// Bit mask of ANV field.
	LPI2C_SASR_ANV_Msk = 0x4000
	// Bit ANV.
	LPI2C_SASR_ANV = 0x4000
	// Received Address (RADDR) is valid
	LPI2C_SASR_ANV_ANV_0 = 0x0
	// Received Address (RADDR) is not valid
	LPI2C_SASR_ANV_ANV_1 = 0x1

	// STAR: Slave Transmit ACK Register
	// Position of TXNACK field.
	LPI2C_STAR_TXNACK_Pos = 0x0
	// Bit mask of TXNACK field.
	LPI2C_STAR_TXNACK_Msk = 0x1
	// Bit TXNACK.
	LPI2C_STAR_TXNACK = 0x1
	// Write a Transmit ACK for each received word
	LPI2C_STAR_TXNACK_TXNACK_0 = 0x0
	// Write a Transmit NACK for each received word
	LPI2C_STAR_TXNACK_TXNACK_1 = 0x1

	// STDR: Slave Transmit Data Register
	// Position of DATA field.
	LPI2C_STDR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	LPI2C_STDR_DATA_Msk = 0xff

	// SRDR: Slave Receive Data Register
	// Position of DATA field.
	LPI2C_SRDR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	LPI2C_SRDR_DATA_Msk = 0xff
	// Position of RXEMPTY field.
	LPI2C_SRDR_RXEMPTY_Pos = 0xe
	// Bit mask of RXEMPTY field.
	LPI2C_SRDR_RXEMPTY_Msk = 0x4000
	// Bit RXEMPTY.
	LPI2C_SRDR_RXEMPTY = 0x4000
	// The Receive Data Register is not empty
	LPI2C_SRDR_RXEMPTY_RXEMPTY_0 = 0x0
	// The Receive Data Register is empty
	LPI2C_SRDR_RXEMPTY_RXEMPTY_1 = 0x1
	// Position of SOF field.
	LPI2C_SRDR_SOF_Pos = 0xf
	// Bit mask of SOF field.
	LPI2C_SRDR_SOF_Msk = 0x8000
	// Bit SOF.
	LPI2C_SRDR_SOF = 0x8000
	// Indicates this is not the first data word since a (repeated) START or STOP condition
	LPI2C_SRDR_SOF_SOF_0 = 0x0
	// Indicates this is the first data word since a (repeated) START or STOP condition
	LPI2C_SRDR_SOF_SOF_1 = 0x1
)

// Bitfields for SystemControl: System Control Block
const (
	// ACTLR: Auxiliary Control Register,
	// Position of DISFOLD field.
	SCB_ACTLR_DISFOLD_Pos = 0x2
	// Bit mask of DISFOLD field.
	SCB_ACTLR_DISFOLD_Msk = 0x4
	// Bit DISFOLD.
	SCB_ACTLR_DISFOLD = 0x4
	// Normal operation.
	SCB_ACTLR_DISFOLD_DISFOLD_0 = 0x0
	// Position of FPEXCODIS field.
	SCB_ACTLR_FPEXCODIS_Pos = 0xa
	// Bit mask of FPEXCODIS field.
	SCB_ACTLR_FPEXCODIS_Msk = 0x400
	// Bit FPEXCODIS.
	SCB_ACTLR_FPEXCODIS = 0x400
	// Normal operation.
	SCB_ACTLR_FPEXCODIS_FPEXCODIS_0 = 0x0
	// FPU exception outputs are disabled.
	SCB_ACTLR_FPEXCODIS_FPEXCODIS_1 = 0x1
	// Position of DISRAMODE field.
	SCB_ACTLR_DISRAMODE_Pos = 0xb
	// Bit mask of DISRAMODE field.
	SCB_ACTLR_DISRAMODE_Msk = 0x800
	// Bit DISRAMODE.
	SCB_ACTLR_DISRAMODE = 0x800
	// Normal operation.
	SCB_ACTLR_DISRAMODE_DISRAMODE_0 = 0x0
	// Dynamic disabled.
	SCB_ACTLR_DISRAMODE_DISRAMODE_1 = 0x1
	// Position of DISITMATBFLUSH field.
	SCB_ACTLR_DISITMATBFLUSH_Pos = 0xc
	// Bit mask of DISITMATBFLUSH field.
	SCB_ACTLR_DISITMATBFLUSH_Msk = 0x1000
	// Bit DISITMATBFLUSH.
	SCB_ACTLR_DISITMATBFLUSH = 0x1000
	// ITM and DWT ATB flush disabled, this bit is always 1.
	SCB_ACTLR_DISITMATBFLUSH_DISITMATBFLUSH_1 = 0x1
	// Position of DISBTACREAD field.
	SCB_ACTLR_DISBTACREAD_Pos = 0xd
	// Bit mask of DISBTACREAD field.
	SCB_ACTLR_DISBTACREAD_Msk = 0x2000
	// Bit DISBTACREAD.
	SCB_ACTLR_DISBTACREAD = 0x2000
	// Normal operation.
	SCB_ACTLR_DISBTACREAD_DISBTACREAD_0 = 0x0
	// BTAC is not used and only static branch prediction can occur.
	SCB_ACTLR_DISBTACREAD_DISBTACREAD_1 = 0x1
	// Position of DISBTACALLOC field.
	SCB_ACTLR_DISBTACALLOC_Pos = 0xe
	// Bit mask of DISBTACALLOC field.
	SCB_ACTLR_DISBTACALLOC_Msk = 0x4000
	// Bit DISBTACALLOC.
	SCB_ACTLR_DISBTACALLOC = 0x4000
	// Normal operation.
	SCB_ACTLR_DISBTACALLOC_DISBTACALLOC_0 = 0x0
	// No new entries are allocated in Branch Target Address Cache (BTAC), but existing entries can be updated.
	SCB_ACTLR_DISBTACALLOC_DISBTACALLOC_1 = 0x1
	// Position of DISCRITAXIRUR field.
	SCB_ACTLR_DISCRITAXIRUR_Pos = 0xf
	// Bit mask of DISCRITAXIRUR field.
	SCB_ACTLR_DISCRITAXIRUR_Msk = 0x8000
	// Bit DISCRITAXIRUR.
	SCB_ACTLR_DISCRITAXIRUR = 0x8000
	// Normal operation.
	SCB_ACTLR_DISCRITAXIRUR_DISCRITAXIRUR_0 = 0x0
	// An AXI read to Strongly-Ordered or Device memory, or an LDREX to Shareable memory, is not put on AXI if there are any outstanding reads on AXI. Transactions on AXI cannot be interrupted. This bit might reduce the time that these transactions are in progress and might improve worst case interrupt latency. Performance is decreased when this bit is set.
	SCB_ACTLR_DISCRITAXIRUR_DISCRITAXIRUR_1 = 0x1
	// Position of DISDI field.
	SCB_ACTLR_DISDI_Pos = 0x10
	// Bit mask of DISDI field.
	SCB_ACTLR_DISDI_Msk = 0x1f0000
	// Normal operation.
	SCB_ACTLR_DISDI_DISDI_0 = 0x0
	// Nothing can be dual-issued when this instruction type is in channel 0.
	SCB_ACTLR_DISDI_DISDI_1 = 0x1
	// Position of DISISSCH1 field.
	SCB_ACTLR_DISISSCH1_Pos = 0x15
	// Bit mask of DISISSCH1 field.
	SCB_ACTLR_DISISSCH1_Msk = 0x3e00000
	// Normal operation.
	SCB_ACTLR_DISISSCH1_DISISSCH1_0 = 0x0
	// Nothing can be dual-issued when this instruction type is in channel 1.
	SCB_ACTLR_DISISSCH1_DISISSCH1_1 = 0x1
	// Position of DISDYNADD field.
	SCB_ACTLR_DISDYNADD_Pos = 0x1a
	// Bit mask of DISDYNADD field.
	SCB_ACTLR_DISDYNADD_Msk = 0x4000000
	// Bit DISDYNADD.
	SCB_ACTLR_DISDYNADD = 0x4000000
	// Normal operation. Some ADD and SUB instrctions are resolved in EX1.
	SCB_ACTLR_DISDYNADD_DISDYNADD_0 = 0x0
	// All ADD and SUB instructions are resolved in EX2.
	SCB_ACTLR_DISDYNADD_DISDYNADD_1 = 0x1
	// Position of DISCRITAXIRUW field.
	SCB_ACTLR_DISCRITAXIRUW_Pos = 0x1b
	// Bit mask of DISCRITAXIRUW field.
	SCB_ACTLR_DISCRITAXIRUW_Msk = 0x8000000
	// Bit DISCRITAXIRUW.
	SCB_ACTLR_DISCRITAXIRUW = 0x8000000
	// Normal operation. This is backwards compatible with r0.
	SCB_ACTLR_DISCRITAXIRUW_DISCRITAXIRUW_0 = 0x0
	// AXI reads to DEV/SO memory. Exclusive reads to Shareable memory are not initiated on the AXIM AR channel until all outstanding stores on AXI are complete.
	SCB_ACTLR_DISCRITAXIRUW_DISCRITAXIRUW_1 = 0x1
	// Position of DISFPUISSOPT field.
	SCB_ACTLR_DISFPUISSOPT_Pos = 0x1c
	// Bit mask of DISFPUISSOPT field.
	SCB_ACTLR_DISFPUISSOPT_Msk = 0x10000000
	// Bit DISFPUISSOPT.
	SCB_ACTLR_DISFPUISSOPT = 0x10000000
	// Normal operation.
	SCB_ACTLR_DISFPUISSOPT_DISFPUISSOPT_0 = 0x0

	// CPUID: CPUID Base Register
	// Position of REVISION field.
	SCB_CPUID_REVISION_Pos = 0x0
	// Bit mask of REVISION field.
	SCB_CPUID_REVISION_Msk = 0xf
	// Position of PARTNO field.
	SCB_CPUID_PARTNO_Pos = 0x4
	// Bit mask of PARTNO field.
	SCB_CPUID_PARTNO_Msk = 0xfff0
	// Position of ARCHITECTURE field.
	SCB_CPUID_ARCHITECTURE_Pos = 0x10
	// Bit mask of ARCHITECTURE field.
	SCB_CPUID_ARCHITECTURE_Msk = 0xf0000
	// Position of VARIANT field.
	SCB_CPUID_VARIANT_Pos = 0x14
	// Bit mask of VARIANT field.
	SCB_CPUID_VARIANT_Msk = 0xf00000
	// Position of IMPLEMENTER field.
	SCB_CPUID_IMPLEMENTER_Pos = 0x18
	// Bit mask of IMPLEMENTER field.
	SCB_CPUID_IMPLEMENTER_Msk = 0xff000000

	// ICSR: Interrupt Control and State Register
	// Position of VECTACTIVE field.
	SCB_ICSR_VECTACTIVE_Pos = 0x0
	// Bit mask of VECTACTIVE field.
	SCB_ICSR_VECTACTIVE_Msk = 0x1ff
	// Position of RETTOBASE field.
	SCB_ICSR_RETTOBASE_Pos = 0xb
	// Bit mask of RETTOBASE field.
	SCB_ICSR_RETTOBASE_Msk = 0x800
	// Bit RETTOBASE.
	SCB_ICSR_RETTOBASE = 0x800
	// there are preempted active exceptions to execute
	SCB_ICSR_RETTOBASE_RETTOBASE_0 = 0x0
	// there are no active exceptions, or the currently-executing exception is the only active exception
	SCB_ICSR_RETTOBASE_RETTOBASE_1 = 0x1
	// Position of VECTPENDING field.
	SCB_ICSR_VECTPENDING_Pos = 0xc
	// Bit mask of VECTPENDING field.
	SCB_ICSR_VECTPENDING_Msk = 0x1ff000
	// Position of ISRPENDING field.
	SCB_ICSR_ISRPENDING_Pos = 0x16
	// Bit mask of ISRPENDING field.
	SCB_ICSR_ISRPENDING_Msk = 0x400000
	// Bit ISRPENDING.
	SCB_ICSR_ISRPENDING = 0x400000
	// No external interrupt pending.
	SCB_ICSR_ISRPENDING_ISRPENDING_0 = 0x0
	// External interrupt pending.
	SCB_ICSR_ISRPENDING_ISRPENDING_1 = 0x1
	// Position of PENDSTCLR field.
	SCB_ICSR_PENDSTCLR_Pos = 0x19
	// Bit mask of PENDSTCLR field.
	SCB_ICSR_PENDSTCLR_Msk = 0x2000000
	// Bit PENDSTCLR.
	SCB_ICSR_PENDSTCLR = 0x2000000
	// no effect
	SCB_ICSR_PENDSTCLR_PENDSTCLR_0 = 0x0
	// removes the pending state from the SysTick exception
	SCB_ICSR_PENDSTCLR_PENDSTCLR_1 = 0x1
	// Position of PENDSTSET field.
	SCB_ICSR_PENDSTSET_Pos = 0x1a
	// Bit mask of PENDSTSET field.
	SCB_ICSR_PENDSTSET_Msk = 0x4000000
	// Bit PENDSTSET.
	SCB_ICSR_PENDSTSET = 0x4000000
	// write: no effect; read: SysTick exception is not pending
	SCB_ICSR_PENDSTSET_PENDSTSET_0 = 0x0
	// write: changes SysTick exception state to pending; read: SysTick exception is pending
	SCB_ICSR_PENDSTSET_PENDSTSET_1 = 0x1
	// Position of PENDSVCLR field.
	SCB_ICSR_PENDSVCLR_Pos = 0x1b
	// Bit mask of PENDSVCLR field.
	SCB_ICSR_PENDSVCLR_Msk = 0x8000000
	// Bit PENDSVCLR.
	SCB_ICSR_PENDSVCLR = 0x8000000
	// no effect
	SCB_ICSR_PENDSVCLR_PENDSVCLR_0 = 0x0
	// removes the pending state from the PendSV exception
	SCB_ICSR_PENDSVCLR_PENDSVCLR_1 = 0x1
	// Position of PENDSVSET field.
	SCB_ICSR_PENDSVSET_Pos = 0x1c
	// Bit mask of PENDSVSET field.
	SCB_ICSR_PENDSVSET_Msk = 0x10000000
	// Bit PENDSVSET.
	SCB_ICSR_PENDSVSET = 0x10000000
	// write: no effect; read: PendSV exception is not pending
	SCB_ICSR_PENDSVSET_PENDSVSET_0 = 0x0
	// write: changes PendSV exception state to pending; read: PendSV exception is pending
	SCB_ICSR_PENDSVSET_PENDSVSET_1 = 0x1
	// Position of NMIPENDSET field.
	SCB_ICSR_NMIPENDSET_Pos = 0x1f
	// Bit mask of NMIPENDSET field.
	SCB_ICSR_NMIPENDSET_Msk = 0x80000000
	// Bit NMIPENDSET.
	SCB_ICSR_NMIPENDSET = 0x80000000
	// write: no effect; read: NMI exception is not pending
	SCB_ICSR_NMIPENDSET_NMIPENDSET_0 = 0x0
	// write: changes NMI exception state to pending; read: NMI exception is pending
	SCB_ICSR_NMIPENDSET_NMIPENDSET_1 = 0x1

	// VTOR: Vector Table Offset Register
	// Position of TBLOFF field.
	SCB_VTOR_TBLOFF_Pos = 0x7
	// Bit mask of TBLOFF field.
	SCB_VTOR_TBLOFF_Msk = 0xffffff80

	// AIRCR: Application Interrupt and Reset Control Register
	// Position of VECTRESET field.
	SCB_AIRCR_VECTRESET_Pos = 0x0
	// Bit mask of VECTRESET field.
	SCB_AIRCR_VECTRESET_Msk = 0x1
	// Bit VECTRESET.
	SCB_AIRCR_VECTRESET = 0x1
	// No change
	SCB_AIRCR_VECTRESET_VECTRESET_0 = 0x0
	// Causes a local system reset
	SCB_AIRCR_VECTRESET_VECTRESET_1 = 0x1
	// Position of VECTCLRACTIVE field.
	SCB_AIRCR_VECTCLRACTIVE_Pos = 0x1
	// Bit mask of VECTCLRACTIVE field.
	SCB_AIRCR_VECTCLRACTIVE_Msk = 0x2
	// Bit VECTCLRACTIVE.
	SCB_AIRCR_VECTCLRACTIVE = 0x2
	// No change
	SCB_AIRCR_VECTCLRACTIVE_VECTCLRACTIVE_0 = 0x0
	// Clears all active state information for fixed and configurable exceptions
	SCB_AIRCR_VECTCLRACTIVE_VECTCLRACTIVE_1 = 0x1
	// Position of SYSRESETREQ field.
	SCB_AIRCR_SYSRESETREQ_Pos = 0x2
	// Bit mask of SYSRESETREQ field.
	SCB_AIRCR_SYSRESETREQ_Msk = 0x4
	// Bit SYSRESETREQ.
	SCB_AIRCR_SYSRESETREQ = 0x4
	// no system reset request
	SCB_AIRCR_SYSRESETREQ_SYSRESETREQ_0 = 0x0
	// asserts a signal to the outer system that requests a reset
	SCB_AIRCR_SYSRESETREQ_SYSRESETREQ_1 = 0x1
	// Position of PRIGROUP field.
	SCB_AIRCR_PRIGROUP_Pos = 0x8
	// Bit mask of PRIGROUP field.
	SCB_AIRCR_PRIGROUP_Msk = 0x700
	// Position of ENDIANNESS field.
	SCB_AIRCR_ENDIANNESS_Pos = 0xf
	// Bit mask of ENDIANNESS field.
	SCB_AIRCR_ENDIANNESS_Msk = 0x8000
	// Bit ENDIANNESS.
	SCB_AIRCR_ENDIANNESS = 0x8000
	// Little-endian
	SCB_AIRCR_ENDIANNESS_ENDIANNESS_0 = 0x0
	// Big-endian
	SCB_AIRCR_ENDIANNESS_ENDIANNESS_1 = 0x1
	// Position of VECTKEY field.
	SCB_AIRCR_VECTKEY_Pos = 0x10
	// Bit mask of VECTKEY field.
	SCB_AIRCR_VECTKEY_Msk = 0xffff0000

	// SCR: System Control Register
	// Position of SLEEPONEXIT field.
	SCB_SCR_SLEEPONEXIT_Pos = 0x1
	// Bit mask of SLEEPONEXIT field.
	SCB_SCR_SLEEPONEXIT_Msk = 0x2
	// Bit SLEEPONEXIT.
	SCB_SCR_SLEEPONEXIT = 0x2
	// o not sleep when returning to Thread mode
	SCB_SCR_SLEEPONEXIT_SLEEPONEXIT_0 = 0x0
	// enter sleep, or deep sleep, on return from an ISR
	SCB_SCR_SLEEPONEXIT_SLEEPONEXIT_1 = 0x1
	// Position of SLEEPDEEP field.
	SCB_SCR_SLEEPDEEP_Pos = 0x2
	// Bit mask of SLEEPDEEP field.
	SCB_SCR_SLEEPDEEP_Msk = 0x4
	// Bit SLEEPDEEP.
	SCB_SCR_SLEEPDEEP = 0x4
	// sleep
	SCB_SCR_SLEEPDEEP_SLEEPDEEP_0 = 0x0
	// deep sleep
	SCB_SCR_SLEEPDEEP_SLEEPDEEP_1 = 0x1
	// Position of SEVONPEND field.
	SCB_SCR_SEVONPEND_Pos = 0x4
	// Bit mask of SEVONPEND field.
	SCB_SCR_SEVONPEND_Msk = 0x10
	// Bit SEVONPEND.
	SCB_SCR_SEVONPEND = 0x10
	// only enabled interrupts or events can wakeup the processor, disabled interrupts are excluded
	SCB_SCR_SEVONPEND_SEVONPEND_0 = 0x0
	// enabled events and all interrupts, including disabled interrupts, can wakeup the processor
	SCB_SCR_SEVONPEND_SEVONPEND_1 = 0x1

	// CCR: Configuration and Control Register
	// Position of NONBASETHRDENA field.
	SCB_CCR_NONBASETHRDENA_Pos = 0x0
	// Bit mask of NONBASETHRDENA field.
	SCB_CCR_NONBASETHRDENA_Msk = 0x1
	// Bit NONBASETHRDENA.
	SCB_CCR_NONBASETHRDENA = 0x1
	// processor can enter Thread mode only when no exception is active
	SCB_CCR_NONBASETHRDENA_NONBASETHRDENA_0 = 0x0
	// processor can enter Thread mode from any level under the control of an EXC_RETURN value
	SCB_CCR_NONBASETHRDENA_NONBASETHRDENA_1 = 0x1
	// Position of USERSETMPEND field.
	SCB_CCR_USERSETMPEND_Pos = 0x1
	// Bit mask of USERSETMPEND field.
	SCB_CCR_USERSETMPEND_Msk = 0x2
	// Bit USERSETMPEND.
	SCB_CCR_USERSETMPEND = 0x2
	// disable
	SCB_CCR_USERSETMPEND_USERSETMPEND_0 = 0x0
	// enable
	SCB_CCR_USERSETMPEND_USERSETMPEND_1 = 0x1
	// Position of UNALIGN_TRP field.
	SCB_CCR_UNALIGN_TRP_Pos = 0x3
	// Bit mask of UNALIGN_TRP field.
	SCB_CCR_UNALIGN_TRP_Msk = 0x8
	// Bit UNALIGN_TRP.
	SCB_CCR_UNALIGN_TRP = 0x8
	// do not trap unaligned halfword and word accesses
	SCB_CCR_UNALIGN_TRP_UNALIGN_TRP_0 = 0x0
	// trap unaligned halfword and word accesses
	SCB_CCR_UNALIGN_TRP_UNALIGN_TRP_1 = 0x1
	// Position of DIV_0_TRP field.
	SCB_CCR_DIV_0_TRP_Pos = 0x4
	// Bit mask of DIV_0_TRP field.
	SCB_CCR_DIV_0_TRP_Msk = 0x10
	// Bit DIV_0_TRP.
	SCB_CCR_DIV_0_TRP = 0x10
	// do not trap divide by 0
	SCB_CCR_DIV_0_TRP_DIV_0_TRP_0 = 0x0
	// trap divide by 0
	SCB_CCR_DIV_0_TRP_DIV_0_TRP_1 = 0x1
	// Position of BFHFNMIGN field.
	SCB_CCR_BFHFNMIGN_Pos = 0x8
	// Bit mask of BFHFNMIGN field.
	SCB_CCR_BFHFNMIGN_Msk = 0x100
	// Bit BFHFNMIGN.
	SCB_CCR_BFHFNMIGN = 0x100
	// data bus faults caused by load and store instructions cause a lock-up
	SCB_CCR_BFHFNMIGN_BFHFNMIGN_0 = 0x0
	// handlers running at priority -1 and -2 ignore data bus faults caused by load and store instructions
	SCB_CCR_BFHFNMIGN_BFHFNMIGN_1 = 0x1
	// Position of STKALIGN field.
	SCB_CCR_STKALIGN_Pos = 0x9
	// Bit mask of STKALIGN field.
	SCB_CCR_STKALIGN_Msk = 0x200
	// Bit STKALIGN.
	SCB_CCR_STKALIGN = 0x200
	// 4-byte aligned
	SCB_CCR_STKALIGN_STKALIGN_0 = 0x0
	// 8-byte aligned
	SCB_CCR_STKALIGN_STKALIGN_1 = 0x1
	// Position of DC field.
	SCB_CCR_DC_Pos = 0x10
	// Bit mask of DC field.
	SCB_CCR_DC_Msk = 0x10000
	// Bit DC.
	SCB_CCR_DC = 0x10000
	// L1 data cache disabled
	SCB_CCR_DC_DC_0 = 0x0
	// L1 data cache enabled
	SCB_CCR_DC_DC_1 = 0x1
	// Position of IC field.
	SCB_CCR_IC_Pos = 0x11
	// Bit mask of IC field.
	SCB_CCR_IC_Msk = 0x20000
	// Bit IC.
	SCB_CCR_IC = 0x20000
	// L1 instruction cache disabled
	SCB_CCR_IC_IC_0 = 0x0
	// L1 instruction cache enabled
	SCB_CCR_IC_IC_1 = 0x1
	// Position of BP field.
	SCB_CCR_BP_Pos = 0x12
	// Bit mask of BP field.
	SCB_CCR_BP_Msk = 0x40000
	// Bit BP.
	SCB_CCR_BP = 0x40000

	// SHPR1: System Handler Priority Register 1
	// Position of PRI_4 field.
	SCB_SHPR1_PRI_4_Pos = 0x0
	// Bit mask of PRI_4 field.
	SCB_SHPR1_PRI_4_Msk = 0xff
	// Position of PRI_5 field.
	SCB_SHPR1_PRI_5_Pos = 0x8
	// Bit mask of PRI_5 field.
	SCB_SHPR1_PRI_5_Msk = 0xff00
	// Position of PRI_6 field.
	SCB_SHPR1_PRI_6_Pos = 0x10
	// Bit mask of PRI_6 field.
	SCB_SHPR1_PRI_6_Msk = 0xff0000

	// SHPR2: System Handler Priority Register 2
	// Position of PRI_11 field.
	SCB_SHPR2_PRI_11_Pos = 0x18
	// Bit mask of PRI_11 field.
	SCB_SHPR2_PRI_11_Msk = 0xff000000

	// SHPR3: System Handler Priority Register 3
	// Position of PRI_14 field.
	SCB_SHPR3_PRI_14_Pos = 0x10
	// Bit mask of PRI_14 field.
	SCB_SHPR3_PRI_14_Msk = 0xff0000
	// Position of PRI_15 field.
	SCB_SHPR3_PRI_15_Pos = 0x18
	// Bit mask of PRI_15 field.
	SCB_SHPR3_PRI_15_Msk = 0xff000000

	// SHCSR: System Handler Control and State Register
	// Position of MEMFAULTACT field.
	SCB_SHCSR_MEMFAULTACT_Pos = 0x0
	// Bit mask of MEMFAULTACT field.
	SCB_SHCSR_MEMFAULTACT_Msk = 0x1
	// Bit MEMFAULTACT.
	SCB_SHCSR_MEMFAULTACT = 0x1
	// exception is not active
	SCB_SHCSR_MEMFAULTACT_MEMFAULTACT_0 = 0x0
	// exception is active
	SCB_SHCSR_MEMFAULTACT_MEMFAULTACT_1 = 0x1
	// Position of BUSFAULTACT field.
	SCB_SHCSR_BUSFAULTACT_Pos = 0x1
	// Bit mask of BUSFAULTACT field.
	SCB_SHCSR_BUSFAULTACT_Msk = 0x2
	// Bit BUSFAULTACT.
	SCB_SHCSR_BUSFAULTACT = 0x2
	// exception is not active
	SCB_SHCSR_BUSFAULTACT_BUSFAULTACT_0 = 0x0
	// exception is active
	SCB_SHCSR_BUSFAULTACT_BUSFAULTACT_1 = 0x1
	// Position of USGFAULTACT field.
	SCB_SHCSR_USGFAULTACT_Pos = 0x3
	// Bit mask of USGFAULTACT field.
	SCB_SHCSR_USGFAULTACT_Msk = 0x8
	// Bit USGFAULTACT.
	SCB_SHCSR_USGFAULTACT = 0x8
	// exception is not active
	SCB_SHCSR_USGFAULTACT_USGFAULTACT_0 = 0x0
	// exception is active
	SCB_SHCSR_USGFAULTACT_USGFAULTACT_1 = 0x1
	// Position of SVCALLACT field.
	SCB_SHCSR_SVCALLACT_Pos = 0x7
	// Bit mask of SVCALLACT field.
	SCB_SHCSR_SVCALLACT_Msk = 0x80
	// Bit SVCALLACT.
	SCB_SHCSR_SVCALLACT = 0x80
	// exception is not active
	SCB_SHCSR_SVCALLACT_SVCALLACT_0 = 0x0
	// exception is active
	SCB_SHCSR_SVCALLACT_SVCALLACT_1 = 0x1
	// Position of MONITORACT field.
	SCB_SHCSR_MONITORACT_Pos = 0x8
	// Bit mask of MONITORACT field.
	SCB_SHCSR_MONITORACT_Msk = 0x100
	// Bit MONITORACT.
	SCB_SHCSR_MONITORACT = 0x100
	// exception is not active
	SCB_SHCSR_MONITORACT_MONITORACT_0 = 0x0
	// exception is active
	SCB_SHCSR_MONITORACT_MONITORACT_1 = 0x1
	// Position of PENDSVACT field.
	SCB_SHCSR_PENDSVACT_Pos = 0xa
	// Bit mask of PENDSVACT field.
	SCB_SHCSR_PENDSVACT_Msk = 0x400
	// Bit PENDSVACT.
	SCB_SHCSR_PENDSVACT = 0x400
	// exception is not active
	SCB_SHCSR_PENDSVACT_PENDSVACT_0 = 0x0
	// exception is active
	SCB_SHCSR_PENDSVACT_PENDSVACT_1 = 0x1
	// Position of SYSTICKACT field.
	SCB_SHCSR_SYSTICKACT_Pos = 0xb
	// Bit mask of SYSTICKACT field.
	SCB_SHCSR_SYSTICKACT_Msk = 0x800
	// Bit SYSTICKACT.
	SCB_SHCSR_SYSTICKACT = 0x800
	// exception is not active
	SCB_SHCSR_SYSTICKACT_SYSTICKACT_0 = 0x0
	// exception is active
	SCB_SHCSR_SYSTICKACT_SYSTICKACT_1 = 0x1
	// Position of USGFAULTPENDED field.
	SCB_SHCSR_USGFAULTPENDED_Pos = 0xc
	// Bit mask of USGFAULTPENDED field.
	SCB_SHCSR_USGFAULTPENDED_Msk = 0x1000
	// Bit USGFAULTPENDED.
	SCB_SHCSR_USGFAULTPENDED = 0x1000
	// exception is not pending
	SCB_SHCSR_USGFAULTPENDED_USGFAULTPENDED_0 = 0x0
	// exception is pending
	SCB_SHCSR_USGFAULTPENDED_USGFAULTPENDED_1 = 0x1
	// Position of MEMFAULTPENDED field.
	SCB_SHCSR_MEMFAULTPENDED_Pos = 0xd
	// Bit mask of MEMFAULTPENDED field.
	SCB_SHCSR_MEMFAULTPENDED_Msk = 0x2000
	// Bit MEMFAULTPENDED.
	SCB_SHCSR_MEMFAULTPENDED = 0x2000
	// exception is not pending
	SCB_SHCSR_MEMFAULTPENDED_MEMFAULTPENDED_0 = 0x0
	// exception is pending
	SCB_SHCSR_MEMFAULTPENDED_MEMFAULTPENDED_1 = 0x1
	// Position of BUSFAULTPENDED field.
	SCB_SHCSR_BUSFAULTPENDED_Pos = 0xe
	// Bit mask of BUSFAULTPENDED field.
	SCB_SHCSR_BUSFAULTPENDED_Msk = 0x4000
	// Bit BUSFAULTPENDED.
	SCB_SHCSR_BUSFAULTPENDED = 0x4000
	// exception is not pending
	SCB_SHCSR_BUSFAULTPENDED_BUSFAULTPENDED_0 = 0x0
	// exception is pending
	SCB_SHCSR_BUSFAULTPENDED_BUSFAULTPENDED_1 = 0x1
	// Position of SVCALLPENDED field.
	SCB_SHCSR_SVCALLPENDED_Pos = 0xf
	// Bit mask of SVCALLPENDED field.
	SCB_SHCSR_SVCALLPENDED_Msk = 0x8000
	// Bit SVCALLPENDED.
	SCB_SHCSR_SVCALLPENDED = 0x8000
	// exception is not pending
	SCB_SHCSR_SVCALLPENDED_SVCALLPENDED_0 = 0x0
	// exception is pending
	SCB_SHCSR_SVCALLPENDED_SVCALLPENDED_1 = 0x1
	// Position of MEMFAULTENA field.
	SCB_SHCSR_MEMFAULTENA_Pos = 0x10
	// Bit mask of MEMFAULTENA field.
	SCB_SHCSR_MEMFAULTENA_Msk = 0x10000
	// Bit MEMFAULTENA.
	SCB_SHCSR_MEMFAULTENA = 0x10000
	// disable the exception
	SCB_SHCSR_MEMFAULTENA_MEMFAULTENA_0 = 0x0
	// enable the exception
	SCB_SHCSR_MEMFAULTENA_MEMFAULTENA_1 = 0x1
	// Position of BUSFAULTENA field.
	SCB_SHCSR_BUSFAULTENA_Pos = 0x11
	// Bit mask of BUSFAULTENA field.
	SCB_SHCSR_BUSFAULTENA_Msk = 0x20000
	// Bit BUSFAULTENA.
	SCB_SHCSR_BUSFAULTENA = 0x20000
	// disable the exception
	SCB_SHCSR_BUSFAULTENA_BUSFAULTENA_0 = 0x0
	// enable the exception
	SCB_SHCSR_BUSFAULTENA_BUSFAULTENA_1 = 0x1
	// Position of USGFAULTENA field.
	SCB_SHCSR_USGFAULTENA_Pos = 0x12
	// Bit mask of USGFAULTENA field.
	SCB_SHCSR_USGFAULTENA_Msk = 0x40000
	// Bit USGFAULTENA.
	SCB_SHCSR_USGFAULTENA = 0x40000
	// disable the exception
	SCB_SHCSR_USGFAULTENA_USGFAULTENA_0 = 0x0
	// enable the exception
	SCB_SHCSR_USGFAULTENA_USGFAULTENA_1 = 0x1

	// CFSR: Configurable Fault Status Register
	// Position of IACCVIOL field.
	SCB_CFSR_IACCVIOL_Pos = 0x0
	// Bit mask of IACCVIOL field.
	SCB_CFSR_IACCVIOL_Msk = 0x1
	// Bit IACCVIOL.
	SCB_CFSR_IACCVIOL = 0x1
	// no instruction access violation fault
	SCB_CFSR_IACCVIOL_IACCVIOL_0 = 0x0
	// the processor attempted an instruction fetch from a location that does not permit execution
	SCB_CFSR_IACCVIOL_IACCVIOL_1 = 0x1
	// Position of DACCVIOL field.
	SCB_CFSR_DACCVIOL_Pos = 0x1
	// Bit mask of DACCVIOL field.
	SCB_CFSR_DACCVIOL_Msk = 0x2
	// Bit DACCVIOL.
	SCB_CFSR_DACCVIOL = 0x2
	// no data access violation fault
	SCB_CFSR_DACCVIOL_DACCVIOL_0 = 0x0
	// the processor attempted a load or store at a location that does not permit the operation
	SCB_CFSR_DACCVIOL_DACCVIOL_1 = 0x1
	// Position of MUNSTKERR field.
	SCB_CFSR_MUNSTKERR_Pos = 0x3
	// Bit mask of MUNSTKERR field.
	SCB_CFSR_MUNSTKERR_Msk = 0x8
	// Bit MUNSTKERR.
	SCB_CFSR_MUNSTKERR = 0x8
	// no unstacking fault
	SCB_CFSR_MUNSTKERR_MUNSTKERR_0 = 0x0
	// unstack for an exception return has caused one or more access violations
	SCB_CFSR_MUNSTKERR_MUNSTKERR_1 = 0x1
	// Position of MSTKERR field.
	SCB_CFSR_MSTKERR_Pos = 0x4
	// Bit mask of MSTKERR field.
	SCB_CFSR_MSTKERR_Msk = 0x10
	// Bit MSTKERR.
	SCB_CFSR_MSTKERR = 0x10
	// no stacking fault
	SCB_CFSR_MSTKERR_MSTKERR_0 = 0x0
	// stacking for an exception entry has caused one or more access violations
	SCB_CFSR_MSTKERR_MSTKERR_1 = 0x1
	// Position of MLSPERR field.
	SCB_CFSR_MLSPERR_Pos = 0x5
	// Bit mask of MLSPERR field.
	SCB_CFSR_MLSPERR_Msk = 0x20
	// Bit MLSPERR.
	SCB_CFSR_MLSPERR = 0x20
	// No MemManage fault occurred during floating-point lazy state preservation
	SCB_CFSR_MLSPERR_MLSPERR_0 = 0x0
	// A MemManage fault occurred during floating-point lazy state preservation
	SCB_CFSR_MLSPERR_MLSPERR_1 = 0x1
	// Position of MMARVALID field.
	SCB_CFSR_MMARVALID_Pos = 0x7
	// Bit mask of MMARVALID field.
	SCB_CFSR_MMARVALID_Msk = 0x80
	// Bit MMARVALID.
	SCB_CFSR_MMARVALID = 0x80
	// value in MMAR is not a valid fault address
	SCB_CFSR_MMARVALID_MMARVALID_0 = 0x0
	// MMAR holds a valid fault address
	SCB_CFSR_MMARVALID_MMARVALID_1 = 0x1
	// Position of IBUSERR field.
	SCB_CFSR_IBUSERR_Pos = 0x8
	// Bit mask of IBUSERR field.
	SCB_CFSR_IBUSERR_Msk = 0x100
	// Bit IBUSERR.
	SCB_CFSR_IBUSERR = 0x100
	// no instruction bus error
	SCB_CFSR_IBUSERR_IBUSERR_0 = 0x0
	// instruction bus error
	SCB_CFSR_IBUSERR_IBUSERR_1 = 0x1
	// Position of PRECISERR field.
	SCB_CFSR_PRECISERR_Pos = 0x9
	// Bit mask of PRECISERR field.
	SCB_CFSR_PRECISERR_Msk = 0x200
	// Bit PRECISERR.
	SCB_CFSR_PRECISERR = 0x200
	// no precise data bus error
	SCB_CFSR_PRECISERR_PRECISERR_0 = 0x0
	// a data bus error has occurred, and the PC value stacked for the exception return points to the instruction that caused the fault
	SCB_CFSR_PRECISERR_PRECISERR_1 = 0x1
	// Position of IMPRECISERR field.
	SCB_CFSR_IMPRECISERR_Pos = 0xa
	// Bit mask of IMPRECISERR field.
	SCB_CFSR_IMPRECISERR_Msk = 0x400
	// Bit IMPRECISERR.
	SCB_CFSR_IMPRECISERR = 0x400
	// no imprecise data bus error
	SCB_CFSR_IMPRECISERR_IMPRECISERR_0 = 0x0
	// a data bus error has occurred, but the return address in the stack frame is not related to the instruction that caused the error
	SCB_CFSR_IMPRECISERR_IMPRECISERR_1 = 0x1
	// Position of UNSTKERR field.
	SCB_CFSR_UNSTKERR_Pos = 0xb
	// Bit mask of UNSTKERR field.
	SCB_CFSR_UNSTKERR_Msk = 0x800
	// Bit UNSTKERR.
	SCB_CFSR_UNSTKERR = 0x800
	// no unstacking fault
	SCB_CFSR_UNSTKERR_UNSTKERR_0 = 0x0
	// unstack for an exception return has caused one or more BusFaults
	SCB_CFSR_UNSTKERR_UNSTKERR_1 = 0x1
	// Position of STKERR field.
	SCB_CFSR_STKERR_Pos = 0xc
	// Bit mask of STKERR field.
	SCB_CFSR_STKERR_Msk = 0x1000
	// Bit STKERR.
	SCB_CFSR_STKERR = 0x1000
	// no stacking fault
	SCB_CFSR_STKERR_STKERR_0 = 0x0
	// stacking for an exception entry has caused one or more BusFaults
	SCB_CFSR_STKERR_STKERR_1 = 0x1
	// Position of LSPERR field.
	SCB_CFSR_LSPERR_Pos = 0xd
	// Bit mask of LSPERR field.
	SCB_CFSR_LSPERR_Msk = 0x2000
	// Bit LSPERR.
	SCB_CFSR_LSPERR = 0x2000
	// No bus fault occurred during floating-point lazy state preservation
	SCB_CFSR_LSPERR_LSPERR_0 = 0x0
	// A bus fault occurred during floating-point lazy state preservation
	SCB_CFSR_LSPERR_LSPERR_1 = 0x1
	// Position of BFARVALID field.
	SCB_CFSR_BFARVALID_Pos = 0xf
	// Bit mask of BFARVALID field.
	SCB_CFSR_BFARVALID_Msk = 0x8000
	// Bit BFARVALID.
	SCB_CFSR_BFARVALID = 0x8000
	// value in BFAR is not a valid fault address
	SCB_CFSR_BFARVALID_BFARVALID_0 = 0x0
	// BFAR holds a valid fault address
	SCB_CFSR_BFARVALID_BFARVALID_1 = 0x1
	// Position of UNDEFINSTR field.
	SCB_CFSR_UNDEFINSTR_Pos = 0x10
	// Bit mask of UNDEFINSTR field.
	SCB_CFSR_UNDEFINSTR_Msk = 0x10000
	// Bit UNDEFINSTR.
	SCB_CFSR_UNDEFINSTR = 0x10000
	// no undefined instruction UsageFault
	SCB_CFSR_UNDEFINSTR_UNDEFINSTR_0 = 0x0
	// the processor has attempted to execute an undefined instruction
	SCB_CFSR_UNDEFINSTR_UNDEFINSTR_1 = 0x1
	// Position of INVSTATE field.
	SCB_CFSR_INVSTATE_Pos = 0x11
	// Bit mask of INVSTATE field.
	SCB_CFSR_INVSTATE_Msk = 0x20000
	// Bit INVSTATE.
	SCB_CFSR_INVSTATE = 0x20000
	// no invalid state UsageFault
	SCB_CFSR_INVSTATE_INVSTATE_0 = 0x0
	// the processor has attempted to execute an instruction that makes illegal use of the EPSR
	SCB_CFSR_INVSTATE_INVSTATE_1 = 0x1
	// Position of INVPC field.
	SCB_CFSR_INVPC_Pos = 0x12
	// Bit mask of INVPC field.
	SCB_CFSR_INVPC_Msk = 0x40000
	// Bit INVPC.
	SCB_CFSR_INVPC = 0x40000
	// no invalid PC load UsageFault
	SCB_CFSR_INVPC_INVPC_0 = 0x0
	// the processor has attempted an illegal load of EXC_RETURN to the PC
	SCB_CFSR_INVPC_INVPC_1 = 0x1
	// Position of NOCP field.
	SCB_CFSR_NOCP_Pos = 0x13
	// Bit mask of NOCP field.
	SCB_CFSR_NOCP_Msk = 0x80000
	// Bit NOCP.
	SCB_CFSR_NOCP = 0x80000
	// no UsageFault caused by attempting to access a coprocessor
	SCB_CFSR_NOCP_NOCP_0 = 0x0
	// the processor has attempted to access a coprocessor
	SCB_CFSR_NOCP_NOCP_1 = 0x1
	// Position of UNALIGNED field.
	SCB_CFSR_UNALIGNED_Pos = 0x18
	// Bit mask of UNALIGNED field.
	SCB_CFSR_UNALIGNED_Msk = 0x1000000
	// Bit UNALIGNED.
	SCB_CFSR_UNALIGNED = 0x1000000
	// no unaligned access fault, or unaligned access trapping not enabled
	SCB_CFSR_UNALIGNED_UNALIGNED_0 = 0x0
	// the processor has made an unaligned memory access
	SCB_CFSR_UNALIGNED_UNALIGNED_1 = 0x1
	// Position of DIVBYZERO field.
	SCB_CFSR_DIVBYZERO_Pos = 0x19
	// Bit mask of DIVBYZERO field.
	SCB_CFSR_DIVBYZERO_Msk = 0x2000000
	// Bit DIVBYZERO.
	SCB_CFSR_DIVBYZERO = 0x2000000
	// no divide by zero fault, or divide by zero trapping not enabled
	SCB_CFSR_DIVBYZERO_DIVBYZERO_0 = 0x0
	// the processor has executed an SDIV or UDIV instruction with a divisor of 0
	SCB_CFSR_DIVBYZERO_DIVBYZERO_1 = 0x1

	// HFSR: HardFault Status register
	// Position of VECTTBL field.
	SCB_HFSR_VECTTBL_Pos = 0x1
	// Bit mask of VECTTBL field.
	SCB_HFSR_VECTTBL_Msk = 0x2
	// Bit VECTTBL.
	SCB_HFSR_VECTTBL = 0x2
	// no BusFault on vector table read
	SCB_HFSR_VECTTBL_VECTTBL_0 = 0x0
	// BusFault on vector table read
	SCB_HFSR_VECTTBL_VECTTBL_1 = 0x1
	// Position of FORCED field.
	SCB_HFSR_FORCED_Pos = 0x1e
	// Bit mask of FORCED field.
	SCB_HFSR_FORCED_Msk = 0x40000000
	// Bit FORCED.
	SCB_HFSR_FORCED = 0x40000000
	// no forced HardFault
	SCB_HFSR_FORCED_FORCED_0 = 0x0
	// forced HardFault
	SCB_HFSR_FORCED_FORCED_1 = 0x1
	// Position of DEBUGEVT field.
	SCB_HFSR_DEBUGEVT_Pos = 0x1f
	// Bit mask of DEBUGEVT field.
	SCB_HFSR_DEBUGEVT_Msk = 0x80000000
	// Bit DEBUGEVT.
	SCB_HFSR_DEBUGEVT = 0x80000000
	// No Debug event has occurred.
	SCB_HFSR_DEBUGEVT_DEBUGEVT_0 = 0x0
	// Debug event has occurred. The Debug Fault Status Register has been updated.
	SCB_HFSR_DEBUGEVT_DEBUGEVT_1 = 0x1

	// DFSR: Debug Fault Status Register
	// Position of HALTED field.
	SCB_DFSR_HALTED_Pos = 0x0
	// Bit mask of HALTED field.
	SCB_DFSR_HALTED_Msk = 0x1
	// Bit HALTED.
	SCB_DFSR_HALTED = 0x1
	// No active halt request debug event
	SCB_DFSR_HALTED_HALTED_0 = 0x0
	// Halt request debug event active
	SCB_DFSR_HALTED_HALTED_1 = 0x1
	// Position of BKPT field.
	SCB_DFSR_BKPT_Pos = 0x1
	// Bit mask of BKPT field.
	SCB_DFSR_BKPT_Msk = 0x2
	// Bit BKPT.
	SCB_DFSR_BKPT = 0x2
	// No current breakpoint debug event
	SCB_DFSR_BKPT_BKPT_0 = 0x0
	// At least one current breakpoint debug event
	SCB_DFSR_BKPT_BKPT_1 = 0x1
	// Position of DWTTRAP field.
	SCB_DFSR_DWTTRAP_Pos = 0x2
	// Bit mask of DWTTRAP field.
	SCB_DFSR_DWTTRAP_Msk = 0x4
	// Bit DWTTRAP.
	SCB_DFSR_DWTTRAP = 0x4
	// No current debug events generated by the DWT
	SCB_DFSR_DWTTRAP_DWTTRAP_0 = 0x0
	// At least one current debug event generated by the DWT
	SCB_DFSR_DWTTRAP_DWTTRAP_1 = 0x1
	// Position of VCATCH field.
	SCB_DFSR_VCATCH_Pos = 0x3
	// Bit mask of VCATCH field.
	SCB_DFSR_VCATCH_Msk = 0x8
	// Bit VCATCH.
	SCB_DFSR_VCATCH = 0x8
	// No Vector catch triggered
	SCB_DFSR_VCATCH_VCATCH_0 = 0x0
	// Vector catch triggered
	SCB_DFSR_VCATCH_VCATCH_1 = 0x1
	// Position of EXTERNAL field.
	SCB_DFSR_EXTERNAL_Pos = 0x4
	// Bit mask of EXTERNAL field.
	SCB_DFSR_EXTERNAL_Msk = 0x10
	// Bit EXTERNAL.
	SCB_DFSR_EXTERNAL = 0x10
	// No external debug request debug event
	SCB_DFSR_EXTERNAL_EXTERNAL_0 = 0x0
	// External debug request debug event
	SCB_DFSR_EXTERNAL_EXTERNAL_1 = 0x1

	// MMFAR: MemManage Fault Address Register
	// Position of ADDRESS field.
	SCB_MMFAR_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	SCB_MMFAR_ADDRESS_Msk = 0xffffffff

	// BFAR: BusFault Address Register
	// Position of ADDRESS field.
	SCB_BFAR_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	SCB_BFAR_ADDRESS_Msk = 0xffffffff

	// ID_PFR0: Processor Feature Register 0
	// Position of STATE0 field.
	SCB_ID_PFR0_STATE0_Pos = 0x0
	// Bit mask of STATE0 field.
	SCB_ID_PFR0_STATE0_Msk = 0xf
	// ARMv7-M unused
	SCB_ID_PFR0_STATE0_STATE0_0 = 0x0
	// ARMv7-M unused
	SCB_ID_PFR0_STATE0_STATE0_1 = 0x1
	// ARMv7-M unused
	SCB_ID_PFR0_STATE0_STATE0_2 = 0x2
	// Support for Thumb encoding including Thumb-2 technology, with all basic 16-bit and 32-bit instructions.
	SCB_ID_PFR0_STATE0_STATE0_3 = 0x3
	// Position of STATE1 field.
	SCB_ID_PFR0_STATE1_Pos = 0x4
	// Bit mask of STATE1 field.
	SCB_ID_PFR0_STATE1_Msk = 0xf0
	// The processor does not support the ARM instruction set.
	SCB_ID_PFR0_STATE1_STATE1_0 = 0x0
	// ARMv7-M unused
	SCB_ID_PFR0_STATE1_STATE1_1 = 0x1
	// Position of STATE2 field.
	SCB_ID_PFR0_STATE2_Pos = 0x8
	// Bit mask of STATE2 field.
	SCB_ID_PFR0_STATE2_Msk = 0xf00
	// Position of STATE3 field.
	SCB_ID_PFR0_STATE3_Pos = 0xc
	// Bit mask of STATE3 field.
	SCB_ID_PFR0_STATE3_Msk = 0xf000

	// ID_PFR1: Processor Feature Register 1
	// Position of PROGMODEL field.
	SCB_ID_PFR1_PROGMODEL_Pos = 0x8
	// Bit mask of PROGMODEL field.
	SCB_ID_PFR1_PROGMODEL_Msk = 0xf00
	// ARMv7-M unused
	SCB_ID_PFR1_PROGMODEL_PROGMODEL_0 = 0x0
	// Two-stack programmers' model supported
	SCB_ID_PFR1_PROGMODEL_PROGMODEL_2 = 0x2

	// ID_DFR0: Debug Feature Register
	// Position of DEBUGMODEL field.
	SCB_ID_DFR0_DEBUGMODEL_Pos = 0x14
	// Bit mask of DEBUGMODEL field.
	SCB_ID_DFR0_DEBUGMODEL_Msk = 0xf00000
	// Not supported
	SCB_ID_DFR0_DEBUGMODEL_DEBUGMODEL_0 = 0x0
	// Support for M profile Debug architecture, with memory-mapped access.
	SCB_ID_DFR0_DEBUGMODEL_DEBUGMODEL_1 = 0x1

	// ID_AFR0: Auxiliary Feature Register
	// Position of IMPLEMENTATION_DEFINED0 field.
	SCB_ID_AFR0_IMPLEMENTATION_DEFINED0_Pos = 0x0
	// Bit mask of IMPLEMENTATION_DEFINED0 field.
	SCB_ID_AFR0_IMPLEMENTATION_DEFINED0_Msk = 0xf
	// Position of IMPLEMENTATION_DEFINED1 field.
	SCB_ID_AFR0_IMPLEMENTATION_DEFINED1_Pos = 0x4
	// Bit mask of IMPLEMENTATION_DEFINED1 field.
	SCB_ID_AFR0_IMPLEMENTATION_DEFINED1_Msk = 0xf0
	// Position of IMPLEMENTATION_DEFINED2 field.
	SCB_ID_AFR0_IMPLEMENTATION_DEFINED2_Pos = 0x8
	// Bit mask of IMPLEMENTATION_DEFINED2 field.
	SCB_ID_AFR0_IMPLEMENTATION_DEFINED2_Msk = 0xf00
	// Position of IMPLEMENTATION_DEFINED3 field.
	SCB_ID_AFR0_IMPLEMENTATION_DEFINED3_Pos = 0xc
	// Bit mask of IMPLEMENTATION_DEFINED3 field.
	SCB_ID_AFR0_IMPLEMENTATION_DEFINED3_Msk = 0xf000

	// ID_MMFR0: Memory Model Feature Register 0
	// Position of PMSASUPPORT field.
	SCB_ID_MMFR0_PMSASUPPORT_Pos = 0x4
	// Bit mask of PMSASUPPORT field.
	SCB_ID_MMFR0_PMSASUPPORT_Msk = 0xf0
	// Not supported
	SCB_ID_MMFR0_PMSASUPPORT_PMSASUPPORT_0 = 0x0
	// ARMv7-M unused
	SCB_ID_MMFR0_PMSASUPPORT_PMSASUPPORT_1 = 0x1
	// ARMv7-M unused
	SCB_ID_MMFR0_PMSASUPPORT_PMSASUPPORT_2 = 0x2
	// PMSAv7, providing support for a base region and subregions.
	SCB_ID_MMFR0_PMSASUPPORT_PMSASUPPORT_3 = 0x3
	// Position of OUTERMOST_SHAREABILITY field.
	SCB_ID_MMFR0_OUTERMOST_SHAREABILITY_Pos = 0x8
	// Bit mask of OUTERMOST_SHAREABILITY field.
	SCB_ID_MMFR0_OUTERMOST_SHAREABILITY_Msk = 0xf00
	// Implemented as Non-cacheable
	SCB_ID_MMFR0_OUTERMOST_SHAREABILITY_OUTERMOST_SHAREABILITY_0 = 0x0
	// ARMv7-M unused
	SCB_ID_MMFR0_OUTERMOST_SHAREABILITY_OUTERMOST_SHAREABILITY_1 = 0x1
	// ARMv7-M unused
	SCB_ID_MMFR0_OUTERMOST_SHAREABILITY_OUTERMOST_SHAREABILITY_2 = 0x2
	// ARMv7-M unused
	SCB_ID_MMFR0_OUTERMOST_SHAREABILITY_OUTERMOST_SHAREABILITY_3 = 0x3
	// ARMv7-M unused
	SCB_ID_MMFR0_OUTERMOST_SHAREABILITY_OUTERMOST_SHAREABILITY_4 = 0x4
	// ARMv7-M unused
	SCB_ID_MMFR0_OUTERMOST_SHAREABILITY_OUTERMOST_SHAREABILITY_5 = 0x5
	// ARMv7-M unused
	SCB_ID_MMFR0_OUTERMOST_SHAREABILITY_OUTERMOST_SHAREABILITY_6 = 0x6
	// ARMv7-M unused
	SCB_ID_MMFR0_OUTERMOST_SHAREABILITY_OUTERMOST_SHAREABILITY_7 = 0x7
	// ARMv7-M unused
	SCB_ID_MMFR0_OUTERMOST_SHAREABILITY_OUTERMOST_SHAREABILITY_8 = 0x8
	// ARMv7-M unused
	SCB_ID_MMFR0_OUTERMOST_SHAREABILITY_OUTERMOST_SHAREABILITY_9 = 0x9
	// ARMv7-M unused
	SCB_ID_MMFR0_OUTERMOST_SHAREABILITY_OUTERMOST_SHAREABILITY_10 = 0xa
	// ARMv7-M unused
	SCB_ID_MMFR0_OUTERMOST_SHAREABILITY_OUTERMOST_SHAREABILITY_11 = 0xb
	// ARMv7-M unused
	SCB_ID_MMFR0_OUTERMOST_SHAREABILITY_OUTERMOST_SHAREABILITY_12 = 0xc
	// ARMv7-M unused
	SCB_ID_MMFR0_OUTERMOST_SHAREABILITY_OUTERMOST_SHAREABILITY_13 = 0xd
	// ARMv7-M unused
	SCB_ID_MMFR0_OUTERMOST_SHAREABILITY_OUTERMOST_SHAREABILITY_14 = 0xe
	// Shareability ignored.
	SCB_ID_MMFR0_OUTERMOST_SHAREABILITY_OUTERMOST_SHAREABILITY_15 = 0xf
	// Position of SHAREABILITY_LEVELS field.
	SCB_ID_MMFR0_SHAREABILITY_LEVELS_Pos = 0xc
	// Bit mask of SHAREABILITY_LEVELS field.
	SCB_ID_MMFR0_SHAREABILITY_LEVELS_Msk = 0xf000
	// One level of shareability implemented
	SCB_ID_MMFR0_SHAREABILITY_LEVELS_SHAREABILITY_LEVELS_0 = 0x0
	// ARMv7-M unused
	SCB_ID_MMFR0_SHAREABILITY_LEVELS_SHAREABILITY_LEVELS_1 = 0x1
	// Position of TCM_SUPPORT field.
	SCB_ID_MMFR0_TCM_SUPPORT_Pos = 0x10
	// Bit mask of TCM_SUPPORT field.
	SCB_ID_MMFR0_TCM_SUPPORT_Msk = 0xf0000
	// No tightly coupled memories implemented.
	SCB_ID_MMFR0_TCM_SUPPORT_TCM_SUPPORT_0 = 0x0
	// Tightly coupled memories implemented with IMPLEMENTATION DEFINED control.
	SCB_ID_MMFR0_TCM_SUPPORT_TCM_SUPPORT_1 = 0x1
	// ARMv7-M unused
	SCB_ID_MMFR0_TCM_SUPPORT_TCM_SUPPORT_2 = 0x2
	// Position of AUXILIARY_REGISTERS field.
	SCB_ID_MMFR0_AUXILIARY_REGISTERS_Pos = 0x14
	// Bit mask of AUXILIARY_REGISTERS field.
	SCB_ID_MMFR0_AUXILIARY_REGISTERS_Msk = 0xf00000
	// Not supported
	SCB_ID_MMFR0_AUXILIARY_REGISTERS_AUXILIARY_REGISTERS_0 = 0x0
	// Support for Auxiliary Control Register only.
	SCB_ID_MMFR0_AUXILIARY_REGISTERS_AUXILIARY_REGISTERS_1 = 0x1
	// ARMv7-M unused
	SCB_ID_MMFR0_AUXILIARY_REGISTERS_AUXILIARY_REGISTERS_2 = 0x2

	// ID_MMFR1: Memory Model Feature Register 1
	// Position of ID_MMFR1 field.
	SCB_ID_MMFR1_ID_MMFR1_Pos = 0x0
	// Bit mask of ID_MMFR1 field.
	SCB_ID_MMFR1_ID_MMFR1_Msk = 0xffffffff

	// ID_MMFR2: Memory Model Feature Register 2
	// Position of WFI_STALL field.
	SCB_ID_MMFR2_WFI_STALL_Pos = 0x18
	// Bit mask of WFI_STALL field.
	SCB_ID_MMFR2_WFI_STALL_Msk = 0xf000000
	// Not supported
	SCB_ID_MMFR2_WFI_STALL_WFI_STALL_0 = 0x0
	// Support for WFI stalling
	SCB_ID_MMFR2_WFI_STALL_WFI_STALL_1 = 0x1

	// ID_MMFR3: Memory Model Feature Register 3
	// Position of ID_MMFR3 field.
	SCB_ID_MMFR3_ID_MMFR3_Pos = 0x0
	// Bit mask of ID_MMFR3 field.
	SCB_ID_MMFR3_ID_MMFR3_Msk = 0xffffffff

	// ID_ISAR0: Instruction Set Attributes Register 0
	// Position of BITCOUNT_INSTRS field.
	SCB_ID_ISAR0_BITCOUNT_INSTRS_Pos = 0x4
	// Bit mask of BITCOUNT_INSTRS field.
	SCB_ID_ISAR0_BITCOUNT_INSTRS_Msk = 0xf0
	// None supported, ARMv7-M unused
	SCB_ID_ISAR0_BITCOUNT_INSTRS_BITCOUNT_INSTRS_0 = 0x0
	// Adds support for the CLZ instruction
	SCB_ID_ISAR0_BITCOUNT_INSTRS_BITCOUNT_INSTRS_1 = 0x1
	// Position of BITFIELD_INSTRS field.
	SCB_ID_ISAR0_BITFIELD_INSTRS_Pos = 0x8
	// Bit mask of BITFIELD_INSTRS field.
	SCB_ID_ISAR0_BITFIELD_INSTRS_Msk = 0xf00
	// None supported, ARMv7-M unused
	SCB_ID_ISAR0_BITFIELD_INSTRS_BITFIELD_INSTRS_0 = 0x0
	// Adds support for the BFC, BFI, SBFX, and UBFX instructions
	SCB_ID_ISAR0_BITFIELD_INSTRS_BITFIELD_INSTRS_1 = 0x1
	// Position of CMPBRANCH_INSTRS field.
	SCB_ID_ISAR0_CMPBRANCH_INSTRS_Pos = 0xc
	// Bit mask of CMPBRANCH_INSTRS field.
	SCB_ID_ISAR0_CMPBRANCH_INSTRS_Msk = 0xf000
	// None supported, ARMv7-M unused
	SCB_ID_ISAR0_CMPBRANCH_INSTRS_CMPBRANCH_INSTRS_0 = 0x0
	// Adds support for the CBNZ and CBZ instructions
	SCB_ID_ISAR0_CMPBRANCH_INSTRS_CMPBRANCH_INSTRS_1 = 0x1
	// Position of COPROC_INSTRS field.
	SCB_ID_ISAR0_COPROC_INSTRS_Pos = 0x10
	// Bit mask of COPROC_INSTRS field.
	SCB_ID_ISAR0_COPROC_INSTRS_Msk = 0xf0000
	// None supported, except for separately attributed architectures, for example the Floating-point extension
	SCB_ID_ISAR0_COPROC_INSTRS_COPROC_INSTRS_0 = 0x0
	// Adds support for generic CDP, LDC, MCR, MRC, and STC instructions
	SCB_ID_ISAR0_COPROC_INSTRS_COPROC_INSTRS_1 = 0x1
	// As for 1, and adds support for generic CDP2, LDC2, MCR2, MRC2, and STC2 instructions
	SCB_ID_ISAR0_COPROC_INSTRS_COPROC_INSTRS_2 = 0x2
	// As for 2, and adds support for generic MCRR and MRRC instructions
	SCB_ID_ISAR0_COPROC_INSTRS_COPROC_INSTRS_3 = 0x3
	// As for 3, and adds support for generic MCRR2 and MRRC2 instructions
	SCB_ID_ISAR0_COPROC_INSTRS_COPROC_INSTRS_4 = 0x4
	// Position of DEBUG_INSTRS field.
	SCB_ID_ISAR0_DEBUG_INSTRS_Pos = 0x14
	// Bit mask of DEBUG_INSTRS field.
	SCB_ID_ISAR0_DEBUG_INSTRS_Msk = 0xf00000
	// None supported, ARMv7-M unused
	SCB_ID_ISAR0_DEBUG_INSTRS_DEBUG_INSTRS_0 = 0x0
	// Adds support for the BKPT instruction
	SCB_ID_ISAR0_DEBUG_INSTRS_DEBUG_INSTRS_1 = 0x1
	// Position of DIVIDE_INSTRS field.
	SCB_ID_ISAR0_DIVIDE_INSTRS_Pos = 0x18
	// Bit mask of DIVIDE_INSTRS field.
	SCB_ID_ISAR0_DIVIDE_INSTRS_Msk = 0xf000000
	// None supported, ARMv7-M unused
	SCB_ID_ISAR0_DIVIDE_INSTRS_DIVIDE_INSTRS_0 = 0x0
	// Adds support for the SDIV and UDIV instructions
	SCB_ID_ISAR0_DIVIDE_INSTRS_DIVIDE_INSTRS_1 = 0x1

	// ID_ISAR1: Instruction Set Attributes Register 1
	// Position of EXTEND_INSTRS field.
	SCB_ID_ISAR1_EXTEND_INSTRS_Pos = 0xc
	// Bit mask of EXTEND_INSTRS field.
	SCB_ID_ISAR1_EXTEND_INSTRS_Msk = 0xf000
	// None supported, ARMv7-M unused
	SCB_ID_ISAR1_EXTEND_INSTRS_EXTEND_INSTRS_0 = 0x0
	// Adds support for the SXTB, SXTH, UXTB, and UXTH instructions
	SCB_ID_ISAR1_EXTEND_INSTRS_EXTEND_INSTRS_1 = 0x1
	// As for 1, and adds support for the SXTAB, SXTAB16, SXTAH, SXTB16, UXTAB, UXTAB16, UXTAH, and UXTB16 instructions
	SCB_ID_ISAR1_EXTEND_INSTRS_EXTEND_INSTRS_2 = 0x2
	// Position of IFTHEN_INSTRS field.
	SCB_ID_ISAR1_IFTHEN_INSTRS_Pos = 0x10
	// Bit mask of IFTHEN_INSTRS field.
	SCB_ID_ISAR1_IFTHEN_INSTRS_Msk = 0xf0000
	// None supported, ARMv7-M unused
	SCB_ID_ISAR1_IFTHEN_INSTRS_IFTHEN_INSTRS_0 = 0x0
	// Adds support for the IT instructions, and for the IT bits in the PSRs
	SCB_ID_ISAR1_IFTHEN_INSTRS_IFTHEN_INSTRS_1 = 0x1
	// Position of IMMEDIATE_INSTRS field.
	SCB_ID_ISAR1_IMMEDIATE_INSTRS_Pos = 0x14
	// Bit mask of IMMEDIATE_INSTRS field.
	SCB_ID_ISAR1_IMMEDIATE_INSTRS_Msk = 0xf00000
	// None supported, ARMv7-M unused
	SCB_ID_ISAR1_IMMEDIATE_INSTRS_IMMEDIATE_INSTRS_0 = 0x0
	// Adds support for the ADDW, MOVW, MOVT, and SUBW instructions
	SCB_ID_ISAR1_IMMEDIATE_INSTRS_IMMEDIATE_INSTRS_1 = 0x1
	// Position of INTERWORK_INSTRS field.
	SCB_ID_ISAR1_INTERWORK_INSTRS_Pos = 0x18
	// Bit mask of INTERWORK_INSTRS field.
	SCB_ID_ISAR1_INTERWORK_INSTRS_Msk = 0xf000000
	// None supported, ARMv7-M unused
	SCB_ID_ISAR1_INTERWORK_INSTRS_INTERWORK_INSTRS_0 = 0x0
	// Adds support for the BX instruction, and the T bit in the PSR
	SCB_ID_ISAR1_INTERWORK_INSTRS_INTERWORK_INSTRS_1 = 0x1
	// As for 1, and adds support for the BLX instruction, and PC loads have BX-like behavior
	SCB_ID_ISAR1_INTERWORK_INSTRS_INTERWORK_INSTRS_2 = 0x2
	// ARMv7-M unused
	SCB_ID_ISAR1_INTERWORK_INSTRS_INTERWORK_INSTRS_3 = 0x3

	// ID_ISAR2: Instruction Set Attributes Register 2
	// Position of LOADSTORE_INSTRS field.
	SCB_ID_ISAR2_LOADSTORE_INSTRS_Pos = 0x0
	// Bit mask of LOADSTORE_INSTRS field.
	SCB_ID_ISAR2_LOADSTORE_INSTRS_Msk = 0xf
	// None supported, ARMv7-M unused
	SCB_ID_ISAR2_LOADSTORE_INSTRS_LOADSTORE_INSTRS_0 = 0x0
	// Adds support for the LDRD and STRD instructions
	SCB_ID_ISAR2_LOADSTORE_INSTRS_LOADSTORE_INSTRS_1 = 0x1
	// Position of MEMHINT_INSTRS field.
	SCB_ID_ISAR2_MEMHINT_INSTRS_Pos = 0x4
	// Bit mask of MEMHINT_INSTRS field.
	SCB_ID_ISAR2_MEMHINT_INSTRS_Msk = 0xf0
	// None supported, ARMv7-M unused.
	SCB_ID_ISAR2_MEMHINT_INSTRS_MEMHINT_INSTRS_0 = 0x0
	// Adds support for the PLD instruction, ARMv7-M unused.
	SCB_ID_ISAR2_MEMHINT_INSTRS_MEMHINT_INSTRS_1 = 0x1
	// As for 1, ARMv7-M unused.
	SCB_ID_ISAR2_MEMHINT_INSTRS_MEMHINT_INSTRS_2 = 0x2
	// As for 1 or 2, and adds support for the PLI instruction.
	SCB_ID_ISAR2_MEMHINT_INSTRS_MEMHINT_INSTRS_3 = 0x3
	// Position of MULTIACCESSINT_INSTRS field.
	SCB_ID_ISAR2_MULTIACCESSINT_INSTRS_Pos = 0x8
	// Bit mask of MULTIACCESSINT_INSTRS field.
	SCB_ID_ISAR2_MULTIACCESSINT_INSTRS_Msk = 0xf00
	// None supported. This means the LDM and STM instructions are not interruptible. ARMv7-M unused.
	SCB_ID_ISAR2_MULTIACCESSINT_INSTRS_MULTIACCESSINT_INSTRS_0 = 0x0
	// LDM and STM instructions are restartable.
	SCB_ID_ISAR2_MULTIACCESSINT_INSTRS_MULTIACCESSINT_INSTRS_1 = 0x1
	// LDM and STM instructions are continuable.
	SCB_ID_ISAR2_MULTIACCESSINT_INSTRS_MULTIACCESSINT_INSTRS_2 = 0x2
	// Position of MULT_INSTRS field.
	SCB_ID_ISAR2_MULT_INSTRS_Pos = 0xc
	// Bit mask of MULT_INSTRS field.
	SCB_ID_ISAR2_MULT_INSTRS_Msk = 0xf000
	// None supported. This means only MUL is supported. ARMv7-M unused.
	SCB_ID_ISAR2_MULT_INSTRS_MULT_INSTRS_0 = 0x0
	// Adds support for the MLA instruction, ARMv7-M unused.
	SCB_ID_ISAR2_MULT_INSTRS_MULT_INSTRS_1 = 0x1
	// As for 1, and adds support for the MLS instruction.
	SCB_ID_ISAR2_MULT_INSTRS_MULT_INSTRS_2 = 0x2
	// Position of MULTS_INSTRS field.
	SCB_ID_ISAR2_MULTS_INSTRS_Pos = 0x10
	// Bit mask of MULTS_INSTRS field.
	SCB_ID_ISAR2_MULTS_INSTRS_Msk = 0xf0000
	// None supported, ARMv7-M unused
	SCB_ID_ISAR2_MULTS_INSTRS_MULTS_INSTRS_0 = 0x0
	// Adds support for the SMULL and SMLAL instructions
	SCB_ID_ISAR2_MULTS_INSTRS_MULTS_INSTRS_1 = 0x1
	// As for 1, and adds support for the SMLABB, SMLABT, SMLALBB, SMLALBT, SMLALTB, SMLALTT, SMLATB, SMLATT, SMLAWB, SMLAWT, SMULBB, SMULBT, SMULTB, SMULTT, SMULWB, and SMULWT instructions.
	SCB_ID_ISAR2_MULTS_INSTRS_MULTS_INSTRS_2 = 0x2
	// As for 2, and adds support for the SMLAD, SMLADX, SMLALD, SMLALDX, SMLSD, SMLSDX, SMLSLD, SMLSLDX, SMMLA, SMMLAR, SMMLS, SMMLSR, SMMUL, SMMULR, SMUAD, SMUADX, SMUSD, and SMUSDX instructions.
	SCB_ID_ISAR2_MULTS_INSTRS_MULTS_INSTRS_3 = 0x3
	// Position of MULTU_INSTRS field.
	SCB_ID_ISAR2_MULTU_INSTRS_Pos = 0x14
	// Bit mask of MULTU_INSTRS field.
	SCB_ID_ISAR2_MULTU_INSTRS_Msk = 0xf00000
	// None supported, ARMv7-M unused
	SCB_ID_ISAR2_MULTU_INSTRS_MULTU_INSTRS_0 = 0x0
	// Adds support for the UMULL and UMLAL instructions.
	SCB_ID_ISAR2_MULTU_INSTRS_MULTU_INSTRS_1 = 0x1
	// As for 1, and adds support for the UMAAL instruction.
	SCB_ID_ISAR2_MULTU_INSTRS_MULTU_INSTRS_2 = 0x2
	// Position of REVERSAL_INSTRS field.
	SCB_ID_ISAR2_REVERSAL_INSTRS_Pos = 0x1c
	// Bit mask of REVERSAL_INSTRS field.
	SCB_ID_ISAR2_REVERSAL_INSTRS_Msk = 0xf0000000
	// None supported, ARMv7-M unused
	SCB_ID_ISAR2_REVERSAL_INSTRS_REVERSAL_INSTRS_0 = 0x0
	// Adds support for the REV, REV16, and REVSH instructions, ARMv7-M unused.
	SCB_ID_ISAR2_REVERSAL_INSTRS_REVERSAL_INSTRS_1 = 0x1
	// As for 1, and adds support for the RBIT instruction.
	SCB_ID_ISAR2_REVERSAL_INSTRS_REVERSAL_INSTRS_2 = 0x2

	// ID_ISAR3: Instruction Set Attributes Register 3
	// Position of SATURATE_INSTRS field.
	SCB_ID_ISAR3_SATURATE_INSTRS_Pos = 0x0
	// Bit mask of SATURATE_INSTRS field.
	SCB_ID_ISAR3_SATURATE_INSTRS_Msk = 0xf
	// None supported
	SCB_ID_ISAR3_SATURATE_INSTRS_SATURATE_INSTRS_0 = 0x0
	// Adds support for the QADD, QDADD, QDSUB, and QSUB instructions, and for the Q bit in the PSRs.
	SCB_ID_ISAR3_SATURATE_INSTRS_SATURATE_INSTRS_1 = 0x1
	// Position of SIMD_INSTRS field.
	SCB_ID_ISAR3_SIMD_INSTRS_Pos = 0x4
	// Bit mask of SIMD_INSTRS field.
	SCB_ID_ISAR3_SIMD_INSTRS_Msk = 0xf0
	// None supported, ARMv7-M unused.
	SCB_ID_ISAR3_SIMD_INSTRS_SIMD_INSTRS_0 = 0x0
	// Adds support for the SSAT and USAT instructions, and for the Q bit in the PSRs.
	SCB_ID_ISAR3_SIMD_INSTRS_SIMD_INSTRS_1 = 0x1
	// As for 1, and adds support for the PKHBT, PKHTB, QADD16, QADD8, QASX, QSUB16, QSUB8, QSAX, SADD16, SADD8, SASX, SEL, SHADD16, SHADD8, SHASX, SHSUB16, SHSUB8, SHSAX, SSAT16, SSUB16, SSUB8, SSAX, SXTAB16, SXTB16, UADD16, UADD8, UASX, UHADD16, UHADD8, UHASX, UHSUB16, UHSUB8, UHSAX, UQADD16, UQADD8, UQASX, UQSUB16, UQSUB8, UQSAX, USAD8, USADA8, USAT16, USUB16, USUB8, USAX, UXTAB16, and UXTB16 instructions. Also adds support for the GE[3:0] bits in the PSRs.
	SCB_ID_ISAR3_SIMD_INSTRS_SIMD_INSTRS_3 = 0x3
	// Position of SVC_INSTRS field.
	SCB_ID_ISAR3_SVC_INSTRS_Pos = 0x8
	// Bit mask of SVC_INSTRS field.
	SCB_ID_ISAR3_SVC_INSTRS_Msk = 0xf00
	// None supported, ARMv7-M unused.
	SCB_ID_ISAR3_SVC_INSTRS_SVC_INSTRS_0 = 0x0
	// Adds support for the SVC instruction.
	SCB_ID_ISAR3_SVC_INSTRS_SVC_INSTRS_1 = 0x1
	// Position of SYNCHPRIM_INSTRS field.
	SCB_ID_ISAR3_SYNCHPRIM_INSTRS_Pos = 0xc
	// Bit mask of SYNCHPRIM_INSTRS field.
	SCB_ID_ISAR3_SYNCHPRIM_INSTRS_Msk = 0xf000
	// Position of TABBRANCH_INSTRS field.
	SCB_ID_ISAR3_TABBRANCH_INSTRS_Pos = 0x10
	// Bit mask of TABBRANCH_INSTRS field.
	SCB_ID_ISAR3_TABBRANCH_INSTRS_Msk = 0xf0000
	// None supported, ARMv7-M unused.
	SCB_ID_ISAR3_TABBRANCH_INSTRS_TABBRANCH_INSTRS_0 = 0x0
	// Adds support for the TBB and TBH instructions.
	SCB_ID_ISAR3_TABBRANCH_INSTRS_TABBRANCH_INSTRS_1 = 0x1
	// Position of THUMBCOPY_INSTRS field.
	SCB_ID_ISAR3_THUMBCOPY_INSTRS_Pos = 0x14
	// Bit mask of THUMBCOPY_INSTRS field.
	SCB_ID_ISAR3_THUMBCOPY_INSTRS_Msk = 0xf00000
	// None supported, ARMv7-M unused.
	SCB_ID_ISAR3_THUMBCOPY_INSTRS_THUMBCOPY_INSTRS_0 = 0x0
	// Adds support for encoding T1 of the MOV (register) instruction copying from a low register to a low register.
	SCB_ID_ISAR3_THUMBCOPY_INSTRS_THUMBCOPY_INSTRS_1 = 0x1
	// Position of TRUENOP_INSTRS field.
	SCB_ID_ISAR3_TRUENOP_INSTRS_Pos = 0x18
	// Bit mask of TRUENOP_INSTRS field.
	SCB_ID_ISAR3_TRUENOP_INSTRS_Msk = 0xf000000
	// None supported, ARMv7-M unused.
	SCB_ID_ISAR3_TRUENOP_INSTRS_TRUENOP_INSTRS_0 = 0x0
	// Adds support for encoding T1 of the MOV (register) instruction copying from a low register to a low register.
	SCB_ID_ISAR3_TRUENOP_INSTRS_TRUENOP_INSTRS_1 = 0x1

	// ID_ISAR4: Instruction Set Attributes Register 4
	// Position of UNPRIV_INSTRS field.
	SCB_ID_ISAR4_UNPRIV_INSTRS_Pos = 0x0
	// Bit mask of UNPRIV_INSTRS field.
	SCB_ID_ISAR4_UNPRIV_INSTRS_Msk = 0xf
	// None supported, ARMv7-M unused.
	SCB_ID_ISAR4_UNPRIV_INSTRS_UNPRIV_INSTRS_0 = 0x0
	// Adds support for the LDRBT, LDRT, STRBT, and STRT instructions.
	SCB_ID_ISAR4_UNPRIV_INSTRS_UNPRIV_INSTRS_1 = 0x1
	// As for 1, and adds support for the LDRHT, LDRSBT, LDRSHT, and STRHT instructions.
	SCB_ID_ISAR4_UNPRIV_INSTRS_UNPRIV_INSTRS_2 = 0x2
	// Position of WITHSHIFTS_INSTRS field.
	SCB_ID_ISAR4_WITHSHIFTS_INSTRS_Pos = 0x4
	// Bit mask of WITHSHIFTS_INSTRS field.
	SCB_ID_ISAR4_WITHSHIFTS_INSTRS_Msk = 0xf0
	// Nonzero shifts supported only in MOV and shift instructions.
	SCB_ID_ISAR4_WITHSHIFTS_INSTRS_WITHSHIFTS_INSTRS_0 = 0x0
	// Adds support for shifts of loads and stores over the range LSL 0-3.
	SCB_ID_ISAR4_WITHSHIFTS_INSTRS_WITHSHIFTS_INSTRS_1 = 0x1
	// As for 1, and adds support for other constant shift options, on loads, stores, and other instructions.
	SCB_ID_ISAR4_WITHSHIFTS_INSTRS_WITHSHIFTS_INSTRS_3 = 0x3
	// ARMv7-M unused.
	SCB_ID_ISAR4_WITHSHIFTS_INSTRS_WITHSHIFTS_INSTRS_4 = 0x4
	// Position of WRITEBACK_INSTRS field.
	SCB_ID_ISAR4_WRITEBACK_INSTRS_Pos = 0x8
	// Bit mask of WRITEBACK_INSTRS field.
	SCB_ID_ISAR4_WRITEBACK_INSTRS_Msk = 0xf00
	// Basic support. Only the LDM, STM, PUSH, and POP instructions support writeback addressing modes. ARMv7-M unused.
	SCB_ID_ISAR4_WRITEBACK_INSTRS_WRITEBACK_INSTRS_0 = 0x0
	// Adds support for all of the writeback addressing modes defined in the ARMv7-M architecture.
	SCB_ID_ISAR4_WRITEBACK_INSTRS_WRITEBACK_INSTRS_1 = 0x1
	// Position of BARRIER_INSTRS field.
	SCB_ID_ISAR4_BARRIER_INSTRS_Pos = 0x10
	// Bit mask of BARRIER_INSTRS field.
	SCB_ID_ISAR4_BARRIER_INSTRS_Msk = 0xf0000
	// None supported, ARMv7-M unused.
	SCB_ID_ISAR4_BARRIER_INSTRS_BARRIER_INSTRS_0 = 0x0
	// Adds support for the DMB, DSB, and ISB barrier instructions.
	SCB_ID_ISAR4_BARRIER_INSTRS_BARRIER_INSTRS_1 = 0x1
	// Position of SYNCHPRIM_INSTRS_FRAC field.
	SCB_ID_ISAR4_SYNCHPRIM_INSTRS_FRAC_Pos = 0x14
	// Bit mask of SYNCHPRIM_INSTRS_FRAC field.
	SCB_ID_ISAR4_SYNCHPRIM_INSTRS_FRAC_Msk = 0xf00000
	// Position of PSR_M_INSTRS field.
	SCB_ID_ISAR4_PSR_M_INSTRS_Pos = 0x18
	// Bit mask of PSR_M_INSTRS field.
	SCB_ID_ISAR4_PSR_M_INSTRS_Msk = 0xf000000
	// None supported, ARMv7-M unused.
	SCB_ID_ISAR4_PSR_M_INSTRS_PSR_M_INSTRS_0 = 0x0
	// Adds support for the M-profile forms of the CPS, MRS, and MSR instructions, to access the PSRs.
	SCB_ID_ISAR4_PSR_M_INSTRS_PSR_M_INSTRS_1 = 0x1

	// CLIDR: Cache Level ID register
	// Position of CL1 field.
	SCB_CLIDR_CL1_Pos = 0x0
	// Bit mask of CL1 field.
	SCB_CLIDR_CL1_Msk = 0x7
	// No cache
	SCB_CLIDR_CL1_CL1_0 = 0x0
	// Instruction cache only
	SCB_CLIDR_CL1_CL1_1 = 0x1
	// Data cache only
	SCB_CLIDR_CL1_CL1_2 = 0x2
	// Separate instruction and data caches
	SCB_CLIDR_CL1_CL1_3 = 0x3
	// Unified cache
	SCB_CLIDR_CL1_CL1_4 = 0x4
	// Position of CL2 field.
	SCB_CLIDR_CL2_Pos = 0x3
	// Bit mask of CL2 field.
	SCB_CLIDR_CL2_Msk = 0x38
	// No cache
	SCB_CLIDR_CL2_CL2_0 = 0x0
	// Instruction cache only
	SCB_CLIDR_CL2_CL2_1 = 0x1
	// Data cache only
	SCB_CLIDR_CL2_CL2_2 = 0x2
	// Separate instruction and data caches
	SCB_CLIDR_CL2_CL2_3 = 0x3
	// Unified cache
	SCB_CLIDR_CL2_CL2_4 = 0x4
	// Position of CL3 field.
	SCB_CLIDR_CL3_Pos = 0x6
	// Bit mask of CL3 field.
	SCB_CLIDR_CL3_Msk = 0x1c0
	// No cache
	SCB_CLIDR_CL3_CL3_0 = 0x0
	// Instruction cache only
	SCB_CLIDR_CL3_CL3_1 = 0x1
	// Data cache only
	SCB_CLIDR_CL3_CL3_2 = 0x2
	// Separate instruction and data caches
	SCB_CLIDR_CL3_CL3_3 = 0x3
	// Unified cache
	SCB_CLIDR_CL3_CL3_4 = 0x4
	// Position of CL4 field.
	SCB_CLIDR_CL4_Pos = 0x9
	// Bit mask of CL4 field.
	SCB_CLIDR_CL4_Msk = 0xe00
	// No cache
	SCB_CLIDR_CL4_CL4_0 = 0x0
	// Instruction cache only
	SCB_CLIDR_CL4_CL4_1 = 0x1
	// Data cache only
	SCB_CLIDR_CL4_CL4_2 = 0x2
	// Separate instruction and data caches
	SCB_CLIDR_CL4_CL4_3 = 0x3
	// Unified cache
	SCB_CLIDR_CL4_CL4_4 = 0x4
	// Position of CL5 field.
	SCB_CLIDR_CL5_Pos = 0xc
	// Bit mask of CL5 field.
	SCB_CLIDR_CL5_Msk = 0x7000
	// No cache
	SCB_CLIDR_CL5_CL5_0 = 0x0
	// Instruction cache only
	SCB_CLIDR_CL5_CL5_1 = 0x1
	// Data cache only
	SCB_CLIDR_CL5_CL5_2 = 0x2
	// Separate instruction and data caches
	SCB_CLIDR_CL5_CL5_3 = 0x3
	// Unified cache
	SCB_CLIDR_CL5_CL5_4 = 0x4
	// Position of CL6 field.
	SCB_CLIDR_CL6_Pos = 0xf
	// Bit mask of CL6 field.
	SCB_CLIDR_CL6_Msk = 0x38000
	// No cache
	SCB_CLIDR_CL6_CL6_0 = 0x0
	// Instruction cache only
	SCB_CLIDR_CL6_CL6_1 = 0x1
	// Data cache only
	SCB_CLIDR_CL6_CL6_2 = 0x2
	// Separate instruction and data caches
	SCB_CLIDR_CL6_CL6_3 = 0x3
	// Unified cache
	SCB_CLIDR_CL6_CL6_4 = 0x4
	// Position of CL7 field.
	SCB_CLIDR_CL7_Pos = 0x12
	// Bit mask of CL7 field.
	SCB_CLIDR_CL7_Msk = 0x1c0000
	// No cache
	SCB_CLIDR_CL7_CL7_0 = 0x0
	// Instruction cache only
	SCB_CLIDR_CL7_CL7_1 = 0x1
	// Data cache only
	SCB_CLIDR_CL7_CL7_2 = 0x2
	// Separate instruction and data caches
	SCB_CLIDR_CL7_CL7_3 = 0x3
	// Unified cache
	SCB_CLIDR_CL7_CL7_4 = 0x4
	// Position of LOUIS field.
	SCB_CLIDR_LOUIS_Pos = 0x15
	// Bit mask of LOUIS field.
	SCB_CLIDR_LOUIS_Msk = 0xe00000
	// 0
	SCB_CLIDR_LOUIS_LOUIS_0 = 0x0
	// 1
	SCB_CLIDR_LOUIS_LOUIS_1 = 0x1
	// 2
	SCB_CLIDR_LOUIS_LOUIS_2 = 0x2
	// 3
	SCB_CLIDR_LOUIS_LOUIS_3 = 0x3
	// 4
	SCB_CLIDR_LOUIS_LOUIS_4 = 0x4
	// 5
	SCB_CLIDR_LOUIS_LOUIS_5 = 0x5
	// 6
	SCB_CLIDR_LOUIS_LOUIS_6 = 0x6
	// 7
	SCB_CLIDR_LOUIS_LOUIS_7 = 0x7
	// Position of LOC field.
	SCB_CLIDR_LOC_Pos = 0x18
	// Bit mask of LOC field.
	SCB_CLIDR_LOC_Msk = 0x7000000
	// 0
	SCB_CLIDR_LOC_LOC_0 = 0x0
	// 1
	SCB_CLIDR_LOC_LOC_1 = 0x1
	// 2
	SCB_CLIDR_LOC_LOC_2 = 0x2
	// 3
	SCB_CLIDR_LOC_LOC_3 = 0x3
	// 4
	SCB_CLIDR_LOC_LOC_4 = 0x4
	// 5
	SCB_CLIDR_LOC_LOC_5 = 0x5
	// 6
	SCB_CLIDR_LOC_LOC_6 = 0x6
	// 7
	SCB_CLIDR_LOC_LOC_7 = 0x7
	// Position of LOU field.
	SCB_CLIDR_LOU_Pos = 0x1b
	// Bit mask of LOU field.
	SCB_CLIDR_LOU_Msk = 0x38000000
	// 0
	SCB_CLIDR_LOU_LOU_0 = 0x0
	// 1
	SCB_CLIDR_LOU_LOU_1 = 0x1
	// 2
	SCB_CLIDR_LOU_LOU_2 = 0x2
	// 3
	SCB_CLIDR_LOU_LOU_3 = 0x3
	// 4
	SCB_CLIDR_LOU_LOU_4 = 0x4
	// 5
	SCB_CLIDR_LOU_LOU_5 = 0x5
	// 6
	SCB_CLIDR_LOU_LOU_6 = 0x6
	// 7
	SCB_CLIDR_LOU_LOU_7 = 0x7

	// CTR: Cache Type register
	// Position of IMINLINE field.
	SCB_CTR_IMINLINE_Pos = 0x0
	// Bit mask of IMINLINE field.
	SCB_CTR_IMINLINE_Msk = 0xf
	// Position of DMINLINE field.
	SCB_CTR_DMINLINE_Pos = 0x10
	// Bit mask of DMINLINE field.
	SCB_CTR_DMINLINE_Msk = 0xf0000
	// Position of ERG field.
	SCB_CTR_ERG_Pos = 0x14
	// Bit mask of ERG field.
	SCB_CTR_ERG_Msk = 0xf00000
	// Position of CWG field.
	SCB_CTR_CWG_Pos = 0x18
	// Bit mask of CWG field.
	SCB_CTR_CWG_Msk = 0xf000000
	// Position of FORMAT field.
	SCB_CTR_FORMAT_Pos = 0x1d
	// Bit mask of FORMAT field.
	SCB_CTR_FORMAT_Msk = 0xe0000000
	// ARMv7 format.
	SCB_CTR_FORMAT_FORMAT_4 = 0x4

	// CCSIDR: Cache Size ID Register
	// Position of LINESIZE field.
	SCB_CCSIDR_LINESIZE_Pos = 0x0
	// Bit mask of LINESIZE field.
	SCB_CCSIDR_LINESIZE_Msk = 0x7
	// The line length of 4 words.
	SCB_CCSIDR_LINESIZE_LINESIZE_0 = 0x0
	// The line length of 8 words.
	SCB_CCSIDR_LINESIZE_LINESIZE_1 = 0x1
	// The line length of 16 words.
	SCB_CCSIDR_LINESIZE_LINESIZE_2 = 0x2
	// The line length of 32 words.
	SCB_CCSIDR_LINESIZE_LINESIZE_3 = 0x3
	// The line length of 64 words.
	SCB_CCSIDR_LINESIZE_LINESIZE_4 = 0x4
	// The line length of 128 words.
	SCB_CCSIDR_LINESIZE_LINESIZE_5 = 0x5
	// The line length of 256 words.
	SCB_CCSIDR_LINESIZE_LINESIZE_6 = 0x6
	// The line length of 512 words.
	SCB_CCSIDR_LINESIZE_LINESIZE_7 = 0x7
	// Position of ASSOCIATIVITY field.
	SCB_CCSIDR_ASSOCIATIVITY_Pos = 0x3
	// Bit mask of ASSOCIATIVITY field.
	SCB_CCSIDR_ASSOCIATIVITY_Msk = 0x1ff8
	// Position of NUMSETS field.
	SCB_CCSIDR_NUMSETS_Pos = 0xd
	// Bit mask of NUMSETS field.
	SCB_CCSIDR_NUMSETS_Msk = 0xfffe000
	// Position of WA field.
	SCB_CCSIDR_WA_Pos = 0x1c
	// Bit mask of WA field.
	SCB_CCSIDR_WA_Msk = 0x10000000
	// Bit WA.
	SCB_CCSIDR_WA = 0x10000000
	// Feature not supported
	SCB_CCSIDR_WA_WA_0 = 0x0
	// Feature supported
	SCB_CCSIDR_WA_WA_1 = 0x1
	// Position of RA field.
	SCB_CCSIDR_RA_Pos = 0x1d
	// Bit mask of RA field.
	SCB_CCSIDR_RA_Msk = 0x20000000
	// Bit RA.
	SCB_CCSIDR_RA = 0x20000000
	// Feature not supported
	SCB_CCSIDR_RA_RA_0 = 0x0
	// Feature supported
	SCB_CCSIDR_RA_RA_1 = 0x1
	// Position of WB field.
	SCB_CCSIDR_WB_Pos = 0x1e
	// Bit mask of WB field.
	SCB_CCSIDR_WB_Msk = 0x40000000
	// Bit WB.
	SCB_CCSIDR_WB = 0x40000000
	// Feature not supported
	SCB_CCSIDR_WB_WB_0 = 0x0
	// Feature supported
	SCB_CCSIDR_WB_WB_1 = 0x1
	// Position of WT field.
	SCB_CCSIDR_WT_Pos = 0x1f
	// Bit mask of WT field.
	SCB_CCSIDR_WT_Msk = 0x80000000
	// Bit WT.
	SCB_CCSIDR_WT = 0x80000000
	// Feature not supported
	SCB_CCSIDR_WT_WT_0 = 0x0
	// Feature supported
	SCB_CCSIDR_WT_WT_1 = 0x1

	// CSSELR: Cache Size Selection Register
	// Position of IND field.
	SCB_CSSELR_IND_Pos = 0x0
	// Bit mask of IND field.
	SCB_CSSELR_IND_Msk = 0x1
	// Bit IND.
	SCB_CSSELR_IND = 0x1
	// Data or unified cache.
	SCB_CSSELR_IND_IND_0 = 0x0
	// Instruction cache.
	SCB_CSSELR_IND_IND_1 = 0x1
	// Position of LEVEL field.
	SCB_CSSELR_LEVEL_Pos = 0x1
	// Bit mask of LEVEL field.
	SCB_CSSELR_LEVEL_Msk = 0xe
	// Level 1 cache.
	SCB_CSSELR_LEVEL_LEVEL_0 = 0x0
	// Level 2 cache.
	SCB_CSSELR_LEVEL_LEVEL_1 = 0x1
	// Level 3 cache.
	SCB_CSSELR_LEVEL_LEVEL_2 = 0x2
	// Level 4 cache.
	SCB_CSSELR_LEVEL_LEVEL_3 = 0x3
	// Level 5 cache.
	SCB_CSSELR_LEVEL_LEVEL_4 = 0x4
	// Level 6 cache.
	SCB_CSSELR_LEVEL_LEVEL_5 = 0x5
	// Level 7 cache.
	SCB_CSSELR_LEVEL_LEVEL_6 = 0x6

	// CPACR: Coprocessor Access Control Register
	// Position of CP0 field.
	SCB_CPACR_CP0_Pos = 0x0
	// Bit mask of CP0 field.
	SCB_CPACR_CP0_Msk = 0x3
	// Access denied. Any attempted access generates a NOCP UsageFault.
	SCB_CPACR_CP0_CP0_0 = 0x0
	// Privileged access only. An unprivileged access generates a NOCP UsageFault.
	SCB_CPACR_CP0_CP0_1 = 0x1
	// Full access.
	SCB_CPACR_CP0_CP0_3 = 0x3
	// Position of CP1 field.
	SCB_CPACR_CP1_Pos = 0x2
	// Bit mask of CP1 field.
	SCB_CPACR_CP1_Msk = 0xc
	// Access denied. Any attempted access generates a NOCP UsageFault.
	SCB_CPACR_CP1_CP1_0 = 0x0
	// Privileged access only. An unprivileged access generates a NOCP UsageFault.
	SCB_CPACR_CP1_CP1_1 = 0x1
	// Full access.
	SCB_CPACR_CP1_CP1_3 = 0x3
	// Position of CP2 field.
	SCB_CPACR_CP2_Pos = 0x4
	// Bit mask of CP2 field.
	SCB_CPACR_CP2_Msk = 0x30
	// Access denied. Any attempted access generates a NOCP UsageFault.
	SCB_CPACR_CP2_CP2_0 = 0x0
	// Privileged access only. An unprivileged access generates a NOCP UsageFault.
	SCB_CPACR_CP2_CP2_1 = 0x1
	// Full access.
	SCB_CPACR_CP2_CP2_3 = 0x3
	// Position of CP3 field.
	SCB_CPACR_CP3_Pos = 0x6
	// Bit mask of CP3 field.
	SCB_CPACR_CP3_Msk = 0xc0
	// Access denied. Any attempted access generates a NOCP UsageFault.
	SCB_CPACR_CP3_CP3_0 = 0x0
	// Privileged access only. An unprivileged access generates a NOCP UsageFault.
	SCB_CPACR_CP3_CP3_1 = 0x1
	// Full access.
	SCB_CPACR_CP3_CP3_3 = 0x3
	// Position of CP4 field.
	SCB_CPACR_CP4_Pos = 0x8
	// Bit mask of CP4 field.
	SCB_CPACR_CP4_Msk = 0x300
	// Access denied. Any attempted access generates a NOCP UsageFault.
	SCB_CPACR_CP4_CP4_0 = 0x0
	// Privileged access only. An unprivileged access generates a NOCP UsageFault.
	SCB_CPACR_CP4_CP4_1 = 0x1
	// Full access.
	SCB_CPACR_CP4_CP4_3 = 0x3
	// Position of CP5 field.
	SCB_CPACR_CP5_Pos = 0xa
	// Bit mask of CP5 field.
	SCB_CPACR_CP5_Msk = 0xc00
	// Access denied. Any attempted access generates a NOCP UsageFault.
	SCB_CPACR_CP5_CP5_0 = 0x0
	// Privileged access only. An unprivileged access generates a NOCP UsageFault.
	SCB_CPACR_CP5_CP5_1 = 0x1
	// Full access.
	SCB_CPACR_CP5_CP5_3 = 0x3
	// Position of CP6 field.
	SCB_CPACR_CP6_Pos = 0xc
	// Bit mask of CP6 field.
	SCB_CPACR_CP6_Msk = 0x3000
	// Access denied. Any attempted access generates a NOCP UsageFault.
	SCB_CPACR_CP6_CP6_0 = 0x0
	// Privileged access only. An unprivileged access generates a NOCP UsageFault.
	SCB_CPACR_CP6_CP6_1 = 0x1
	// Full access.
	SCB_CPACR_CP6_CP6_3 = 0x3
	// Position of CP7 field.
	SCB_CPACR_CP7_Pos = 0xe
	// Bit mask of CP7 field.
	SCB_CPACR_CP7_Msk = 0xc000
	// Access denied. Any attempted access generates a NOCP UsageFault.
	SCB_CPACR_CP7_CP7_0 = 0x0
	// Privileged access only. An unprivileged access generates a NOCP UsageFault.
	SCB_CPACR_CP7_CP7_1 = 0x1
	// Full access.
	SCB_CPACR_CP7_CP7_3 = 0x3
	// Position of CP10 field.
	SCB_CPACR_CP10_Pos = 0x14
	// Bit mask of CP10 field.
	SCB_CPACR_CP10_Msk = 0x300000
	// Access denied. Any attempted access generates a NOCP UsageFault.
	SCB_CPACR_CP10_CP10_0 = 0x0
	// Privileged access only. An unprivileged access generates a NOCP UsageFault.
	SCB_CPACR_CP10_CP10_1 = 0x1
	// Full access.
	SCB_CPACR_CP10_CP10_3 = 0x3
	// Position of CP11 field.
	SCB_CPACR_CP11_Pos = 0x16
	// Bit mask of CP11 field.
	SCB_CPACR_CP11_Msk = 0xc00000
	// Access denied. Any attempted access generates a NOCP UsageFault.
	SCB_CPACR_CP11_CP11_0 = 0x0
	// Privileged access only. An unprivileged access generates a NOCP UsageFault.
	SCB_CPACR_CP11_CP11_1 = 0x1
	// Full access.
	SCB_CPACR_CP11_CP11_3 = 0x3

	// STIR: Instruction cache invalidate all to Point of Unification (PoU)
	// Position of INTID field.
	SCB_STIR_INTID_Pos = 0x0
	// Bit mask of INTID field.
	SCB_STIR_INTID_Msk = 0x1ff

	// ICIALLU: Instruction cache invalidate all to Point of Unification (PoU)
	// Position of ICIALLU field.
	SCB_ICIALLU_ICIALLU_Pos = 0x0
	// Bit mask of ICIALLU field.
	SCB_ICIALLU_ICIALLU_Msk = 0xffffffff

	// ICIMVAU: Instruction cache invalidate by address to PoU
	// Position of ICIMVAU field.
	SCB_ICIMVAU_ICIMVAU_Pos = 0x0
	// Bit mask of ICIMVAU field.
	SCB_ICIMVAU_ICIMVAU_Msk = 0xffffffff

	// DCIMVAC: Data cache invalidate by address to Point of Coherency (PoC)
	// Position of DCIMVAC field.
	SCB_DCIMVAC_DCIMVAC_Pos = 0x0
	// Bit mask of DCIMVAC field.
	SCB_DCIMVAC_DCIMVAC_Msk = 0xffffffff

	// DCISW: Data cache invalidate by set/way
	// Position of DCISW field.
	SCB_DCISW_DCISW_Pos = 0x0
	// Bit mask of DCISW field.
	SCB_DCISW_DCISW_Msk = 0xffffffff

	// DCCMVAU: Data cache by address to PoU
	// Position of DCCMVAU field.
	SCB_DCCMVAU_DCCMVAU_Pos = 0x0
	// Bit mask of DCCMVAU field.
	SCB_DCCMVAU_DCCMVAU_Msk = 0xffffffff

	// DCCMVAC: Data cache clean by address to PoC
	// Position of DCCMVAC field.
	SCB_DCCMVAC_DCCMVAC_Pos = 0x0
	// Bit mask of DCCMVAC field.
	SCB_DCCMVAC_DCCMVAC_Msk = 0xffffffff

	// DCCSW: Data cache clean by set/way
	// Position of DCCSW field.
	SCB_DCCSW_DCCSW_Pos = 0x0
	// Bit mask of DCCSW field.
	SCB_DCCSW_DCCSW_Msk = 0xffffffff

	// DCCIMVAC: Data cache clean and invalidate by address to PoC
	// Position of DCCIMVAC field.
	SCB_DCCIMVAC_DCCIMVAC_Pos = 0x0
	// Bit mask of DCCIMVAC field.
	SCB_DCCIMVAC_DCCIMVAC_Msk = 0xffffffff

	// DCCISW: Data cache clean and invalidate by set/way
	// Position of DCCISW field.
	SCB_DCCISW_DCCISW_Pos = 0x0
	// Bit mask of DCCISW field.
	SCB_DCCISW_DCCISW_Msk = 0xffffffff

	// CM7_ITCMCR: Instruction Tightly-Coupled Memory Control Register
	// Position of EN field.
	SCB_CM7_ITCMCR_EN_Pos = 0x0
	// Bit mask of EN field.
	SCB_CM7_ITCMCR_EN_Msk = 0x1
	// Bit EN.
	SCB_CM7_ITCMCR_EN = 0x1
	// TCM disabled.
	SCB_CM7_ITCMCR_EN_EN_0 = 0x0
	// TCM enabled.
	SCB_CM7_ITCMCR_EN_EN_1 = 0x1
	// Position of RMW field.
	SCB_CM7_ITCMCR_RMW_Pos = 0x1
	// Bit mask of RMW field.
	SCB_CM7_ITCMCR_RMW_Msk = 0x2
	// Bit RMW.
	SCB_CM7_ITCMCR_RMW = 0x2
	// RMW disabled.
	SCB_CM7_ITCMCR_RMW_RMW_0 = 0x0
	// RMW enabled.
	SCB_CM7_ITCMCR_RMW_RMW_1 = 0x1
	// Position of RETEN field.
	SCB_CM7_ITCMCR_RETEN_Pos = 0x2
	// Bit mask of RETEN field.
	SCB_CM7_ITCMCR_RETEN_Msk = 0x4
	// Bit RETEN.
	SCB_CM7_ITCMCR_RETEN = 0x4
	// Retry phase disabled.
	SCB_CM7_ITCMCR_RETEN_RETEN_0 = 0x0
	// Retry phase enabled.
	SCB_CM7_ITCMCR_RETEN_RETEN_1 = 0x1
	// Position of SZ field.
	SCB_CM7_ITCMCR_SZ_Pos = 0x3
	// Bit mask of SZ field.
	SCB_CM7_ITCMCR_SZ_Msk = 0x78
	// No TCM implemented.
	SCB_CM7_ITCMCR_SZ_SZ_0 = 0x0
	// 4KB.
	SCB_CM7_ITCMCR_SZ_SZ_3 = 0x3
	// 8KB.
	SCB_CM7_ITCMCR_SZ_SZ_4 = 0x4
	// 16KB.
	SCB_CM7_ITCMCR_SZ_SZ_5 = 0x5
	// 32KB.
	SCB_CM7_ITCMCR_SZ_SZ_6 = 0x6
	// 64KB.
	SCB_CM7_ITCMCR_SZ_SZ_7 = 0x7
	// 128KB.
	SCB_CM7_ITCMCR_SZ_SZ_8 = 0x8
	// 256KB.
	SCB_CM7_ITCMCR_SZ_SZ_9 = 0x9
	// 512KB.
	SCB_CM7_ITCMCR_SZ_SZ_10 = 0xa
	// 1MB.
	SCB_CM7_ITCMCR_SZ_SZ_11 = 0xb
	// 2MB.
	SCB_CM7_ITCMCR_SZ_SZ_12 = 0xc
	// 4MB.
	SCB_CM7_ITCMCR_SZ_SZ_13 = 0xd
	// 8MB.
	SCB_CM7_ITCMCR_SZ_SZ_14 = 0xe
	// 16MB.
	SCB_CM7_ITCMCR_SZ_SZ_15 = 0xf

	// CM7_DTCMCR: Data Tightly-Coupled Memory Control Register
	// Position of EN field.
	SCB_CM7_DTCMCR_EN_Pos = 0x0
	// Bit mask of EN field.
	SCB_CM7_DTCMCR_EN_Msk = 0x1
	// Bit EN.
	SCB_CM7_DTCMCR_EN = 0x1
	// TCM disabled.
	SCB_CM7_DTCMCR_EN_EN_0 = 0x0
	// TCM enabled.
	SCB_CM7_DTCMCR_EN_EN_1 = 0x1
	// Position of RMW field.
	SCB_CM7_DTCMCR_RMW_Pos = 0x1
	// Bit mask of RMW field.
	SCB_CM7_DTCMCR_RMW_Msk = 0x2
	// Bit RMW.
	SCB_CM7_DTCMCR_RMW = 0x2
	// RMW disabled.
	SCB_CM7_DTCMCR_RMW_RMW_0 = 0x0
	// RMW enabled.
	SCB_CM7_DTCMCR_RMW_RMW_1 = 0x1
	// Position of RETEN field.
	SCB_CM7_DTCMCR_RETEN_Pos = 0x2
	// Bit mask of RETEN field.
	SCB_CM7_DTCMCR_RETEN_Msk = 0x4
	// Bit RETEN.
	SCB_CM7_DTCMCR_RETEN = 0x4
	// Retry phase disabled.
	SCB_CM7_DTCMCR_RETEN_RETEN_0 = 0x0
	// Retry phase enabled.
	SCB_CM7_DTCMCR_RETEN_RETEN_1 = 0x1
	// Position of SZ field.
	SCB_CM7_DTCMCR_SZ_Pos = 0x3
	// Bit mask of SZ field.
	SCB_CM7_DTCMCR_SZ_Msk = 0x78
	// No TCM implemented.
	SCB_CM7_DTCMCR_SZ_SZ_0 = 0x0
	// 4KB.
	SCB_CM7_DTCMCR_SZ_SZ_3 = 0x3
	// 8KB.
	SCB_CM7_DTCMCR_SZ_SZ_4 = 0x4
	// 16KB.
	SCB_CM7_DTCMCR_SZ_SZ_5 = 0x5
	// 32KB.
	SCB_CM7_DTCMCR_SZ_SZ_6 = 0x6
	// 64KB.
	SCB_CM7_DTCMCR_SZ_SZ_7 = 0x7
	// 128KB.
	SCB_CM7_DTCMCR_SZ_SZ_8 = 0x8
	// 256KB.
	SCB_CM7_DTCMCR_SZ_SZ_9 = 0x9
	// 512KB.
	SCB_CM7_DTCMCR_SZ_SZ_10 = 0xa
	// 1MB.
	SCB_CM7_DTCMCR_SZ_SZ_11 = 0xb
	// 2MB.
	SCB_CM7_DTCMCR_SZ_SZ_12 = 0xc
	// 4MB.
	SCB_CM7_DTCMCR_SZ_SZ_13 = 0xd
	// 8MB.
	SCB_CM7_DTCMCR_SZ_SZ_14 = 0xe
	// 16MB.
	SCB_CM7_DTCMCR_SZ_SZ_15 = 0xf

	// CM7_AHBPCR: AHBP Control Register
	// Position of EN field.
	SCB_CM7_AHBPCR_EN_Pos = 0x0
	// Bit mask of EN field.
	SCB_CM7_AHBPCR_EN_Msk = 0x1
	// Bit EN.
	SCB_CM7_AHBPCR_EN = 0x1
	// AHBP disabled. When disabled all accesses are made to the AXIM interface.
	SCB_CM7_AHBPCR_EN_EN_0 = 0x0
	// AHBP enabled.
	SCB_CM7_AHBPCR_EN_EN_1 = 0x1
	// Position of SZ field.
	SCB_CM7_AHBPCR_SZ_Pos = 0x1
	// Bit mask of SZ field.
	SCB_CM7_AHBPCR_SZ_Msk = 0xe
	// 0MB. AHBP disabled.
	SCB_CM7_AHBPCR_SZ_SZ_0 = 0x0
	// 64MB.
	SCB_CM7_AHBPCR_SZ_SZ_1 = 0x1
	// 128MB.
	SCB_CM7_AHBPCR_SZ_SZ_2 = 0x2
	// 256MB.
	SCB_CM7_AHBPCR_SZ_SZ_3 = 0x3
	// 512MB.
	SCB_CM7_AHBPCR_SZ_SZ_4 = 0x4

	// CM7_CACR: L1 Cache Control Register
	// Position of SIWT field.
	SCB_CM7_CACR_SIWT_Pos = 0x0
	// Bit mask of SIWT field.
	SCB_CM7_CACR_SIWT_Msk = 0x1
	// Bit SIWT.
	SCB_CM7_CACR_SIWT = 0x1
	// Normal Cacheable Shared locations are treated as being Non-cacheable. Default mode of operation for Shared memory.
	SCB_CM7_CACR_SIWT_SIWT_0 = 0x0
	// Normal Cacheable shared locations are treated as Write-Through.
	SCB_CM7_CACR_SIWT_SIWT_1 = 0x1
	// Position of ECCDIS field.
	SCB_CM7_CACR_ECCDIS_Pos = 0x1
	// Bit mask of ECCDIS field.
	SCB_CM7_CACR_ECCDIS_Msk = 0x2
	// Bit ECCDIS.
	SCB_CM7_CACR_ECCDIS = 0x2
	// Enables ECC in the instruction and data cache.
	SCB_CM7_CACR_ECCDIS_ECCDIS_0 = 0x0
	// Disables ECC in the instruction and data cache.
	SCB_CM7_CACR_ECCDIS_ECCDIS_1 = 0x1
	// Position of FORCEWT field.
	SCB_CM7_CACR_FORCEWT_Pos = 0x2
	// Bit mask of FORCEWT field.
	SCB_CM7_CACR_FORCEWT_Msk = 0x4
	// Bit FORCEWT.
	SCB_CM7_CACR_FORCEWT = 0x4
	// Disables Force Write-Through.
	SCB_CM7_CACR_FORCEWT_FORCEWT_0 = 0x0
	// Enables Force Write-Through. All Cacheable memory regions are treated as Write-Through.
	SCB_CM7_CACR_FORCEWT_FORCEWT_1 = 0x1

	// CM7_AHBSCR: AHB Slave Control Register
	// Position of CTL field.
	SCB_CM7_AHBSCR_CTL_Pos = 0x0
	// Bit mask of CTL field.
	SCB_CM7_AHBSCR_CTL_Msk = 0x3
	// AHBS access priority demoted. This is the reset value.
	SCB_CM7_AHBSCR_CTL_CTL_0 = 0x0
	// Software access priority demoted.
	SCB_CM7_AHBSCR_CTL_CTL_1 = 0x1
	// AHBS access priority demoted by initializing the fairness counter to the CM7_AHBSCR[INITCOUNT] value when the software execution priority is higher than or equal to the threshold level programed in CM7_AHBSCR[TPRI].
	SCB_CM7_AHBSCR_CTL_CTL_2 = 0x2
	// AHBSPRI signal has control of access priority.
	SCB_CM7_AHBSCR_CTL_CTL_3 = 0x3
	// Position of TPRI field.
	SCB_CM7_AHBSCR_TPRI_Pos = 0x2
	// Bit mask of TPRI field.
	SCB_CM7_AHBSCR_TPRI_Msk = 0x7fc
	// Position of INITCOUNT field.
	SCB_CM7_AHBSCR_INITCOUNT_Pos = 0xb
	// Bit mask of INITCOUNT field.
	SCB_CM7_AHBSCR_INITCOUNT_Msk = 0xf800

	// CM7_ABFSR: Auxiliary Bus Fault Status Register
	// Position of ITCM field.
	SCB_CM7_ABFSR_ITCM_Pos = 0x0
	// Bit mask of ITCM field.
	SCB_CM7_ABFSR_ITCM_Msk = 0x1
	// Bit ITCM.
	SCB_CM7_ABFSR_ITCM = 0x1
	// Position of DTCM field.
	SCB_CM7_ABFSR_DTCM_Pos = 0x1
	// Bit mask of DTCM field.
	SCB_CM7_ABFSR_DTCM_Msk = 0x2
	// Bit DTCM.
	SCB_CM7_ABFSR_DTCM = 0x2
	// Position of AHBP field.
	SCB_CM7_ABFSR_AHBP_Pos = 0x2
	// Bit mask of AHBP field.
	SCB_CM7_ABFSR_AHBP_Msk = 0x4
	// Bit AHBP.
	SCB_CM7_ABFSR_AHBP = 0x4
	// Position of AXIM field.
	SCB_CM7_ABFSR_AXIM_Pos = 0x3
	// Bit mask of AXIM field.
	SCB_CM7_ABFSR_AXIM_Msk = 0x8
	// Bit AXIM.
	SCB_CM7_ABFSR_AXIM = 0x8
	// Position of EPPB field.
	SCB_CM7_ABFSR_EPPB_Pos = 0x4
	// Bit mask of EPPB field.
	SCB_CM7_ABFSR_EPPB_Msk = 0x10
	// Bit EPPB.
	SCB_CM7_ABFSR_EPPB = 0x10
	// Position of AXIMTYPE field.
	SCB_CM7_ABFSR_AXIMTYPE_Pos = 0x8
	// Bit mask of AXIMTYPE field.
	SCB_CM7_ABFSR_AXIMTYPE_Msk = 0x300
	// OKAY.
	SCB_CM7_ABFSR_AXIMTYPE_AXIMTYPE_0 = 0x0
	// EXOKAY.
	SCB_CM7_ABFSR_AXIMTYPE_AXIMTYPE_1 = 0x1
	// SLVERR.
	SCB_CM7_ABFSR_AXIMTYPE_AXIMTYPE_2 = 0x2
	// DECERR.
	SCB_CM7_ABFSR_AXIMTYPE_AXIMTYPE_3 = 0x3
)

// Bitfields for NVIC: Nested Vectored Interrupt Controller
const (
	// NVICISER0: Interrupt Set Enable Register n
	// Position of SETENA field.
	NVIC_NVICISER0_SETENA_Pos = 0x0
	// Bit mask of SETENA field.
	NVIC_NVICISER0_SETENA_Msk = 0xffffffff

	// NVICISER1: Interrupt Set Enable Register n
	// Position of SETENA field.
	NVIC_NVICISER1_SETENA_Pos = 0x0
	// Bit mask of SETENA field.
	NVIC_NVICISER1_SETENA_Msk = 0xffffffff

	// NVICISER2: Interrupt Set Enable Register n
	// Position of SETENA field.
	NVIC_NVICISER2_SETENA_Pos = 0x0
	// Bit mask of SETENA field.
	NVIC_NVICISER2_SETENA_Msk = 0xffffffff

	// NVICISER3: Interrupt Set Enable Register n
	// Position of SETENA field.
	NVIC_NVICISER3_SETENA_Pos = 0x0
	// Bit mask of SETENA field.
	NVIC_NVICISER3_SETENA_Msk = 0xffffffff

	// NVICISER4: Interrupt Set Enable Register n
	// Position of SETENA field.
	NVIC_NVICISER4_SETENA_Pos = 0x0
	// Bit mask of SETENA field.
	NVIC_NVICISER4_SETENA_Msk = 0xffffffff

	// NVICICER0: Interrupt Clear Enable Register n
	// Position of CLRENA field.
	NVIC_NVICICER0_CLRENA_Pos = 0x0
	// Bit mask of CLRENA field.
	NVIC_NVICICER0_CLRENA_Msk = 0xffffffff

	// NVICICER1: Interrupt Clear Enable Register n
	// Position of CLRENA field.
	NVIC_NVICICER1_CLRENA_Pos = 0x0
	// Bit mask of CLRENA field.
	NVIC_NVICICER1_CLRENA_Msk = 0xffffffff

	// NVICICER2: Interrupt Clear Enable Register n
	// Position of CLRENA field.
	NVIC_NVICICER2_CLRENA_Pos = 0x0
	// Bit mask of CLRENA field.
	NVIC_NVICICER2_CLRENA_Msk = 0xffffffff

	// NVICICER3: Interrupt Clear Enable Register n
	// Position of CLRENA field.
	NVIC_NVICICER3_CLRENA_Pos = 0x0
	// Bit mask of CLRENA field.
	NVIC_NVICICER3_CLRENA_Msk = 0xffffffff

	// NVICICER4: Interrupt Clear Enable Register n
	// Position of CLRENA field.
	NVIC_NVICICER4_CLRENA_Pos = 0x0
	// Bit mask of CLRENA field.
	NVIC_NVICICER4_CLRENA_Msk = 0xffffffff

	// NVICISPR0: Interrupt Set Pending Register n
	// Position of SETPEND field.
	NVIC_NVICISPR0_SETPEND_Pos = 0x0
	// Bit mask of SETPEND field.
	NVIC_NVICISPR0_SETPEND_Msk = 0xffffffff

	// NVICISPR1: Interrupt Set Pending Register n
	// Position of SETPEND field.
	NVIC_NVICISPR1_SETPEND_Pos = 0x0
	// Bit mask of SETPEND field.
	NVIC_NVICISPR1_SETPEND_Msk = 0xffffffff

	// NVICISPR2: Interrupt Set Pending Register n
	// Position of SETPEND field.
	NVIC_NVICISPR2_SETPEND_Pos = 0x0
	// Bit mask of SETPEND field.
	NVIC_NVICISPR2_SETPEND_Msk = 0xffffffff

	// NVICISPR3: Interrupt Set Pending Register n
	// Position of SETPEND field.
	NVIC_NVICISPR3_SETPEND_Pos = 0x0
	// Bit mask of SETPEND field.
	NVIC_NVICISPR3_SETPEND_Msk = 0xffffffff

	// NVICISPR4: Interrupt Set Pending Register n
	// Position of SETPEND field.
	NVIC_NVICISPR4_SETPEND_Pos = 0x0
	// Bit mask of SETPEND field.
	NVIC_NVICISPR4_SETPEND_Msk = 0xffffffff

	// NVICICPR0: Interrupt Clear Pending Register n
	// Position of CLRPEND field.
	NVIC_NVICICPR0_CLRPEND_Pos = 0x0
	// Bit mask of CLRPEND field.
	NVIC_NVICICPR0_CLRPEND_Msk = 0xffffffff

	// NVICICPR1: Interrupt Clear Pending Register n
	// Position of CLRPEND field.
	NVIC_NVICICPR1_CLRPEND_Pos = 0x0
	// Bit mask of CLRPEND field.
	NVIC_NVICICPR1_CLRPEND_Msk = 0xffffffff

	// NVICICPR2: Interrupt Clear Pending Register n
	// Position of CLRPEND field.
	NVIC_NVICICPR2_CLRPEND_Pos = 0x0
	// Bit mask of CLRPEND field.
	NVIC_NVICICPR2_CLRPEND_Msk = 0xffffffff

	// NVICICPR3: Interrupt Clear Pending Register n
	// Position of CLRPEND field.
	NVIC_NVICICPR3_CLRPEND_Pos = 0x0
	// Bit mask of CLRPEND field.
	NVIC_NVICICPR3_CLRPEND_Msk = 0xffffffff

	// NVICICPR4: Interrupt Clear Pending Register n
	// Position of CLRPEND field.
	NVIC_NVICICPR4_CLRPEND_Pos = 0x0
	// Bit mask of CLRPEND field.
	NVIC_NVICICPR4_CLRPEND_Msk = 0xffffffff

	// NVICIABR0: Interrupt Active bit Register n
	// Position of ACTIVE field.
	NVIC_NVICIABR0_ACTIVE_Pos = 0x0
	// Bit mask of ACTIVE field.
	NVIC_NVICIABR0_ACTIVE_Msk = 0xffffffff

	// NVICIABR1: Interrupt Active bit Register n
	// Position of ACTIVE field.
	NVIC_NVICIABR1_ACTIVE_Pos = 0x0
	// Bit mask of ACTIVE field.
	NVIC_NVICIABR1_ACTIVE_Msk = 0xffffffff

	// NVICIABR2: Interrupt Active bit Register n
	// Position of ACTIVE field.
	NVIC_NVICIABR2_ACTIVE_Pos = 0x0
	// Bit mask of ACTIVE field.
	NVIC_NVICIABR2_ACTIVE_Msk = 0xffffffff

	// NVICIABR3: Interrupt Active bit Register n
	// Position of ACTIVE field.
	NVIC_NVICIABR3_ACTIVE_Pos = 0x0
	// Bit mask of ACTIVE field.
	NVIC_NVICIABR3_ACTIVE_Msk = 0xffffffff

	// NVICIABR4: Interrupt Active bit Register n
	// Position of ACTIVE field.
	NVIC_NVICIABR4_ACTIVE_Pos = 0x0
	// Bit mask of ACTIVE field.
	NVIC_NVICIABR4_ACTIVE_Msk = 0xffffffff

	// NVICIP0: Interrupt Priority Register 0
	// Position of PRI0 field.
	NVIC_NVICIP0_PRI0_Pos = 0x4
	// Bit mask of PRI0 field.
	NVIC_NVICIP0_PRI0_Msk = 0xf0

	// NVICIP1: Interrupt Priority Register 1
	// Position of PRI1 field.
	NVIC_NVICIP1_PRI1_Pos = 0x4
	// Bit mask of PRI1 field.
	NVIC_NVICIP1_PRI1_Msk = 0xf0

	// NVICIP2: Interrupt Priority Register 2
	// Position of PRI2 field.
	NVIC_NVICIP2_PRI2_Pos = 0x4
	// Bit mask of PRI2 field.
	NVIC_NVICIP2_PRI2_Msk = 0xf0

	// NVICIP3: Interrupt Priority Register 3
	// Position of PRI3 field.
	NVIC_NVICIP3_PRI3_Pos = 0x4
	// Bit mask of PRI3 field.
	NVIC_NVICIP3_PRI3_Msk = 0xf0

	// NVICIP4: Interrupt Priority Register 4
	// Position of PRI4 field.
	NVIC_NVICIP4_PRI4_Pos = 0x4
	// Bit mask of PRI4 field.
	NVIC_NVICIP4_PRI4_Msk = 0xf0

	// NVICIP5: Interrupt Priority Register 5
	// Position of PRI5 field.
	NVIC_NVICIP5_PRI5_Pos = 0x4
	// Bit mask of PRI5 field.
	NVIC_NVICIP5_PRI5_Msk = 0xf0

	// NVICIP6: Interrupt Priority Register 6
	// Position of PRI6 field.
	NVIC_NVICIP6_PRI6_Pos = 0x4
	// Bit mask of PRI6 field.
	NVIC_NVICIP6_PRI6_Msk = 0xf0

	// NVICIP7: Interrupt Priority Register 7
	// Position of PRI7 field.
	NVIC_NVICIP7_PRI7_Pos = 0x4
	// Bit mask of PRI7 field.
	NVIC_NVICIP7_PRI7_Msk = 0xf0

	// NVICIP8: Interrupt Priority Register 8
	// Position of PRI8 field.
	NVIC_NVICIP8_PRI8_Pos = 0x4
	// Bit mask of PRI8 field.
	NVIC_NVICIP8_PRI8_Msk = 0xf0

	// NVICIP9: Interrupt Priority Register 9
	// Position of PRI9 field.
	NVIC_NVICIP9_PRI9_Pos = 0x4
	// Bit mask of PRI9 field.
	NVIC_NVICIP9_PRI9_Msk = 0xf0

	// NVICIP10: Interrupt Priority Register 10
	// Position of PRI10 field.
	NVIC_NVICIP10_PRI10_Pos = 0x4
	// Bit mask of PRI10 field.
	NVIC_NVICIP10_PRI10_Msk = 0xf0

	// NVICIP11: Interrupt Priority Register 11
	// Position of PRI11 field.
	NVIC_NVICIP11_PRI11_Pos = 0x4
	// Bit mask of PRI11 field.
	NVIC_NVICIP11_PRI11_Msk = 0xf0

	// NVICIP12: Interrupt Priority Register 12
	// Position of PRI12 field.
	NVIC_NVICIP12_PRI12_Pos = 0x4
	// Bit mask of PRI12 field.
	NVIC_NVICIP12_PRI12_Msk = 0xf0

	// NVICIP13: Interrupt Priority Register 13
	// Position of PRI13 field.
	NVIC_NVICIP13_PRI13_Pos = 0x4
	// Bit mask of PRI13 field.
	NVIC_NVICIP13_PRI13_Msk = 0xf0

	// NVICIP14: Interrupt Priority Register 14
	// Position of PRI14 field.
	NVIC_NVICIP14_PRI14_Pos = 0x4
	// Bit mask of PRI14 field.
	NVIC_NVICIP14_PRI14_Msk = 0xf0

	// NVICIP15: Interrupt Priority Register 15
	// Position of PRI15 field.
	NVIC_NVICIP15_PRI15_Pos = 0x4
	// Bit mask of PRI15 field.
	NVIC_NVICIP15_PRI15_Msk = 0xf0

	// NVICIP16: Interrupt Priority Register 16
	// Position of PRI16 field.
	NVIC_NVICIP16_PRI16_Pos = 0x4
	// Bit mask of PRI16 field.
	NVIC_NVICIP16_PRI16_Msk = 0xf0

	// NVICIP17: Interrupt Priority Register 17
	// Position of PRI17 field.
	NVIC_NVICIP17_PRI17_Pos = 0x4
	// Bit mask of PRI17 field.
	NVIC_NVICIP17_PRI17_Msk = 0xf0

	// NVICIP18: Interrupt Priority Register 18
	// Position of PRI18 field.
	NVIC_NVICIP18_PRI18_Pos = 0x4
	// Bit mask of PRI18 field.
	NVIC_NVICIP18_PRI18_Msk = 0xf0

	// NVICIP19: Interrupt Priority Register 19
	// Position of PRI19 field.
	NVIC_NVICIP19_PRI19_Pos = 0x4
	// Bit mask of PRI19 field.
	NVIC_NVICIP19_PRI19_Msk = 0xf0

	// NVICIP20: Interrupt Priority Register 20
	// Position of PRI20 field.
	NVIC_NVICIP20_PRI20_Pos = 0x4
	// Bit mask of PRI20 field.
	NVIC_NVICIP20_PRI20_Msk = 0xf0

	// NVICIP21: Interrupt Priority Register 21
	// Position of PRI21 field.
	NVIC_NVICIP21_PRI21_Pos = 0x4
	// Bit mask of PRI21 field.
	NVIC_NVICIP21_PRI21_Msk = 0xf0

	// NVICIP22: Interrupt Priority Register 22
	// Position of PRI22 field.
	NVIC_NVICIP22_PRI22_Pos = 0x4
	// Bit mask of PRI22 field.
	NVIC_NVICIP22_PRI22_Msk = 0xf0

	// NVICIP23: Interrupt Priority Register 23
	// Position of PRI23 field.
	NVIC_NVICIP23_PRI23_Pos = 0x4
	// Bit mask of PRI23 field.
	NVIC_NVICIP23_PRI23_Msk = 0xf0

	// NVICIP24: Interrupt Priority Register 24
	// Position of PRI24 field.
	NVIC_NVICIP24_PRI24_Pos = 0x4
	// Bit mask of PRI24 field.
	NVIC_NVICIP24_PRI24_Msk = 0xf0

	// NVICIP25: Interrupt Priority Register 25
	// Position of PRI25 field.
	NVIC_NVICIP25_PRI25_Pos = 0x4
	// Bit mask of PRI25 field.
	NVIC_NVICIP25_PRI25_Msk = 0xf0

	// NVICIP26: Interrupt Priority Register 26
	// Position of PRI26 field.
	NVIC_NVICIP26_PRI26_Pos = 0x4
	// Bit mask of PRI26 field.
	NVIC_NVICIP26_PRI26_Msk = 0xf0

	// NVICIP27: Interrupt Priority Register 27
	// Position of PRI27 field.
	NVIC_NVICIP27_PRI27_Pos = 0x4
	// Bit mask of PRI27 field.
	NVIC_NVICIP27_PRI27_Msk = 0xf0

	// NVICIP28: Interrupt Priority Register 28
	// Position of PRI28 field.
	NVIC_NVICIP28_PRI28_Pos = 0x4
	// Bit mask of PRI28 field.
	NVIC_NVICIP28_PRI28_Msk = 0xf0

	// NVICIP29: Interrupt Priority Register 29
	// Position of PRI29 field.
	NVIC_NVICIP29_PRI29_Pos = 0x4
	// Bit mask of PRI29 field.
	NVIC_NVICIP29_PRI29_Msk = 0xf0

	// NVICIP30: Interrupt Priority Register 30
	// Position of PRI30 field.
	NVIC_NVICIP30_PRI30_Pos = 0x4
	// Bit mask of PRI30 field.
	NVIC_NVICIP30_PRI30_Msk = 0xf0

	// NVICIP31: Interrupt Priority Register 31
	// Position of PRI31 field.
	NVIC_NVICIP31_PRI31_Pos = 0x4
	// Bit mask of PRI31 field.
	NVIC_NVICIP31_PRI31_Msk = 0xf0

	// NVICIP32: Interrupt Priority Register 32
	// Position of PRI32 field.
	NVIC_NVICIP32_PRI32_Pos = 0x4
	// Bit mask of PRI32 field.
	NVIC_NVICIP32_PRI32_Msk = 0xf0

	// NVICIP33: Interrupt Priority Register 33
	// Position of PRI33 field.
	NVIC_NVICIP33_PRI33_Pos = 0x4
	// Bit mask of PRI33 field.
	NVIC_NVICIP33_PRI33_Msk = 0xf0

	// NVICIP34: Interrupt Priority Register 34
	// Position of PRI34 field.
	NVIC_NVICIP34_PRI34_Pos = 0x4
	// Bit mask of PRI34 field.
	NVIC_NVICIP34_PRI34_Msk = 0xf0

	// NVICIP35: Interrupt Priority Register 35
	// Position of PRI35 field.
	NVIC_NVICIP35_PRI35_Pos = 0x4
	// Bit mask of PRI35 field.
	NVIC_NVICIP35_PRI35_Msk = 0xf0

	// NVICIP36: Interrupt Priority Register 36
	// Position of PRI36 field.
	NVIC_NVICIP36_PRI36_Pos = 0x4
	// Bit mask of PRI36 field.
	NVIC_NVICIP36_PRI36_Msk = 0xf0

	// NVICIP37: Interrupt Priority Register 37
	// Position of PRI37 field.
	NVIC_NVICIP37_PRI37_Pos = 0x4
	// Bit mask of PRI37 field.
	NVIC_NVICIP37_PRI37_Msk = 0xf0

	// NVICIP38: Interrupt Priority Register 38
	// Position of PRI38 field.
	NVIC_NVICIP38_PRI38_Pos = 0x4
	// Bit mask of PRI38 field.
	NVIC_NVICIP38_PRI38_Msk = 0xf0

	// NVICIP39: Interrupt Priority Register 39
	// Position of PRI39 field.
	NVIC_NVICIP39_PRI39_Pos = 0x4
	// Bit mask of PRI39 field.
	NVIC_NVICIP39_PRI39_Msk = 0xf0

	// NVICIP40: Interrupt Priority Register 40
	// Position of PRI40 field.
	NVIC_NVICIP40_PRI40_Pos = 0x4
	// Bit mask of PRI40 field.
	NVIC_NVICIP40_PRI40_Msk = 0xf0

	// NVICIP41: Interrupt Priority Register 41
	// Position of PRI41 field.
	NVIC_NVICIP41_PRI41_Pos = 0x4
	// Bit mask of PRI41 field.
	NVIC_NVICIP41_PRI41_Msk = 0xf0

	// NVICIP42: Interrupt Priority Register 42
	// Position of PRI42 field.
	NVIC_NVICIP42_PRI42_Pos = 0x4
	// Bit mask of PRI42 field.
	NVIC_NVICIP42_PRI42_Msk = 0xf0

	// NVICIP43: Interrupt Priority Register 43
	// Position of PRI43 field.
	NVIC_NVICIP43_PRI43_Pos = 0x4
	// Bit mask of PRI43 field.
	NVIC_NVICIP43_PRI43_Msk = 0xf0

	// NVICIP44: Interrupt Priority Register 44
	// Position of PRI44 field.
	NVIC_NVICIP44_PRI44_Pos = 0x4
	// Bit mask of PRI44 field.
	NVIC_NVICIP44_PRI44_Msk = 0xf0

	// NVICIP45: Interrupt Priority Register 45
	// Position of PRI45 field.
	NVIC_NVICIP45_PRI45_Pos = 0x4
	// Bit mask of PRI45 field.
	NVIC_NVICIP45_PRI45_Msk = 0xf0

	// NVICIP46: Interrupt Priority Register 46
	// Position of PRI46 field.
	NVIC_NVICIP46_PRI46_Pos = 0x4
	// Bit mask of PRI46 field.
	NVIC_NVICIP46_PRI46_Msk = 0xf0

	// NVICIP47: Interrupt Priority Register 47
	// Position of PRI47 field.
	NVIC_NVICIP47_PRI47_Pos = 0x4
	// Bit mask of PRI47 field.
	NVIC_NVICIP47_PRI47_Msk = 0xf0

	// NVICIP48: Interrupt Priority Register 48
	// Position of PRI48 field.
	NVIC_NVICIP48_PRI48_Pos = 0x4
	// Bit mask of PRI48 field.
	NVIC_NVICIP48_PRI48_Msk = 0xf0

	// NVICIP49: Interrupt Priority Register 49
	// Position of PRI49 field.
	NVIC_NVICIP49_PRI49_Pos = 0x4
	// Bit mask of PRI49 field.
	NVIC_NVICIP49_PRI49_Msk = 0xf0

	// NVICIP50: Interrupt Priority Register 50
	// Position of PRI50 field.
	NVIC_NVICIP50_PRI50_Pos = 0x4
	// Bit mask of PRI50 field.
	NVIC_NVICIP50_PRI50_Msk = 0xf0

	// NVICIP51: Interrupt Priority Register 51
	// Position of PRI51 field.
	NVIC_NVICIP51_PRI51_Pos = 0x4
	// Bit mask of PRI51 field.
	NVIC_NVICIP51_PRI51_Msk = 0xf0

	// NVICIP52: Interrupt Priority Register 52
	// Position of PRI52 field.
	NVIC_NVICIP52_PRI52_Pos = 0x4
	// Bit mask of PRI52 field.
	NVIC_NVICIP52_PRI52_Msk = 0xf0

	// NVICIP53: Interrupt Priority Register 53
	// Position of PRI53 field.
	NVIC_NVICIP53_PRI53_Pos = 0x4
	// Bit mask of PRI53 field.
	NVIC_NVICIP53_PRI53_Msk = 0xf0

	// NVICIP54: Interrupt Priority Register 54
	// Position of PRI54 field.
	NVIC_NVICIP54_PRI54_Pos = 0x4
	// Bit mask of PRI54 field.
	NVIC_NVICIP54_PRI54_Msk = 0xf0

	// NVICIP55: Interrupt Priority Register 55
	// Position of PRI55 field.
	NVIC_NVICIP55_PRI55_Pos = 0x4
	// Bit mask of PRI55 field.
	NVIC_NVICIP55_PRI55_Msk = 0xf0

	// NVICIP56: Interrupt Priority Register 56
	// Position of PRI56 field.
	NVIC_NVICIP56_PRI56_Pos = 0x4
	// Bit mask of PRI56 field.
	NVIC_NVICIP56_PRI56_Msk = 0xf0

	// NVICIP57: Interrupt Priority Register 57
	// Position of PRI57 field.
	NVIC_NVICIP57_PRI57_Pos = 0x4
	// Bit mask of PRI57 field.
	NVIC_NVICIP57_PRI57_Msk = 0xf0

	// NVICIP58: Interrupt Priority Register 58
	// Position of PRI58 field.
	NVIC_NVICIP58_PRI58_Pos = 0x4
	// Bit mask of PRI58 field.
	NVIC_NVICIP58_PRI58_Msk = 0xf0

	// NVICIP59: Interrupt Priority Register 59
	// Position of PRI59 field.
	NVIC_NVICIP59_PRI59_Pos = 0x4
	// Bit mask of PRI59 field.
	NVIC_NVICIP59_PRI59_Msk = 0xf0

	// NVICIP60: Interrupt Priority Register 60
	// Position of PRI60 field.
	NVIC_NVICIP60_PRI60_Pos = 0x4
	// Bit mask of PRI60 field.
	NVIC_NVICIP60_PRI60_Msk = 0xf0

	// NVICIP61: Interrupt Priority Register 61
	// Position of PRI61 field.
	NVIC_NVICIP61_PRI61_Pos = 0x4
	// Bit mask of PRI61 field.
	NVIC_NVICIP61_PRI61_Msk = 0xf0

	// NVICIP62: Interrupt Priority Register 62
	// Position of PRI62 field.
	NVIC_NVICIP62_PRI62_Pos = 0x4
	// Bit mask of PRI62 field.
	NVIC_NVICIP62_PRI62_Msk = 0xf0

	// NVICIP63: Interrupt Priority Register 63
	// Position of PRI63 field.
	NVIC_NVICIP63_PRI63_Pos = 0x4
	// Bit mask of PRI63 field.
	NVIC_NVICIP63_PRI63_Msk = 0xf0

	// NVICIP64: Interrupt Priority Register 64
	// Position of PRI64 field.
	NVIC_NVICIP64_PRI64_Pos = 0x4
	// Bit mask of PRI64 field.
	NVIC_NVICIP64_PRI64_Msk = 0xf0

	// NVICIP65: Interrupt Priority Register 65
	// Position of PRI65 field.
	NVIC_NVICIP65_PRI65_Pos = 0x4
	// Bit mask of PRI65 field.
	NVIC_NVICIP65_PRI65_Msk = 0xf0

	// NVICIP66: Interrupt Priority Register 66
	// Position of PRI66 field.
	NVIC_NVICIP66_PRI66_Pos = 0x4
	// Bit mask of PRI66 field.
	NVIC_NVICIP66_PRI66_Msk = 0xf0

	// NVICIP67: Interrupt Priority Register 67
	// Position of PRI67 field.
	NVIC_NVICIP67_PRI67_Pos = 0x4
	// Bit mask of PRI67 field.
	NVIC_NVICIP67_PRI67_Msk = 0xf0

	// NVICIP68: Interrupt Priority Register 68
	// Position of PRI68 field.
	NVIC_NVICIP68_PRI68_Pos = 0x4
	// Bit mask of PRI68 field.
	NVIC_NVICIP68_PRI68_Msk = 0xf0

	// NVICIP69: Interrupt Priority Register 69
	// Position of PRI69 field.
	NVIC_NVICIP69_PRI69_Pos = 0x4
	// Bit mask of PRI69 field.
	NVIC_NVICIP69_PRI69_Msk = 0xf0

	// NVICIP70: Interrupt Priority Register 70
	// Position of PRI70 field.
	NVIC_NVICIP70_PRI70_Pos = 0x4
	// Bit mask of PRI70 field.
	NVIC_NVICIP70_PRI70_Msk = 0xf0

	// NVICIP71: Interrupt Priority Register 71
	// Position of PRI71 field.
	NVIC_NVICIP71_PRI71_Pos = 0x4
	// Bit mask of PRI71 field.
	NVIC_NVICIP71_PRI71_Msk = 0xf0

	// NVICIP72: Interrupt Priority Register 72
	// Position of PRI72 field.
	NVIC_NVICIP72_PRI72_Pos = 0x4
	// Bit mask of PRI72 field.
	NVIC_NVICIP72_PRI72_Msk = 0xf0

	// NVICIP73: Interrupt Priority Register 73
	// Position of PRI73 field.
	NVIC_NVICIP73_PRI73_Pos = 0x4
	// Bit mask of PRI73 field.
	NVIC_NVICIP73_PRI73_Msk = 0xf0

	// NVICIP74: Interrupt Priority Register 74
	// Position of PRI74 field.
	NVIC_NVICIP74_PRI74_Pos = 0x4
	// Bit mask of PRI74 field.
	NVIC_NVICIP74_PRI74_Msk = 0xf0

	// NVICIP75: Interrupt Priority Register 75
	// Position of PRI75 field.
	NVIC_NVICIP75_PRI75_Pos = 0x4
	// Bit mask of PRI75 field.
	NVIC_NVICIP75_PRI75_Msk = 0xf0

	// NVICIP76: Interrupt Priority Register 76
	// Position of PRI76 field.
	NVIC_NVICIP76_PRI76_Pos = 0x4
	// Bit mask of PRI76 field.
	NVIC_NVICIP76_PRI76_Msk = 0xf0

	// NVICIP77: Interrupt Priority Register 77
	// Position of PRI77 field.
	NVIC_NVICIP77_PRI77_Pos = 0x4
	// Bit mask of PRI77 field.
	NVIC_NVICIP77_PRI77_Msk = 0xf0

	// NVICIP78: Interrupt Priority Register 78
	// Position of PRI78 field.
	NVIC_NVICIP78_PRI78_Pos = 0x4
	// Bit mask of PRI78 field.
	NVIC_NVICIP78_PRI78_Msk = 0xf0

	// NVICIP79: Interrupt Priority Register 79
	// Position of PRI79 field.
	NVIC_NVICIP79_PRI79_Pos = 0x4
	// Bit mask of PRI79 field.
	NVIC_NVICIP79_PRI79_Msk = 0xf0

	// NVICIP80: Interrupt Priority Register 80
	// Position of PRI80 field.
	NVIC_NVICIP80_PRI80_Pos = 0x4
	// Bit mask of PRI80 field.
	NVIC_NVICIP80_PRI80_Msk = 0xf0

	// NVICIP81: Interrupt Priority Register 81
	// Position of PRI81 field.
	NVIC_NVICIP81_PRI81_Pos = 0x4
	// Bit mask of PRI81 field.
	NVIC_NVICIP81_PRI81_Msk = 0xf0

	// NVICIP82: Interrupt Priority Register 82
	// Position of PRI82 field.
	NVIC_NVICIP82_PRI82_Pos = 0x4
	// Bit mask of PRI82 field.
	NVIC_NVICIP82_PRI82_Msk = 0xf0

	// NVICIP83: Interrupt Priority Register 83
	// Position of PRI83 field.
	NVIC_NVICIP83_PRI83_Pos = 0x4
	// Bit mask of PRI83 field.
	NVIC_NVICIP83_PRI83_Msk = 0xf0

	// NVICIP84: Interrupt Priority Register 84
	// Position of PRI84 field.
	NVIC_NVICIP84_PRI84_Pos = 0x4
	// Bit mask of PRI84 field.
	NVIC_NVICIP84_PRI84_Msk = 0xf0

	// NVICIP85: Interrupt Priority Register 85
	// Position of PRI85 field.
	NVIC_NVICIP85_PRI85_Pos = 0x4
	// Bit mask of PRI85 field.
	NVIC_NVICIP85_PRI85_Msk = 0xf0

	// NVICIP86: Interrupt Priority Register 86
	// Position of PRI86 field.
	NVIC_NVICIP86_PRI86_Pos = 0x4
	// Bit mask of PRI86 field.
	NVIC_NVICIP86_PRI86_Msk = 0xf0

	// NVICIP87: Interrupt Priority Register 87
	// Position of PRI87 field.
	NVIC_NVICIP87_PRI87_Pos = 0x4
	// Bit mask of PRI87 field.
	NVIC_NVICIP87_PRI87_Msk = 0xf0

	// NVICIP88: Interrupt Priority Register 88
	// Position of PRI88 field.
	NVIC_NVICIP88_PRI88_Pos = 0x4
	// Bit mask of PRI88 field.
	NVIC_NVICIP88_PRI88_Msk = 0xf0

	// NVICIP89: Interrupt Priority Register 89
	// Position of PRI89 field.
	NVIC_NVICIP89_PRI89_Pos = 0x4
	// Bit mask of PRI89 field.
	NVIC_NVICIP89_PRI89_Msk = 0xf0

	// NVICIP90: Interrupt Priority Register 90
	// Position of PRI90 field.
	NVIC_NVICIP90_PRI90_Pos = 0x4
	// Bit mask of PRI90 field.
	NVIC_NVICIP90_PRI90_Msk = 0xf0

	// NVICIP91: Interrupt Priority Register 91
	// Position of PRI91 field.
	NVIC_NVICIP91_PRI91_Pos = 0x4
	// Bit mask of PRI91 field.
	NVIC_NVICIP91_PRI91_Msk = 0xf0

	// NVICIP92: Interrupt Priority Register 92
	// Position of PRI92 field.
	NVIC_NVICIP92_PRI92_Pos = 0x4
	// Bit mask of PRI92 field.
	NVIC_NVICIP92_PRI92_Msk = 0xf0

	// NVICIP93: Interrupt Priority Register 93
	// Position of PRI93 field.
	NVIC_NVICIP93_PRI93_Pos = 0x4
	// Bit mask of PRI93 field.
	NVIC_NVICIP93_PRI93_Msk = 0xf0

	// NVICIP94: Interrupt Priority Register 94
	// Position of PRI94 field.
	NVIC_NVICIP94_PRI94_Pos = 0x4
	// Bit mask of PRI94 field.
	NVIC_NVICIP94_PRI94_Msk = 0xf0

	// NVICIP95: Interrupt Priority Register 95
	// Position of PRI95 field.
	NVIC_NVICIP95_PRI95_Pos = 0x4
	// Bit mask of PRI95 field.
	NVIC_NVICIP95_PRI95_Msk = 0xf0

	// NVICIP96: Interrupt Priority Register 96
	// Position of PRI96 field.
	NVIC_NVICIP96_PRI96_Pos = 0x4
	// Bit mask of PRI96 field.
	NVIC_NVICIP96_PRI96_Msk = 0xf0

	// NVICIP97: Interrupt Priority Register 97
	// Position of PRI97 field.
	NVIC_NVICIP97_PRI97_Pos = 0x4
	// Bit mask of PRI97 field.
	NVIC_NVICIP97_PRI97_Msk = 0xf0

	// NVICIP98: Interrupt Priority Register 98
	// Position of PRI98 field.
	NVIC_NVICIP98_PRI98_Pos = 0x4
	// Bit mask of PRI98 field.
	NVIC_NVICIP98_PRI98_Msk = 0xf0

	// NVICIP99: Interrupt Priority Register 99
	// Position of PRI99 field.
	NVIC_NVICIP99_PRI99_Pos = 0x4
	// Bit mask of PRI99 field.
	NVIC_NVICIP99_PRI99_Msk = 0xf0

	// NVICIP100: Interrupt Priority Register 100
	// Position of PRI100 field.
	NVIC_NVICIP100_PRI100_Pos = 0x4
	// Bit mask of PRI100 field.
	NVIC_NVICIP100_PRI100_Msk = 0xf0

	// NVICIP101: Interrupt Priority Register 101
	// Position of PRI101 field.
	NVIC_NVICIP101_PRI101_Pos = 0x4
	// Bit mask of PRI101 field.
	NVIC_NVICIP101_PRI101_Msk = 0xf0

	// NVICIP102: Interrupt Priority Register 102
	// Position of PRI102 field.
	NVIC_NVICIP102_PRI102_Pos = 0x4
	// Bit mask of PRI102 field.
	NVIC_NVICIP102_PRI102_Msk = 0xf0

	// NVICIP103: Interrupt Priority Register 103
	// Position of PRI103 field.
	NVIC_NVICIP103_PRI103_Pos = 0x4
	// Bit mask of PRI103 field.
	NVIC_NVICIP103_PRI103_Msk = 0xf0

	// NVICIP104: Interrupt Priority Register 104
	// Position of PRI104 field.
	NVIC_NVICIP104_PRI104_Pos = 0x4
	// Bit mask of PRI104 field.
	NVIC_NVICIP104_PRI104_Msk = 0xf0

	// NVICIP105: Interrupt Priority Register 105
	// Position of PRI105 field.
	NVIC_NVICIP105_PRI105_Pos = 0x4
	// Bit mask of PRI105 field.
	NVIC_NVICIP105_PRI105_Msk = 0xf0

	// NVICIP106: Interrupt Priority Register 106
	// Position of PRI106 field.
	NVIC_NVICIP106_PRI106_Pos = 0x4
	// Bit mask of PRI106 field.
	NVIC_NVICIP106_PRI106_Msk = 0xf0

	// NVICIP107: Interrupt Priority Register 107
	// Position of PRI107 field.
	NVIC_NVICIP107_PRI107_Pos = 0x4
	// Bit mask of PRI107 field.
	NVIC_NVICIP107_PRI107_Msk = 0xf0

	// NVICIP108: Interrupt Priority Register 108
	// Position of PRI108 field.
	NVIC_NVICIP108_PRI108_Pos = 0x4
	// Bit mask of PRI108 field.
	NVIC_NVICIP108_PRI108_Msk = 0xf0

	// NVICIP109: Interrupt Priority Register 109
	// Position of PRI109 field.
	NVIC_NVICIP109_PRI109_Pos = 0x4
	// Bit mask of PRI109 field.
	NVIC_NVICIP109_PRI109_Msk = 0xf0

	// NVICIP110: Interrupt Priority Register 110
	// Position of PRI110 field.
	NVIC_NVICIP110_PRI110_Pos = 0x4
	// Bit mask of PRI110 field.
	NVIC_NVICIP110_PRI110_Msk = 0xf0

	// NVICIP111: Interrupt Priority Register 111
	// Position of PRI111 field.
	NVIC_NVICIP111_PRI111_Pos = 0x4
	// Bit mask of PRI111 field.
	NVIC_NVICIP111_PRI111_Msk = 0xf0

	// NVICIP112: Interrupt Priority Register 112
	// Position of PRI112 field.
	NVIC_NVICIP112_PRI112_Pos = 0x4
	// Bit mask of PRI112 field.
	NVIC_NVICIP112_PRI112_Msk = 0xf0

	// NVICIP113: Interrupt Priority Register 113
	// Position of PRI113 field.
	NVIC_NVICIP113_PRI113_Pos = 0x4
	// Bit mask of PRI113 field.
	NVIC_NVICIP113_PRI113_Msk = 0xf0

	// NVICIP114: Interrupt Priority Register 114
	// Position of PRI114 field.
	NVIC_NVICIP114_PRI114_Pos = 0x4
	// Bit mask of PRI114 field.
	NVIC_NVICIP114_PRI114_Msk = 0xf0

	// NVICIP115: Interrupt Priority Register 115
	// Position of PRI115 field.
	NVIC_NVICIP115_PRI115_Pos = 0x4
	// Bit mask of PRI115 field.
	NVIC_NVICIP115_PRI115_Msk = 0xf0

	// NVICIP116: Interrupt Priority Register 116
	// Position of PRI116 field.
	NVIC_NVICIP116_PRI116_Pos = 0x4
	// Bit mask of PRI116 field.
	NVIC_NVICIP116_PRI116_Msk = 0xf0

	// NVICIP117: Interrupt Priority Register 117
	// Position of PRI117 field.
	NVIC_NVICIP117_PRI117_Pos = 0x4
	// Bit mask of PRI117 field.
	NVIC_NVICIP117_PRI117_Msk = 0xf0

	// NVICIP118: Interrupt Priority Register 118
	// Position of PRI118 field.
	NVIC_NVICIP118_PRI118_Pos = 0x4
	// Bit mask of PRI118 field.
	NVIC_NVICIP118_PRI118_Msk = 0xf0

	// NVICIP119: Interrupt Priority Register 119
	// Position of PRI119 field.
	NVIC_NVICIP119_PRI119_Pos = 0x4
	// Bit mask of PRI119 field.
	NVIC_NVICIP119_PRI119_Msk = 0xf0

	// NVICIP120: Interrupt Priority Register 120
	// Position of PRI120 field.
	NVIC_NVICIP120_PRI120_Pos = 0x4
	// Bit mask of PRI120 field.
	NVIC_NVICIP120_PRI120_Msk = 0xf0

	// NVICIP121: Interrupt Priority Register 121
	// Position of PRI121 field.
	NVIC_NVICIP121_PRI121_Pos = 0x4
	// Bit mask of PRI121 field.
	NVIC_NVICIP121_PRI121_Msk = 0xf0

	// NVICIP122: Interrupt Priority Register 122
	// Position of PRI122 field.
	NVIC_NVICIP122_PRI122_Pos = 0x4
	// Bit mask of PRI122 field.
	NVIC_NVICIP122_PRI122_Msk = 0xf0

	// NVICIP123: Interrupt Priority Register 123
	// Position of PRI123 field.
	NVIC_NVICIP123_PRI123_Pos = 0x4
	// Bit mask of PRI123 field.
	NVIC_NVICIP123_PRI123_Msk = 0xf0

	// NVICIP124: Interrupt Priority Register 124
	// Position of PRI124 field.
	NVIC_NVICIP124_PRI124_Pos = 0x4
	// Bit mask of PRI124 field.
	NVIC_NVICIP124_PRI124_Msk = 0xf0

	// NVICIP125: Interrupt Priority Register 125
	// Position of PRI125 field.
	NVIC_NVICIP125_PRI125_Pos = 0x4
	// Bit mask of PRI125 field.
	NVIC_NVICIP125_PRI125_Msk = 0xf0

	// NVICIP126: Interrupt Priority Register 126
	// Position of PRI126 field.
	NVIC_NVICIP126_PRI126_Pos = 0x4
	// Bit mask of PRI126 field.
	NVIC_NVICIP126_PRI126_Msk = 0xf0

	// NVICIP127: Interrupt Priority Register 127
	// Position of PRI127 field.
	NVIC_NVICIP127_PRI127_Pos = 0x4
	// Bit mask of PRI127 field.
	NVIC_NVICIP127_PRI127_Msk = 0xf0

	// NVICIP128: Interrupt Priority Register 128
	// Position of PRI128 field.
	NVIC_NVICIP128_PRI128_Pos = 0x4
	// Bit mask of PRI128 field.
	NVIC_NVICIP128_PRI128_Msk = 0xf0

	// NVICIP129: Interrupt Priority Register 129
	// Position of PRI129 field.
	NVIC_NVICIP129_PRI129_Pos = 0x4
	// Bit mask of PRI129 field.
	NVIC_NVICIP129_PRI129_Msk = 0xf0

	// NVICIP130: Interrupt Priority Register 130
	// Position of PRI130 field.
	NVIC_NVICIP130_PRI130_Pos = 0x4
	// Bit mask of PRI130 field.
	NVIC_NVICIP130_PRI130_Msk = 0xf0

	// NVICIP131: Interrupt Priority Register 131
	// Position of PRI131 field.
	NVIC_NVICIP131_PRI131_Pos = 0x4
	// Bit mask of PRI131 field.
	NVIC_NVICIP131_PRI131_Msk = 0xf0

	// NVICIP132: Interrupt Priority Register 132
	// Position of PRI132 field.
	NVIC_NVICIP132_PRI132_Pos = 0x4
	// Bit mask of PRI132 field.
	NVIC_NVICIP132_PRI132_Msk = 0xf0

	// NVICIP133: Interrupt Priority Register 133
	// Position of PRI133 field.
	NVIC_NVICIP133_PRI133_Pos = 0x4
	// Bit mask of PRI133 field.
	NVIC_NVICIP133_PRI133_Msk = 0xf0

	// NVICIP134: Interrupt Priority Register 134
	// Position of PRI134 field.
	NVIC_NVICIP134_PRI134_Pos = 0x4
	// Bit mask of PRI134 field.
	NVIC_NVICIP134_PRI134_Msk = 0xf0

	// NVICIP135: Interrupt Priority Register 135
	// Position of PRI135 field.
	NVIC_NVICIP135_PRI135_Pos = 0x4
	// Bit mask of PRI135 field.
	NVIC_NVICIP135_PRI135_Msk = 0xf0

	// NVICIP136: Interrupt Priority Register 136
	// Position of PRI136 field.
	NVIC_NVICIP136_PRI136_Pos = 0x4
	// Bit mask of PRI136 field.
	NVIC_NVICIP136_PRI136_Msk = 0xf0

	// NVICIP137: Interrupt Priority Register 137
	// Position of PRI137 field.
	NVIC_NVICIP137_PRI137_Pos = 0x4
	// Bit mask of PRI137 field.
	NVIC_NVICIP137_PRI137_Msk = 0xf0

	// NVICIP138: Interrupt Priority Register 138
	// Position of PRI138 field.
	NVIC_NVICIP138_PRI138_Pos = 0x4
	// Bit mask of PRI138 field.
	NVIC_NVICIP138_PRI138_Msk = 0xf0

	// NVICIP139: Interrupt Priority Register 139
	// Position of PRI139 field.
	NVIC_NVICIP139_PRI139_Pos = 0x4
	// Bit mask of PRI139 field.
	NVIC_NVICIP139_PRI139_Msk = 0xf0

	// NVICIP140: Interrupt Priority Register 140
	// Position of PRI140 field.
	NVIC_NVICIP140_PRI140_Pos = 0x4
	// Bit mask of PRI140 field.
	NVIC_NVICIP140_PRI140_Msk = 0xf0

	// NVICIP141: Interrupt Priority Register 141
	// Position of PRI141 field.
	NVIC_NVICIP141_PRI141_Pos = 0x4
	// Bit mask of PRI141 field.
	NVIC_NVICIP141_PRI141_Msk = 0xf0

	// NVICIP142: Interrupt Priority Register 142
	// Position of PRI142 field.
	NVIC_NVICIP142_PRI142_Pos = 0x4
	// Bit mask of PRI142 field.
	NVIC_NVICIP142_PRI142_Msk = 0xf0

	// NVICIP143: Interrupt Priority Register 143
	// Position of PRI143 field.
	NVIC_NVICIP143_PRI143_Pos = 0x4
	// Bit mask of PRI143 field.
	NVIC_NVICIP143_PRI143_Msk = 0xf0

	// NVICIP144: Interrupt Priority Register 144
	// Position of PRI144 field.
	NVIC_NVICIP144_PRI144_Pos = 0x4
	// Bit mask of PRI144 field.
	NVIC_NVICIP144_PRI144_Msk = 0xf0

	// NVICIP145: Interrupt Priority Register 145
	// Position of PRI145 field.
	NVIC_NVICIP145_PRI145_Pos = 0x4
	// Bit mask of PRI145 field.
	NVIC_NVICIP145_PRI145_Msk = 0xf0

	// NVICIP146: Interrupt Priority Register 146
	// Position of PRI146 field.
	NVIC_NVICIP146_PRI146_Pos = 0x4
	// Bit mask of PRI146 field.
	NVIC_NVICIP146_PRI146_Msk = 0xf0

	// NVICIP147: Interrupt Priority Register 147
	// Position of PRI147 field.
	NVIC_NVICIP147_PRI147_Pos = 0x4
	// Bit mask of PRI147 field.
	NVIC_NVICIP147_PRI147_Msk = 0xf0

	// NVICIP148: Interrupt Priority Register 148
	// Position of PRI148 field.
	NVIC_NVICIP148_PRI148_Pos = 0x4
	// Bit mask of PRI148 field.
	NVIC_NVICIP148_PRI148_Msk = 0xf0

	// NVICIP149: Interrupt Priority Register 149
	// Position of PRI149 field.
	NVIC_NVICIP149_PRI149_Pos = 0x4
	// Bit mask of PRI149 field.
	NVIC_NVICIP149_PRI149_Msk = 0xf0

	// NVICIP150: Interrupt Priority Register 150
	// Position of PRI150 field.
	NVIC_NVICIP150_PRI150_Pos = 0x4
	// Bit mask of PRI150 field.
	NVIC_NVICIP150_PRI150_Msk = 0xf0

	// NVICIP151: Interrupt Priority Register 151
	// Position of PRI151 field.
	NVIC_NVICIP151_PRI151_Pos = 0x4
	// Bit mask of PRI151 field.
	NVIC_NVICIP151_PRI151_Msk = 0xf0

	// NVICIP152: Interrupt Priority Register 152
	// Position of PRI152 field.
	NVIC_NVICIP152_PRI152_Pos = 0x4
	// Bit mask of PRI152 field.
	NVIC_NVICIP152_PRI152_Msk = 0xf0

	// NVICIP153: Interrupt Priority Register 153
	// Position of PRI153 field.
	NVIC_NVICIP153_PRI153_Pos = 0x4
	// Bit mask of PRI153 field.
	NVIC_NVICIP153_PRI153_Msk = 0xf0

	// NVICIP154: Interrupt Priority Register 154
	// Position of PRI154 field.
	NVIC_NVICIP154_PRI154_Pos = 0x4
	// Bit mask of PRI154 field.
	NVIC_NVICIP154_PRI154_Msk = 0xf0

	// NVICIP155: Interrupt Priority Register 155
	// Position of PRI155 field.
	NVIC_NVICIP155_PRI155_Pos = 0x4
	// Bit mask of PRI155 field.
	NVIC_NVICIP155_PRI155_Msk = 0xf0

	// NVICIP156: Interrupt Priority Register 156
	// Position of PRI156 field.
	NVIC_NVICIP156_PRI156_Pos = 0x4
	// Bit mask of PRI156 field.
	NVIC_NVICIP156_PRI156_Msk = 0xf0

	// NVICIP157: Interrupt Priority Register 157
	// Position of PRI157 field.
	NVIC_NVICIP157_PRI157_Pos = 0x4
	// Bit mask of PRI157 field.
	NVIC_NVICIP157_PRI157_Msk = 0xf0

	// NVICSTIR: Software Trigger Interrupt Register
	// Position of INTID field.
	NVIC_NVICSTIR_INTID_Pos = 0x0
	// Bit mask of INTID field.
	NVIC_NVICSTIR_INTID_Msk = 0x1ff
)
